/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.Account
import org.openapitools.client.models.AnalyticsMetricsResponse
import org.openapitools.client.models.BoardsUserFollowsList200Response
import org.openapitools.client.models.Error
import org.openapitools.client.models.FollowUserRequest
import org.openapitools.client.models.FollowersList200Response
import org.openapitools.client.models.LinkedBusiness
import org.openapitools.client.models.TopPinsAnalyticsResponse
import org.openapitools.client.models.TopVideoPinsAnalyticsResponse
import org.openapitools.client.models.UserAccountFollowedInterests200Response
import org.openapitools.client.models.UserFollowingFeedType
import org.openapitools.client.models.UserFollowingGet200Response
import org.openapitools.client.models.UserSummary
import org.openapitools.client.models.UserWebsiteSummary
import org.openapitools.client.models.UserWebsiteVerificationCode
import org.openapitools.client.models.UserWebsiteVerifyRequest
import org.openapitools.client.models.UserWebsitesGet200Response

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class UserAccountApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.pinterest.com/v5")
        }
    }

    /**
     * List following boards
     * Get a list of the boards a user follows. The request returns a board summary object array.
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @param explicitFollowing Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows. (optional, default to false)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return BoardsUserFollowsList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun boardsUserFollowsList(bookmark: kotlin.String? = null, pageSize: kotlin.Int? = 25, explicitFollowing: kotlin.Boolean? = false, adAccountId: kotlin.String? = null) : BoardsUserFollowsList200Response {
        val localVarResponse = boardsUserFollowsListWithHttpInfo(bookmark = bookmark, pageSize = pageSize, explicitFollowing = explicitFollowing, adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BoardsUserFollowsList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List following boards
     * Get a list of the boards a user follows. The request returns a board summary object array.
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @param explicitFollowing Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows. (optional, default to false)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<BoardsUserFollowsList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun boardsUserFollowsListWithHttpInfo(bookmark: kotlin.String?, pageSize: kotlin.Int?, explicitFollowing: kotlin.Boolean?, adAccountId: kotlin.String?) : ApiResponse<BoardsUserFollowsList200Response?> {
        val localVariableConfig = boardsUserFollowsListRequestConfig(bookmark = bookmark, pageSize = pageSize, explicitFollowing = explicitFollowing, adAccountId = adAccountId)

        return request<Unit, BoardsUserFollowsList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation boardsUserFollowsList
     *
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @param explicitFollowing Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows. (optional, default to false)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun boardsUserFollowsListRequestConfig(bookmark: kotlin.String?, pageSize: kotlin.Int?, explicitFollowing: kotlin.Boolean?, adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bookmark != null) {
                    put("bookmark", listOf(bookmark.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (explicitFollowing != null) {
                    put("explicit_following", listOf(explicitFollowing.toString()))
                }
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/following/boards",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Follow user
     * &lt;strong&gt;This endpoint is currently in beta and not available to all apps. &lt;a href&#x3D;&#39;/docs/getting-started/beta-and-advanced-access/&#39;&gt;Learn more&lt;/a&gt;.&lt;/strong&gt;  Use this request, as a signed-in user, to follow another user.
     * @param username A valid username
     * @param followUserRequest Follow a user.
     * @return UserSummary
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun followUserUpdate(username: kotlin.String, followUserRequest: FollowUserRequest) : UserSummary {
        val localVarResponse = followUserUpdateWithHttpInfo(username = username, followUserRequest = followUserRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserSummary
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Follow user
     * &lt;strong&gt;This endpoint is currently in beta and not available to all apps. &lt;a href&#x3D;&#39;/docs/getting-started/beta-and-advanced-access/&#39;&gt;Learn more&lt;/a&gt;.&lt;/strong&gt;  Use this request, as a signed-in user, to follow another user.
     * @param username A valid username
     * @param followUserRequest Follow a user.
     * @return ApiResponse<UserSummary?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun followUserUpdateWithHttpInfo(username: kotlin.String, followUserRequest: FollowUserRequest) : ApiResponse<UserSummary?> {
        val localVariableConfig = followUserUpdateRequestConfig(username = username, followUserRequest = followUserRequest)

        return request<FollowUserRequest, UserSummary>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation followUserUpdate
     *
     * @param username A valid username
     * @param followUserRequest Follow a user.
     * @return RequestConfig
     */
    fun followUserUpdateRequestConfig(username: kotlin.String, followUserRequest: FollowUserRequest) : RequestConfig<FollowUserRequest> {
        val localVariableBody = followUserRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/user_account/following/{username}".replace("{"+"username"+"}", encodeURIComponent(username.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List followers
     * Get a list of your followers.
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return FollowersList200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun followersList(bookmark: kotlin.String? = null, pageSize: kotlin.Int? = 25) : FollowersList200Response {
        val localVarResponse = followersListWithHttpInfo(bookmark = bookmark, pageSize = pageSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FollowersList200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List followers
     * Get a list of your followers.
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return ApiResponse<FollowersList200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun followersListWithHttpInfo(bookmark: kotlin.String?, pageSize: kotlin.Int?) : ApiResponse<FollowersList200Response?> {
        val localVariableConfig = followersListRequestConfig(bookmark = bookmark, pageSize = pageSize)

        return request<Unit, FollowersList200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation followersList
     *
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return RequestConfig
     */
    fun followersListRequestConfig(bookmark: kotlin.String?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bookmark != null) {
                    put("bookmark", listOf(bookmark.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/followers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List linked businesses
     * Get a list of your linked business accounts.
     * @return kotlin.collections.List<LinkedBusiness>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun linkedBusinessAccountsGet() : kotlin.collections.List<LinkedBusiness> {
        val localVarResponse = linkedBusinessAccountsGetWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<LinkedBusiness>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List linked businesses
     * Get a list of your linked business accounts.
     * @return ApiResponse<kotlin.collections.List<LinkedBusiness>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun linkedBusinessAccountsGetWithHttpInfo() : ApiResponse<kotlin.collections.List<LinkedBusiness>?> {
        val localVariableConfig = linkedBusinessAccountsGetRequestConfig()

        return request<Unit, kotlin.collections.List<LinkedBusiness>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation linkedBusinessAccountsGet
     *
     * @return RequestConfig
     */
    fun linkedBusinessAccountsGetRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/businesses",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Unverify website
     * Unverifu a website verified by the signed-in user.
     * @param website Website with path or domain only
     * @return void
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun unverifyWebsiteDelete(website: kotlin.String) : Unit {
        val localVarResponse = unverifyWebsiteDeleteWithHttpInfo(website = website)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Unverify website
     * Unverifu a website verified by the signed-in user.
     * @param website Website with path or domain only
     * @return ApiResponse<Unit?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Throws(IllegalStateException::class, IOException::class)
    fun unverifyWebsiteDeleteWithHttpInfo(website: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = unverifyWebsiteDeleteRequestConfig(website = website)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation unverifyWebsiteDelete
     *
     * @param website Website with path or domain only
     * @return RequestConfig
     */
    fun unverifyWebsiteDeleteRequestConfig(website: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("website", listOf(website.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.DELETE,
            path = "/user_account/websites",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter fromClaimedContent
     */
     enum class FromClaimedContentUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "OTHER") OTHER("OTHER"),
         @Json(name = "CLAIMED") CLAIMED("CLAIMED"),
         @Json(name = "BOTH") BOTH("BOTH");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter pinFormat
     */
     enum class PinFormatUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "ORGANIC_IMAGE") ORGANIC_IMAGE("ORGANIC_IMAGE"),
         @Json(name = "ORGANIC_PRODUCT") ORGANIC_PRODUCT("ORGANIC_PRODUCT"),
         @Json(name = "ORGANIC_VIDEO") ORGANIC_VIDEO("ORGANIC_VIDEO"),
         @Json(name = "ADS_STANDARD") ADS_STANDARD("ADS_STANDARD"),
         @Json(name = "ADS_PRODUCT") ADS_PRODUCT("ADS_PRODUCT"),
         @Json(name = "ADS_VIDEO") ADS_VIDEO("ADS_VIDEO"),
         @Json(name = "ADS_IDEA") ADS_IDEA("ADS_IDEA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter appTypes
     */
     enum class AppTypesUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "MOBILE") MOBILE("MOBILE"),
         @Json(name = "TABLET") TABLET("TABLET"),
         @Json(name = "WEB") WEB("WEB");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter contentType
     */
     enum class ContentTypeUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "PAID") PAID("PAID"),
         @Json(name = "ORGANIC") ORGANIC("ORGANIC");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter source
     */
     enum class SourceUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "YOUR_PINS") YOUR_PINS("YOUR_PINS"),
         @Json(name = "OTHER_PINS") OTHER_PINS("OTHER_PINS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter metricTypes
     */
     enum class MetricTypesUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "ENGAGEMENT") ENGAGEMENT("ENGAGEMENT"),
         @Json(name = "ENGAGEMENT_RATE") ENGAGEMENT_RATE("ENGAGEMENT_RATE"),
         @Json(name = "IMPRESSION") IMPRESSION("IMPRESSION"),
         @Json(name = "OUTBOUND_CLICK") OUTBOUND_CLICK("OUTBOUND_CLICK"),
         @Json(name = "OUTBOUND_CLICK_RATE") OUTBOUND_CLICK_RATE("OUTBOUND_CLICK_RATE"),
         @Json(name = "PIN_CLICK") PIN_CLICK("PIN_CLICK"),
         @Json(name = "PIN_CLICK_RATE") PIN_CLICK_RATE("PIN_CLICK_RATE"),
         @Json(name = "SAVE") SAVE("SAVE"),
         @Json(name = "SAVE_RATE") SAVE_RATE("SAVE_RATE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter splitField
     */
     enum class SplitFieldUserAccountAnalytics(val value: kotlin.String) {
         @Json(name = "NO_SPLIT") NO_SPLIT("NO_SPLIT"),
         @Json(name = "APP_TYPE") APP_TYPE("APP_TYPE"),
         @Json(name = "OWNED_CONTENT") OWNED_CONTENT("OWNED_CONTENT"),
         @Json(name = "SOURCE") SOURCE("SOURCE"),
         @Json(name = "PIN_FORMAT") PIN_FORMAT("PIN_FORMAT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get user account analytics
     * Get analytics for the \&quot;operation user_account\&quot; - By default, the \&quot;operation user_account\&quot; is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;.
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get data for, default is all.  (optional)
     * @param splitField How to split the data into groups. Not including this param means data won&#39;t be split. (optional, default to NO_SPLIT)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return kotlin.collections.Map<kotlin.String, AnalyticsMetricsResponse>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccountAnalytics(startDate: java.time.LocalDate, endDate: java.time.LocalDate, fromClaimedContent: FromClaimedContentUserAccountAnalytics? = FromClaimedContentUserAccountAnalytics.BOTH, pinFormat: PinFormatUserAccountAnalytics? = PinFormatUserAccountAnalytics.ALL, appTypes: AppTypesUserAccountAnalytics? = AppTypesUserAccountAnalytics.ALL, contentType: ContentTypeUserAccountAnalytics? = ContentTypeUserAccountAnalytics.ALL, source: SourceUserAccountAnalytics? = SourceUserAccountAnalytics.ALL, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalytics>? = null, splitField: SplitFieldUserAccountAnalytics? = SplitFieldUserAccountAnalytics.NO_SPLIT, adAccountId: kotlin.String? = null) : kotlin.collections.Map<kotlin.String, AnalyticsMetricsResponse> {
        val localVarResponse = userAccountAnalyticsWithHttpInfo(startDate = startDate, endDate = endDate, fromClaimedContent = fromClaimedContent, pinFormat = pinFormat, appTypes = appTypes, contentType = contentType, source = source, metricTypes = metricTypes, splitField = splitField, adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, AnalyticsMetricsResponse>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user account analytics
     * Get analytics for the \&quot;operation user_account\&quot; - By default, the \&quot;operation user_account\&quot; is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;.
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get data for, default is all.  (optional)
     * @param splitField How to split the data into groups. Not including this param means data won&#39;t be split. (optional, default to NO_SPLIT)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<kotlin.collections.Map<kotlin.String, AnalyticsMetricsResponse>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userAccountAnalyticsWithHttpInfo(startDate: java.time.LocalDate, endDate: java.time.LocalDate, fromClaimedContent: FromClaimedContentUserAccountAnalytics?, pinFormat: PinFormatUserAccountAnalytics?, appTypes: AppTypesUserAccountAnalytics?, contentType: ContentTypeUserAccountAnalytics?, source: SourceUserAccountAnalytics?, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalytics>?, splitField: SplitFieldUserAccountAnalytics?, adAccountId: kotlin.String?) : ApiResponse<kotlin.collections.Map<kotlin.String, AnalyticsMetricsResponse>?> {
        val localVariableConfig = userAccountAnalyticsRequestConfig(startDate = startDate, endDate = endDate, fromClaimedContent = fromClaimedContent, pinFormat = pinFormat, appTypes = appTypes, contentType = contentType, source = source, metricTypes = metricTypes, splitField = splitField, adAccountId = adAccountId)

        return request<Unit, kotlin.collections.Map<kotlin.String, AnalyticsMetricsResponse>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userAccountAnalytics
     *
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get data for, default is all.  (optional)
     * @param splitField How to split the data into groups. Not including this param means data won&#39;t be split. (optional, default to NO_SPLIT)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun userAccountAnalyticsRequestConfig(startDate: java.time.LocalDate, endDate: java.time.LocalDate, fromClaimedContent: FromClaimedContentUserAccountAnalytics?, pinFormat: PinFormatUserAccountAnalytics?, appTypes: AppTypesUserAccountAnalytics?, contentType: ContentTypeUserAccountAnalytics?, source: SourceUserAccountAnalytics?, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalytics>?, splitField: SplitFieldUserAccountAnalytics?, adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start_date", listOf(parseDateToQueryString(startDate)))
                put("end_date", listOf(parseDateToQueryString(endDate)))
                if (fromClaimedContent != null) {
                    put("from_claimed_content", listOf(fromClaimedContent.value))
                }
                if (pinFormat != null) {
                    put("pin_format", listOf(pinFormat.value))
                }
                if (appTypes != null) {
                    put("app_types", listOf(appTypes.value))
                }
                if (contentType != null) {
                    put("content_type", listOf(contentType.value))
                }
                if (source != null) {
                    put("source", listOf(source.value))
                }
                if (metricTypes != null) {
                    put("metric_types", toMultiValue(metricTypes.toList(), "csv"))
                }
                if (splitField != null) {
                    put("split_field", listOf(splitField.value))
                }
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/analytics",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortBy
     */
     enum class SortByUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "ENGAGEMENT") ENGAGEMENT("ENGAGEMENT"),
         @Json(name = "IMPRESSION") IMPRESSION("IMPRESSION"),
         @Json(name = "OUTBOUND_CLICK") OUTBOUND_CLICK("OUTBOUND_CLICK"),
         @Json(name = "PIN_CLICK") PIN_CLICK("PIN_CLICK"),
         @Json(name = "SAVE") SAVE("SAVE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fromClaimedContent
     */
     enum class FromClaimedContentUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "OTHER") OTHER("OTHER"),
         @Json(name = "CLAIMED") CLAIMED("CLAIMED"),
         @Json(name = "BOTH") BOTH("BOTH");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter pinFormat
     */
     enum class PinFormatUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "ORGANIC_IMAGE") ORGANIC_IMAGE("ORGANIC_IMAGE"),
         @Json(name = "ORGANIC_PRODUCT") ORGANIC_PRODUCT("ORGANIC_PRODUCT"),
         @Json(name = "ORGANIC_VIDEO") ORGANIC_VIDEO("ORGANIC_VIDEO"),
         @Json(name = "ADS_STANDARD") ADS_STANDARD("ADS_STANDARD"),
         @Json(name = "ADS_PRODUCT") ADS_PRODUCT("ADS_PRODUCT"),
         @Json(name = "ADS_VIDEO") ADS_VIDEO("ADS_VIDEO"),
         @Json(name = "ADS_IDEA") ADS_IDEA("ADS_IDEA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter appTypes
     */
     enum class AppTypesUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "MOBILE") MOBILE("MOBILE"),
         @Json(name = "TABLET") TABLET("TABLET"),
         @Json(name = "WEB") WEB("WEB");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter contentType
     */
     enum class ContentTypeUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "PAID") PAID("PAID"),
         @Json(name = "ORGANIC") ORGANIC("ORGANIC");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter source
     */
     enum class SourceUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "YOUR_PINS") YOUR_PINS("YOUR_PINS"),
         @Json(name = "OTHER_PINS") OTHER_PINS("OTHER_PINS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter metricTypes
     */
     enum class MetricTypesUserAccountAnalyticsTopPins(val value: kotlin.String) {
         @Json(name = "ENGAGEMENT") ENGAGEMENT("ENGAGEMENT"),
         @Json(name = "ENGAGEMENT_RATE") ENGAGEMENT_RATE("ENGAGEMENT_RATE"),
         @Json(name = "IMPRESSION") IMPRESSION("IMPRESSION"),
         @Json(name = "OUTBOUND_CLICK") OUTBOUND_CLICK("OUTBOUND_CLICK"),
         @Json(name = "OUTBOUND_CLICK_RATE") OUTBOUND_CLICK_RATE("OUTBOUND_CLICK_RATE"),
         @Json(name = "PIN_CLICK") PIN_CLICK("PIN_CLICK"),
         @Json(name = "PIN_CLICK_RATE") PIN_CLICK_RATE("PIN_CLICK_RATE"),
         @Json(name = "SAVE") SAVE("SAVE"),
         @Json(name = "SAVE_RATE") SAVE_RATE("SAVE_RATE");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter createdInLastNDays
     */
     enum class CreatedInLastNDaysUserAccountAnalyticsTopPins(val value: kotlin.Int) {
         @Json(name = "30") _30(30);

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get user account top pins analytics
     * Gets analytics data about a user&#39;s top pins (limited to the top 50). - By default, the \&quot;operation user_account\&quot; is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;.
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param sortBy Specify sorting order for metrics
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get data for, default is all.  (optional)
     * @param numOfPins Number of pins to include, default is 10. Max is 50. (optional, default to 10)
     * @param createdInLastNDays Get metrics for pins created in the last \&quot;n\&quot; days. (optional)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return TopPinsAnalyticsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccountAnalyticsTopPins(startDate: java.time.LocalDate, endDate: java.time.LocalDate, sortBy: SortByUserAccountAnalyticsTopPins, fromClaimedContent: FromClaimedContentUserAccountAnalyticsTopPins? = FromClaimedContentUserAccountAnalyticsTopPins.BOTH, pinFormat: PinFormatUserAccountAnalyticsTopPins? = PinFormatUserAccountAnalyticsTopPins.ALL, appTypes: AppTypesUserAccountAnalyticsTopPins? = AppTypesUserAccountAnalyticsTopPins.ALL, contentType: ContentTypeUserAccountAnalyticsTopPins? = ContentTypeUserAccountAnalyticsTopPins.ALL, source: SourceUserAccountAnalyticsTopPins? = SourceUserAccountAnalyticsTopPins.ALL, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalyticsTopPins>? = null, numOfPins: kotlin.Int? = 10, createdInLastNDays: CreatedInLastNDaysUserAccountAnalyticsTopPins? = null, adAccountId: kotlin.String? = null) : TopPinsAnalyticsResponse {
        val localVarResponse = userAccountAnalyticsTopPinsWithHttpInfo(startDate = startDate, endDate = endDate, sortBy = sortBy, fromClaimedContent = fromClaimedContent, pinFormat = pinFormat, appTypes = appTypes, contentType = contentType, source = source, metricTypes = metricTypes, numOfPins = numOfPins, createdInLastNDays = createdInLastNDays, adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TopPinsAnalyticsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user account top pins analytics
     * Gets analytics data about a user&#39;s top pins (limited to the top 50). - By default, the \&quot;operation user_account\&quot; is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;.
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param sortBy Specify sorting order for metrics
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get data for, default is all.  (optional)
     * @param numOfPins Number of pins to include, default is 10. Max is 50. (optional, default to 10)
     * @param createdInLastNDays Get metrics for pins created in the last \&quot;n\&quot; days. (optional)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<TopPinsAnalyticsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userAccountAnalyticsTopPinsWithHttpInfo(startDate: java.time.LocalDate, endDate: java.time.LocalDate, sortBy: SortByUserAccountAnalyticsTopPins, fromClaimedContent: FromClaimedContentUserAccountAnalyticsTopPins?, pinFormat: PinFormatUserAccountAnalyticsTopPins?, appTypes: AppTypesUserAccountAnalyticsTopPins?, contentType: ContentTypeUserAccountAnalyticsTopPins?, source: SourceUserAccountAnalyticsTopPins?, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalyticsTopPins>?, numOfPins: kotlin.Int?, createdInLastNDays: CreatedInLastNDaysUserAccountAnalyticsTopPins?, adAccountId: kotlin.String?) : ApiResponse<TopPinsAnalyticsResponse?> {
        val localVariableConfig = userAccountAnalyticsTopPinsRequestConfig(startDate = startDate, endDate = endDate, sortBy = sortBy, fromClaimedContent = fromClaimedContent, pinFormat = pinFormat, appTypes = appTypes, contentType = contentType, source = source, metricTypes = metricTypes, numOfPins = numOfPins, createdInLastNDays = createdInLastNDays, adAccountId = adAccountId)

        return request<Unit, TopPinsAnalyticsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userAccountAnalyticsTopPins
     *
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param sortBy Specify sorting order for metrics
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get data for, default is all.  (optional)
     * @param numOfPins Number of pins to include, default is 10. Max is 50. (optional, default to 10)
     * @param createdInLastNDays Get metrics for pins created in the last \&quot;n\&quot; days. (optional)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun userAccountAnalyticsTopPinsRequestConfig(startDate: java.time.LocalDate, endDate: java.time.LocalDate, sortBy: SortByUserAccountAnalyticsTopPins, fromClaimedContent: FromClaimedContentUserAccountAnalyticsTopPins?, pinFormat: PinFormatUserAccountAnalyticsTopPins?, appTypes: AppTypesUserAccountAnalyticsTopPins?, contentType: ContentTypeUserAccountAnalyticsTopPins?, source: SourceUserAccountAnalyticsTopPins?, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalyticsTopPins>?, numOfPins: kotlin.Int?, createdInLastNDays: CreatedInLastNDaysUserAccountAnalyticsTopPins?, adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start_date", listOf(parseDateToQueryString(startDate)))
                put("end_date", listOf(parseDateToQueryString(endDate)))
                put("sort_by", listOf(sortBy.value))
                if (fromClaimedContent != null) {
                    put("from_claimed_content", listOf(fromClaimedContent.value))
                }
                if (pinFormat != null) {
                    put("pin_format", listOf(pinFormat.value))
                }
                if (appTypes != null) {
                    put("app_types", listOf(appTypes.value))
                }
                if (contentType != null) {
                    put("content_type", listOf(contentType.value))
                }
                if (source != null) {
                    put("source", listOf(source.value))
                }
                if (metricTypes != null) {
                    put("metric_types", toMultiValue(metricTypes.toList(), "csv"))
                }
                if (numOfPins != null) {
                    put("num_of_pins", listOf(numOfPins.toString()))
                }
                if (createdInLastNDays != null) {
                    put("created_in_last_n_days", listOf(createdInLastNDays.toString()))
                }
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/analytics/top_pins",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortBy
     */
     enum class SortByUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "IMPRESSION") IMPRESSION("IMPRESSION"),
         @Json(name = "SAVE") SAVE("SAVE"),
         @Json(name = "OUTBOUND_CLICK") OUTBOUND_CLICK("OUTBOUND_CLICK"),
         @Json(name = "VIDEO_MRC_VIEW") VIDEO_MRC_VIEW("VIDEO_MRC_VIEW"),
         @Json(name = "VIDEO_AVG_WATCH_TIME") VIDEO_AVG_WATCH_TIME("VIDEO_AVG_WATCH_TIME"),
         @Json(name = "VIDEO_V50_WATCH_TIME") VIDEO_V50_WATCH_TIME("VIDEO_V50_WATCH_TIME"),
         @Json(name = "QUARTILE_95_PERCENT_VIEW") QUARTILE_95_PERCENT_VIEW("QUARTILE_95_PERCENT_VIEW"),
         @Json(name = "VIDEO_10S_VIEW") VIDEO_10S_VIEW("VIDEO_10S_VIEW"),
         @Json(name = "VIDEO_START") VIDEO_START("VIDEO_START");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter fromClaimedContent
     */
     enum class FromClaimedContentUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "OTHER") OTHER("OTHER"),
         @Json(name = "CLAIMED") CLAIMED("CLAIMED"),
         @Json(name = "BOTH") BOTH("BOTH");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter pinFormat
     */
     enum class PinFormatUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "ORGANIC_IMAGE") ORGANIC_IMAGE("ORGANIC_IMAGE"),
         @Json(name = "ORGANIC_PRODUCT") ORGANIC_PRODUCT("ORGANIC_PRODUCT"),
         @Json(name = "ORGANIC_VIDEO") ORGANIC_VIDEO("ORGANIC_VIDEO"),
         @Json(name = "ADS_STANDARD") ADS_STANDARD("ADS_STANDARD"),
         @Json(name = "ADS_PRODUCT") ADS_PRODUCT("ADS_PRODUCT"),
         @Json(name = "ADS_VIDEO") ADS_VIDEO("ADS_VIDEO"),
         @Json(name = "ADS_IDEA") ADS_IDEA("ADS_IDEA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter appTypes
     */
     enum class AppTypesUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "MOBILE") MOBILE("MOBILE"),
         @Json(name = "TABLET") TABLET("TABLET"),
         @Json(name = "WEB") WEB("WEB");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter contentType
     */
     enum class ContentTypeUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "PAID") PAID("PAID"),
         @Json(name = "ORGANIC") ORGANIC("ORGANIC");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter source
     */
     enum class SourceUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "ALL") ALL("ALL"),
         @Json(name = "YOUR_PINS") YOUR_PINS("YOUR_PINS"),
         @Json(name = "OTHER_PINS") OTHER_PINS("OTHER_PINS");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter metricTypes
     */
     enum class MetricTypesUserAccountAnalyticsTopVideoPins(val value: kotlin.String) {
         @Json(name = "IMPRESSION") IMPRESSION("IMPRESSION"),
         @Json(name = "SAVE") SAVE("SAVE"),
         @Json(name = "VIDEO_MRC_VIEW") VIDEO_MRC_VIEW("VIDEO_MRC_VIEW"),
         @Json(name = "VIDEO_AVG_WATCH_TIME") VIDEO_AVG_WATCH_TIME("VIDEO_AVG_WATCH_TIME"),
         @Json(name = "VIDEO_V50_WATCH_TIME") VIDEO_V50_WATCH_TIME("VIDEO_V50_WATCH_TIME"),
         @Json(name = "QUARTILE_95_PERCENT_VIEW") QUARTILE_95_PERCENT_VIEW("QUARTILE_95_PERCENT_VIEW"),
         @Json(name = "VIDEO_10S_VIEW") VIDEO_10S_VIEW("VIDEO_10S_VIEW"),
         @Json(name = "VIDEO_START") VIDEO_START("VIDEO_START"),
         @Json(name = "OUTBOUND_CLICK") OUTBOUND_CLICK("OUTBOUND_CLICK");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter createdInLastNDays
     */
     enum class CreatedInLastNDaysUserAccountAnalyticsTopVideoPins(val value: kotlin.Int) {
         @Json(name = "30") _30(30);

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * Get user account top video pins analytics
     * Gets analytics data about a user&#39;s top video pins (limited to the top 50). - By default, the \&quot;operation user_account\&quot; is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;.
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param sortBy Specify sorting order for video metrics
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get video data for, default is all.  (optional)
     * @param numOfPins Number of pins to include, default is 10. Max is 50. (optional, default to 10)
     * @param createdInLastNDays Get metrics for pins created in the last \&quot;n\&quot; days. (optional)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return TopVideoPinsAnalyticsResponse
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccountAnalyticsTopVideoPins(startDate: java.time.LocalDate, endDate: java.time.LocalDate, sortBy: SortByUserAccountAnalyticsTopVideoPins, fromClaimedContent: FromClaimedContentUserAccountAnalyticsTopVideoPins? = FromClaimedContentUserAccountAnalyticsTopVideoPins.BOTH, pinFormat: PinFormatUserAccountAnalyticsTopVideoPins? = PinFormatUserAccountAnalyticsTopVideoPins.ALL, appTypes: AppTypesUserAccountAnalyticsTopVideoPins? = AppTypesUserAccountAnalyticsTopVideoPins.ALL, contentType: ContentTypeUserAccountAnalyticsTopVideoPins? = ContentTypeUserAccountAnalyticsTopVideoPins.ALL, source: SourceUserAccountAnalyticsTopVideoPins? = SourceUserAccountAnalyticsTopVideoPins.ALL, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalyticsTopVideoPins>? = null, numOfPins: kotlin.Int? = 10, createdInLastNDays: CreatedInLastNDaysUserAccountAnalyticsTopVideoPins? = null, adAccountId: kotlin.String? = null) : TopVideoPinsAnalyticsResponse {
        val localVarResponse = userAccountAnalyticsTopVideoPinsWithHttpInfo(startDate = startDate, endDate = endDate, sortBy = sortBy, fromClaimedContent = fromClaimedContent, pinFormat = pinFormat, appTypes = appTypes, contentType = contentType, source = source, metricTypes = metricTypes, numOfPins = numOfPins, createdInLastNDays = createdInLastNDays, adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TopVideoPinsAnalyticsResponse
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user account top video pins analytics
     * Gets analytics data about a user&#39;s top video pins (limited to the top 50). - By default, the \&quot;operation user_account\&quot; is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;.
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param sortBy Specify sorting order for video metrics
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get video data for, default is all.  (optional)
     * @param numOfPins Number of pins to include, default is 10. Max is 50. (optional, default to 10)
     * @param createdInLastNDays Get metrics for pins created in the last \&quot;n\&quot; days. (optional)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<TopVideoPinsAnalyticsResponse?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userAccountAnalyticsTopVideoPinsWithHttpInfo(startDate: java.time.LocalDate, endDate: java.time.LocalDate, sortBy: SortByUserAccountAnalyticsTopVideoPins, fromClaimedContent: FromClaimedContentUserAccountAnalyticsTopVideoPins?, pinFormat: PinFormatUserAccountAnalyticsTopVideoPins?, appTypes: AppTypesUserAccountAnalyticsTopVideoPins?, contentType: ContentTypeUserAccountAnalyticsTopVideoPins?, source: SourceUserAccountAnalyticsTopVideoPins?, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalyticsTopVideoPins>?, numOfPins: kotlin.Int?, createdInLastNDays: CreatedInLastNDaysUserAccountAnalyticsTopVideoPins?, adAccountId: kotlin.String?) : ApiResponse<TopVideoPinsAnalyticsResponse?> {
        val localVariableConfig = userAccountAnalyticsTopVideoPinsRequestConfig(startDate = startDate, endDate = endDate, sortBy = sortBy, fromClaimedContent = fromClaimedContent, pinFormat = pinFormat, appTypes = appTypes, contentType = contentType, source = source, metricTypes = metricTypes, numOfPins = numOfPins, createdInLastNDays = createdInLastNDays, adAccountId = adAccountId)

        return request<Unit, TopVideoPinsAnalyticsResponse>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userAccountAnalyticsTopVideoPins
     *
     * @param startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param sortBy Specify sorting order for video metrics
     * @param fromClaimedContent Filter on Pins that match your claimed domain. (optional, default to BOTH)
     * @param pinFormat Pin formats to get data for, default is all. (optional, default to ALL)
     * @param appTypes Apps or devices to get data for, default is all. (optional, default to ALL)
     * @param contentType Filter to paid or organic data. Default is all. (optional, default to ALL)
     * @param source Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts (optional, default to ALL)
     * @param metricTypes Metric types to get video data for, default is all.  (optional)
     * @param numOfPins Number of pins to include, default is 10. Max is 50. (optional, default to 10)
     * @param createdInLastNDays Get metrics for pins created in the last \&quot;n\&quot; days. (optional)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun userAccountAnalyticsTopVideoPinsRequestConfig(startDate: java.time.LocalDate, endDate: java.time.LocalDate, sortBy: SortByUserAccountAnalyticsTopVideoPins, fromClaimedContent: FromClaimedContentUserAccountAnalyticsTopVideoPins?, pinFormat: PinFormatUserAccountAnalyticsTopVideoPins?, appTypes: AppTypesUserAccountAnalyticsTopVideoPins?, contentType: ContentTypeUserAccountAnalyticsTopVideoPins?, source: SourceUserAccountAnalyticsTopVideoPins?, metricTypes: kotlin.collections.List<MetricTypesUserAccountAnalyticsTopVideoPins>?, numOfPins: kotlin.Int?, createdInLastNDays: CreatedInLastNDaysUserAccountAnalyticsTopVideoPins?, adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start_date", listOf(parseDateToQueryString(startDate)))
                put("end_date", listOf(parseDateToQueryString(endDate)))
                put("sort_by", listOf(sortBy.value))
                if (fromClaimedContent != null) {
                    put("from_claimed_content", listOf(fromClaimedContent.value))
                }
                if (pinFormat != null) {
                    put("pin_format", listOf(pinFormat.value))
                }
                if (appTypes != null) {
                    put("app_types", listOf(appTypes.value))
                }
                if (contentType != null) {
                    put("content_type", listOf(contentType.value))
                }
                if (source != null) {
                    put("source", listOf(source.value))
                }
                if (metricTypes != null) {
                    put("metric_types", toMultiValue(metricTypes.toList(), "csv"))
                }
                if (numOfPins != null) {
                    put("num_of_pins", listOf(numOfPins.toString()))
                }
                if (createdInLastNDays != null) {
                    put("created_in_last_n_days", listOf(createdInLastNDays.toString()))
                }
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/analytics/top_video_pins",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List following interests
     * Get a list of a user&#39;s following interests in one place.
     * @param username A valid username
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return UserAccountFollowedInterests200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccountFollowedInterests(username: kotlin.String, bookmark: kotlin.String? = null, pageSize: kotlin.Int? = 25) : UserAccountFollowedInterests200Response {
        val localVarResponse = userAccountFollowedInterestsWithHttpInfo(username = username, bookmark = bookmark, pageSize = pageSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserAccountFollowedInterests200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List following interests
     * Get a list of a user&#39;s following interests in one place.
     * @param username A valid username
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return ApiResponse<UserAccountFollowedInterests200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userAccountFollowedInterestsWithHttpInfo(username: kotlin.String, bookmark: kotlin.String?, pageSize: kotlin.Int?) : ApiResponse<UserAccountFollowedInterests200Response?> {
        val localVariableConfig = userAccountFollowedInterestsRequestConfig(username = username, bookmark = bookmark, pageSize = pageSize)

        return request<Unit, UserAccountFollowedInterests200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userAccountFollowedInterests
     *
     * @param username A valid username
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return RequestConfig
     */
    fun userAccountFollowedInterestsRequestConfig(username: kotlin.String, bookmark: kotlin.String?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bookmark != null) {
                    put("bookmark", listOf(bookmark.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/users/{username}/interests/follow".replace("{"+"username"+"}", encodeURIComponent(username.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user account
     * Get account information for the \&quot;operation user_account\&quot; - By default, the \&quot;operation user_account\&quot; is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;. See &lt;a href&#x3D;&#39;/docs/getting-started/using-business-access/&#39;&gt;Understanding Business Access&lt;/a&gt; for more information.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return Account
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userAccountGet(adAccountId: kotlin.String? = null) : Account {
        val localVarResponse = userAccountGetWithHttpInfo(adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Account
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user account
     * Get account information for the \&quot;operation user_account\&quot; - By default, the \&quot;operation user_account\&quot; is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \&quot;operation user_account\&quot;. See &lt;a href&#x3D;&#39;/docs/getting-started/using-business-access/&#39;&gt;Understanding Business Access&lt;/a&gt; for more information.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<Account?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userAccountGetWithHttpInfo(adAccountId: kotlin.String?) : ApiResponse<Account?> {
        val localVariableConfig = userAccountGetRequestConfig(adAccountId = adAccountId)

        return request<Unit, Account>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userAccountGet
     *
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun userAccountGetRequestConfig(adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * List following
     * Get a list of who a certain user follows.
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @param feedType Thrift param specifying what type of followees will be kept. Default to include all followees. (optional, default to ALL)
     * @param explicitFollowing Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows. (optional, default to false)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return UserFollowingGet200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userFollowingGet(bookmark: kotlin.String? = null, pageSize: kotlin.Int? = 25, feedType: UserFollowingFeedType? = ALL, explicitFollowing: kotlin.Boolean? = false, adAccountId: kotlin.String? = null) : UserFollowingGet200Response {
        val localVarResponse = userFollowingGetWithHttpInfo(bookmark = bookmark, pageSize = pageSize, feedType = feedType, explicitFollowing = explicitFollowing, adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserFollowingGet200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * List following
     * Get a list of who a certain user follows.
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @param feedType Thrift param specifying what type of followees will be kept. Default to include all followees. (optional, default to ALL)
     * @param explicitFollowing Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows. (optional, default to false)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<UserFollowingGet200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userFollowingGetWithHttpInfo(bookmark: kotlin.String?, pageSize: kotlin.Int?, feedType: UserFollowingFeedType?, explicitFollowing: kotlin.Boolean?, adAccountId: kotlin.String?) : ApiResponse<UserFollowingGet200Response?> {
        val localVariableConfig = userFollowingGetRequestConfig(bookmark = bookmark, pageSize = pageSize, feedType = feedType, explicitFollowing = explicitFollowing, adAccountId = adAccountId)

        return request<Unit, UserFollowingGet200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userFollowingGet
     *
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @param feedType Thrift param specifying what type of followees will be kept. Default to include all followees. (optional, default to ALL)
     * @param explicitFollowing Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows. (optional, default to false)
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun userFollowingGetRequestConfig(bookmark: kotlin.String?, pageSize: kotlin.Int?, feedType: UserFollowingFeedType?, explicitFollowing: kotlin.Boolean?, adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bookmark != null) {
                    put("bookmark", listOf(bookmark.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
                if (feedType != null) {
                    put("feed_type", listOf(feedType.toString()))
                }
                if (explicitFollowing != null) {
                    put("explicit_following", listOf(explicitFollowing.toString()))
                }
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/following",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user websites
     * Get user websites, claimed or not
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return UserWebsitesGet200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun userWebsitesGet(bookmark: kotlin.String? = null, pageSize: kotlin.Int? = 25) : UserWebsitesGet200Response {
        val localVarResponse = userWebsitesGetWithHttpInfo(bookmark = bookmark, pageSize = pageSize)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWebsitesGet200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user websites
     * Get user websites, claimed or not
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return ApiResponse<UserWebsitesGet200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun userWebsitesGetWithHttpInfo(bookmark: kotlin.String?, pageSize: kotlin.Int?) : ApiResponse<UserWebsitesGet200Response?> {
        val localVariableConfig = userWebsitesGetRequestConfig(bookmark = bookmark, pageSize = pageSize)

        return request<Unit, UserWebsitesGet200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation userWebsitesGet
     *
     * @param bookmark Cursor used to fetch the next page of items (optional)
     * @param pageSize Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information. (optional, default to 25)
     * @return RequestConfig
     */
    fun userWebsitesGetRequestConfig(bookmark: kotlin.String?, pageSize: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (bookmark != null) {
                    put("bookmark", listOf(bookmark.toString()))
                }
                if (pageSize != null) {
                    put("page_size", listOf(pageSize.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/websites",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Verify website
     * Verify a website as a signed-in user.
     * @param userWebsiteVerifyRequest Verify a website.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return UserWebsiteSummary
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun verifyWebsiteUpdate(userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId: kotlin.String? = null) : UserWebsiteSummary {
        val localVarResponse = verifyWebsiteUpdateWithHttpInfo(userWebsiteVerifyRequest = userWebsiteVerifyRequest, adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWebsiteSummary
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Verify website
     * Verify a website as a signed-in user.
     * @param userWebsiteVerifyRequest Verify a website.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<UserWebsiteSummary?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun verifyWebsiteUpdateWithHttpInfo(userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId: kotlin.String?) : ApiResponse<UserWebsiteSummary?> {
        val localVariableConfig = verifyWebsiteUpdateRequestConfig(userWebsiteVerifyRequest = userWebsiteVerifyRequest, adAccountId = adAccountId)

        return request<UserWebsiteVerifyRequest, UserWebsiteSummary>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation verifyWebsiteUpdate
     *
     * @param userWebsiteVerifyRequest Verify a website.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun verifyWebsiteUpdateRequestConfig(userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId: kotlin.String?) : RequestConfig<UserWebsiteVerifyRequest> {
        val localVariableBody = userWebsiteVerifyRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/user_account/websites",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * Get user verification code for website claiming
     * Get verification code for user to install on the website to claim it.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return UserWebsiteVerificationCode
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun websiteVerificationGet(adAccountId: kotlin.String? = null) : UserWebsiteVerificationCode {
        val localVarResponse = websiteVerificationGetWithHttpInfo(adAccountId = adAccountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as UserWebsiteVerificationCode
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * Get user verification code for website claiming
     * Get verification code for user to install on the website to claim it.
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return ApiResponse<UserWebsiteVerificationCode?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun websiteVerificationGetWithHttpInfo(adAccountId: kotlin.String?) : ApiResponse<UserWebsiteVerificationCode?> {
        val localVariableConfig = websiteVerificationGetRequestConfig(adAccountId = adAccountId)

        return request<Unit, UserWebsiteVerificationCode>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation websiteVerificationGet
     *
     * @param adAccountId Unique identifier of an ad account. (optional)
     * @return RequestConfig
     */
    fun websiteVerificationGetRequestConfig(adAccountId: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adAccountId != null) {
                    put("ad_account_id", listOf(adAccountId.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/user_account/websites/verification",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
