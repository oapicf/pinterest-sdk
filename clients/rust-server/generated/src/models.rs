#![allow(unused_qualifications)]

use crate::models;
#[cfg(any(feature = "client", feature = "server"))]
use crate::header;

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Account {
    /// Type of account
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "account_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub account_type: Option<String>,

    #[serde(rename = "profile_image")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub profile_image: Option<String>,

    #[serde(rename = "website_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub website_url: Option<String>,

    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}

impl Account {
    pub fn new() -> Account {
        Account {
            account_type: None,
            profile_image: None,
            website_url: None,
            username: None,
        }
    }
}

/// Converts the Account value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Account {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref account_type) = self.account_type {
            params.push("account_type".to_string());
            params.push(account_type.to_string());
        }


        if let Some(ref profile_image) = self.profile_image {
            params.push("profile_image".to_string());
            params.push(profile_image.to_string());
        }


        if let Some(ref website_url) = self.website_url {
            params.push("website_url".to_string());
            params.push(website_url.to_string());
        }


        if let Some(ref username) = self.username {
            params.push("username".to_string());
            params.push(username.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Account value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Account {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub account_type: Vec<String>,
            pub profile_image: Vec<String>,
            pub website_url: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Account".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "account_type" => intermediate_rep.account_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "profile_image" => intermediate_rep.profile_image.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "website_url" => intermediate_rep.website_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Account".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Account {
            account_type: intermediate_rep.account_type.into_iter().next(),
            profile_image: intermediate_rep.profile_image.into_iter().next(),
            website_url: intermediate_rep.website_url.into_iter().next(),
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Account> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Account>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Account>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Account - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Account> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Account as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Account - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Ad group billable event type.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ActionType {
    #[serde(rename = "CLICKTHROUGH")]
    CLICKTHROUGH,
    #[serde(rename = "IMPRESSION")]
    IMPRESSION,
    #[serde(rename = "VIDEO_V_50_MRC")]
    VIDEO_V_50_MRC,
    #[serde(rename = "BILLABLE_ENGAGEMENT")]
    BILLABLE_ENGAGEMENT,
}

impl std::fmt::Display for ActionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ActionType::CLICKTHROUGH => write!(f, "{}", "CLICKTHROUGH"),
            ActionType::IMPRESSION => write!(f, "{}", "IMPRESSION"),
            ActionType::VIDEO_V_50_MRC => write!(f, "{}", "VIDEO_V_50_MRC"),
            ActionType::BILLABLE_ENGAGEMENT => write!(f, "{}", "BILLABLE_ENGAGEMENT"),
        }
    }
}

impl std::str::FromStr for ActionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "CLICKTHROUGH" => std::result::Result::Ok(ActionType::CLICKTHROUGH),
            "IMPRESSION" => std::result::Result::Ok(ActionType::IMPRESSION),
            "VIDEO_V_50_MRC" => std::result::Result::Ok(ActionType::VIDEO_V_50_MRC),
            "BILLABLE_ENGAGEMENT" => std::result::Result::Ok(ActionType::BILLABLE_ENGAGEMENT),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccount {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<models::AdAccountOwner>,

    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<models::Country>,

    #[serde(rename = "currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub currency: Option<models::Currency>,

}

impl AdAccount {
    pub fn new() -> AdAccount {
        AdAccount {
            id: None,
            name: None,
            owner: None,
            country: None,
            currency: None,
        }
    }
}

/// Converts the AdAccount value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdAccount {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        // Skipping owner in query parameter serialization

        // Skipping country in query parameter serialization

        // Skipping currency in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccount value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccount {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub owner: Vec<models::AdAccountOwner>,
            pub country: Vec<models::Country>,
            pub currency: Vec<models::Currency>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccount".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "owner" => intermediate_rep.owner.push(<models::AdAccountOwner as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "currency" => intermediate_rep.currency.push(<models::Currency as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccount".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccount {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
            owner: intermediate_rep.owner.into_iter().next(),
            country: intermediate_rep.country.into_iter().next(),
            currency: intermediate_rep.currency.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccount> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccount>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccount>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccount - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdAccount> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccount as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccount - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdAccountOwner {
    /// Public username for the user account
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}

impl AdAccountOwner {
    pub fn new() -> AdAccountOwner {
        AdAccountOwner {
            username: None,
        }
    }
}

/// Converts the AdAccountOwner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdAccountOwner {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref username) = self.username {
            params.push("username".to_string());
            params.push(username.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdAccountOwner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdAccountOwner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdAccountOwner".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdAccountOwner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdAccountOwner {
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdAccountOwner> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdAccountOwner>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdAccountOwner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdAccountOwner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdAccountOwner> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdAccountOwner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdAccountOwner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupResponse {
    /// Ad group name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Ad group/entity status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<EntityStatus>,

    /// Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
    #[serde(rename = "budget_in_micro_currency")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_in_micro_currency: Option<swagger::Nullable<isize>>,

    /// Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<swagger::Nullable<isize>>,

    /// Budget type. If DAILY, an ad group's daily spend will not exceed the budget parameter value. If LIFETIME, the end_time parameter is **REQUIRED**, and the ad group spend is spread evenly between the ad group `start_time` and `end_time` range. A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "budget_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_type: Option<String>,

    /// Ad group start time. Unix timestamp in seconds. Defaults to current time.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<swagger::Nullable<isize>>,

    /// Ad group end time. Unix timestamp in seconds.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<swagger::Nullable<isize>>,

    /// Ad group targeting specification defining the ad group target audience. For example, '{\"APPTYPE\":[\"iphone\"], \"GENDER\":[\"male\"], \"LOCALE\":[\"en-US\"], \"LOCATION\":[\"501\"], \"AGE_BUCKET\":[\"25-34\"]}'
    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<std::collections::HashMap<String, Vec<String>>>,

    /// Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\\\"/docs/redoc/#section/Billable-event\\\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
    #[serde(rename = "lifetime_frequency_cap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_frequency_cap: Option<isize>,

    /// Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"https://developers.pinterest.com/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<swagger::Nullable<TrackingUrls>>,

    /// Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<swagger::Nullable<bool>>,

    /// <a href=\\\"/docs/redoc/#section/Placement-group\\\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<PlacementGroupType>,

    /// Pacing delivery type. With ACCELERATED, an ad group budget is spent as fast as possible. With STANDARD, an ad group budget is spent smoothly over a day.
    #[serde(rename = "pacing_delivery_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pacing_delivery_type: Option<PacingDeliveryType>,

    /// oCPM learn mode
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "conversion_learning_mode_type")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_learning_mode_type: Option<swagger::Nullable<String>>,

    /// Ad group summary status.
    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<AdGroupSummaryStatus>,

    /// Feed Profile ID associated to the adgroup.
    #[serde(rename = "feed_profile_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_profile_id: Option<String>,

    /// Campaign ID of the ad group.
    #[serde(rename = "campaign_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    #[serde(rename = "billable_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_event: Option<models::ActionType>,

    /// Ad group ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Always \"adgroup\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<String>,

    /// Advertiser ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

    /// Ad group creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<isize>,

    /// Ad group last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<isize>,

}

impl AdGroupResponse {
    pub fn new() -> AdGroupResponse {
        AdGroupResponse {
            name: None,
            status: None,
            budget_in_micro_currency: None,
            bid_in_micro_currency: None,
            budget_type: None,
            start_time: None,
            end_time: None,
            targeting_spec: None,
            lifetime_frequency_cap: None,
            tracking_urls: None,
            auto_targeting_enabled: None,
            placement_group: None,
            pacing_delivery_type: None,
            conversion_learning_mode_type: None,
            summary_status: None,
            feed_profile_id: None,
            campaign_id: None,
            billable_event: None,
            id: None,
            type_: None,
            ad_account_id: None,
            created_time: None,
            updated_time: None,
        }
    }
}

/// Converts the AdGroupResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdGroupResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        // Skipping status in query parameter serialization


        if let Some(ref budget_in_micro_currency) = self.budget_in_micro_currency {
            params.push("budget_in_micro_currency".to_string());
            params.push(budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref bid_in_micro_currency) = self.bid_in_micro_currency {
            params.push("bid_in_micro_currency".to_string());
            params.push(bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref budget_type) = self.budget_type {
            params.push("budget_type".to_string());
            params.push(budget_type.to_string());
        }


        if let Some(ref start_time) = self.start_time {
            params.push("start_time".to_string());
            params.push(start_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref end_time) = self.end_time {
            params.push("end_time".to_string());
            params.push(end_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping targeting_spec in query parameter serialization
        // Skipping targeting_spec in query parameter serialization


        if let Some(ref lifetime_frequency_cap) = self.lifetime_frequency_cap {
            params.push("lifetime_frequency_cap".to_string());
            params.push(lifetime_frequency_cap.to_string());
        }

        // Skipping tracking_urls in query parameter serialization
        // Skipping tracking_urls in query parameter serialization


        if let Some(ref auto_targeting_enabled) = self.auto_targeting_enabled {
            params.push("auto_targeting_enabled".to_string());
            params.push(auto_targeting_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping placement_group in query parameter serialization

        // Skipping pacing_delivery_type in query parameter serialization


        if let Some(ref conversion_learning_mode_type) = self.conversion_learning_mode_type {
            params.push("conversion_learning_mode_type".to_string());
            params.push(conversion_learning_mode_type.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping summary_status in query parameter serialization


        if let Some(ref feed_profile_id) = self.feed_profile_id {
            params.push("feed_profile_id".to_string());
            params.push(feed_profile_id.to_string());
        }


        if let Some(ref campaign_id) = self.campaign_id {
            params.push("campaign_id".to_string());
            params.push(campaign_id.to_string());
        }

        // Skipping billable_event in query parameter serialization


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref type_) = self.type_ {
            params.push("type".to_string());
            params.push(type_.to_string());
        }


        if let Some(ref ad_account_id) = self.ad_account_id {
            params.push("ad_account_id".to_string());
            params.push(ad_account_id.to_string());
        }


        if let Some(ref created_time) = self.created_time {
            params.push("created_time".to_string());
            params.push(created_time.to_string());
        }


        if let Some(ref updated_time) = self.updated_time {
            params.push("updated_time".to_string());
            params.push(updated_time.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<EntityStatus>,
            pub budget_in_micro_currency: Vec<isize>,
            pub bid_in_micro_currency: Vec<isize>,
            pub budget_type: Vec<String>,
            pub start_time: Vec<isize>,
            pub end_time: Vec<isize>,
            pub targeting_spec: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub lifetime_frequency_cap: Vec<isize>,
            pub tracking_urls: Vec<TrackingUrls>,
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<PlacementGroupType>,
            pub pacing_delivery_type: Vec<PacingDeliveryType>,
            pub conversion_learning_mode_type: Vec<String>,
            pub summary_status: Vec<AdGroupSummaryStatus>,
            pub feed_profile_id: Vec<String>,
            pub campaign_id: Vec<String>,
            pub billable_event: Vec<models::ActionType>,
            pub id: Vec<String>,
            pub type_: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub created_time: Vec<isize>,
            pub updated_time: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "budget_type" => intermediate_rep.budget_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "targeting_spec" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupResponse".to_string()),
                    "lifetime_frequency_cap" => intermediate_rep.lifetime_frequency_cap.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "auto_targeting_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "placement_group" => intermediate_rep.placement_group.push(<PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "pacing_delivery_type" => intermediate_rep.pacing_delivery_type.push(<PacingDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "conversion_learning_mode_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponse".to_string()),
                    "summary_status" => intermediate_rep.summary_status.push(<AdGroupSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "feed_profile_id" => intermediate_rep.feed_profile_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_time" => intermediate_rep.created_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time" => intermediate_rep.updated_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupResponse {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            budget_type: intermediate_rep.budget_type.into_iter().next(),
            start_time: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            lifetime_frequency_cap: intermediate_rep.lifetime_frequency_cap.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            auto_targeting_enabled: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            pacing_delivery_type: intermediate_rep.pacing_delivery_type.into_iter().next(),
            conversion_learning_mode_type: std::result::Result::Err("Nullable types not supported in AdGroupResponse".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            feed_profile_id: intermediate_rep.feed_profile_id.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            billable_event: intermediate_rep.billable_event.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            type_: intermediate_rep.type_.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdGroupResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupResponseAllOf {
    /// Ad group name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// Ad group/entity status.
    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<EntityStatus>,

    /// Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
    #[serde(rename = "budget_in_micro_currency")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_in_micro_currency: Option<swagger::Nullable<isize>>,

    /// Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
    #[serde(rename = "bid_in_micro_currency")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bid_in_micro_currency: Option<swagger::Nullable<isize>>,

    /// Budget type. If DAILY, an ad group's daily spend will not exceed the budget parameter value. If LIFETIME, the end_time parameter is **REQUIRED**, and the ad group spend is spread evenly between the ad group `start_time` and `end_time` range. A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "budget_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub budget_type: Option<String>,

    /// Ad group start time. Unix timestamp in seconds. Defaults to current time.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<swagger::Nullable<isize>>,

    /// Ad group end time. Unix timestamp in seconds.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<swagger::Nullable<isize>>,

    /// Ad group targeting specification defining the ad group target audience. For example, '{\"APPTYPE\":[\"iphone\"], \"GENDER\":[\"male\"], \"LOCALE\":[\"en-US\"], \"LOCATION\":[\"501\"], \"AGE_BUCKET\":[\"25-34\"]}'
    #[serde(rename = "targeting_spec")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_spec: Option<std::collections::HashMap<String, Vec<String>>>,

    /// Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\\\"/docs/redoc/#section/Billable-event\\\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
    #[serde(rename = "lifetime_frequency_cap")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_frequency_cap: Option<isize>,

    /// Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"https://developers.pinterest.com/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<swagger::Nullable<TrackingUrls>>,

    /// Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
    #[serde(rename = "auto_targeting_enabled")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub auto_targeting_enabled: Option<swagger::Nullable<bool>>,

    /// <a href=\\\"/docs/redoc/#section/Placement-group\\\">Placement group</a>.
    #[serde(rename = "placement_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub placement_group: Option<PlacementGroupType>,

    /// Pacing delivery type. With ACCELERATED, an ad group budget is spent as fast as possible. With STANDARD, an ad group budget is spent smoothly over a day.
    #[serde(rename = "pacing_delivery_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pacing_delivery_type: Option<PacingDeliveryType>,

    /// oCPM learn mode
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "conversion_learning_mode_type")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_learning_mode_type: Option<swagger::Nullable<String>>,

    /// Ad group summary status.
    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<AdGroupSummaryStatus>,

    /// Feed Profile ID associated to the adgroup.
    #[serde(rename = "feed_profile_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_profile_id: Option<String>,

}

impl AdGroupResponseAllOf {
    pub fn new() -> AdGroupResponseAllOf {
        AdGroupResponseAllOf {
            name: None,
            status: None,
            budget_in_micro_currency: None,
            bid_in_micro_currency: None,
            budget_type: None,
            start_time: None,
            end_time: None,
            targeting_spec: None,
            lifetime_frequency_cap: None,
            tracking_urls: None,
            auto_targeting_enabled: None,
            placement_group: None,
            pacing_delivery_type: None,
            conversion_learning_mode_type: None,
            summary_status: None,
            feed_profile_id: None,
        }
    }
}

/// Converts the AdGroupResponseAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdGroupResponseAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        // Skipping status in query parameter serialization


        if let Some(ref budget_in_micro_currency) = self.budget_in_micro_currency {
            params.push("budget_in_micro_currency".to_string());
            params.push(budget_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref bid_in_micro_currency) = self.bid_in_micro_currency {
            params.push("bid_in_micro_currency".to_string());
            params.push(bid_in_micro_currency.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref budget_type) = self.budget_type {
            params.push("budget_type".to_string());
            params.push(budget_type.to_string());
        }


        if let Some(ref start_time) = self.start_time {
            params.push("start_time".to_string());
            params.push(start_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref end_time) = self.end_time {
            params.push("end_time".to_string());
            params.push(end_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping targeting_spec in query parameter serialization
        // Skipping targeting_spec in query parameter serialization


        if let Some(ref lifetime_frequency_cap) = self.lifetime_frequency_cap {
            params.push("lifetime_frequency_cap".to_string());
            params.push(lifetime_frequency_cap.to_string());
        }

        // Skipping tracking_urls in query parameter serialization
        // Skipping tracking_urls in query parameter serialization


        if let Some(ref auto_targeting_enabled) = self.auto_targeting_enabled {
            params.push("auto_targeting_enabled".to_string());
            params.push(auto_targeting_enabled.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping placement_group in query parameter serialization

        // Skipping pacing_delivery_type in query parameter serialization


        if let Some(ref conversion_learning_mode_type) = self.conversion_learning_mode_type {
            params.push("conversion_learning_mode_type".to_string());
            params.push(conversion_learning_mode_type.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping summary_status in query parameter serialization


        if let Some(ref feed_profile_id) = self.feed_profile_id {
            params.push("feed_profile_id".to_string());
            params.push(feed_profile_id.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupResponseAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupResponseAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub name: Vec<String>,
            pub status: Vec<EntityStatus>,
            pub budget_in_micro_currency: Vec<isize>,
            pub bid_in_micro_currency: Vec<isize>,
            pub budget_type: Vec<String>,
            pub start_time: Vec<isize>,
            pub end_time: Vec<isize>,
            pub targeting_spec: Vec<std::collections::HashMap<String, Vec<String>>>,
            pub lifetime_frequency_cap: Vec<isize>,
            pub tracking_urls: Vec<TrackingUrls>,
            pub auto_targeting_enabled: Vec<bool>,
            pub placement_group: Vec<PlacementGroupType>,
            pub pacing_delivery_type: Vec<PacingDeliveryType>,
            pub conversion_learning_mode_type: Vec<String>,
            pub summary_status: Vec<AdGroupSummaryStatus>,
            pub feed_profile_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupResponseAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "budget_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "bid_in_micro_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "budget_type" => intermediate_rep.budget_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "targeting_spec" => return std::result::Result::Err("Parsing a container in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "lifetime_frequency_cap" => intermediate_rep.lifetime_frequency_cap.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "auto_targeting_enabled" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "placement_group" => intermediate_rep.placement_group.push(<PlacementGroupType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "pacing_delivery_type" => intermediate_rep.pacing_delivery_type.push(<PacingDeliveryType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "conversion_learning_mode_type" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdGroupResponseAllOf".to_string()),
                    "summary_status" => intermediate_rep.summary_status.push(<AdGroupSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "feed_profile_id" => intermediate_rep.feed_profile_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupResponseAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupResponseAllOf {
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            budget_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            bid_in_micro_currency: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            budget_type: intermediate_rep.budget_type.into_iter().next(),
            start_time: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            targeting_spec: intermediate_rep.targeting_spec.into_iter().next(),
            lifetime_frequency_cap: intermediate_rep.lifetime_frequency_cap.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            auto_targeting_enabled: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            placement_group: intermediate_rep.placement_group.into_iter().next(),
            pacing_delivery_type: intermediate_rep.pacing_delivery_type.into_iter().next(),
            conversion_learning_mode_type: std::result::Result::Err("Nullable types not supported in AdGroupResponseAllOf".to_string())?,
            summary_status: intermediate_rep.summary_status.into_iter().next(),
            feed_profile_id: intermediate_rep.feed_profile_id.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupResponseAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupResponseAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupResponseAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupResponseAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdGroupResponseAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupResponseAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupResponseAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdGroupResponseAllOf1 {
    /// Campaign ID of the ad group.
    #[serde(rename = "campaign_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    #[serde(rename = "billable_event")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub billable_event: Option<models::ActionType>,

    /// Ad group ID.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Always \"adgroup\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<String>,

    /// Advertiser ID.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

    /// Ad group creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<isize>,

    /// Ad group last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<isize>,

}

impl AdGroupResponseAllOf1 {
    pub fn new() -> AdGroupResponseAllOf1 {
        AdGroupResponseAllOf1 {
            campaign_id: None,
            billable_event: None,
            id: None,
            type_: None,
            ad_account_id: None,
            created_time: None,
            updated_time: None,
        }
    }
}

/// Converts the AdGroupResponseAllOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdGroupResponseAllOf1 {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref campaign_id) = self.campaign_id {
            params.push("campaign_id".to_string());
            params.push(campaign_id.to_string());
        }

        // Skipping billable_event in query parameter serialization


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref type_) = self.type_ {
            params.push("type".to_string());
            params.push(type_.to_string());
        }


        if let Some(ref ad_account_id) = self.ad_account_id {
            params.push("ad_account_id".to_string());
            params.push(ad_account_id.to_string());
        }


        if let Some(ref created_time) = self.created_time {
            params.push("created_time".to_string());
            params.push(created_time.to_string());
        }


        if let Some(ref updated_time) = self.updated_time {
            params.push("updated_time".to_string());
            params.push(updated_time.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdGroupResponseAllOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdGroupResponseAllOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub campaign_id: Vec<String>,
            pub billable_event: Vec<models::ActionType>,
            pub id: Vec<String>,
            pub type_: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub created_time: Vec<isize>,
            pub updated_time: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdGroupResponseAllOf1".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "billable_event" => intermediate_rep.billable_event.push(<models::ActionType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_time" => intermediate_rep.created_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time" => intermediate_rep.updated_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdGroupResponseAllOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdGroupResponseAllOf1 {
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            billable_event: intermediate_rep.billable_event.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            type_: intermediate_rep.type_.into_iter().next(),
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdGroupResponseAllOf1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdGroupResponseAllOf1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdGroupResponseAllOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdGroupResponseAllOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdGroupResponseAllOf1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdGroupResponseAllOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdGroupResponseAllOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Summary status for ad group
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdGroupSummaryStatus {
    #[serde(rename = "RUNNING")]
    RUNNING,
    #[serde(rename = "PAUSED")]
    PAUSED,
    #[serde(rename = "NOT_STARTED")]
    NOT_STARTED,
    #[serde(rename = "COMPLETED")]
    COMPLETED,
    #[serde(rename = "ADVERTISER_DISABLED")]
    ADVERTISER_DISABLED,
    #[serde(rename = "ARCHIVED")]
    ARCHIVED,
}

impl std::fmt::Display for AdGroupSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdGroupSummaryStatus::RUNNING => write!(f, "{}", "RUNNING"),
            AdGroupSummaryStatus::PAUSED => write!(f, "{}", "PAUSED"),
            AdGroupSummaryStatus::NOT_STARTED => write!(f, "{}", "NOT_STARTED"),
            AdGroupSummaryStatus::COMPLETED => write!(f, "{}", "COMPLETED"),
            AdGroupSummaryStatus::ADVERTISER_DISABLED => write!(f, "{}", "ADVERTISER_DISABLED"),
            AdGroupSummaryStatus::ARCHIVED => write!(f, "{}", "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for AdGroupSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(AdGroupSummaryStatus::RUNNING),
            "PAUSED" => std::result::Result::Ok(AdGroupSummaryStatus::PAUSED),
            "NOT_STARTED" => std::result::Result::Ok(AdGroupSummaryStatus::NOT_STARTED),
            "COMPLETED" => std::result::Result::Ok(AdGroupSummaryStatus::COMPLETED),
            "ADVERTISER_DISABLED" => std::result::Result::Ok(AdGroupSummaryStatus::ADVERTISER_DISABLED),
            "ARCHIVED" => std::result::Result::Ok(AdGroupSummaryStatus::ARCHIVED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdResponse {
    /// ID of the ad group that contains the ad.
    #[serde(rename = "ad_group_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_id: Option<String>,

    /// Deep link URL for Android devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "android_deep_link")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<swagger::Nullable<String>>,

    /// Comma-separated deep links for the carousel pin on Android.
    #[serde(rename = "carousel_android_deep_links")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_android_deep_links: Option<swagger::Nullable<Vec<String>>>,

    /// Comma-separated destination URLs for the carousel pin to promote.
    #[serde(rename = "carousel_destination_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_destination_urls: Option<swagger::Nullable<Vec<String>>>,

    /// Comma-separated deep links for the carousel pin on iOS.
    #[serde(rename = "carousel_ios_deep_links")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_ios_deep_links: Option<swagger::Nullable<Vec<String>>>,

    /// Tracking url for the ad clicks.
    #[serde(rename = "click_tracking_url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_tracking_url: Option<swagger::Nullable<String>>,

    /// Ad creative type enum
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<String>,

    /// Destination URL.
    #[serde(rename = "destination_url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<swagger::Nullable<String>>,

    /// Deep link URL for iOS devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "ios_deep_link")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<swagger::Nullable<String>>,

    /// Is original pin deleted?
    #[serde(rename = "is_pin_deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pin_deleted: Option<bool>,

    /// Is pin repinnable?
    #[serde(rename = "is_removable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_removable: Option<bool>,

    /// Name of the ad - 255 chars max.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

    /// Pin ID.
    #[serde(rename = "pin_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<swagger::Nullable<TrackingUrls>>,

    /// Tracking URL for ad impressions.
    #[serde(rename = "view_tracking_url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_tracking_url: Option<swagger::Nullable<String>>,

    /// The ID of the advertiser that this ad belongs to.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

    /// ID of the ad campaign that contains this ad.
    #[serde(rename = "campaign_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    /// Destination URL template for all items within a collections drawer.
    #[serde(rename = "collection_items_destination_url_template")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub collection_items_destination_url_template: Option<swagger::Nullable<String>>,

    /// Pin creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<isize>,

    /// The ID of this ad.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Enum reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "rejected_reasons")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_reasons: Option<Vec<String>>,

    /// Text reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
    #[serde(rename = "rejection_labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejection_labels: Option<Vec<String>>,

    /// Ad review status
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "review_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_status: Option<String>,

    /// Always \"ad\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<String>,

    /// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<isize>,

    /// Ad summary status
    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<PinPromotionSummaryStatus>,

}

impl AdResponse {
    pub fn new() -> AdResponse {
        AdResponse {
            ad_group_id: None,
            android_deep_link: None,
            carousel_android_deep_links: None,
            carousel_destination_urls: None,
            carousel_ios_deep_links: None,
            click_tracking_url: None,
            creative_type: None,
            destination_url: None,
            ios_deep_link: None,
            is_pin_deleted: None,
            is_removable: None,
            name: None,
            pin_id: None,
            status: None,
            tracking_urls: None,
            view_tracking_url: None,
            ad_account_id: None,
            campaign_id: None,
            collection_items_destination_url_template: None,
            created_time: None,
            id: None,
            rejected_reasons: None,
            rejection_labels: None,
            review_status: None,
            type_: None,
            updated_time: None,
            summary_status: None,
        }
    }
}

/// Converts the AdResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref ad_group_id) = self.ad_group_id {
            params.push("ad_group_id".to_string());
            params.push(ad_group_id.to_string());
        }


        if let Some(ref android_deep_link) = self.android_deep_link {
            params.push("android_deep_link".to_string());
            params.push(android_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref carousel_android_deep_links) = self.carousel_android_deep_links {
            params.push("carousel_android_deep_links".to_string());
            params.push(carousel_android_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string()));
        }


        if let Some(ref carousel_destination_urls) = self.carousel_destination_urls {
            params.push("carousel_destination_urls".to_string());
            params.push(carousel_destination_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string()));
        }


        if let Some(ref carousel_ios_deep_links) = self.carousel_ios_deep_links {
            params.push("carousel_ios_deep_links".to_string());
            params.push(carousel_ios_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string()));
        }


        if let Some(ref click_tracking_url) = self.click_tracking_url {
            params.push("click_tracking_url".to_string());
            params.push(click_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref creative_type) = self.creative_type {
            params.push("creative_type".to_string());
            params.push(creative_type.to_string());
        }


        if let Some(ref destination_url) = self.destination_url {
            params.push("destination_url".to_string());
            params.push(destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref ios_deep_link) = self.ios_deep_link {
            params.push("ios_deep_link".to_string());
            params.push(ios_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref is_pin_deleted) = self.is_pin_deleted {
            params.push("is_pin_deleted".to_string());
            params.push(is_pin_deleted.to_string());
        }


        if let Some(ref is_removable) = self.is_removable {
            params.push("is_removable".to_string());
            params.push(is_removable.to_string());
        }


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref pin_id) = self.pin_id {
            params.push("pin_id".to_string());
            params.push(pin_id.to_string());
        }

        // Skipping status in query parameter serialization

        // Skipping tracking_urls in query parameter serialization
        // Skipping tracking_urls in query parameter serialization


        if let Some(ref view_tracking_url) = self.view_tracking_url {
            params.push("view_tracking_url".to_string());
            params.push(view_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref ad_account_id) = self.ad_account_id {
            params.push("ad_account_id".to_string());
            params.push(ad_account_id.to_string());
        }


        if let Some(ref campaign_id) = self.campaign_id {
            params.push("campaign_id".to_string());
            params.push(campaign_id.to_string());
        }


        if let Some(ref collection_items_destination_url_template) = self.collection_items_destination_url_template {
            params.push("collection_items_destination_url_template".to_string());
            params.push(collection_items_destination_url_template.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref created_time) = self.created_time {
            params.push("created_time".to_string());
            params.push(created_time.to_string());
        }


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref rejected_reasons) = self.rejected_reasons {
            params.push("rejected_reasons".to_string());
            params.push(rejected_reasons.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref rejection_labels) = self.rejection_labels {
            params.push("rejection_labels".to_string());
            params.push(rejection_labels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref review_status) = self.review_status {
            params.push("review_status".to_string());
            params.push(review_status.to_string());
        }


        if let Some(ref type_) = self.type_ {
            params.push("type".to_string());
            params.push(type_.to_string());
        }


        if let Some(ref updated_time) = self.updated_time {
            params.push("updated_time".to_string());
            params.push(updated_time.to_string());
        }

        // Skipping summary_status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub carousel_android_deep_links: Vec<Vec<String>>,
            pub carousel_destination_urls: Vec<Vec<String>>,
            pub carousel_ios_deep_links: Vec<Vec<String>>,
            pub click_tracking_url: Vec<String>,
            pub creative_type: Vec<String>,
            pub destination_url: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub is_pin_deleted: Vec<bool>,
            pub is_removable: Vec<bool>,
            pub name: Vec<String>,
            pub pin_id: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_urls: Vec<TrackingUrls>,
            pub view_tracking_url: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub campaign_id: Vec<String>,
            pub collection_items_destination_url_template: Vec<String>,
            pub created_time: Vec<isize>,
            pub id: Vec<String>,
            pub rejected_reasons: Vec<Vec<String>>,
            pub rejection_labels: Vec<Vec<String>>,
            pub review_status: Vec<String>,
            pub type_: Vec<String>,
            pub updated_time: Vec<isize>,
            pub summary_status: Vec<PinPromotionSummaryStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "android_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "carousel_android_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "carousel_destination_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "carousel_ios_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "click_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "creative_type" => intermediate_rep.creative_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "ios_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "is_pin_deleted" => intermediate_rep.is_pin_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "is_removable" => intermediate_rep.is_removable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "view_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "collection_items_destination_url_template" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponse".to_string()),
                    "created_time" => intermediate_rep.created_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "rejected_reasons" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "rejection_labels" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponse".to_string()),
                    "review_status" => intermediate_rep.review_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time" => intermediate_rep.updated_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "summary_status" => intermediate_rep.summary_status.push(<PinPromotionSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdResponse {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next(),
            android_deep_link: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            carousel_android_deep_links: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            carousel_destination_urls: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            carousel_ios_deep_links: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            click_tracking_url: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next(),
            destination_url: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            ios_deep_link: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            is_pin_deleted: intermediate_rep.is_pin_deleted.into_iter().next(),
            is_removable: intermediate_rep.is_removable.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            pin_id: intermediate_rep.pin_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            view_tracking_url: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            collection_items_destination_url_template: std::result::Result::Err("Nullable types not supported in AdResponse".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            rejected_reasons: intermediate_rep.rejected_reasons.into_iter().next(),
            rejection_labels: intermediate_rep.rejection_labels.into_iter().next(),
            review_status: intermediate_rep.review_status.into_iter().next(),
            type_: intermediate_rep.type_.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            summary_status: intermediate_rep.summary_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Creation fields
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdResponseAllOf {
    /// ID of the ad group that contains the ad.
    #[serde(rename = "ad_group_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_id: Option<String>,

    /// Deep link URL for Android devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "android_deep_link")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link: Option<swagger::Nullable<String>>,

    /// Comma-separated deep links for the carousel pin on Android.
    #[serde(rename = "carousel_android_deep_links")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_android_deep_links: Option<swagger::Nullable<Vec<String>>>,

    /// Comma-separated destination URLs for the carousel pin to promote.
    #[serde(rename = "carousel_destination_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_destination_urls: Option<swagger::Nullable<Vec<String>>>,

    /// Comma-separated deep links for the carousel pin on iOS.
    #[serde(rename = "carousel_ios_deep_links")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub carousel_ios_deep_links: Option<swagger::Nullable<Vec<String>>>,

    /// Tracking url for the ad clicks.
    #[serde(rename = "click_tracking_url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_tracking_url: Option<swagger::Nullable<String>>,

    /// Ad creative type enum
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "creative_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub creative_type: Option<String>,

    /// Destination URL.
    #[serde(rename = "destination_url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub destination_url: Option<swagger::Nullable<String>>,

    /// Deep link URL for iOS devices. Not currently available. Using this field will generate an error.
    #[serde(rename = "ios_deep_link")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link: Option<swagger::Nullable<String>>,

    /// Is original pin deleted?
    #[serde(rename = "is_pin_deleted")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_pin_deleted: Option<bool>,

    /// Is pin repinnable?
    #[serde(rename = "is_removable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_removable: Option<bool>,

    /// Name of the ad - 255 chars max.
    #[serde(rename = "name")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<swagger::Nullable<String>>,

    /// Pin ID.
    #[serde(rename = "pin_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pin_id: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::EntityStatus>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<swagger::Nullable<TrackingUrls>>,

    /// Tracking URL for ad impressions.
    #[serde(rename = "view_tracking_url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_tracking_url: Option<swagger::Nullable<String>>,

}

impl AdResponseAllOf {
    pub fn new() -> AdResponseAllOf {
        AdResponseAllOf {
            ad_group_id: None,
            android_deep_link: None,
            carousel_android_deep_links: None,
            carousel_destination_urls: None,
            carousel_ios_deep_links: None,
            click_tracking_url: None,
            creative_type: None,
            destination_url: None,
            ios_deep_link: None,
            is_pin_deleted: None,
            is_removable: None,
            name: None,
            pin_id: None,
            status: None,
            tracking_urls: None,
            view_tracking_url: None,
        }
    }
}

/// Converts the AdResponseAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdResponseAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref ad_group_id) = self.ad_group_id {
            params.push("ad_group_id".to_string());
            params.push(ad_group_id.to_string());
        }


        if let Some(ref android_deep_link) = self.android_deep_link {
            params.push("android_deep_link".to_string());
            params.push(android_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref carousel_android_deep_links) = self.carousel_android_deep_links {
            params.push("carousel_android_deep_links".to_string());
            params.push(carousel_android_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string()));
        }


        if let Some(ref carousel_destination_urls) = self.carousel_destination_urls {
            params.push("carousel_destination_urls".to_string());
            params.push(carousel_destination_urls.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string()));
        }


        if let Some(ref carousel_ios_deep_links) = self.carousel_ios_deep_links {
            params.push("carousel_ios_deep_links".to_string());
            params.push(carousel_ios_deep_links.as_ref().map_or("null".to_string(), |x| x.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string()));
        }


        if let Some(ref click_tracking_url) = self.click_tracking_url {
            params.push("click_tracking_url".to_string());
            params.push(click_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref creative_type) = self.creative_type {
            params.push("creative_type".to_string());
            params.push(creative_type.to_string());
        }


        if let Some(ref destination_url) = self.destination_url {
            params.push("destination_url".to_string());
            params.push(destination_url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref ios_deep_link) = self.ios_deep_link {
            params.push("ios_deep_link".to_string());
            params.push(ios_deep_link.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref is_pin_deleted) = self.is_pin_deleted {
            params.push("is_pin_deleted".to_string());
            params.push(is_pin_deleted.to_string());
        }


        if let Some(ref is_removable) = self.is_removable {
            params.push("is_removable".to_string());
            params.push(is_removable.to_string());
        }


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref pin_id) = self.pin_id {
            params.push("pin_id".to_string());
            params.push(pin_id.to_string());
        }

        // Skipping status in query parameter serialization

        // Skipping tracking_urls in query parameter serialization
        // Skipping tracking_urls in query parameter serialization


        if let Some(ref view_tracking_url) = self.view_tracking_url {
            params.push("view_tracking_url".to_string());
            params.push(view_tracking_url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdResponseAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdResponseAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub ad_group_id: Vec<String>,
            pub android_deep_link: Vec<String>,
            pub carousel_android_deep_links: Vec<Vec<String>>,
            pub carousel_destination_urls: Vec<Vec<String>>,
            pub carousel_ios_deep_links: Vec<Vec<String>>,
            pub click_tracking_url: Vec<String>,
            pub creative_type: Vec<String>,
            pub destination_url: Vec<String>,
            pub ios_deep_link: Vec<String>,
            pub is_pin_deleted: Vec<bool>,
            pub is_removable: Vec<bool>,
            pub name: Vec<String>,
            pub pin_id: Vec<String>,
            pub status: Vec<models::EntityStatus>,
            pub tracking_urls: Vec<TrackingUrls>,
            pub view_tracking_url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdResponseAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ad_group_id" => intermediate_rep.ad_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "android_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    "carousel_android_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponseAllOf".to_string()),
                    "carousel_destination_urls" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponseAllOf".to_string()),
                    "carousel_ios_deep_links" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponseAllOf".to_string()),
                    "click_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    "creative_type" => intermediate_rep.creative_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "destination_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    "ios_deep_link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    "is_pin_deleted" => intermediate_rep.is_pin_deleted.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "is_removable" => intermediate_rep.is_removable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    "pin_id" => intermediate_rep.pin_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<models::EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    "view_tracking_url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdResponseAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdResponseAllOf {
            ad_group_id: intermediate_rep.ad_group_id.into_iter().next(),
            android_deep_link: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            carousel_android_deep_links: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            carousel_destination_urls: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            carousel_ios_deep_links: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            click_tracking_url: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            creative_type: intermediate_rep.creative_type.into_iter().next(),
            destination_url: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            ios_deep_link: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            is_pin_deleted: intermediate_rep.is_pin_deleted.into_iter().next(),
            is_removable: intermediate_rep.is_removable.into_iter().next(),
            name: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            pin_id: intermediate_rep.pin_id.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            tracking_urls: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
            view_tracking_url: std::result::Result::Err("Nullable types not supported in AdResponseAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdResponseAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdResponseAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdResponseAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdResponseAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdResponseAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdResponseAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdResponseAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdResponseAllOf1 {
    /// The ID of the advertiser that this ad belongs to.
    #[serde(rename = "ad_account_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_account_id: Option<String>,

    /// ID of the ad campaign that contains this ad.
    #[serde(rename = "campaign_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_id: Option<String>,

    /// Destination URL template for all items within a collections drawer.
    #[serde(rename = "collection_items_destination_url_template")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub collection_items_destination_url_template: Option<swagger::Nullable<String>>,

    /// Pin creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<isize>,

    /// The ID of this ad.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// Enum reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "rejected_reasons")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejected_reasons: Option<Vec<String>>,

    /// Text reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
    #[serde(rename = "rejection_labels")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub rejection_labels: Option<Vec<String>>,

    /// Ad review status
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "review_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub review_status: Option<String>,

    /// Always \"ad\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<String>,

    /// Last update time. Unix timestamp in seconds.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<isize>,

    /// Ad summary status
    #[serde(rename = "summary_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_status: Option<PinPromotionSummaryStatus>,

}

impl AdResponseAllOf1 {
    pub fn new() -> AdResponseAllOf1 {
        AdResponseAllOf1 {
            ad_account_id: None,
            campaign_id: None,
            collection_items_destination_url_template: None,
            created_time: None,
            id: None,
            rejected_reasons: None,
            rejection_labels: None,
            review_status: None,
            type_: None,
            updated_time: None,
            summary_status: None,
        }
    }
}

/// Converts the AdResponseAllOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdResponseAllOf1 {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref ad_account_id) = self.ad_account_id {
            params.push("ad_account_id".to_string());
            params.push(ad_account_id.to_string());
        }


        if let Some(ref campaign_id) = self.campaign_id {
            params.push("campaign_id".to_string());
            params.push(campaign_id.to_string());
        }


        if let Some(ref collection_items_destination_url_template) = self.collection_items_destination_url_template {
            params.push("collection_items_destination_url_template".to_string());
            params.push(collection_items_destination_url_template.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref created_time) = self.created_time {
            params.push("created_time".to_string());
            params.push(created_time.to_string());
        }


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref rejected_reasons) = self.rejected_reasons {
            params.push("rejected_reasons".to_string());
            params.push(rejected_reasons.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref rejection_labels) = self.rejection_labels {
            params.push("rejection_labels".to_string());
            params.push(rejection_labels.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref review_status) = self.review_status {
            params.push("review_status".to_string());
            params.push(review_status.to_string());
        }


        if let Some(ref type_) = self.type_ {
            params.push("type".to_string());
            params.push(type_.to_string());
        }


        if let Some(ref updated_time) = self.updated_time {
            params.push("updated_time".to_string());
            params.push(updated_time.to_string());
        }

        // Skipping summary_status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdResponseAllOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdResponseAllOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub campaign_id: Vec<String>,
            pub collection_items_destination_url_template: Vec<String>,
            pub created_time: Vec<isize>,
            pub id: Vec<String>,
            pub rejected_reasons: Vec<Vec<String>>,
            pub rejection_labels: Vec<Vec<String>>,
            pub review_status: Vec<String>,
            pub type_: Vec<String>,
            pub updated_time: Vec<isize>,
            pub summary_status: Vec<PinPromotionSummaryStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdResponseAllOf1".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "campaign_id" => intermediate_rep.campaign_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "collection_items_destination_url_template" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdResponseAllOf1".to_string()),
                    "created_time" => intermediate_rep.created_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "rejected_reasons" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponseAllOf1".to_string()),
                    "rejection_labels" => return std::result::Result::Err("Parsing a container in this style is not supported in AdResponseAllOf1".to_string()),
                    "review_status" => intermediate_rep.review_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time" => intermediate_rep.updated_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "summary_status" => intermediate_rep.summary_status.push(<PinPromotionSummaryStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdResponseAllOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdResponseAllOf1 {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next(),
            campaign_id: intermediate_rep.campaign_id.into_iter().next(),
            collection_items_destination_url_template: std::result::Result::Err("Nullable types not supported in AdResponseAllOf1".to_string())?,
            created_time: intermediate_rep.created_time.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            rejected_reasons: intermediate_rep.rejected_reasons.into_iter().next(),
            rejection_labels: intermediate_rep.rejection_labels.into_iter().next(),
            review_status: intermediate_rep.review_status.into_iter().next(),
            type_: intermediate_rep.type_.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            summary_status: intermediate_rep.summary_status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdResponseAllOf1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdResponseAllOf1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdResponseAllOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdResponseAllOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdResponseAllOf1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdResponseAllOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdResponseAllOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsCreateAsyncRequest {
    /// Metric report start date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    pub start_date: String,

    /// Metric report end date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    pub end_date: String,

    /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
    #[serde(rename = "granularity")]
    pub granularity: Granularity,

    /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
    #[serde(rename = "click_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_window_days: Option<ConversionAttributionWindowDays>,

    /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
    #[serde(rename = "engagement_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_window_days: Option<ConversionAttributionWindowDays>,

    /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
    #[serde(rename = "view_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_window_days: Option<ConversionAttributionWindowDays>,

    /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
    #[serde(rename = "conversion_report_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_report_time: Option<ConversionReportTimeType>,

    /// List of types of attribution for the conversion report
    #[serde(rename = "attribution_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attribution_types: Option<Vec<models::ConversionReportAttributionType>>,

    /// Metric and entity columns
    #[serde(rename = "columns")]
    pub columns: Vec<models::ReportingColumnAsync>,

    /// Level of the report
    #[serde(rename = "level")]
    pub level: MetricsReportingLevel,

    /// Specification for formatting report data
    #[serde(rename = "report_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_format: Option<DataOutputFormat>,

    /// List of campaign ids
    #[serde(rename = "campaign_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_ids: Option<Vec<String>>,

    /// List of status values for filtering
    #[serde(rename = "campaign_statuses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_statuses: Option<Vec<models::CampaignSummaryStatus>>,

    /// List of values for filtering
    #[serde(rename = "campaign_objective_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub campaign_objective_types: Option<Vec<models::ObjectiveType>>,

    /// List of ad group ids
    #[serde(rename = "ad_group_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_ids: Option<Vec<String>>,

    /// List of values for filtering
    #[serde(rename = "ad_group_statuses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_group_statuses: Option<Vec<models::AdGroupSummaryStatus>>,

    /// List of ad ids
    #[serde(rename = "ad_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_ids: Option<Vec<String>>,

    /// List of values for filtering
    #[serde(rename = "ad_statuses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_statuses: Option<Vec<models::PinPromotionSummaryStatus>>,

    /// List of product group ids
    #[serde(rename = "product_group_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_group_ids: Option<Vec<String>>,

    /// List of values for filtering
    #[serde(rename = "product_group_statuses")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_group_statuses: Option<Vec<models::ProductGroupSummaryStatus>>,

    /// List of product item ids
    #[serde(rename = "product_item_ids")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_item_ids: Option<Vec<String>>,

    /// List of targeting types
    #[serde(rename = "targeting_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_types: Option<Vec<models::AdsAnalyticsTargetingType>>,

    /// List of metrics filters
    #[serde(rename = "metrics_filters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics_filters: Option<Vec<models::AdsAnalyticsMetricsFilter>>,

}

impl AdsAnalyticsCreateAsyncRequest {
    pub fn new(start_date: String, end_date: String, granularity: Granularity, columns: Vec<models::ReportingColumnAsync>, level: MetricsReportingLevel, ) -> AdsAnalyticsCreateAsyncRequest {
        AdsAnalyticsCreateAsyncRequest {
            start_date: start_date,
            end_date: end_date,
            granularity: granularity,
            click_window_days: Some(30),
            engagement_window_days: Some(30),
            view_window_days: Some(1),
            conversion_report_time: Some("TIME_OF_AD_ACTION".to_string()),
            attribution_types: None,
            columns: columns,
            level: level,
            report_format: Some("JSON".to_string()),
            campaign_ids: None,
            campaign_statuses: None,
            campaign_objective_types: None,
            ad_group_ids: None,
            ad_group_statuses: None,
            ad_ids: None,
            ad_statuses: None,
            product_group_ids: None,
            product_group_statuses: None,
            product_item_ids: None,
            targeting_types: None,
            metrics_filters: None,
        }
    }
}

/// Converts the AdsAnalyticsCreateAsyncRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdsAnalyticsCreateAsyncRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("start_date".to_string());
        params.push(self.start_date.to_string());


        params.push("end_date".to_string());
        params.push(self.end_date.to_string());

        // Skipping granularity in query parameter serialization

        // Skipping click_window_days in query parameter serialization

        // Skipping engagement_window_days in query parameter serialization

        // Skipping view_window_days in query parameter serialization

        // Skipping conversion_report_time in query parameter serialization

        // Skipping attribution_types in query parameter serialization

        // Skipping columns in query parameter serialization

        // Skipping level in query parameter serialization

        // Skipping report_format in query parameter serialization


        if let Some(ref campaign_ids) = self.campaign_ids {
            params.push("campaign_ids".to_string());
            params.push(campaign_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        // Skipping campaign_statuses in query parameter serialization

        // Skipping campaign_objective_types in query parameter serialization


        if let Some(ref ad_group_ids) = self.ad_group_ids {
            params.push("ad_group_ids".to_string());
            params.push(ad_group_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        // Skipping ad_group_statuses in query parameter serialization


        if let Some(ref ad_ids) = self.ad_ids {
            params.push("ad_ids".to_string());
            params.push(ad_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        // Skipping ad_statuses in query parameter serialization


        if let Some(ref product_group_ids) = self.product_group_ids {
            params.push("product_group_ids".to_string());
            params.push(product_group_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        // Skipping product_group_statuses in query parameter serialization


        if let Some(ref product_item_ids) = self.product_item_ids {
            params.push("product_item_ids".to_string());
            params.push(product_item_ids.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        // Skipping targeting_types in query parameter serialization

        // Skipping metrics_filters in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsCreateAsyncRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsCreateAsyncRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub granularity: Vec<Granularity>,
            pub click_window_days: Vec<ConversionAttributionWindowDays>,
            pub engagement_window_days: Vec<ConversionAttributionWindowDays>,
            pub view_window_days: Vec<ConversionAttributionWindowDays>,
            pub conversion_report_time: Vec<ConversionReportTimeType>,
            pub attribution_types: Vec<Vec<models::ConversionReportAttributionType>>,
            pub columns: Vec<Vec<models::ReportingColumnAsync>>,
            pub level: Vec<MetricsReportingLevel>,
            pub report_format: Vec<DataOutputFormat>,
            pub campaign_ids: Vec<Vec<String>>,
            pub campaign_statuses: Vec<Vec<models::CampaignSummaryStatus>>,
            pub campaign_objective_types: Vec<Vec<models::ObjectiveType>>,
            pub ad_group_ids: Vec<Vec<String>>,
            pub ad_group_statuses: Vec<Vec<models::AdGroupSummaryStatus>>,
            pub ad_ids: Vec<Vec<String>>,
            pub ad_statuses: Vec<Vec<models::PinPromotionSummaryStatus>>,
            pub product_group_ids: Vec<Vec<String>>,
            pub product_group_statuses: Vec<Vec<models::ProductGroupSummaryStatus>>,
            pub product_item_ids: Vec<Vec<String>>,
            pub targeting_types: Vec<Vec<models::AdsAnalyticsTargetingType>>,
            pub metrics_filters: Vec<Vec<models::AdsAnalyticsMetricsFilter>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsCreateAsyncRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "granularity" => intermediate_rep.granularity.push(<Granularity as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "click_window_days" => intermediate_rep.click_window_days.push(<ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "engagement_window_days" => intermediate_rep.engagement_window_days.push(<ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "view_window_days" => intermediate_rep.view_window_days.push(<ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "conversion_report_time" => intermediate_rep.conversion_report_time.push(<ConversionReportTimeType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "attribution_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "columns" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "level" => intermediate_rep.level.push(<MetricsReportingLevel as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "report_format" => intermediate_rep.report_format.push(<DataOutputFormat as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "campaign_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "campaign_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "campaign_objective_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_group_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_group_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "ad_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "product_group_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "product_group_statuses" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "product_item_ids" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "targeting_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    "metrics_filters" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsCreateAsyncRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsCreateAsyncRequest {
            start_date: intermediate_rep.start_date.into_iter().next().ok_or("start_date missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            end_date: intermediate_rep.end_date.into_iter().next().ok_or("end_date missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            granularity: intermediate_rep.granularity.into_iter().next().ok_or("granularity missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            click_window_days: intermediate_rep.click_window_days.into_iter().next(),
            engagement_window_days: intermediate_rep.engagement_window_days.into_iter().next(),
            view_window_days: intermediate_rep.view_window_days.into_iter().next(),
            conversion_report_time: intermediate_rep.conversion_report_time.into_iter().next(),
            attribution_types: intermediate_rep.attribution_types.into_iter().next(),
            columns: intermediate_rep.columns.into_iter().next().ok_or("columns missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            level: intermediate_rep.level.into_iter().next().ok_or("level missing in AdsAnalyticsCreateAsyncRequest".to_string())?,
            report_format: intermediate_rep.report_format.into_iter().next(),
            campaign_ids: intermediate_rep.campaign_ids.into_iter().next(),
            campaign_statuses: intermediate_rep.campaign_statuses.into_iter().next(),
            campaign_objective_types: intermediate_rep.campaign_objective_types.into_iter().next(),
            ad_group_ids: intermediate_rep.ad_group_ids.into_iter().next(),
            ad_group_statuses: intermediate_rep.ad_group_statuses.into_iter().next(),
            ad_ids: intermediate_rep.ad_ids.into_iter().next(),
            ad_statuses: intermediate_rep.ad_statuses.into_iter().next(),
            product_group_ids: intermediate_rep.product_group_ids.into_iter().next(),
            product_group_statuses: intermediate_rep.product_group_statuses.into_iter().next(),
            product_item_ids: intermediate_rep.product_item_ids.into_iter().next(),
            targeting_types: intermediate_rep.targeting_types.into_iter().next(),
            metrics_filters: intermediate_rep.metrics_filters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsCreateAsyncRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsCreateAsyncRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsCreateAsyncRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsCreateAsyncRequestAllOf {
    /// Metric report start date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "start_date")]
    pub start_date: String,

    /// Metric report end date (UTC). Format: YYYY-MM-DD
    #[serde(rename = "end_date")]
    pub end_date: String,

    /// TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
    #[serde(rename = "granularity")]
    pub granularity: Granularity,

    /// Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
    #[serde(rename = "click_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click_window_days: Option<ConversionAttributionWindowDays>,

    /// Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
    #[serde(rename = "engagement_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement_window_days: Option<ConversionAttributionWindowDays>,

    /// Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
    #[serde(rename = "view_window_days")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub view_window_days: Option<ConversionAttributionWindowDays>,

    /// The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
    #[serde(rename = "conversion_report_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub conversion_report_time: Option<ConversionReportTimeType>,

    /// List of types of attribution for the conversion report
    #[serde(rename = "attribution_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attribution_types: Option<Vec<models::ConversionReportAttributionType>>,

}

impl AdsAnalyticsCreateAsyncRequestAllOf {
    pub fn new(start_date: String, end_date: String, granularity: Granularity, ) -> AdsAnalyticsCreateAsyncRequestAllOf {
        AdsAnalyticsCreateAsyncRequestAllOf {
            start_date: start_date,
            end_date: end_date,
            granularity: granularity,
            click_window_days: Some(30),
            engagement_window_days: Some(30),
            view_window_days: Some(1),
            conversion_report_time: Some("TIME_OF_AD_ACTION".to_string()),
            attribution_types: None,
        }
    }
}

/// Converts the AdsAnalyticsCreateAsyncRequestAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdsAnalyticsCreateAsyncRequestAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("start_date".to_string());
        params.push(self.start_date.to_string());


        params.push("end_date".to_string());
        params.push(self.end_date.to_string());

        // Skipping granularity in query parameter serialization

        // Skipping click_window_days in query parameter serialization

        // Skipping engagement_window_days in query parameter serialization

        // Skipping view_window_days in query parameter serialization

        // Skipping conversion_report_time in query parameter serialization

        // Skipping attribution_types in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsCreateAsyncRequestAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsCreateAsyncRequestAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub start_date: Vec<String>,
            pub end_date: Vec<String>,
            pub granularity: Vec<Granularity>,
            pub click_window_days: Vec<ConversionAttributionWindowDays>,
            pub engagement_window_days: Vec<ConversionAttributionWindowDays>,
            pub view_window_days: Vec<ConversionAttributionWindowDays>,
            pub conversion_report_time: Vec<ConversionReportTimeType>,
            pub attribution_types: Vec<Vec<models::ConversionReportAttributionType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsCreateAsyncRequestAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "start_date" => intermediate_rep.start_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "end_date" => intermediate_rep.end_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "granularity" => intermediate_rep.granularity.push(<Granularity as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "click_window_days" => intermediate_rep.click_window_days.push(<ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "engagement_window_days" => intermediate_rep.engagement_window_days.push(<ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "view_window_days" => intermediate_rep.view_window_days.push(<ConversionAttributionWindowDays as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "conversion_report_time" => intermediate_rep.conversion_report_time.push(<ConversionReportTimeType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "attribution_types" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequestAllOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsCreateAsyncRequestAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsCreateAsyncRequestAllOf {
            start_date: intermediate_rep.start_date.into_iter().next().ok_or("start_date missing in AdsAnalyticsCreateAsyncRequestAllOf".to_string())?,
            end_date: intermediate_rep.end_date.into_iter().next().ok_or("end_date missing in AdsAnalyticsCreateAsyncRequestAllOf".to_string())?,
            granularity: intermediate_rep.granularity.into_iter().next().ok_or("granularity missing in AdsAnalyticsCreateAsyncRequestAllOf".to_string())?,
            click_window_days: intermediate_rep.click_window_days.into_iter().next(),
            engagement_window_days: intermediate_rep.engagement_window_days.into_iter().next(),
            view_window_days: intermediate_rep.view_window_days.into_iter().next(),
            conversion_report_time: intermediate_rep.conversion_report_time.into_iter().next(),
            attribution_types: intermediate_rep.attribution_types.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsCreateAsyncRequestAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsCreateAsyncRequestAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsCreateAsyncRequestAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsCreateAsyncRequestAllOf1 {
    /// Metric and entity columns
    #[serde(rename = "columns")]
    pub columns: Vec<models::ReportingColumnAsync>,

    /// Level of the report
    #[serde(rename = "level")]
    pub level: MetricsReportingLevel,

    /// Specification for formatting report data
    #[serde(rename = "report_format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_format: Option<DataOutputFormat>,

}

impl AdsAnalyticsCreateAsyncRequestAllOf1 {
    pub fn new(columns: Vec<models::ReportingColumnAsync>, level: MetricsReportingLevel, ) -> AdsAnalyticsCreateAsyncRequestAllOf1 {
        AdsAnalyticsCreateAsyncRequestAllOf1 {
            columns: columns,
            level: level,
            report_format: Some("JSON".to_string()),
        }
    }
}

/// Converts the AdsAnalyticsCreateAsyncRequestAllOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdsAnalyticsCreateAsyncRequestAllOf1 {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping columns in query parameter serialization

        // Skipping level in query parameter serialization

        // Skipping report_format in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsCreateAsyncRequestAllOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsCreateAsyncRequestAllOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub columns: Vec<Vec<models::ReportingColumnAsync>>,
            pub level: Vec<MetricsReportingLevel>,
            pub report_format: Vec<DataOutputFormat>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsCreateAsyncRequestAllOf1".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "columns" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsCreateAsyncRequestAllOf1".to_string()),
                    "level" => intermediate_rep.level.push(<MetricsReportingLevel as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "report_format" => intermediate_rep.report_format.push(<DataOutputFormat as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsCreateAsyncRequestAllOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsCreateAsyncRequestAllOf1 {
            columns: intermediate_rep.columns.into_iter().next().ok_or("columns missing in AdsAnalyticsCreateAsyncRequestAllOf1".to_string())?,
            level: intermediate_rep.level.into_iter().next().ok_or("level missing in AdsAnalyticsCreateAsyncRequestAllOf1".to_string())?,
            report_format: intermediate_rep.report_format.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsCreateAsyncRequestAllOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdsAnalyticsCreateAsyncRequestAllOf1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsCreateAsyncRequestAllOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsCreateAsyncRequestAllOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsCreateAsyncResponse {
    #[serde(rename = "report_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_status: Option<String>,

    #[serde(rename = "token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub token: Option<String>,

    #[serde(rename = "message")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<swagger::Nullable<String>>,

}

impl AdsAnalyticsCreateAsyncResponse {
    pub fn new() -> AdsAnalyticsCreateAsyncResponse {
        AdsAnalyticsCreateAsyncResponse {
            report_status: None,
            token: None,
            message: None,
        }
    }
}

/// Converts the AdsAnalyticsCreateAsyncResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdsAnalyticsCreateAsyncResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref report_status) = self.report_status {
            params.push("report_status".to_string());
            params.push(report_status.to_string());
        }


        if let Some(ref token) = self.token {
            params.push("token".to_string());
            params.push(token.to_string());
        }


        if let Some(ref message) = self.message {
            params.push("message".to_string());
            params.push(message.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsCreateAsyncResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsCreateAsyncResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub report_status: Vec<String>,
            pub token: Vec<String>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsCreateAsyncResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "report_status" => intermediate_rep.report_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "token" => intermediate_rep.token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "message" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsAnalyticsCreateAsyncResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsCreateAsyncResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsCreateAsyncResponse {
            report_status: intermediate_rep.report_status.into_iter().next(),
            token: intermediate_rep.token.into_iter().next(),
            message: std::result::Result::Err("Nullable types not supported in AdsAnalyticsCreateAsyncResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsCreateAsyncResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdsAnalyticsCreateAsyncResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsCreateAsyncResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsCreateAsyncResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Reporting columns for sync reporting data filter
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdsAnalyticsFilterColumn {
    #[serde(rename = "SPEND_IN_DOLLAR")]
    SPEND_IN_DOLLAR,
    #[serde(rename = "TOTAL_IMPRESSION")]
    TOTAL_IMPRESSION,
}

impl std::fmt::Display for AdsAnalyticsFilterColumn {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdsAnalyticsFilterColumn::SPEND_IN_DOLLAR => write!(f, "{}", "SPEND_IN_DOLLAR"),
            AdsAnalyticsFilterColumn::TOTAL_IMPRESSION => write!(f, "{}", "TOTAL_IMPRESSION"),
        }
    }
}

impl std::str::FromStr for AdsAnalyticsFilterColumn {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SPEND_IN_DOLLAR" => std::result::Result::Ok(AdsAnalyticsFilterColumn::SPEND_IN_DOLLAR),
            "TOTAL_IMPRESSION" => std::result::Result::Ok(AdsAnalyticsFilterColumn::TOTAL_IMPRESSION),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Filter operator for sync reporting
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdsAnalyticsFilterOperator {
    #[serde(rename = "LESS_THAN")]
    LESS_THAN,
    #[serde(rename = "GREATER_THAN")]
    GREATER_THAN,
}

impl std::fmt::Display for AdsAnalyticsFilterOperator {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdsAnalyticsFilterOperator::LESS_THAN => write!(f, "{}", "LESS_THAN"),
            AdsAnalyticsFilterOperator::GREATER_THAN => write!(f, "{}", "GREATER_THAN"),
        }
    }
}

impl std::str::FromStr for AdsAnalyticsFilterOperator {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "LESS_THAN" => std::result::Result::Ok(AdsAnalyticsFilterOperator::LESS_THAN),
            "GREATER_THAN" => std::result::Result::Ok(AdsAnalyticsFilterOperator::GREATER_THAN),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsGetAsyncResponse {
    #[serde(rename = "report_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub report_status: Option<String>,

    #[serde(rename = "url")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<swagger::Nullable<String>>,

    #[serde(rename = "size")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<swagger::Nullable<f64>>,

}

impl AdsAnalyticsGetAsyncResponse {
    pub fn new() -> AdsAnalyticsGetAsyncResponse {
        AdsAnalyticsGetAsyncResponse {
            report_status: None,
            url: None,
            size: None,
        }
    }
}

/// Converts the AdsAnalyticsGetAsyncResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdsAnalyticsGetAsyncResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref report_status) = self.report_status {
            params.push("report_status".to_string());
            params.push(report_status.to_string());
        }


        if let Some(ref url) = self.url {
            params.push("url".to_string());
            params.push(url.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref size) = self.size {
            params.push("size".to_string());
            params.push(size.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsGetAsyncResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsGetAsyncResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub report_status: Vec<String>,
            pub url: Vec<String>,
            pub size: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsGetAsyncResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "report_status" => intermediate_rep.report_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "url" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsAnalyticsGetAsyncResponse".to_string()),
                    "size" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in AdsAnalyticsGetAsyncResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsGetAsyncResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsGetAsyncResponse {
            report_status: intermediate_rep.report_status.into_iter().next(),
            url: std::result::Result::Err("Nullable types not supported in AdsAnalyticsGetAsyncResponse".to_string())?,
            size: std::result::Result::Err("Nullable types not supported in AdsAnalyticsGetAsyncResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsGetAsyncResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdsAnalyticsGetAsyncResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsGetAsyncResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsGetAsyncResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AdsAnalyticsMetricsFilter {
    #[serde(rename = "field")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub field: Option<models::AdsAnalyticsFilterColumn>,

    #[serde(rename = "operator")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operator: Option<models::AdsAnalyticsFilterOperator>,

    /// List of values for filtering
    #[serde(rename = "values")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub values: Option<Vec<f64>>,

}

impl AdsAnalyticsMetricsFilter {
    pub fn new() -> AdsAnalyticsMetricsFilter {
        AdsAnalyticsMetricsFilter {
            field: None,
            operator: None,
            values: None,
        }
    }
}

/// Converts the AdsAnalyticsMetricsFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AdsAnalyticsMetricsFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping field in query parameter serialization

        // Skipping operator in query parameter serialization


        if let Some(ref values) = self.values {
            params.push("values".to_string());
            params.push(values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AdsAnalyticsMetricsFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AdsAnalyticsMetricsFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub field: Vec<models::AdsAnalyticsFilterColumn>,
            pub operator: Vec<models::AdsAnalyticsFilterOperator>,
            pub values: Vec<Vec<f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AdsAnalyticsMetricsFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "field" => intermediate_rep.field.push(<models::AdsAnalyticsFilterColumn as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "operator" => intermediate_rep.operator.push(<models::AdsAnalyticsFilterOperator as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in AdsAnalyticsMetricsFilter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AdsAnalyticsMetricsFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AdsAnalyticsMetricsFilter {
            field: intermediate_rep.field.into_iter().next(),
            operator: intermediate_rep.operator.into_iter().next(),
            values: intermediate_rep.values.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AdsAnalyticsMetricsFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AdsAnalyticsMetricsFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AdsAnalyticsMetricsFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AdsAnalyticsMetricsFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AdsAnalyticsMetricsFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AdsAnalyticsMetricsFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AdsAnalyticsMetricsFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Reporting targeting type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum AdsAnalyticsTargetingType {
    #[serde(rename = "KEYWORD")]
    KEYWORD,
    #[serde(rename = "APPTYPE")]
    APPTYPE,
    #[serde(rename = "GENDER")]
    GENDER,
    #[serde(rename = "LOCATION")]
    LOCATION,
    #[serde(rename = "PLACEMENT")]
    PLACEMENT,
    #[serde(rename = "COUNTRY")]
    COUNTRY,
    #[serde(rename = "TARGETED_INTEREST")]
    TARGETED_INTEREST,
    #[serde(rename = "PINNER_INTEREST")]
    PINNER_INTEREST,
    #[serde(rename = "AUDIENCE_INCLUDE")]
    AUDIENCE_INCLUDE,
    #[serde(rename = "AUDIENCE_EXCLUDE")]
    AUDIENCE_EXCLUDE,
    #[serde(rename = "GEO")]
    GEO,
    #[serde(rename = "AGE_BUCKET")]
    AGE_BUCKET,
    #[serde(rename = "REGION")]
    REGION,
}

impl std::fmt::Display for AdsAnalyticsTargetingType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            AdsAnalyticsTargetingType::KEYWORD => write!(f, "{}", "KEYWORD"),
            AdsAnalyticsTargetingType::APPTYPE => write!(f, "{}", "APPTYPE"),
            AdsAnalyticsTargetingType::GENDER => write!(f, "{}", "GENDER"),
            AdsAnalyticsTargetingType::LOCATION => write!(f, "{}", "LOCATION"),
            AdsAnalyticsTargetingType::PLACEMENT => write!(f, "{}", "PLACEMENT"),
            AdsAnalyticsTargetingType::COUNTRY => write!(f, "{}", "COUNTRY"),
            AdsAnalyticsTargetingType::TARGETED_INTEREST => write!(f, "{}", "TARGETED_INTEREST"),
            AdsAnalyticsTargetingType::PINNER_INTEREST => write!(f, "{}", "PINNER_INTEREST"),
            AdsAnalyticsTargetingType::AUDIENCE_INCLUDE => write!(f, "{}", "AUDIENCE_INCLUDE"),
            AdsAnalyticsTargetingType::AUDIENCE_EXCLUDE => write!(f, "{}", "AUDIENCE_EXCLUDE"),
            AdsAnalyticsTargetingType::GEO => write!(f, "{}", "GEO"),
            AdsAnalyticsTargetingType::AGE_BUCKET => write!(f, "{}", "AGE_BUCKET"),
            AdsAnalyticsTargetingType::REGION => write!(f, "{}", "REGION"),
        }
    }
}

impl std::str::FromStr for AdsAnalyticsTargetingType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "KEYWORD" => std::result::Result::Ok(AdsAnalyticsTargetingType::KEYWORD),
            "APPTYPE" => std::result::Result::Ok(AdsAnalyticsTargetingType::APPTYPE),
            "GENDER" => std::result::Result::Ok(AdsAnalyticsTargetingType::GENDER),
            "LOCATION" => std::result::Result::Ok(AdsAnalyticsTargetingType::LOCATION),
            "PLACEMENT" => std::result::Result::Ok(AdsAnalyticsTargetingType::PLACEMENT),
            "COUNTRY" => std::result::Result::Ok(AdsAnalyticsTargetingType::COUNTRY),
            "TARGETED_INTEREST" => std::result::Result::Ok(AdsAnalyticsTargetingType::TARGETED_INTEREST),
            "PINNER_INTEREST" => std::result::Result::Ok(AdsAnalyticsTargetingType::PINNER_INTEREST),
            "AUDIENCE_INCLUDE" => std::result::Result::Ok(AdsAnalyticsTargetingType::AUDIENCE_INCLUDE),
            "AUDIENCE_EXCLUDE" => std::result::Result::Ok(AdsAnalyticsTargetingType::AUDIENCE_EXCLUDE),
            "GEO" => std::result::Result::Ok(AdsAnalyticsTargetingType::GEO),
            "AGE_BUCKET" => std::result::Result::Ok(AdsAnalyticsTargetingType::AGE_BUCKET),
            "REGION" => std::result::Result::Ok(AdsAnalyticsTargetingType::REGION),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AnalyticsMetricsResponse {
    /// Array with the requested daily metric records
    #[serde(rename = "daily_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_metrics: Option<Vec<models::AnalyticsMetricsResponseDailyMetrics>>,

    /// The metric name and value over the requested period for each requested metric
    #[serde(rename = "summary_metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub summary_metrics: Option<std::collections::HashMap<String, f64>>,

}

impl AnalyticsMetricsResponse {
    pub fn new() -> AnalyticsMetricsResponse {
        AnalyticsMetricsResponse {
            daily_metrics: None,
            summary_metrics: None,
        }
    }
}

/// Converts the AnalyticsMetricsResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AnalyticsMetricsResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping daily_metrics in query parameter serialization

        // Skipping summary_metrics in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AnalyticsMetricsResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AnalyticsMetricsResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub daily_metrics: Vec<Vec<models::AnalyticsMetricsResponseDailyMetrics>>,
            pub summary_metrics: Vec<std::collections::HashMap<String, f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AnalyticsMetricsResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "daily_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AnalyticsMetricsResponse".to_string()),
                    "summary_metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AnalyticsMetricsResponse".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AnalyticsMetricsResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AnalyticsMetricsResponse {
            daily_metrics: intermediate_rep.daily_metrics.into_iter().next(),
            summary_metrics: intermediate_rep.summary_metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AnalyticsMetricsResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AnalyticsMetricsResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AnalyticsMetricsResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AnalyticsMetricsResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AnalyticsMetricsResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AnalyticsMetricsResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AnalyticsMetricsResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AnalyticsMetricsResponseDailyMetrics {
    /// Metrics availablity, e.g., \"READY\".
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "data_status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub data_status: Option<String>,

    /// Metrics date (UTC): YYYY-MM-DD.
    #[serde(rename = "date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub date: Option<String>,

    /// The metric name and daily value for each requested metric
    #[serde(rename = "metrics")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub metrics: Option<std::collections::HashMap<String, f64>>,

}

impl AnalyticsMetricsResponseDailyMetrics {
    pub fn new() -> AnalyticsMetricsResponseDailyMetrics {
        AnalyticsMetricsResponseDailyMetrics {
            data_status: None,
            date: None,
            metrics: None,
        }
    }
}

/// Converts the AnalyticsMetricsResponseDailyMetrics value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AnalyticsMetricsResponseDailyMetrics {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref data_status) = self.data_status {
            params.push("data_status".to_string());
            params.push(data_status.to_string());
        }


        if let Some(ref date) = self.date {
            params.push("date".to_string());
            params.push(date.to_string());
        }

        // Skipping metrics in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AnalyticsMetricsResponseDailyMetrics value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AnalyticsMetricsResponseDailyMetrics {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub data_status: Vec<String>,
            pub date: Vec<String>,
            pub metrics: Vec<std::collections::HashMap<String, f64>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AnalyticsMetricsResponseDailyMetrics".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "data_status" => intermediate_rep.data_status.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "date" => intermediate_rep.date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "metrics" => return std::result::Result::Err("Parsing a container in this style is not supported in AnalyticsMetricsResponseDailyMetrics".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AnalyticsMetricsResponseDailyMetrics".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AnalyticsMetricsResponseDailyMetrics {
            data_status: intermediate_rep.data_status.into_iter().next(),
            date: intermediate_rep.date.into_iter().next(),
            metrics: intermediate_rep.metrics.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AnalyticsMetricsResponseDailyMetrics> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AnalyticsMetricsResponseDailyMetrics>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AnalyticsMetricsResponseDailyMetrics>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AnalyticsMetricsResponseDailyMetrics - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AnalyticsMetricsResponseDailyMetrics> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AnalyticsMetricsResponseDailyMetrics as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AnalyticsMetricsResponseDailyMetrics - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AvailabilityFilter {
    #[serde(rename = "AVAILABILITY")]
    pub availability: models::CatalogsProductGroupMultipleStringCriteria,

}

impl AvailabilityFilter {
    pub fn new(availability: models::CatalogsProductGroupMultipleStringCriteria, ) -> AvailabilityFilter {
        AvailabilityFilter {
            availability: availability,
        }
    }
}

/// Converts the AvailabilityFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for AvailabilityFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping AVAILABILITY in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AvailabilityFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AvailabilityFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub availability: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AvailabilityFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "AVAILABILITY" => intermediate_rep.availability.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AvailabilityFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AvailabilityFilter {
            availability: intermediate_rep.availability.into_iter().next().ok_or("AVAILABILITY missing in AvailabilityFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AvailabilityFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<AvailabilityFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AvailabilityFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for AvailabilityFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<AvailabilityFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AvailabilityFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into AvailabilityFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The operation performed by the batch
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BatchOperation {
    #[serde(rename = "UPDATE")]
    UPDATE,
    #[serde(rename = "CREATE")]
    CREATE,
    #[serde(rename = "UPSERT")]
    UPSERT,
}

impl std::fmt::Display for BatchOperation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BatchOperation::UPDATE => write!(f, "{}", "UPDATE"),
            BatchOperation::CREATE => write!(f, "{}", "CREATE"),
            BatchOperation::UPSERT => write!(f, "{}", "UPSERT"),
        }
    }
}

impl std::str::FromStr for BatchOperation {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UPDATE" => std::result::Result::Ok(BatchOperation::UPDATE),
            "CREATE" => std::result::Result::Ok(BatchOperation::CREATE),
            "UPSERT" => std::result::Result::Ok(BatchOperation::UPSERT),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The status of the operation performed by the batch
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum BatchOperationStatus {
    #[serde(rename = "PROCESSING")]
    PROCESSING,
    #[serde(rename = "COMPLETED")]
    COMPLETED,
}

impl std::fmt::Display for BatchOperationStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            BatchOperationStatus::PROCESSING => write!(f, "{}", "PROCESSING"),
            BatchOperationStatus::COMPLETED => write!(f, "{}", "COMPLETED"),
        }
    }
}

impl std::str::FromStr for BatchOperationStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "PROCESSING" => std::result::Result::Ok(BatchOperationStatus::PROCESSING),
            "COMPLETED" => std::result::Result::Ok(BatchOperationStatus::COMPLETED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Board
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Board {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    #[serde(rename = "owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub owner: Option<BoardOwner>,

    /// Privacy setting for a board. Learn more about <a href=\"https://help.pinterest.com/en/article/secret-boards\">secret boards</a> and <a href=\"https://help.pinterest.com/en/business/article/protected-boards\">protected boards</a>
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "privacy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,

}

impl Board {
    pub fn new(name: String, ) -> Board {
        Board {
            id: None,
            name: name,
            description: None,
            owner: None,
            privacy: Some("PUBLIC".to_string()),
        }
    }
}

/// Converts the Board value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Board {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        params.push("name".to_string());
        params.push(self.name.to_string());


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping owner in query parameter serialization
        // Skipping owner in query parameter serialization


        if let Some(ref privacy) = self.privacy {
            params.push("privacy".to_string());
            params.push(privacy.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Board value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Board {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub owner: Vec<BoardOwner>,
            pub privacy: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Board".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Board".to_string()),
                    "owner" => intermediate_rep.owner.push(<BoardOwner as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "privacy" => intermediate_rep.privacy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Board".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Board {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next().ok_or("name missing in Board".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in Board".to_string())?,
            owner: intermediate_rep.owner.into_iter().next(),
            privacy: intermediate_rep.privacy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Board> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Board>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Board>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Board - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Board> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Board as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Board - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardOwner {
    #[serde(rename = "username")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub username: Option<String>,

}

impl BoardOwner {
    pub fn new() -> BoardOwner {
        BoardOwner {
            username: None,
        }
    }
}

/// Converts the BoardOwner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BoardOwner {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref username) = self.username {
            params.push("username".to_string());
            params.push(username.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardOwner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardOwner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardOwner".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardOwner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardOwner {
            username: intermediate_rep.username.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardOwner> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardOwner>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardOwner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardOwner - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BoardOwner> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardOwner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardOwner - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Sections help organize pins within a board.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardSection {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

}

impl BoardSection {
    pub fn new() -> BoardSection {
        BoardSection {
            id: None,
            name: None,
        }
    }
}

/// Converts the BoardSection value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BoardSection {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardSection value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardSection {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardSection".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardSection".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardSection {
            id: intermediate_rep.id.into_iter().next(),
            name: intermediate_rep.name.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardSection> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardSection>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardSection>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardSection - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BoardSection> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardSection as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardSection - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Board fields for updates
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BoardUpdate {
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "privacy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub privacy: Option<String>,

}

impl BoardUpdate {
    pub fn new() -> BoardUpdate {
        BoardUpdate {
            name: None,
            description: None,
            privacy: None,
        }
    }
}

/// Converts the BoardUpdate value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BoardUpdate {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref privacy) = self.privacy {
            params.push("privacy".to_string());
            params.push(privacy.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BoardUpdate value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BoardUpdate {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub privacy: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BoardUpdate".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in BoardUpdate".to_string()),
                    "privacy" => intermediate_rep.privacy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BoardUpdate".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BoardUpdate {
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in BoardUpdate".to_string())?,
            privacy: intermediate_rep.privacy.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BoardUpdate> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BoardUpdate>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BoardUpdate>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BoardUpdate - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BoardUpdate> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BoardUpdate as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BoardUpdate - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BrandFilter {
    #[serde(rename = "BRAND")]
    pub brand: models::CatalogsProductGroupMultipleStringCriteria,

}

impl BrandFilter {
    pub fn new(brand: models::CatalogsProductGroupMultipleStringCriteria, ) -> BrandFilter {
        BrandFilter {
            brand: brand,
        }
    }
}

/// Converts the BrandFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for BrandFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping BRAND in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BrandFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BrandFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub brand: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BrandFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "BRAND" => intermediate_rep.brand.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BrandFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BrandFilter {
            brand: intermediate_rep.brand.into_iter().next().ok_or("BRAND missing in BrandFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BrandFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<BrandFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BrandFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for BrandFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<BrandFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BrandFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into BrandFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Campaign Data
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignCommon {
    /// Campaign's Advertiser ID.
    #[serde(rename = "ad_account_id")]
    pub ad_account_id: String,

    /// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<EntityStatus>,

    /// Campaign total spending cap.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<swagger::Nullable<isize>>,

    /// Campaign daily spending cap.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<swagger::Nullable<isize>>,

    /// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<swagger::Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<swagger::Nullable<TrackingUrls>>,

    /// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<swagger::Nullable<isize>>,

    /// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<swagger::Nullable<isize>>,

}

impl CampaignCommon {
    pub fn new(ad_account_id: String, ) -> CampaignCommon {
        CampaignCommon {
            ad_account_id: ad_account_id,
            name: None,
            status: Some("ACTIVE".to_string()),
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
        }
    }
}

/// Converts the CampaignCommon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignCommon {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("ad_account_id".to_string());
        params.push(self.ad_account_id.to_string());


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        // Skipping status in query parameter serialization


        if let Some(ref lifetime_spend_cap) = self.lifetime_spend_cap {
            params.push("lifetime_spend_cap".to_string());
            params.push(lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref daily_spend_cap) = self.daily_spend_cap {
            params.push("daily_spend_cap".to_string());
            params.push(daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref order_line_id) = self.order_line_id {
            params.push("order_line_id".to_string());
            params.push(order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping tracking_urls in query parameter serialization
        // Skipping tracking_urls in query parameter serialization


        if let Some(ref start_time) = self.start_time {
            params.push("start_time".to_string());
            params.push(start_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref end_time) = self.end_time {
            params.push("end_time".to_string());
            params.push(end_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignCommon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignCommon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<EntityStatus>,
            pub lifetime_spend_cap: Vec<isize>,
            pub daily_spend_cap: Vec<isize>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<TrackingUrls>,
            pub start_time: Vec<isize>,
            pub end_time: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignCommon".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignCommon".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignCommon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignCommon {
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next().ok_or("ad_account_id missing in CampaignCommon".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignCommon".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignCommon> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignCommon>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignCommon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignCommon - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignCommon> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignCommon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignCommon - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignResponse {
    /// Campaign ID.
    #[serde(rename = "id")]
    pub id: String,

    /// Campaign's Advertiser ID.
    #[serde(rename = "ad_account_id")]
    pub ad_account_id: String,

    /// Campaign name.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<EntityStatus>,

    /// Campaign total spending cap.
    #[serde(rename = "lifetime_spend_cap")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub lifetime_spend_cap: Option<swagger::Nullable<isize>>,

    /// Campaign daily spending cap.
    #[serde(rename = "daily_spend_cap")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub daily_spend_cap: Option<swagger::Nullable<isize>>,

    /// Order line ID that appears on the invoice.
    #[serde(rename = "order_line_id")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order_line_id: Option<swagger::Nullable<String>>,

    #[serde(rename = "tracking_urls")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tracking_urls: Option<swagger::Nullable<TrackingUrls>>,

    /// Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "start_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub start_time: Option<swagger::Nullable<isize>>,

    /// Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
    #[serde(rename = "end_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub end_time: Option<swagger::Nullable<isize>>,

    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<models::ObjectiveType>,

    /// Campaign creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<isize>,

    /// UTC timestamp. Last update time.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<isize>,

    /// Always \"campaign\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<String>,

}

impl CampaignResponse {
    pub fn new(id: String, ad_account_id: String, ) -> CampaignResponse {
        CampaignResponse {
            id: id,
            ad_account_id: ad_account_id,
            name: None,
            status: Some("ACTIVE".to_string()),
            lifetime_spend_cap: None,
            daily_spend_cap: None,
            order_line_id: None,
            tracking_urls: None,
            start_time: None,
            end_time: None,
            objective_type: None,
            created_time: None,
            updated_time: None,
            type_: None,
        }
    }
}

/// Converts the CampaignResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("id".to_string());
        params.push(self.id.to_string());


        params.push("ad_account_id".to_string());
        params.push(self.ad_account_id.to_string());


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        // Skipping status in query parameter serialization


        if let Some(ref lifetime_spend_cap) = self.lifetime_spend_cap {
            params.push("lifetime_spend_cap".to_string());
            params.push(lifetime_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref daily_spend_cap) = self.daily_spend_cap {
            params.push("daily_spend_cap".to_string());
            params.push(daily_spend_cap.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref order_line_id) = self.order_line_id {
            params.push("order_line_id".to_string());
            params.push(order_line_id.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping tracking_urls in query parameter serialization
        // Skipping tracking_urls in query parameter serialization


        if let Some(ref start_time) = self.start_time {
            params.push("start_time".to_string());
            params.push(start_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref end_time) = self.end_time {
            params.push("end_time".to_string());
            params.push(end_time.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping objective_type in query parameter serialization


        if let Some(ref created_time) = self.created_time {
            params.push("created_time".to_string());
            params.push(created_time.to_string());
        }


        if let Some(ref updated_time) = self.updated_time {
            params.push("updated_time".to_string());
            params.push(updated_time.to_string());
        }


        if let Some(ref type_) = self.type_ {
            params.push("type".to_string());
            params.push(type_.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
            pub ad_account_id: Vec<String>,
            pub name: Vec<String>,
            pub status: Vec<EntityStatus>,
            pub lifetime_spend_cap: Vec<isize>,
            pub daily_spend_cap: Vec<isize>,
            pub order_line_id: Vec<String>,
            pub tracking_urls: Vec<TrackingUrls>,
            pub start_time: Vec<isize>,
            pub end_time: Vec<isize>,
            pub objective_type: Vec<models::ObjectiveType>,
            pub created_time: Vec<isize>,
            pub updated_time: Vec<isize>,
            pub type_: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ad_account_id" => intermediate_rep.ad_account_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<EntityStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "lifetime_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "daily_spend_cap" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "order_line_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "tracking_urls" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "start_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "end_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CampaignResponse".to_string()),
                    "objective_type" => intermediate_rep.objective_type.push(<models::ObjectiveType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_time" => intermediate_rep.created_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time" => intermediate_rep.updated_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignResponse {
            id: intermediate_rep.id.into_iter().next().ok_or("id missing in CampaignResponse".to_string())?,
            ad_account_id: intermediate_rep.ad_account_id.into_iter().next().ok_or("ad_account_id missing in CampaignResponse".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            lifetime_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            daily_spend_cap: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            order_line_id: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            tracking_urls: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            start_time: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            end_time: std::result::Result::Err("Nullable types not supported in CampaignResponse".to_string())?,
            objective_type: intermediate_rep.objective_type.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            type_: intermediate_rep.type_.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignResponseAllOf {
    /// Campaign ID.
    #[serde(rename = "id")]
    pub id: String,

}

impl CampaignResponseAllOf {
    pub fn new(id: String, ) -> CampaignResponseAllOf {
        CampaignResponseAllOf {
            id: id,
        }
    }
}

/// Converts the CampaignResponseAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignResponseAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("id".to_string());
        params.push(self.id.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignResponseAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignResponseAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignResponseAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignResponseAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignResponseAllOf {
            id: intermediate_rep.id.into_iter().next().ok_or("id missing in CampaignResponseAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignResponseAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignResponseAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignResponseAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignResponseAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignResponseAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignResponseAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignResponseAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CampaignResponseAllOf1 {
    #[serde(rename = "objective_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub objective_type: Option<models::ObjectiveType>,

    /// Campaign creation time. Unix timestamp in seconds.
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<isize>,

    /// UTC timestamp. Last update time.
    #[serde(rename = "updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time: Option<isize>,

    /// Always \"campaign\".
    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<String>,

}

impl CampaignResponseAllOf1 {
    pub fn new() -> CampaignResponseAllOf1 {
        CampaignResponseAllOf1 {
            objective_type: None,
            created_time: None,
            updated_time: None,
            type_: None,
        }
    }
}

/// Converts the CampaignResponseAllOf1 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CampaignResponseAllOf1 {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping objective_type in query parameter serialization


        if let Some(ref created_time) = self.created_time {
            params.push("created_time".to_string());
            params.push(created_time.to_string());
        }


        if let Some(ref updated_time) = self.updated_time {
            params.push("updated_time".to_string());
            params.push(updated_time.to_string());
        }


        if let Some(ref type_) = self.type_ {
            params.push("type".to_string());
            params.push(type_.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CampaignResponseAllOf1 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CampaignResponseAllOf1 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub objective_type: Vec<models::ObjectiveType>,
            pub created_time: Vec<isize>,
            pub updated_time: Vec<isize>,
            pub type_: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CampaignResponseAllOf1".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "objective_type" => intermediate_rep.objective_type.push(<models::ObjectiveType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_time" => intermediate_rep.created_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time" => intermediate_rep.updated_time.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CampaignResponseAllOf1".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CampaignResponseAllOf1 {
            objective_type: intermediate_rep.objective_type.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            updated_time: intermediate_rep.updated_time.into_iter().next(),
            type_: intermediate_rep.type_.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CampaignResponseAllOf1> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CampaignResponseAllOf1>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CampaignResponseAllOf1>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CampaignResponseAllOf1 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CampaignResponseAllOf1> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CampaignResponseAllOf1 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CampaignResponseAllOf1 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Summary status for campaign
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CampaignSummaryStatus {
    #[serde(rename = "RUNNING")]
    RUNNING,
    #[serde(rename = "PAUSED")]
    PAUSED,
    #[serde(rename = "NOT_STARTED")]
    NOT_STARTED,
    #[serde(rename = "COMPLETED")]
    COMPLETED,
    #[serde(rename = "ADVERTISER_DISABLED")]
    ADVERTISER_DISABLED,
    #[serde(rename = "ARCHIVED")]
    ARCHIVED,
}

impl std::fmt::Display for CampaignSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CampaignSummaryStatus::RUNNING => write!(f, "{}", "RUNNING"),
            CampaignSummaryStatus::PAUSED => write!(f, "{}", "PAUSED"),
            CampaignSummaryStatus::NOT_STARTED => write!(f, "{}", "NOT_STARTED"),
            CampaignSummaryStatus::COMPLETED => write!(f, "{}", "COMPLETED"),
            CampaignSummaryStatus::ADVERTISER_DISABLED => write!(f, "{}", "ADVERTISER_DISABLED"),
            CampaignSummaryStatus::ARCHIVED => write!(f, "{}", "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for CampaignSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(CampaignSummaryStatus::RUNNING),
            "PAUSED" => std::result::Result::Ok(CampaignSummaryStatus::PAUSED),
            "NOT_STARTED" => std::result::Result::Ok(CampaignSummaryStatus::NOT_STARTED),
            "COMPLETED" => std::result::Result::Ok(CampaignSummaryStatus::COMPLETED),
            "ADVERTISER_DISABLED" => std::result::Result::Ok(CampaignSummaryStatus::ADVERTISER_DISABLED),
            "ARCHIVED" => std::result::Result::Ok(CampaignSummaryStatus::ARCHIVED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsDbItem {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

}

impl CatalogsDbItem {
    pub fn new() -> CatalogsDbItem {
        CatalogsDbItem {
            created_at: None,
            id: None,
            updated_at: None,
        }
    }
}

/// Converts the CatalogsDbItem value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsDbItem {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping created_at in query parameter serialization


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }

        // Skipping updated_at in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsDbItem value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsDbItem {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsDbItem".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsDbItem".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsDbItem {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsDbItem> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsDbItem>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsDbItem>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsDbItem - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsDbItem> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsDbItem as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsDbItem - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Catalogs Catalogs Feed object
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeed {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "default_country")]
    pub default_country: models::Country,

    #[serde(rename = "default_availability")]
    pub default_availability: swagger::Nullable<models::ProductAvailabilityType>,

    #[serde(rename = "default_currency")]
    pub default_currency: swagger::Nullable<models::NullableCurrency>,

    /// A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
    #[serde(rename = "name")]
    pub name: swagger::Nullable<String>,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    /// The locale used within a feed for product descriptions.
    #[serde(rename = "default_locale")]
    pub default_locale: String,

    #[serde(rename = "credentials")]
    pub credentials: swagger::Nullable<models::CatalogsFeedCredentials>,

    /// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    pub preferred_processing_schedule: swagger::Nullable<models::CatalogsFeedProcessingSchedule>,

    #[serde(rename = "status")]
    pub status: models::CatalogsStatus,

}

impl CatalogsFeed {
    pub fn new(default_country: models::Country, default_availability: swagger::Nullable<models::ProductAvailabilityType>, default_currency: swagger::Nullable<models::NullableCurrency>, name: swagger::Nullable<String>, format: models::CatalogsFormat, default_locale: String, credentials: swagger::Nullable<models::CatalogsFeedCredentials>, location: String, preferred_processing_schedule: swagger::Nullable<models::CatalogsFeedProcessingSchedule>, status: models::CatalogsStatus, ) -> CatalogsFeed {
        CatalogsFeed {
            created_at: None,
            id: None,
            updated_at: None,
            default_country: default_country,
            default_availability: default_availability,
            default_currency: default_currency,
            name: name,
            format: format,
            default_locale: default_locale,
            credentials: credentials,
            location: location,
            preferred_processing_schedule: preferred_processing_schedule,
            status: status,
        }
    }
}

/// Converts the CatalogsFeed value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeed {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping created_at in query parameter serialization


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }

        // Skipping updated_at in query parameter serialization

        // Skipping default_country in query parameter serialization

        // Skipping default_availability in query parameter serialization

        // Skipping default_currency in query parameter serialization


        params.push("name".to_string());
        params.push(self.name.as_ref().map_or("null".to_string(), |x| x.to_string()));

        // Skipping format in query parameter serialization


        params.push("default_locale".to_string());
        params.push(self.default_locale.to_string());

        // Skipping credentials in query parameter serialization


        params.push("location".to_string());
        params.push(self.location.to_string());

        // Skipping preferred_processing_schedule in query parameter serialization

        // Skipping status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeed value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeed {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub default_country: Vec<models::Country>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub default_locale: Vec<String>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeed".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_country" => intermediate_rep.default_country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeed".to_string()),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeed".to_string()),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeed".to_string()),
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_locale" => intermediate_rep.default_locale.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeed".to_string()),
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeed".to_string()),
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeed".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeed {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            default_country: intermediate_rep.default_country.into_iter().next().ok_or("default_country missing in CatalogsFeed".to_string())?,
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsFeed".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsFeed".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in CatalogsFeed".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or("format missing in CatalogsFeed".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next().ok_or("default_locale missing in CatalogsFeed".to_string())?,
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsFeed".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or("location missing in CatalogsFeed".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsFeed".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or("status missing in CatalogsFeed".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeed> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeed>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeed>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeed - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeed> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeed as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeed - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Use this if your feed file requires username and password.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedCredentials {
    /// The required password for downloading a feed.
    #[serde(rename = "password")]
    pub password: String,

    /// The required username for downloading a feed.
    #[serde(rename = "username")]
    pub username: String,

}

impl CatalogsFeedCredentials {
    pub fn new(password: String, username: String, ) -> CatalogsFeedCredentials {
        CatalogsFeedCredentials {
            password: password,
            username: username,
        }
    }
}

/// Converts the CatalogsFeedCredentials value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedCredentials {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("password".to_string());
        params.push(self.password.to_string());


        params.push("username".to_string());
        params.push(self.username.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedCredentials value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedCredentials {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub password: Vec<String>,
            pub username: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedCredentials".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "password" => intermediate_rep.password.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "username" => intermediate_rep.username.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedCredentials".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedCredentials {
            password: intermediate_rep.password.into_iter().next().ok_or("password missing in CatalogsFeedCredentials".to_string())?,
            username: intermediate_rep.username.into_iter().next().ok_or("username missing in CatalogsFeedCredentials".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedCredentials> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedCredentials>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedCredentials>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedCredentials - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedCredentials> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedCredentials as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedCredentials - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionDetails {
    #[serde(rename = "errors")]
    pub errors: models::CatalogsFeedIngestionErrors,

    #[serde(rename = "info")]
    pub info: models::CatalogsFeedIngestionInfo,

}

impl CatalogsFeedIngestionDetails {
    pub fn new(errors: models::CatalogsFeedIngestionErrors, info: models::CatalogsFeedIngestionInfo, ) -> CatalogsFeedIngestionDetails {
        CatalogsFeedIngestionDetails {
            errors: errors,
            info: info,
        }
    }
}

/// Converts the CatalogsFeedIngestionDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedIngestionDetails {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping errors in query parameter serialization

        // Skipping info in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub errors: Vec<models::CatalogsFeedIngestionErrors>,
            pub info: Vec<models::CatalogsFeedIngestionInfo>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionDetails".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "errors" => intermediate_rep.errors.push(<models::CatalogsFeedIngestionErrors as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "info" => intermediate_rep.info.push(<models::CatalogsFeedIngestionInfo as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionDetails {
            errors: intermediate_rep.errors.into_iter().next().ok_or("errors missing in CatalogsFeedIngestionDetails".to_string())?,
            info: intermediate_rep.info.into_iter().next().ok_or("info missing in CatalogsFeedIngestionDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionErrors {
    #[serde(rename = "image_download_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_download_error: Option<isize>,

    #[serde(rename = "image_download_connection_timeout")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_download_connection_timeout: Option<isize>,

    #[serde(rename = "image_format_unrecognize")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_format_unrecognize: Option<isize>,

    #[serde(rename = "line_level_internal_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub line_level_internal_error: Option<isize>,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "large_product_count_decrease")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub large_product_count_decrease: Option<isize>,

}

impl CatalogsFeedIngestionErrors {
    pub fn new() -> CatalogsFeedIngestionErrors {
        CatalogsFeedIngestionErrors {
            image_download_error: None,
            image_download_connection_timeout: None,
            image_format_unrecognize: None,
            line_level_internal_error: None,
            large_product_count_decrease: None,
        }
    }
}

/// Converts the CatalogsFeedIngestionErrors value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedIngestionErrors {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref image_download_error) = self.image_download_error {
            params.push("image_download_error".to_string());
            params.push(image_download_error.to_string());
        }


        if let Some(ref image_download_connection_timeout) = self.image_download_connection_timeout {
            params.push("image_download_connection_timeout".to_string());
            params.push(image_download_connection_timeout.to_string());
        }


        if let Some(ref image_format_unrecognize) = self.image_format_unrecognize {
            params.push("image_format_unrecognize".to_string());
            params.push(image_format_unrecognize.to_string());
        }


        if let Some(ref line_level_internal_error) = self.line_level_internal_error {
            params.push("line_level_internal_error".to_string());
            params.push(line_level_internal_error.to_string());
        }


        if let Some(ref large_product_count_decrease) = self.large_product_count_decrease {
            params.push("large_product_count_decrease".to_string());
            params.push(large_product_count_decrease.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionErrors value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionErrors {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub image_download_error: Vec<isize>,
            pub image_download_connection_timeout: Vec<isize>,
            pub image_format_unrecognize: Vec<isize>,
            pub line_level_internal_error: Vec<isize>,
            pub large_product_count_decrease: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionErrors".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "image_download_error" => intermediate_rep.image_download_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "image_download_connection_timeout" => intermediate_rep.image_download_connection_timeout.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "image_format_unrecognize" => intermediate_rep.image_format_unrecognize.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "line_level_internal_error" => intermediate_rep.line_level_internal_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "large_product_count_decrease" => intermediate_rep.large_product_count_decrease.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionErrors".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionErrors {
            image_download_error: intermediate_rep.image_download_error.into_iter().next(),
            image_download_connection_timeout: intermediate_rep.image_download_connection_timeout.into_iter().next(),
            image_format_unrecognize: intermediate_rep.image_format_unrecognize.into_iter().next(),
            line_level_internal_error: intermediate_rep.line_level_internal_error.into_iter().next(),
            large_product_count_decrease: intermediate_rep.large_product_count_decrease.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionErrors> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionErrors>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionErrors>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionErrors - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionErrors> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionErrors as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionErrors - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedIngestionInfo {
    #[serde(rename = "in_stock")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub in_stock: Option<isize>,

    #[serde(rename = "out_of_stock")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub out_of_stock: Option<isize>,

    #[serde(rename = "preorder")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preorder: Option<isize>,

}

impl CatalogsFeedIngestionInfo {
    pub fn new() -> CatalogsFeedIngestionInfo {
        CatalogsFeedIngestionInfo {
            in_stock: None,
            out_of_stock: None,
            preorder: None,
        }
    }
}

/// Converts the CatalogsFeedIngestionInfo value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedIngestionInfo {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref in_stock) = self.in_stock {
            params.push("in_stock".to_string());
            params.push(in_stock.to_string());
        }


        if let Some(ref out_of_stock) = self.out_of_stock {
            params.push("out_of_stock".to_string());
            params.push(out_of_stock.to_string());
        }


        if let Some(ref preorder) = self.preorder {
            params.push("preorder".to_string());
            params.push(preorder.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedIngestionInfo value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedIngestionInfo {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub in_stock: Vec<isize>,
            pub out_of_stock: Vec<isize>,
            pub preorder: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedIngestionInfo".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "in_stock" => intermediate_rep.in_stock.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "out_of_stock" => intermediate_rep.out_of_stock.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "preorder" => intermediate_rep.preorder.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedIngestionInfo".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedIngestionInfo {
            in_stock: intermediate_rep.in_stock.into_iter().next(),
            out_of_stock: intermediate_rep.out_of_stock.into_iter().next(),
            preorder: intermediate_rep.preorder.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedIngestionInfo> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedIngestionInfo>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedIngestionInfo>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedIngestionInfo - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedIngestionInfo> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedIngestionInfo as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedIngestionInfo - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProcessingResult {
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "ingestion_details")]
    pub ingestion_details: models::CatalogsFeedIngestionDetails,

    #[serde(rename = "status")]
    pub status: models::CatalogsFeedProcessingStatus,

    #[serde(rename = "product_counts")]
    pub product_counts: swagger::Nullable<models::CatalogsFeedProductCounts>,

    #[serde(rename = "validation_details")]
    pub validation_details: models::CatalogsFeedValidationDetails,

}

impl CatalogsFeedProcessingResult {
    pub fn new(ingestion_details: models::CatalogsFeedIngestionDetails, status: models::CatalogsFeedProcessingStatus, product_counts: swagger::Nullable<models::CatalogsFeedProductCounts>, validation_details: models::CatalogsFeedValidationDetails, ) -> CatalogsFeedProcessingResult {
        CatalogsFeedProcessingResult {
            created_at: None,
            id: None,
            updated_at: None,
            ingestion_details: ingestion_details,
            status: status,
            product_counts: product_counts,
            validation_details: validation_details,
        }
    }
}

/// Converts the CatalogsFeedProcessingResult value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedProcessingResult {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping created_at in query parameter serialization


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }

        // Skipping updated_at in query parameter serialization

        // Skipping ingestion_details in query parameter serialization

        // Skipping status in query parameter serialization

        // Skipping product_counts in query parameter serialization

        // Skipping validation_details in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProcessingResult value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProcessingResult {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub id: Vec<String>,
            pub updated_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub ingestion_details: Vec<models::CatalogsFeedIngestionDetails>,
            pub status: Vec<models::CatalogsFeedProcessingStatus>,
            pub product_counts: Vec<models::CatalogsFeedProductCounts>,
            pub validation_details: Vec<models::CatalogsFeedValidationDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProcessingResult".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_at" => intermediate_rep.updated_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ingestion_details" => intermediate_rep.ingestion_details.push(<models::CatalogsFeedIngestionDetails as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<models::CatalogsFeedProcessingStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_counts" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedProcessingResult".to_string()),
                    "validation_details" => intermediate_rep.validation_details.push(<models::CatalogsFeedValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProcessingResult".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProcessingResult {
            created_at: intermediate_rep.created_at.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
            ingestion_details: intermediate_rep.ingestion_details.into_iter().next().ok_or("ingestion_details missing in CatalogsFeedProcessingResult".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or("status missing in CatalogsFeedProcessingResult".to_string())?,
            product_counts: std::result::Result::Err("Nullable types not supported in CatalogsFeedProcessingResult".to_string())?,
            validation_details: intermediate_rep.validation_details.into_iter().next().ok_or("validation_details missing in CatalogsFeedProcessingResult".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProcessingResult> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProcessingResult>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProcessingResult>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProcessingResult - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedProcessingResult> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProcessingResult as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProcessingResult - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProcessingResultFields {
    #[serde(rename = "ingestion_details")]
    pub ingestion_details: models::CatalogsFeedIngestionDetails,

    #[serde(rename = "status")]
    pub status: models::CatalogsFeedProcessingStatus,

    #[serde(rename = "product_counts")]
    pub product_counts: swagger::Nullable<models::CatalogsFeedProductCounts>,

    #[serde(rename = "validation_details")]
    pub validation_details: models::CatalogsFeedValidationDetails,

}

impl CatalogsFeedProcessingResultFields {
    pub fn new(ingestion_details: models::CatalogsFeedIngestionDetails, status: models::CatalogsFeedProcessingStatus, product_counts: swagger::Nullable<models::CatalogsFeedProductCounts>, validation_details: models::CatalogsFeedValidationDetails, ) -> CatalogsFeedProcessingResultFields {
        CatalogsFeedProcessingResultFields {
            ingestion_details: ingestion_details,
            status: status,
            product_counts: product_counts,
            validation_details: validation_details,
        }
    }
}

/// Converts the CatalogsFeedProcessingResultFields value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedProcessingResultFields {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping ingestion_details in query parameter serialization

        // Skipping status in query parameter serialization

        // Skipping product_counts in query parameter serialization

        // Skipping validation_details in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProcessingResultFields value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProcessingResultFields {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub ingestion_details: Vec<models::CatalogsFeedIngestionDetails>,
            pub status: Vec<models::CatalogsFeedProcessingStatus>,
            pub product_counts: Vec<models::CatalogsFeedProductCounts>,
            pub validation_details: Vec<models::CatalogsFeedValidationDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProcessingResultFields".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ingestion_details" => intermediate_rep.ingestion_details.push(<models::CatalogsFeedIngestionDetails as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<models::CatalogsFeedProcessingStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_counts" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedProcessingResultFields".to_string()),
                    "validation_details" => intermediate_rep.validation_details.push(<models::CatalogsFeedValidationDetails as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProcessingResultFields".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProcessingResultFields {
            ingestion_details: intermediate_rep.ingestion_details.into_iter().next().ok_or("ingestion_details missing in CatalogsFeedProcessingResultFields".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or("status missing in CatalogsFeedProcessingResultFields".to_string())?,
            product_counts: std::result::Result::Err("Nullable types not supported in CatalogsFeedProcessingResultFields".to_string())?,
            validation_details: intermediate_rep.validation_details.into_iter().next().ok_or("validation_details missing in CatalogsFeedProcessingResultFields".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProcessingResultFields> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProcessingResultFields>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProcessingResultFields>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProcessingResultFields - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedProcessingResultFields> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProcessingResultFields as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProcessingResultFields - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Optional daily processing schedule. Use this to configure the preferred time for processing a feed (otherwise random).
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProcessingSchedule {
    /// A time in format HH:MM with leading 0 (zero)
    #[serde(rename = "time")]
    pub time: String,

    /// The timezone considered for the processing schedule time.
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "timezone")]
    pub timezone: swagger::Nullable<String>,

}

impl CatalogsFeedProcessingSchedule {
    pub fn new(time: String, timezone: swagger::Nullable<String>, ) -> CatalogsFeedProcessingSchedule {
        CatalogsFeedProcessingSchedule {
            time: time,
            timezone: timezone,
        }
    }
}

/// Converts the CatalogsFeedProcessingSchedule value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedProcessingSchedule {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("time".to_string());
        params.push(self.time.to_string());


        params.push("timezone".to_string());
        params.push(self.timezone.as_ref().map_or("null".to_string(), |x| x.to_string()));

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProcessingSchedule value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProcessingSchedule {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub time: Vec<String>,
            pub timezone: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProcessingSchedule".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "time" => intermediate_rep.time.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "timezone" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedProcessingSchedule".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProcessingSchedule".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProcessingSchedule {
            time: intermediate_rep.time.into_iter().next().ok_or("time missing in CatalogsFeedProcessingSchedule".to_string())?,
            timezone: std::result::Result::Err("Nullable types not supported in CatalogsFeedProcessingSchedule".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProcessingSchedule> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProcessingSchedule>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProcessingSchedule>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProcessingSchedule - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedProcessingSchedule> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProcessingSchedule as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProcessingSchedule - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsFeedProcessingStatus {
    #[serde(rename = "COMPLETED")]
    COMPLETED,
    #[serde(rename = "COMPLETED_EARLY")]
    COMPLETED_EARLY,
    #[serde(rename = "DISAPPROVED")]
    DISAPPROVED,
    #[serde(rename = "FAILED")]
    FAILED,
    #[serde(rename = "PROCESSING")]
    PROCESSING,
    #[serde(rename = "QUEUED_FOR_PROCESSING")]
    QUEUED_FOR_PROCESSING,
    #[serde(rename = "UNDER_APPEAL")]
    UNDER_APPEAL,
    #[serde(rename = "UNDER_REVIEW")]
    UNDER_REVIEW,
}

impl std::fmt::Display for CatalogsFeedProcessingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsFeedProcessingStatus::COMPLETED => write!(f, "{}", "COMPLETED"),
            CatalogsFeedProcessingStatus::COMPLETED_EARLY => write!(f, "{}", "COMPLETED_EARLY"),
            CatalogsFeedProcessingStatus::DISAPPROVED => write!(f, "{}", "DISAPPROVED"),
            CatalogsFeedProcessingStatus::FAILED => write!(f, "{}", "FAILED"),
            CatalogsFeedProcessingStatus::PROCESSING => write!(f, "{}", "PROCESSING"),
            CatalogsFeedProcessingStatus::QUEUED_FOR_PROCESSING => write!(f, "{}", "QUEUED_FOR_PROCESSING"),
            CatalogsFeedProcessingStatus::UNDER_APPEAL => write!(f, "{}", "UNDER_APPEAL"),
            CatalogsFeedProcessingStatus::UNDER_REVIEW => write!(f, "{}", "UNDER_REVIEW"),
        }
    }
}

impl std::str::FromStr for CatalogsFeedProcessingStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "COMPLETED" => std::result::Result::Ok(CatalogsFeedProcessingStatus::COMPLETED),
            "COMPLETED_EARLY" => std::result::Result::Ok(CatalogsFeedProcessingStatus::COMPLETED_EARLY),
            "DISAPPROVED" => std::result::Result::Ok(CatalogsFeedProcessingStatus::DISAPPROVED),
            "FAILED" => std::result::Result::Ok(CatalogsFeedProcessingStatus::FAILED),
            "PROCESSING" => std::result::Result::Ok(CatalogsFeedProcessingStatus::PROCESSING),
            "QUEUED_FOR_PROCESSING" => std::result::Result::Ok(CatalogsFeedProcessingStatus::QUEUED_FOR_PROCESSING),
            "UNDER_APPEAL" => std::result::Result::Ok(CatalogsFeedProcessingStatus::UNDER_APPEAL),
            "UNDER_REVIEW" => std::result::Result::Ok(CatalogsFeedProcessingStatus::UNDER_REVIEW),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// The counts can be null early in the process.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedProductCounts {
    /// The number of products in the feed file
    #[serde(rename = "original")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub original: Option<isize>,

}

impl CatalogsFeedProductCounts {
    pub fn new() -> CatalogsFeedProductCounts {
        CatalogsFeedProductCounts {
            original: None,
        }
    }
}

/// Converts the CatalogsFeedProductCounts value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedProductCounts {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref original) = self.original {
            params.push("original".to_string());
            params.push(original.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedProductCounts value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedProductCounts {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub original: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedProductCounts".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "original" => intermediate_rep.original.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedProductCounts".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedProductCounts {
            original: intermediate_rep.original.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedProductCounts> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedProductCounts>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedProductCounts>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedProductCounts - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedProductCounts> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedProductCounts as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedProductCounts - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedValidationDetails {
    #[serde(rename = "errors")]
    pub errors: models::CatalogsFeedValidationErrors,

    #[serde(rename = "warnings")]
    pub warnings: models::CatalogsFeedValidationWarnings,

}

impl CatalogsFeedValidationDetails {
    pub fn new(errors: models::CatalogsFeedValidationErrors, warnings: models::CatalogsFeedValidationWarnings, ) -> CatalogsFeedValidationDetails {
        CatalogsFeedValidationDetails {
            errors: errors,
            warnings: warnings,
        }
    }
}

/// Converts the CatalogsFeedValidationDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedValidationDetails {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping errors in query parameter serialization

        // Skipping warnings in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedValidationDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedValidationDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub errors: Vec<models::CatalogsFeedValidationErrors>,
            pub warnings: Vec<models::CatalogsFeedValidationWarnings>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedValidationDetails".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "errors" => intermediate_rep.errors.push(<models::CatalogsFeedValidationErrors as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "warnings" => intermediate_rep.warnings.push(<models::CatalogsFeedValidationWarnings as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedValidationDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedValidationDetails {
            errors: intermediate_rep.errors.into_iter().next().ok_or("errors missing in CatalogsFeedValidationDetails".to_string())?,
            warnings: intermediate_rep.warnings.into_iter().next().ok_or("warnings missing in CatalogsFeedValidationDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedValidationDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedValidationDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedValidationDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedValidationDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedValidationDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedValidationDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedValidationDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedValidationErrors {
    #[serde(rename = "fetch_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fetch_error: Option<isize>,

    #[serde(rename = "fetch_inactive_feed_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fetch_inactive_feed_error: Option<isize>,

    #[serde(rename = "encoding_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub encoding_error: Option<isize>,

    #[serde(rename = "delimiter_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub delimiter_error: Option<isize>,

    #[serde(rename = "required_columns_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub required_columns_missing: Option<isize>,

    #[serde(rename = "image_link_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_invalid: Option<isize>,

    #[serde(rename = "itemid_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub itemid_missing: Option<isize>,

    #[serde(rename = "title_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title_missing: Option<isize>,

    #[serde(rename = "description_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description_missing: Option<isize>,

    #[serde(rename = "product_category_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_category_invalid: Option<isize>,

    #[serde(rename = "product_link_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_link_missing: Option<isize>,

    #[serde(rename = "image_link_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_missing: Option<isize>,

    #[serde(rename = "availability_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_invalid: Option<isize>,

    #[serde(rename = "product_price_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_price_invalid: Option<isize>,

    #[serde(rename = "link_format_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_format_invalid: Option<isize>,

    #[serde(rename = "parse_line_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub parse_line_error: Option<isize>,

    #[serde(rename = "adwords_format_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_format_invalid: Option<isize>,

    #[serde(rename = "product_category_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_category_missing: Option<isize>,

    #[serde(rename = "internal_service_error")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub internal_service_error: Option<isize>,

    #[serde(rename = "no_verified_domain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub no_verified_domain: Option<isize>,

    #[serde(rename = "adult_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult_invalid: Option<isize>,

    #[serde(rename = "invalid_domain")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub invalid_domain: Option<isize>,

    #[serde(rename = "feed_length_too_long")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_length_too_long: Option<isize>,

    #[serde(rename = "link_length_too_long")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_length_too_long: Option<isize>,

    #[serde(rename = "malformed_xml")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub malformed_xml: Option<isize>,

    #[serde(rename = "redirect_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub redirect_invalid: Option<isize>,

    #[serde(rename = "price_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price_missing: Option<isize>,

    #[serde(rename = "feed_too_small")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_too_small: Option<isize>,

    #[serde(rename = "condition_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition_invalid: Option<isize>,

    #[serde(rename = "shopify_no_products")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shopify_no_products: Option<isize>,

    #[serde(rename = "max_items_per_item_group_exceeded")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_items_per_item_group_exceeded: Option<isize>,

    #[serde(rename = "item_main_image_download_failure")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_main_image_download_failure: Option<isize>,

    #[serde(rename = "pinjoin_content_unsafe")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pinjoin_content_unsafe: Option<isize>,

    #[serde(rename = "blocklisted_image_signature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub blocklisted_image_signature: Option<isize>,

}

impl CatalogsFeedValidationErrors {
    pub fn new() -> CatalogsFeedValidationErrors {
        CatalogsFeedValidationErrors {
            fetch_error: None,
            fetch_inactive_feed_error: None,
            encoding_error: None,
            delimiter_error: None,
            required_columns_missing: None,
            image_link_invalid: None,
            itemid_missing: None,
            title_missing: None,
            description_missing: None,
            product_category_invalid: None,
            product_link_missing: None,
            image_link_missing: None,
            availability_invalid: None,
            product_price_invalid: None,
            link_format_invalid: None,
            parse_line_error: None,
            adwords_format_invalid: None,
            product_category_missing: None,
            internal_service_error: None,
            no_verified_domain: None,
            adult_invalid: None,
            invalid_domain: None,
            feed_length_too_long: None,
            link_length_too_long: None,
            malformed_xml: None,
            redirect_invalid: None,
            price_missing: None,
            feed_too_small: None,
            condition_invalid: None,
            shopify_no_products: None,
            max_items_per_item_group_exceeded: None,
            item_main_image_download_failure: None,
            pinjoin_content_unsafe: None,
            blocklisted_image_signature: None,
        }
    }
}

/// Converts the CatalogsFeedValidationErrors value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedValidationErrors {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref fetch_error) = self.fetch_error {
            params.push("fetch_error".to_string());
            params.push(fetch_error.to_string());
        }


        if let Some(ref fetch_inactive_feed_error) = self.fetch_inactive_feed_error {
            params.push("fetch_inactive_feed_error".to_string());
            params.push(fetch_inactive_feed_error.to_string());
        }


        if let Some(ref encoding_error) = self.encoding_error {
            params.push("encoding_error".to_string());
            params.push(encoding_error.to_string());
        }


        if let Some(ref delimiter_error) = self.delimiter_error {
            params.push("delimiter_error".to_string());
            params.push(delimiter_error.to_string());
        }


        if let Some(ref required_columns_missing) = self.required_columns_missing {
            params.push("required_columns_missing".to_string());
            params.push(required_columns_missing.to_string());
        }


        if let Some(ref image_link_invalid) = self.image_link_invalid {
            params.push("image_link_invalid".to_string());
            params.push(image_link_invalid.to_string());
        }


        if let Some(ref itemid_missing) = self.itemid_missing {
            params.push("itemid_missing".to_string());
            params.push(itemid_missing.to_string());
        }


        if let Some(ref title_missing) = self.title_missing {
            params.push("title_missing".to_string());
            params.push(title_missing.to_string());
        }


        if let Some(ref description_missing) = self.description_missing {
            params.push("description_missing".to_string());
            params.push(description_missing.to_string());
        }


        if let Some(ref product_category_invalid) = self.product_category_invalid {
            params.push("product_category_invalid".to_string());
            params.push(product_category_invalid.to_string());
        }


        if let Some(ref product_link_missing) = self.product_link_missing {
            params.push("product_link_missing".to_string());
            params.push(product_link_missing.to_string());
        }


        if let Some(ref image_link_missing) = self.image_link_missing {
            params.push("image_link_missing".to_string());
            params.push(image_link_missing.to_string());
        }


        if let Some(ref availability_invalid) = self.availability_invalid {
            params.push("availability_invalid".to_string());
            params.push(availability_invalid.to_string());
        }


        if let Some(ref product_price_invalid) = self.product_price_invalid {
            params.push("product_price_invalid".to_string());
            params.push(product_price_invalid.to_string());
        }


        if let Some(ref link_format_invalid) = self.link_format_invalid {
            params.push("link_format_invalid".to_string());
            params.push(link_format_invalid.to_string());
        }


        if let Some(ref parse_line_error) = self.parse_line_error {
            params.push("parse_line_error".to_string());
            params.push(parse_line_error.to_string());
        }


        if let Some(ref adwords_format_invalid) = self.adwords_format_invalid {
            params.push("adwords_format_invalid".to_string());
            params.push(adwords_format_invalid.to_string());
        }


        if let Some(ref product_category_missing) = self.product_category_missing {
            params.push("product_category_missing".to_string());
            params.push(product_category_missing.to_string());
        }


        if let Some(ref internal_service_error) = self.internal_service_error {
            params.push("internal_service_error".to_string());
            params.push(internal_service_error.to_string());
        }


        if let Some(ref no_verified_domain) = self.no_verified_domain {
            params.push("no_verified_domain".to_string());
            params.push(no_verified_domain.to_string());
        }


        if let Some(ref adult_invalid) = self.adult_invalid {
            params.push("adult_invalid".to_string());
            params.push(adult_invalid.to_string());
        }


        if let Some(ref invalid_domain) = self.invalid_domain {
            params.push("invalid_domain".to_string());
            params.push(invalid_domain.to_string());
        }


        if let Some(ref feed_length_too_long) = self.feed_length_too_long {
            params.push("feed_length_too_long".to_string());
            params.push(feed_length_too_long.to_string());
        }


        if let Some(ref link_length_too_long) = self.link_length_too_long {
            params.push("link_length_too_long".to_string());
            params.push(link_length_too_long.to_string());
        }


        if let Some(ref malformed_xml) = self.malformed_xml {
            params.push("malformed_xml".to_string());
            params.push(malformed_xml.to_string());
        }


        if let Some(ref redirect_invalid) = self.redirect_invalid {
            params.push("redirect_invalid".to_string());
            params.push(redirect_invalid.to_string());
        }


        if let Some(ref price_missing) = self.price_missing {
            params.push("price_missing".to_string());
            params.push(price_missing.to_string());
        }


        if let Some(ref feed_too_small) = self.feed_too_small {
            params.push("feed_too_small".to_string());
            params.push(feed_too_small.to_string());
        }


        if let Some(ref condition_invalid) = self.condition_invalid {
            params.push("condition_invalid".to_string());
            params.push(condition_invalid.to_string());
        }


        if let Some(ref shopify_no_products) = self.shopify_no_products {
            params.push("shopify_no_products".to_string());
            params.push(shopify_no_products.to_string());
        }


        if let Some(ref max_items_per_item_group_exceeded) = self.max_items_per_item_group_exceeded {
            params.push("max_items_per_item_group_exceeded".to_string());
            params.push(max_items_per_item_group_exceeded.to_string());
        }


        if let Some(ref item_main_image_download_failure) = self.item_main_image_download_failure {
            params.push("item_main_image_download_failure".to_string());
            params.push(item_main_image_download_failure.to_string());
        }


        if let Some(ref pinjoin_content_unsafe) = self.pinjoin_content_unsafe {
            params.push("pinjoin_content_unsafe".to_string());
            params.push(pinjoin_content_unsafe.to_string());
        }


        if let Some(ref blocklisted_image_signature) = self.blocklisted_image_signature {
            params.push("blocklisted_image_signature".to_string());
            params.push(blocklisted_image_signature.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedValidationErrors value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedValidationErrors {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub fetch_error: Vec<isize>,
            pub fetch_inactive_feed_error: Vec<isize>,
            pub encoding_error: Vec<isize>,
            pub delimiter_error: Vec<isize>,
            pub required_columns_missing: Vec<isize>,
            pub image_link_invalid: Vec<isize>,
            pub itemid_missing: Vec<isize>,
            pub title_missing: Vec<isize>,
            pub description_missing: Vec<isize>,
            pub product_category_invalid: Vec<isize>,
            pub product_link_missing: Vec<isize>,
            pub image_link_missing: Vec<isize>,
            pub availability_invalid: Vec<isize>,
            pub product_price_invalid: Vec<isize>,
            pub link_format_invalid: Vec<isize>,
            pub parse_line_error: Vec<isize>,
            pub adwords_format_invalid: Vec<isize>,
            pub product_category_missing: Vec<isize>,
            pub internal_service_error: Vec<isize>,
            pub no_verified_domain: Vec<isize>,
            pub adult_invalid: Vec<isize>,
            pub invalid_domain: Vec<isize>,
            pub feed_length_too_long: Vec<isize>,
            pub link_length_too_long: Vec<isize>,
            pub malformed_xml: Vec<isize>,
            pub redirect_invalid: Vec<isize>,
            pub price_missing: Vec<isize>,
            pub feed_too_small: Vec<isize>,
            pub condition_invalid: Vec<isize>,
            pub shopify_no_products: Vec<isize>,
            pub max_items_per_item_group_exceeded: Vec<isize>,
            pub item_main_image_download_failure: Vec<isize>,
            pub pinjoin_content_unsafe: Vec<isize>,
            pub blocklisted_image_signature: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedValidationErrors".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "fetch_error" => intermediate_rep.fetch_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "fetch_inactive_feed_error" => intermediate_rep.fetch_inactive_feed_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "encoding_error" => intermediate_rep.encoding_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "delimiter_error" => intermediate_rep.delimiter_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "required_columns_missing" => intermediate_rep.required_columns_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "image_link_invalid" => intermediate_rep.image_link_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "itemid_missing" => intermediate_rep.itemid_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "title_missing" => intermediate_rep.title_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description_missing" => intermediate_rep.description_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_category_invalid" => intermediate_rep.product_category_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_link_missing" => intermediate_rep.product_link_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "image_link_missing" => intermediate_rep.image_link_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "availability_invalid" => intermediate_rep.availability_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_price_invalid" => intermediate_rep.product_price_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "link_format_invalid" => intermediate_rep.link_format_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "parse_line_error" => intermediate_rep.parse_line_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "adwords_format_invalid" => intermediate_rep.adwords_format_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_category_missing" => intermediate_rep.product_category_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "internal_service_error" => intermediate_rep.internal_service_error.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "no_verified_domain" => intermediate_rep.no_verified_domain.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "adult_invalid" => intermediate_rep.adult_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "invalid_domain" => intermediate_rep.invalid_domain.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "feed_length_too_long" => intermediate_rep.feed_length_too_long.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "link_length_too_long" => intermediate_rep.link_length_too_long.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "malformed_xml" => intermediate_rep.malformed_xml.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "redirect_invalid" => intermediate_rep.redirect_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "price_missing" => intermediate_rep.price_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "feed_too_small" => intermediate_rep.feed_too_small.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "condition_invalid" => intermediate_rep.condition_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shopify_no_products" => intermediate_rep.shopify_no_products.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "max_items_per_item_group_exceeded" => intermediate_rep.max_items_per_item_group_exceeded.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "item_main_image_download_failure" => intermediate_rep.item_main_image_download_failure.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "pinjoin_content_unsafe" => intermediate_rep.pinjoin_content_unsafe.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "blocklisted_image_signature" => intermediate_rep.blocklisted_image_signature.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedValidationErrors".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedValidationErrors {
            fetch_error: intermediate_rep.fetch_error.into_iter().next(),
            fetch_inactive_feed_error: intermediate_rep.fetch_inactive_feed_error.into_iter().next(),
            encoding_error: intermediate_rep.encoding_error.into_iter().next(),
            delimiter_error: intermediate_rep.delimiter_error.into_iter().next(),
            required_columns_missing: intermediate_rep.required_columns_missing.into_iter().next(),
            image_link_invalid: intermediate_rep.image_link_invalid.into_iter().next(),
            itemid_missing: intermediate_rep.itemid_missing.into_iter().next(),
            title_missing: intermediate_rep.title_missing.into_iter().next(),
            description_missing: intermediate_rep.description_missing.into_iter().next(),
            product_category_invalid: intermediate_rep.product_category_invalid.into_iter().next(),
            product_link_missing: intermediate_rep.product_link_missing.into_iter().next(),
            image_link_missing: intermediate_rep.image_link_missing.into_iter().next(),
            availability_invalid: intermediate_rep.availability_invalid.into_iter().next(),
            product_price_invalid: intermediate_rep.product_price_invalid.into_iter().next(),
            link_format_invalid: intermediate_rep.link_format_invalid.into_iter().next(),
            parse_line_error: intermediate_rep.parse_line_error.into_iter().next(),
            adwords_format_invalid: intermediate_rep.adwords_format_invalid.into_iter().next(),
            product_category_missing: intermediate_rep.product_category_missing.into_iter().next(),
            internal_service_error: intermediate_rep.internal_service_error.into_iter().next(),
            no_verified_domain: intermediate_rep.no_verified_domain.into_iter().next(),
            adult_invalid: intermediate_rep.adult_invalid.into_iter().next(),
            invalid_domain: intermediate_rep.invalid_domain.into_iter().next(),
            feed_length_too_long: intermediate_rep.feed_length_too_long.into_iter().next(),
            link_length_too_long: intermediate_rep.link_length_too_long.into_iter().next(),
            malformed_xml: intermediate_rep.malformed_xml.into_iter().next(),
            redirect_invalid: intermediate_rep.redirect_invalid.into_iter().next(),
            price_missing: intermediate_rep.price_missing.into_iter().next(),
            feed_too_small: intermediate_rep.feed_too_small.into_iter().next(),
            condition_invalid: intermediate_rep.condition_invalid.into_iter().next(),
            shopify_no_products: intermediate_rep.shopify_no_products.into_iter().next(),
            max_items_per_item_group_exceeded: intermediate_rep.max_items_per_item_group_exceeded.into_iter().next(),
            item_main_image_download_failure: intermediate_rep.item_main_image_download_failure.into_iter().next(),
            pinjoin_content_unsafe: intermediate_rep.pinjoin_content_unsafe.into_iter().next(),
            blocklisted_image_signature: intermediate_rep.blocklisted_image_signature.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedValidationErrors> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedValidationErrors>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedValidationErrors>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedValidationErrors - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedValidationErrors> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedValidationErrors as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedValidationErrors - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedValidationWarnings {
    #[serde(rename = "title_length_too_long")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title_length_too_long: Option<isize>,

    #[serde(rename = "description_length_too_long")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description_length_too_long: Option<isize>,

    #[serde(rename = "gender_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender_invalid: Option<isize>,

    #[serde(rename = "age_group_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group_invalid: Option<isize>,

    #[serde(rename = "size_type_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type_invalid: Option<isize>,

    #[serde(rename = "link_format_warning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link_format_warning: Option<isize>,

    #[serde(rename = "duplicate_products")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duplicate_products: Option<isize>,

    #[serde(rename = "duplicate_links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duplicate_links: Option<isize>,

    #[serde(rename = "sales_price_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sales_price_invalid: Option<isize>,

    #[serde(rename = "product_category_depth_warning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_category_depth_warning: Option<isize>,

    #[serde(rename = "adwords_same_as_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_same_as_link: Option<isize>,

    #[serde(rename = "duplicate_headers")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub duplicate_headers: Option<isize>,

    #[serde(rename = "fetch_same_signature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fetch_same_signature: Option<isize>,

    #[serde(rename = "adwords_format_warning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adwords_format_warning: Option<isize>,

    #[serde(rename = "additional_image_link_warning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link_warning: Option<isize>,

    #[serde(rename = "image_link_warning")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link_warning: Option<isize>,

    #[serde(rename = "shipping_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_invalid: Option<isize>,

    #[serde(rename = "tax_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax_invalid: Option<isize>,

    #[serde(rename = "shipping_weight_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_weight_invalid: Option<isize>,

    #[serde(rename = "expiration_date_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub expiration_date_invalid: Option<isize>,

    #[serde(rename = "availability_date_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_date_invalid: Option<isize>,

    #[serde(rename = "sale_date_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_date_invalid: Option<isize>,

    #[serde(rename = "weight_unit_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight_unit_invalid: Option<isize>,

    #[serde(rename = "is_bundle_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_bundle_invalid: Option<isize>,

    #[serde(rename = "updated_time_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_time_invalid: Option<isize>,

    #[serde(rename = "custom_label_length_too_long")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_length_too_long: Option<isize>,

    #[serde(rename = "product_type_length_too_long")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_type_length_too_long: Option<isize>,

    #[serde(rename = "too_many_additional_image_links")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub too_many_additional_image_links: Option<isize>,

    #[serde(rename = "multipack_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub multipack_invalid: Option<isize>,

    #[serde(rename = "indexed_product_count_large_delta")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub indexed_product_count_large_delta: Option<isize>,

    #[serde(rename = "item_additional_image_download_failure")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_additional_image_download_failure: Option<isize>,

    #[serde(rename = "optional_product_category_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_product_category_missing: Option<isize>,

    #[serde(rename = "optional_product_category_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_product_category_invalid: Option<isize>,

    #[serde(rename = "optional_condition_missing")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_condition_missing: Option<isize>,

    #[serde(rename = "optional_condition_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub optional_condition_invalid: Option<isize>,

    #[serde(rename = "ios_deep_link_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ios_deep_link_invalid: Option<isize>,

    #[serde(rename = "android_deep_link_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub android_deep_link_invalid: Option<isize>,

    #[serde(rename = "availability_normalized")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability_normalized: Option<isize>,

    #[serde(rename = "condition_normalized")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition_normalized: Option<isize>,

    #[serde(rename = "gender_normalized")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender_normalized: Option<isize>,

    #[serde(rename = "size_type_normalized")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type_normalized: Option<isize>,

    #[serde(rename = "age_group_normalized")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group_normalized: Option<isize>,

    #[serde(rename = "utm_source_auto_corrected")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub utm_source_auto_corrected: Option<isize>,

    #[serde(rename = "country_does_not_map_to_currency")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country_does_not_map_to_currency: Option<isize>,

    #[serde(rename = "min_ad_price_invalid")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_ad_price_invalid: Option<isize>,

}

impl CatalogsFeedValidationWarnings {
    pub fn new() -> CatalogsFeedValidationWarnings {
        CatalogsFeedValidationWarnings {
            title_length_too_long: None,
            description_length_too_long: None,
            gender_invalid: None,
            age_group_invalid: None,
            size_type_invalid: None,
            link_format_warning: None,
            duplicate_products: None,
            duplicate_links: None,
            sales_price_invalid: None,
            product_category_depth_warning: None,
            adwords_same_as_link: None,
            duplicate_headers: None,
            fetch_same_signature: None,
            adwords_format_warning: None,
            additional_image_link_warning: None,
            image_link_warning: None,
            shipping_invalid: None,
            tax_invalid: None,
            shipping_weight_invalid: None,
            expiration_date_invalid: None,
            availability_date_invalid: None,
            sale_date_invalid: None,
            weight_unit_invalid: None,
            is_bundle_invalid: None,
            updated_time_invalid: None,
            custom_label_length_too_long: None,
            product_type_length_too_long: None,
            too_many_additional_image_links: None,
            multipack_invalid: None,
            indexed_product_count_large_delta: None,
            item_additional_image_download_failure: None,
            optional_product_category_missing: None,
            optional_product_category_invalid: None,
            optional_condition_missing: None,
            optional_condition_invalid: None,
            ios_deep_link_invalid: None,
            android_deep_link_invalid: None,
            availability_normalized: None,
            condition_normalized: None,
            gender_normalized: None,
            size_type_normalized: None,
            age_group_normalized: None,
            utm_source_auto_corrected: None,
            country_does_not_map_to_currency: None,
            min_ad_price_invalid: None,
        }
    }
}

/// Converts the CatalogsFeedValidationWarnings value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedValidationWarnings {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref title_length_too_long) = self.title_length_too_long {
            params.push("title_length_too_long".to_string());
            params.push(title_length_too_long.to_string());
        }


        if let Some(ref description_length_too_long) = self.description_length_too_long {
            params.push("description_length_too_long".to_string());
            params.push(description_length_too_long.to_string());
        }


        if let Some(ref gender_invalid) = self.gender_invalid {
            params.push("gender_invalid".to_string());
            params.push(gender_invalid.to_string());
        }


        if let Some(ref age_group_invalid) = self.age_group_invalid {
            params.push("age_group_invalid".to_string());
            params.push(age_group_invalid.to_string());
        }


        if let Some(ref size_type_invalid) = self.size_type_invalid {
            params.push("size_type_invalid".to_string());
            params.push(size_type_invalid.to_string());
        }


        if let Some(ref link_format_warning) = self.link_format_warning {
            params.push("link_format_warning".to_string());
            params.push(link_format_warning.to_string());
        }


        if let Some(ref duplicate_products) = self.duplicate_products {
            params.push("duplicate_products".to_string());
            params.push(duplicate_products.to_string());
        }


        if let Some(ref duplicate_links) = self.duplicate_links {
            params.push("duplicate_links".to_string());
            params.push(duplicate_links.to_string());
        }


        if let Some(ref sales_price_invalid) = self.sales_price_invalid {
            params.push("sales_price_invalid".to_string());
            params.push(sales_price_invalid.to_string());
        }


        if let Some(ref product_category_depth_warning) = self.product_category_depth_warning {
            params.push("product_category_depth_warning".to_string());
            params.push(product_category_depth_warning.to_string());
        }


        if let Some(ref adwords_same_as_link) = self.adwords_same_as_link {
            params.push("adwords_same_as_link".to_string());
            params.push(adwords_same_as_link.to_string());
        }


        if let Some(ref duplicate_headers) = self.duplicate_headers {
            params.push("duplicate_headers".to_string());
            params.push(duplicate_headers.to_string());
        }


        if let Some(ref fetch_same_signature) = self.fetch_same_signature {
            params.push("fetch_same_signature".to_string());
            params.push(fetch_same_signature.to_string());
        }


        if let Some(ref adwords_format_warning) = self.adwords_format_warning {
            params.push("adwords_format_warning".to_string());
            params.push(adwords_format_warning.to_string());
        }


        if let Some(ref additional_image_link_warning) = self.additional_image_link_warning {
            params.push("additional_image_link_warning".to_string());
            params.push(additional_image_link_warning.to_string());
        }


        if let Some(ref image_link_warning) = self.image_link_warning {
            params.push("image_link_warning".to_string());
            params.push(image_link_warning.to_string());
        }


        if let Some(ref shipping_invalid) = self.shipping_invalid {
            params.push("shipping_invalid".to_string());
            params.push(shipping_invalid.to_string());
        }


        if let Some(ref tax_invalid) = self.tax_invalid {
            params.push("tax_invalid".to_string());
            params.push(tax_invalid.to_string());
        }


        if let Some(ref shipping_weight_invalid) = self.shipping_weight_invalid {
            params.push("shipping_weight_invalid".to_string());
            params.push(shipping_weight_invalid.to_string());
        }


        if let Some(ref expiration_date_invalid) = self.expiration_date_invalid {
            params.push("expiration_date_invalid".to_string());
            params.push(expiration_date_invalid.to_string());
        }


        if let Some(ref availability_date_invalid) = self.availability_date_invalid {
            params.push("availability_date_invalid".to_string());
            params.push(availability_date_invalid.to_string());
        }


        if let Some(ref sale_date_invalid) = self.sale_date_invalid {
            params.push("sale_date_invalid".to_string());
            params.push(sale_date_invalid.to_string());
        }


        if let Some(ref weight_unit_invalid) = self.weight_unit_invalid {
            params.push("weight_unit_invalid".to_string());
            params.push(weight_unit_invalid.to_string());
        }


        if let Some(ref is_bundle_invalid) = self.is_bundle_invalid {
            params.push("is_bundle_invalid".to_string());
            params.push(is_bundle_invalid.to_string());
        }


        if let Some(ref updated_time_invalid) = self.updated_time_invalid {
            params.push("updated_time_invalid".to_string());
            params.push(updated_time_invalid.to_string());
        }


        if let Some(ref custom_label_length_too_long) = self.custom_label_length_too_long {
            params.push("custom_label_length_too_long".to_string());
            params.push(custom_label_length_too_long.to_string());
        }


        if let Some(ref product_type_length_too_long) = self.product_type_length_too_long {
            params.push("product_type_length_too_long".to_string());
            params.push(product_type_length_too_long.to_string());
        }


        if let Some(ref too_many_additional_image_links) = self.too_many_additional_image_links {
            params.push("too_many_additional_image_links".to_string());
            params.push(too_many_additional_image_links.to_string());
        }


        if let Some(ref multipack_invalid) = self.multipack_invalid {
            params.push("multipack_invalid".to_string());
            params.push(multipack_invalid.to_string());
        }


        if let Some(ref indexed_product_count_large_delta) = self.indexed_product_count_large_delta {
            params.push("indexed_product_count_large_delta".to_string());
            params.push(indexed_product_count_large_delta.to_string());
        }


        if let Some(ref item_additional_image_download_failure) = self.item_additional_image_download_failure {
            params.push("item_additional_image_download_failure".to_string());
            params.push(item_additional_image_download_failure.to_string());
        }


        if let Some(ref optional_product_category_missing) = self.optional_product_category_missing {
            params.push("optional_product_category_missing".to_string());
            params.push(optional_product_category_missing.to_string());
        }


        if let Some(ref optional_product_category_invalid) = self.optional_product_category_invalid {
            params.push("optional_product_category_invalid".to_string());
            params.push(optional_product_category_invalid.to_string());
        }


        if let Some(ref optional_condition_missing) = self.optional_condition_missing {
            params.push("optional_condition_missing".to_string());
            params.push(optional_condition_missing.to_string());
        }


        if let Some(ref optional_condition_invalid) = self.optional_condition_invalid {
            params.push("optional_condition_invalid".to_string());
            params.push(optional_condition_invalid.to_string());
        }


        if let Some(ref ios_deep_link_invalid) = self.ios_deep_link_invalid {
            params.push("ios_deep_link_invalid".to_string());
            params.push(ios_deep_link_invalid.to_string());
        }


        if let Some(ref android_deep_link_invalid) = self.android_deep_link_invalid {
            params.push("android_deep_link_invalid".to_string());
            params.push(android_deep_link_invalid.to_string());
        }


        if let Some(ref availability_normalized) = self.availability_normalized {
            params.push("availability_normalized".to_string());
            params.push(availability_normalized.to_string());
        }


        if let Some(ref condition_normalized) = self.condition_normalized {
            params.push("condition_normalized".to_string());
            params.push(condition_normalized.to_string());
        }


        if let Some(ref gender_normalized) = self.gender_normalized {
            params.push("gender_normalized".to_string());
            params.push(gender_normalized.to_string());
        }


        if let Some(ref size_type_normalized) = self.size_type_normalized {
            params.push("size_type_normalized".to_string());
            params.push(size_type_normalized.to_string());
        }


        if let Some(ref age_group_normalized) = self.age_group_normalized {
            params.push("age_group_normalized".to_string());
            params.push(age_group_normalized.to_string());
        }


        if let Some(ref utm_source_auto_corrected) = self.utm_source_auto_corrected {
            params.push("utm_source_auto_corrected".to_string());
            params.push(utm_source_auto_corrected.to_string());
        }


        if let Some(ref country_does_not_map_to_currency) = self.country_does_not_map_to_currency {
            params.push("country_does_not_map_to_currency".to_string());
            params.push(country_does_not_map_to_currency.to_string());
        }


        if let Some(ref min_ad_price_invalid) = self.min_ad_price_invalid {
            params.push("min_ad_price_invalid".to_string());
            params.push(min_ad_price_invalid.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedValidationWarnings value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedValidationWarnings {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub title_length_too_long: Vec<isize>,
            pub description_length_too_long: Vec<isize>,
            pub gender_invalid: Vec<isize>,
            pub age_group_invalid: Vec<isize>,
            pub size_type_invalid: Vec<isize>,
            pub link_format_warning: Vec<isize>,
            pub duplicate_products: Vec<isize>,
            pub duplicate_links: Vec<isize>,
            pub sales_price_invalid: Vec<isize>,
            pub product_category_depth_warning: Vec<isize>,
            pub adwords_same_as_link: Vec<isize>,
            pub duplicate_headers: Vec<isize>,
            pub fetch_same_signature: Vec<isize>,
            pub adwords_format_warning: Vec<isize>,
            pub additional_image_link_warning: Vec<isize>,
            pub image_link_warning: Vec<isize>,
            pub shipping_invalid: Vec<isize>,
            pub tax_invalid: Vec<isize>,
            pub shipping_weight_invalid: Vec<isize>,
            pub expiration_date_invalid: Vec<isize>,
            pub availability_date_invalid: Vec<isize>,
            pub sale_date_invalid: Vec<isize>,
            pub weight_unit_invalid: Vec<isize>,
            pub is_bundle_invalid: Vec<isize>,
            pub updated_time_invalid: Vec<isize>,
            pub custom_label_length_too_long: Vec<isize>,
            pub product_type_length_too_long: Vec<isize>,
            pub too_many_additional_image_links: Vec<isize>,
            pub multipack_invalid: Vec<isize>,
            pub indexed_product_count_large_delta: Vec<isize>,
            pub item_additional_image_download_failure: Vec<isize>,
            pub optional_product_category_missing: Vec<isize>,
            pub optional_product_category_invalid: Vec<isize>,
            pub optional_condition_missing: Vec<isize>,
            pub optional_condition_invalid: Vec<isize>,
            pub ios_deep_link_invalid: Vec<isize>,
            pub android_deep_link_invalid: Vec<isize>,
            pub availability_normalized: Vec<isize>,
            pub condition_normalized: Vec<isize>,
            pub gender_normalized: Vec<isize>,
            pub size_type_normalized: Vec<isize>,
            pub age_group_normalized: Vec<isize>,
            pub utm_source_auto_corrected: Vec<isize>,
            pub country_does_not_map_to_currency: Vec<isize>,
            pub min_ad_price_invalid: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedValidationWarnings".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "title_length_too_long" => intermediate_rep.title_length_too_long.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description_length_too_long" => intermediate_rep.description_length_too_long.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "gender_invalid" => intermediate_rep.gender_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "age_group_invalid" => intermediate_rep.age_group_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "size_type_invalid" => intermediate_rep.size_type_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "link_format_warning" => intermediate_rep.link_format_warning.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "duplicate_products" => intermediate_rep.duplicate_products.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "duplicate_links" => intermediate_rep.duplicate_links.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "sales_price_invalid" => intermediate_rep.sales_price_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_category_depth_warning" => intermediate_rep.product_category_depth_warning.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "adwords_same_as_link" => intermediate_rep.adwords_same_as_link.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "duplicate_headers" => intermediate_rep.duplicate_headers.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "fetch_same_signature" => intermediate_rep.fetch_same_signature.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "adwords_format_warning" => intermediate_rep.adwords_format_warning.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "additional_image_link_warning" => intermediate_rep.additional_image_link_warning.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "image_link_warning" => intermediate_rep.image_link_warning.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shipping_invalid" => intermediate_rep.shipping_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "tax_invalid" => intermediate_rep.tax_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shipping_weight_invalid" => intermediate_rep.shipping_weight_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "expiration_date_invalid" => intermediate_rep.expiration_date_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "availability_date_invalid" => intermediate_rep.availability_date_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "sale_date_invalid" => intermediate_rep.sale_date_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "weight_unit_invalid" => intermediate_rep.weight_unit_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "is_bundle_invalid" => intermediate_rep.is_bundle_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_time_invalid" => intermediate_rep.updated_time_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "custom_label_length_too_long" => intermediate_rep.custom_label_length_too_long.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_type_length_too_long" => intermediate_rep.product_type_length_too_long.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "too_many_additional_image_links" => intermediate_rep.too_many_additional_image_links.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "multipack_invalid" => intermediate_rep.multipack_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "indexed_product_count_large_delta" => intermediate_rep.indexed_product_count_large_delta.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "item_additional_image_download_failure" => intermediate_rep.item_additional_image_download_failure.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "optional_product_category_missing" => intermediate_rep.optional_product_category_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "optional_product_category_invalid" => intermediate_rep.optional_product_category_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "optional_condition_missing" => intermediate_rep.optional_condition_missing.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "optional_condition_invalid" => intermediate_rep.optional_condition_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ios_deep_link_invalid" => intermediate_rep.ios_deep_link_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "android_deep_link_invalid" => intermediate_rep.android_deep_link_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "availability_normalized" => intermediate_rep.availability_normalized.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "condition_normalized" => intermediate_rep.condition_normalized.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "gender_normalized" => intermediate_rep.gender_normalized.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "size_type_normalized" => intermediate_rep.size_type_normalized.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "age_group_normalized" => intermediate_rep.age_group_normalized.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "utm_source_auto_corrected" => intermediate_rep.utm_source_auto_corrected.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "country_does_not_map_to_currency" => intermediate_rep.country_does_not_map_to_currency.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "min_ad_price_invalid" => intermediate_rep.min_ad_price_invalid.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedValidationWarnings".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedValidationWarnings {
            title_length_too_long: intermediate_rep.title_length_too_long.into_iter().next(),
            description_length_too_long: intermediate_rep.description_length_too_long.into_iter().next(),
            gender_invalid: intermediate_rep.gender_invalid.into_iter().next(),
            age_group_invalid: intermediate_rep.age_group_invalid.into_iter().next(),
            size_type_invalid: intermediate_rep.size_type_invalid.into_iter().next(),
            link_format_warning: intermediate_rep.link_format_warning.into_iter().next(),
            duplicate_products: intermediate_rep.duplicate_products.into_iter().next(),
            duplicate_links: intermediate_rep.duplicate_links.into_iter().next(),
            sales_price_invalid: intermediate_rep.sales_price_invalid.into_iter().next(),
            product_category_depth_warning: intermediate_rep.product_category_depth_warning.into_iter().next(),
            adwords_same_as_link: intermediate_rep.adwords_same_as_link.into_iter().next(),
            duplicate_headers: intermediate_rep.duplicate_headers.into_iter().next(),
            fetch_same_signature: intermediate_rep.fetch_same_signature.into_iter().next(),
            adwords_format_warning: intermediate_rep.adwords_format_warning.into_iter().next(),
            additional_image_link_warning: intermediate_rep.additional_image_link_warning.into_iter().next(),
            image_link_warning: intermediate_rep.image_link_warning.into_iter().next(),
            shipping_invalid: intermediate_rep.shipping_invalid.into_iter().next(),
            tax_invalid: intermediate_rep.tax_invalid.into_iter().next(),
            shipping_weight_invalid: intermediate_rep.shipping_weight_invalid.into_iter().next(),
            expiration_date_invalid: intermediate_rep.expiration_date_invalid.into_iter().next(),
            availability_date_invalid: intermediate_rep.availability_date_invalid.into_iter().next(),
            sale_date_invalid: intermediate_rep.sale_date_invalid.into_iter().next(),
            weight_unit_invalid: intermediate_rep.weight_unit_invalid.into_iter().next(),
            is_bundle_invalid: intermediate_rep.is_bundle_invalid.into_iter().next(),
            updated_time_invalid: intermediate_rep.updated_time_invalid.into_iter().next(),
            custom_label_length_too_long: intermediate_rep.custom_label_length_too_long.into_iter().next(),
            product_type_length_too_long: intermediate_rep.product_type_length_too_long.into_iter().next(),
            too_many_additional_image_links: intermediate_rep.too_many_additional_image_links.into_iter().next(),
            multipack_invalid: intermediate_rep.multipack_invalid.into_iter().next(),
            indexed_product_count_large_delta: intermediate_rep.indexed_product_count_large_delta.into_iter().next(),
            item_additional_image_download_failure: intermediate_rep.item_additional_image_download_failure.into_iter().next(),
            optional_product_category_missing: intermediate_rep.optional_product_category_missing.into_iter().next(),
            optional_product_category_invalid: intermediate_rep.optional_product_category_invalid.into_iter().next(),
            optional_condition_missing: intermediate_rep.optional_condition_missing.into_iter().next(),
            optional_condition_invalid: intermediate_rep.optional_condition_invalid.into_iter().next(),
            ios_deep_link_invalid: intermediate_rep.ios_deep_link_invalid.into_iter().next(),
            android_deep_link_invalid: intermediate_rep.android_deep_link_invalid.into_iter().next(),
            availability_normalized: intermediate_rep.availability_normalized.into_iter().next(),
            condition_normalized: intermediate_rep.condition_normalized.into_iter().next(),
            gender_normalized: intermediate_rep.gender_normalized.into_iter().next(),
            size_type_normalized: intermediate_rep.size_type_normalized.into_iter().next(),
            age_group_normalized: intermediate_rep.age_group_normalized.into_iter().next(),
            utm_source_auto_corrected: intermediate_rep.utm_source_auto_corrected.into_iter().next(),
            country_does_not_map_to_currency: intermediate_rep.country_does_not_map_to_currency.into_iter().next(),
            min_ad_price_invalid: intermediate_rep.min_ad_price_invalid.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedValidationWarnings> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedValidationWarnings>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedValidationWarnings>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedValidationWarnings - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedValidationWarnings> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedValidationWarnings as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedValidationWarnings - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Request object for creating a feed. Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedsCreateRequest {
    #[serde(rename = "default_country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_country: Option<models::Country>,

    #[serde(rename = "default_availability")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_availability: Option<swagger::Nullable<models::ProductAvailabilityType>>,

    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<swagger::Nullable<models::NullableCurrency>>,

    /// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    /// The locale used within a feed for product descriptions.
    #[serde(rename = "default_locale")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_locale: Option<String>,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<swagger::Nullable<models::CatalogsFeedCredentials>>,

    /// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<swagger::Nullable<models::CatalogsFeedProcessingSchedule>>,

}

impl CatalogsFeedsCreateRequest {
    pub fn new(name: String, format: models::CatalogsFormat, location: String, ) -> CatalogsFeedsCreateRequest {
        CatalogsFeedsCreateRequest {
            default_country: None,
            default_availability: None,
            default_currency: None,
            name: name,
            format: format,
            default_locale: None,
            credentials: None,
            location: location,
            preferred_processing_schedule: None,
        }
    }
}

/// Converts the CatalogsFeedsCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedsCreateRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping default_country in query parameter serialization

        // Skipping default_availability in query parameter serialization

        // Skipping default_currency in query parameter serialization


        params.push("name".to_string());
        params.push(self.name.to_string());

        // Skipping format in query parameter serialization


        if let Some(ref default_locale) = self.default_locale {
            params.push("default_locale".to_string());
            params.push(default_locale.to_string());
        }

        // Skipping credentials in query parameter serialization


        params.push("location".to_string());
        params.push(self.location.to_string());

        // Skipping preferred_processing_schedule in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedsCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedsCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub default_country: Vec<models::Country>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub default_locale: Vec<String>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedsCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "default_country" => intermediate_rep.default_country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_locale" => intermediate_rep.default_locale.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsCreateRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedsCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedsCreateRequest {
            default_country: intermediate_rep.default_country.into_iter().next(),
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or("name missing in CatalogsFeedsCreateRequest".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or("format missing in CatalogsFeedsCreateRequest".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next(),
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or("location missing in CatalogsFeedsCreateRequest".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsFeedsCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedsCreateRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedsCreateRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedsCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedsCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedsCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedsCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedsCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Request object for updating a feed.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsFeedsUpdateRequest {
    #[serde(rename = "default_availability")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_availability: Option<swagger::Nullable<models::ProductAvailabilityType>>,

    #[serde(rename = "default_currency")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default_currency: Option<swagger::Nullable<models::NullableCurrency>>,

    /// A human-friendly name associated to a given feed.
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "format")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub format: Option<models::CatalogsFormat>,

    #[serde(rename = "credentials")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub credentials: Option<swagger::Nullable<models::CatalogsFeedCredentials>>,

    /// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub location: Option<String>,

    #[serde(rename = "preferred_processing_schedule")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub preferred_processing_schedule: Option<swagger::Nullable<models::CatalogsFeedProcessingSchedule>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsStatus>,

}

impl CatalogsFeedsUpdateRequest {
    pub fn new() -> CatalogsFeedsUpdateRequest {
        CatalogsFeedsUpdateRequest {
            default_availability: None,
            default_currency: None,
            name: None,
            format: None,
            credentials: None,
            location: None,
            preferred_processing_schedule: None,
            status: None,
        }
    }
}

/// Converts the CatalogsFeedsUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsFeedsUpdateRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping default_availability in query parameter serialization

        // Skipping default_currency in query parameter serialization


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }

        // Skipping format in query parameter serialization

        // Skipping credentials in query parameter serialization


        if let Some(ref location) = self.location {
            params.push("location".to_string());
            params.push(location.to_string());
        }

        // Skipping preferred_processing_schedule in query parameter serialization

        // Skipping status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsFeedsUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsFeedsUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub default_availability: Vec<models::ProductAvailabilityType>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsFeedsUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsFeedsUpdateRequest".to_string()),
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsFeedsUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsFeedsUpdateRequest {
            default_availability: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            format: intermediate_rep.format.into_iter().next(),
            credentials: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            location: intermediate_rep.location.into_iter().next(),
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in CatalogsFeedsUpdateRequest".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsFeedsUpdateRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsFeedsUpdateRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsFeedsUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsFeedsUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsFeedsUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsFeedsUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsFeedsUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The file format of a feed.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsFormat {
    #[serde(rename = "TSV")]
    TSV,
    #[serde(rename = "CSV")]
    CSV,
    #[serde(rename = "XML")]
    XML,
}

impl std::fmt::Display for CatalogsFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsFormat::TSV => write!(f, "{}", "TSV"),
            CatalogsFormat::CSV => write!(f, "{}", "CSV"),
            CatalogsFormat::XML => write!(f, "{}", "XML"),
        }
    }
}

impl std::str::FromStr for CatalogsFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TSV" => std::result::Result::Ok(CatalogsFormat::TSV),
            "CSV" => std::result::Result::Ok(CatalogsFormat::CSV),
            "XML" => std::result::Result::Ok(CatalogsFormat::XML),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Response object of catalogs items
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItems {
    /// Array with catalogs items
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ItemBatchRecord>>,

}

impl CatalogsItems {
    pub fn new() -> CatalogsItems {
        CatalogsItems {
            items: None,
        }
    }
}

/// Converts the CatalogsItems value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsItems {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping items in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItems value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItems {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub items: Vec<Vec<models::ItemBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItems".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItems".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItems".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItems {
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItems> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItems>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItems>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItems - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsItems> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItems as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItems - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Object describing the catalogs items batch
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsBatch {
    /// Array with the catalogs items processing records part of the catalogs items batch
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ItemProcessingRecord>>,

    /// Id of the catalogs items batch
    #[serde(rename = "batch_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub batch_id: Option<String>,

    /// Time of the batch creation: YYYY-MM-DD'T'hh:mm:ssTZD
    #[serde(rename = "created_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_time: Option<chrono::DateTime::<chrono::Utc>>,

    /// Time of the batch completion: YYYY-MM-DD'T'hh:mm:ssTZD
    #[serde(rename = "completed_time")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub completed_time: Option<swagger::Nullable<chrono::DateTime::<chrono::Utc>>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::BatchOperationStatus>,

}

impl CatalogsItemsBatch {
    pub fn new() -> CatalogsItemsBatch {
        CatalogsItemsBatch {
            items: None,
            batch_id: None,
            created_time: None,
            completed_time: None,
            status: None,
        }
    }
}

/// Converts the CatalogsItemsBatch value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsItemsBatch {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping items in query parameter serialization


        if let Some(ref batch_id) = self.batch_id {
            params.push("batch_id".to_string());
            params.push(batch_id.to_string());
        }

        // Skipping created_time in query parameter serialization

        // Skipping completed_time in query parameter serialization

        // Skipping status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsBatch value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsBatch {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub items: Vec<Vec<models::ItemProcessingRecord>>,
            pub batch_id: Vec<String>,
            pub created_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub completed_time: Vec<chrono::DateTime::<chrono::Utc>>,
            pub status: Vec<models::BatchOperationStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsBatch".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsBatch".to_string()),
                    "batch_id" => intermediate_rep.batch_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_time" => intermediate_rep.created_time.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "completed_time" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsItemsBatch".to_string()),
                    "status" => intermediate_rep.status.push(<models::BatchOperationStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsBatch".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsBatch {
            items: intermediate_rep.items.into_iter().next(),
            batch_id: intermediate_rep.batch_id.into_iter().next(),
            created_time: intermediate_rep.created_time.into_iter().next(),
            completed_time: std::result::Result::Err("Nullable types not supported in CatalogsItemsBatch".to_string())?,
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsBatch> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsBatch>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsBatch>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsBatch - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsItemsBatch> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsBatch as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsBatch - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Request object of catalogs items batch
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsItemsBatchRequest {
    #[serde(rename = "country")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub country: Option<models::Country>,

    #[serde(rename = "language")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub language: Option<models::Language>,

    #[serde(rename = "operation")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub operation: Option<models::BatchOperation>,

    /// Array with catalogs items
    #[serde(rename = "items")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub items: Option<Vec<models::ItemBatchRecord>>,

}

impl CatalogsItemsBatchRequest {
    pub fn new() -> CatalogsItemsBatchRequest {
        CatalogsItemsBatchRequest {
            country: None,
            language: None,
            operation: None,
            items: None,
        }
    }
}

/// Converts the CatalogsItemsBatchRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsItemsBatchRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping country in query parameter serialization

        // Skipping language in query parameter serialization

        // Skipping operation in query parameter serialization

        // Skipping items in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsItemsBatchRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsItemsBatchRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub country: Vec<models::Country>,
            pub language: Vec<models::Language>,
            pub operation: Vec<models::BatchOperation>,
            pub items: Vec<Vec<models::ItemBatchRecord>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsItemsBatchRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "country" => intermediate_rep.country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "language" => intermediate_rep.language.push(<models::Language as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "operation" => intermediate_rep.operation.push(<models::BatchOperation as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsItemsBatchRequest".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsItemsBatchRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsItemsBatchRequest {
            country: intermediate_rep.country.into_iter().next(),
            language: intermediate_rep.language.into_iter().next(),
            operation: intermediate_rep.operation.into_iter().next(),
            items: intermediate_rep.items.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsItemsBatchRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsItemsBatchRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsItemsBatchRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsItemsBatchRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsItemsBatchRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsItemsBatchRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsItemsBatchRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// catalog product group entity
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroup {
    /// ID of the catalog product group.
    #[serde(rename = "id")]
    pub id: String,

    /// Name of catalog product group
    #[serde(rename = "name")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFilters,

    #[serde(rename = "type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub type_: Option<models::CatalogsProductGroupType>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::CatalogsProductGroupStatus>,

    /// id of the catalogs feed belonging to this catalog product group
    #[serde(rename = "feed_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub feed_id: Option<String>,

    /// Unix timestamp in seconds of when catalog product group was created.
    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<isize>,

    /// Unix timestamp in seconds of last time catalog product group was updated.
    #[serde(rename = "updated_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub updated_at: Option<isize>,

}

impl CatalogsProductGroup {
    pub fn new(id: String, filters: models::CatalogsProductGroupFilters, ) -> CatalogsProductGroup {
        CatalogsProductGroup {
            id: id,
            name: None,
            description: None,
            filters: filters,
            type_: None,
            status: None,
            feed_id: None,
            created_at: None,
            updated_at: None,
        }
    }
}

/// Converts the CatalogsProductGroup value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroup {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("id".to_string());
        params.push(self.id.to_string());


        if let Some(ref name) = self.name {
            params.push("name".to_string());
            params.push(name.to_string());
        }


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping filters in query parameter serialization

        // Skipping type in query parameter serialization

        // Skipping status in query parameter serialization


        if let Some(ref feed_id) = self.feed_id {
            params.push("feed_id".to_string());
            params.push(feed_id.to_string());
        }


        if let Some(ref created_at) = self.created_at {
            params.push("created_at".to_string());
            params.push(created_at.to_string());
        }


        if let Some(ref updated_at) = self.updated_at {
            params.push("updated_at".to_string());
            params.push(updated_at.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroup value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroup {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsProductGroupFilters>,
            pub type_: Vec<models::CatalogsProductGroupType>,
            pub status: Vec<models::CatalogsProductGroupStatus>,
            pub feed_id: Vec<String>,
            pub created_at: Vec<isize>,
            pub updated_at: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroup".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroup".to_string()),
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "type" => intermediate_rep.type_.push(<models::CatalogsProductGroupType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<models::CatalogsProductGroupStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "feed_id" => intermediate_rep.feed_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_at" => intermediate_rep.created_at.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "updated_at" => intermediate_rep.updated_at.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroup".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroup {
            id: intermediate_rep.id.into_iter().next().ok_or("id missing in CatalogsProductGroup".to_string())?,
            name: intermediate_rep.name.into_iter().next(),
            description: std::result::Result::Err("Nullable types not supported in CatalogsProductGroup".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or("filters missing in CatalogsProductGroup".to_string())?,
            type_: intermediate_rep.type_.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
            feed_id: intermediate_rep.feed_id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            updated_at: intermediate_rep.updated_at.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroup> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroup>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroup>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroup - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroup> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroup as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroup - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Request object for creating a product group.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupCreateRequest {
    /// Catalog Feed id pertaining to the catalog product group.
    #[serde(rename = "feed_id")]
    pub feed_id: String,

    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFilters,

}

impl CatalogsProductGroupCreateRequest {
    pub fn new(feed_id: String, name: String, filters: models::CatalogsProductGroupFilters, ) -> CatalogsProductGroupCreateRequest {
        CatalogsProductGroupCreateRequest {
            feed_id: feed_id,
            name: name,
            description: None,
            filters: filters,
        }
    }
}

/// Converts the CatalogsProductGroupCreateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupCreateRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("feed_id".to_string());
        params.push(self.feed_id.to_string());


        params.push("name".to_string());
        params.push(self.name.to_string());


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping filters in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupCreateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupCreateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub feed_id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsProductGroupFilters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupCreateRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "feed_id" => intermediate_rep.feed_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroupCreateRequest".to_string()),
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupCreateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupCreateRequest {
            feed_id: intermediate_rep.feed_id.into_iter().next().ok_or("feed_id missing in CatalogsProductGroupCreateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or("name missing in CatalogsProductGroupCreateRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CatalogsProductGroupCreateRequest".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or("filters missing in CatalogsProductGroupCreateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupCreateRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupCreateRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupCreateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupCreateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupCreateRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupCreateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupCreateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupCurrencyCriteria {
    #[serde(rename = "values")]
    pub values: models::NonNullableCatalogsCurrency,

    #[serde(rename = "negated")]
    pub negated: bool,

}

impl CatalogsProductGroupCurrencyCriteria {
    pub fn new(values: models::NonNullableCatalogsCurrency, negated: bool, ) -> CatalogsProductGroupCurrencyCriteria {
        CatalogsProductGroupCurrencyCriteria {
            values: values,
            negated: negated,
        }
    }
}

/// Converts the CatalogsProductGroupCurrencyCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupCurrencyCriteria {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping values in query parameter serialization


        params.push("negated".to_string());
        params.push(self.negated.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupCurrencyCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupCurrencyCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub values: Vec<models::NonNullableCatalogsCurrency>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupCurrencyCriteria".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "values" => intermediate_rep.values.push(<models::NonNullableCatalogsCurrency as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupCurrencyCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupCurrencyCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or("values missing in CatalogsProductGroupCurrencyCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next().ok_or("negated missing in CatalogsProductGroupCurrencyCriteria".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupCurrencyCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupCurrencyCriteria> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupCurrencyCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFilterKeys {
    #[serde(rename = "MIN_PRICE")]
    pub min_price: models::CatalogsProductGroupPricingCriteria,

    #[serde(rename = "MAX_PRICE")]
    pub max_price: models::CatalogsProductGroupPricingCriteria,

    #[serde(rename = "CURRENCY")]
    pub currency: models::CatalogsProductGroupCurrencyCriteria,

    #[serde(rename = "ITEM_ID")]
    pub item_id: models::CatalogsProductGroupCurrencyCriteria,

    #[serde(rename = "AVAILABILITY")]
    pub availability: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "BRAND")]
    pub brand: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "CONDITION")]
    pub condition: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "CUSTOM_LABEL_0")]
    pub custom_label_0: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "CUSTOM_LABEL_1")]
    pub custom_label_1: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "CUSTOM_LABEL_2")]
    pub custom_label_2: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "CUSTOM_LABEL_3")]
    pub custom_label_3: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "CUSTOM_LABEL_4")]
    pub custom_label_4: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "ITEM_GROUP_ID")]
    pub item_group_id: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "GENDER")]
    pub gender: models::CatalogsProductGroupMultipleStringCriteria,

    #[serde(rename = "PRODUCT_TYPE_4")]
    pub product_type_4: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "PRODUCT_TYPE_3")]
    pub product_type_3: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "PRODUCT_TYPE_2")]
    pub product_type_2: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "PRODUCT_TYPE_1")]
    pub product_type_1: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "PRODUCT_TYPE_0")]
    pub product_type_0: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_6")]
    pub google_product_category_6: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_5")]
    pub google_product_category_5: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_4")]
    pub google_product_category_4: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_3")]
    pub google_product_category_3: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_2")]
    pub google_product_category_2: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_1")]
    pub google_product_category_1: models::CatalogsProductGroupMultipleStringListCriteria,

    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_0")]
    pub google_product_category_0: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl CatalogsProductGroupFilterKeys {
    pub fn new(min_price: models::CatalogsProductGroupPricingCriteria, max_price: models::CatalogsProductGroupPricingCriteria, currency: models::CatalogsProductGroupCurrencyCriteria, item_id: models::CatalogsProductGroupCurrencyCriteria, availability: models::CatalogsProductGroupMultipleStringCriteria, brand: models::CatalogsProductGroupMultipleStringCriteria, condition: models::CatalogsProductGroupMultipleStringCriteria, custom_label_0: models::CatalogsProductGroupMultipleStringCriteria, custom_label_1: models::CatalogsProductGroupMultipleStringCriteria, custom_label_2: models::CatalogsProductGroupMultipleStringCriteria, custom_label_3: models::CatalogsProductGroupMultipleStringCriteria, custom_label_4: models::CatalogsProductGroupMultipleStringCriteria, item_group_id: models::CatalogsProductGroupMultipleStringCriteria, gender: models::CatalogsProductGroupMultipleStringCriteria, product_type_4: models::CatalogsProductGroupMultipleStringListCriteria, product_type_3: models::CatalogsProductGroupMultipleStringListCriteria, product_type_2: models::CatalogsProductGroupMultipleStringListCriteria, product_type_1: models::CatalogsProductGroupMultipleStringListCriteria, product_type_0: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_6: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_5: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_4: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_3: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_2: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_1: models::CatalogsProductGroupMultipleStringListCriteria, google_product_category_0: models::CatalogsProductGroupMultipleStringListCriteria, ) -> CatalogsProductGroupFilterKeys {
        CatalogsProductGroupFilterKeys {
            min_price: min_price,
            max_price: max_price,
            currency: currency,
            item_id: item_id,
            availability: availability,
            brand: brand,
            condition: condition,
            custom_label_0: custom_label_0,
            custom_label_1: custom_label_1,
            custom_label_2: custom_label_2,
            custom_label_3: custom_label_3,
            custom_label_4: custom_label_4,
            item_group_id: item_group_id,
            gender: gender,
            product_type_4: product_type_4,
            product_type_3: product_type_3,
            product_type_2: product_type_2,
            product_type_1: product_type_1,
            product_type_0: product_type_0,
            google_product_category_6: google_product_category_6,
            google_product_category_5: google_product_category_5,
            google_product_category_4: google_product_category_4,
            google_product_category_3: google_product_category_3,
            google_product_category_2: google_product_category_2,
            google_product_category_1: google_product_category_1,
            google_product_category_0: google_product_category_0,
        }
    }
}

/// Converts the CatalogsProductGroupFilterKeys value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupFilterKeys {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping MIN_PRICE in query parameter serialization

        // Skipping MAX_PRICE in query parameter serialization

        // Skipping CURRENCY in query parameter serialization

        // Skipping ITEM_ID in query parameter serialization

        // Skipping AVAILABILITY in query parameter serialization

        // Skipping BRAND in query parameter serialization

        // Skipping CONDITION in query parameter serialization

        // Skipping CUSTOM_LABEL_0 in query parameter serialization

        // Skipping CUSTOM_LABEL_1 in query parameter serialization

        // Skipping CUSTOM_LABEL_2 in query parameter serialization

        // Skipping CUSTOM_LABEL_3 in query parameter serialization

        // Skipping CUSTOM_LABEL_4 in query parameter serialization

        // Skipping ITEM_GROUP_ID in query parameter serialization

        // Skipping GENDER in query parameter serialization

        // Skipping PRODUCT_TYPE_4 in query parameter serialization

        // Skipping PRODUCT_TYPE_3 in query parameter serialization

        // Skipping PRODUCT_TYPE_2 in query parameter serialization

        // Skipping PRODUCT_TYPE_1 in query parameter serialization

        // Skipping PRODUCT_TYPE_0 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_6 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_5 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_4 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_3 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_2 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_1 in query parameter serialization

        // Skipping GOOGLE_PRODUCT_CATEGORY_0 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFilterKeys value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFilterKeys {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub min_price: Vec<models::CatalogsProductGroupPricingCriteria>,
            pub max_price: Vec<models::CatalogsProductGroupPricingCriteria>,
            pub currency: Vec<models::CatalogsProductGroupCurrencyCriteria>,
            pub item_id: Vec<models::CatalogsProductGroupCurrencyCriteria>,
            pub availability: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub brand: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub condition: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub custom_label_0: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub custom_label_1: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub custom_label_2: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub custom_label_3: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub custom_label_4: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub item_group_id: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub gender: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
            pub product_type_4: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub product_type_3: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub product_type_2: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub product_type_1: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub product_type_0: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_6: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_5: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_4: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_3: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_2: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_1: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
            pub google_product_category_0: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFilterKeys".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "MIN_PRICE" => intermediate_rep.min_price.push(<models::CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "MAX_PRICE" => intermediate_rep.max_price.push(<models::CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CURRENCY" => intermediate_rep.currency.push(<models::CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ITEM_ID" => intermediate_rep.item_id.push(<models::CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "AVAILABILITY" => intermediate_rep.availability.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "BRAND" => intermediate_rep.brand.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CONDITION" => intermediate_rep.condition.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CUSTOM_LABEL_0" => intermediate_rep.custom_label_0.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CUSTOM_LABEL_1" => intermediate_rep.custom_label_1.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CUSTOM_LABEL_2" => intermediate_rep.custom_label_2.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CUSTOM_LABEL_3" => intermediate_rep.custom_label_3.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "CUSTOM_LABEL_4" => intermediate_rep.custom_label_4.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "ITEM_GROUP_ID" => intermediate_rep.item_group_id.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GENDER" => intermediate_rep.gender.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "PRODUCT_TYPE_4" => intermediate_rep.product_type_4.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "PRODUCT_TYPE_3" => intermediate_rep.product_type_3.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "PRODUCT_TYPE_2" => intermediate_rep.product_type_2.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "PRODUCT_TYPE_1" => intermediate_rep.product_type_1.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "PRODUCT_TYPE_0" => intermediate_rep.product_type_0.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_6" => intermediate_rep.google_product_category_6.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_5" => intermediate_rep.google_product_category_5.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_4" => intermediate_rep.google_product_category_4.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_3" => intermediate_rep.google_product_category_3.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_2" => intermediate_rep.google_product_category_2.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_1" => intermediate_rep.google_product_category_1.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "GOOGLE_PRODUCT_CATEGORY_0" => intermediate_rep.google_product_category_0.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFilterKeys".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFilterKeys {
            min_price: intermediate_rep.min_price.into_iter().next().ok_or("MIN_PRICE missing in CatalogsProductGroupFilterKeys".to_string())?,
            max_price: intermediate_rep.max_price.into_iter().next().ok_or("MAX_PRICE missing in CatalogsProductGroupFilterKeys".to_string())?,
            currency: intermediate_rep.currency.into_iter().next().ok_or("CURRENCY missing in CatalogsProductGroupFilterKeys".to_string())?,
            item_id: intermediate_rep.item_id.into_iter().next().ok_or("ITEM_ID missing in CatalogsProductGroupFilterKeys".to_string())?,
            availability: intermediate_rep.availability.into_iter().next().ok_or("AVAILABILITY missing in CatalogsProductGroupFilterKeys".to_string())?,
            brand: intermediate_rep.brand.into_iter().next().ok_or("BRAND missing in CatalogsProductGroupFilterKeys".to_string())?,
            condition: intermediate_rep.condition.into_iter().next().ok_or("CONDITION missing in CatalogsProductGroupFilterKeys".to_string())?,
            custom_label_0: intermediate_rep.custom_label_0.into_iter().next().ok_or("CUSTOM_LABEL_0 missing in CatalogsProductGroupFilterKeys".to_string())?,
            custom_label_1: intermediate_rep.custom_label_1.into_iter().next().ok_or("CUSTOM_LABEL_1 missing in CatalogsProductGroupFilterKeys".to_string())?,
            custom_label_2: intermediate_rep.custom_label_2.into_iter().next().ok_or("CUSTOM_LABEL_2 missing in CatalogsProductGroupFilterKeys".to_string())?,
            custom_label_3: intermediate_rep.custom_label_3.into_iter().next().ok_or("CUSTOM_LABEL_3 missing in CatalogsProductGroupFilterKeys".to_string())?,
            custom_label_4: intermediate_rep.custom_label_4.into_iter().next().ok_or("CUSTOM_LABEL_4 missing in CatalogsProductGroupFilterKeys".to_string())?,
            item_group_id: intermediate_rep.item_group_id.into_iter().next().ok_or("ITEM_GROUP_ID missing in CatalogsProductGroupFilterKeys".to_string())?,
            gender: intermediate_rep.gender.into_iter().next().ok_or("GENDER missing in CatalogsProductGroupFilterKeys".to_string())?,
            product_type_4: intermediate_rep.product_type_4.into_iter().next().ok_or("PRODUCT_TYPE_4 missing in CatalogsProductGroupFilterKeys".to_string())?,
            product_type_3: intermediate_rep.product_type_3.into_iter().next().ok_or("PRODUCT_TYPE_3 missing in CatalogsProductGroupFilterKeys".to_string())?,
            product_type_2: intermediate_rep.product_type_2.into_iter().next().ok_or("PRODUCT_TYPE_2 missing in CatalogsProductGroupFilterKeys".to_string())?,
            product_type_1: intermediate_rep.product_type_1.into_iter().next().ok_or("PRODUCT_TYPE_1 missing in CatalogsProductGroupFilterKeys".to_string())?,
            product_type_0: intermediate_rep.product_type_0.into_iter().next().ok_or("PRODUCT_TYPE_0 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_6: intermediate_rep.google_product_category_6.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_6 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_5: intermediate_rep.google_product_category_5.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_5 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_4: intermediate_rep.google_product_category_4.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_4 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_3: intermediate_rep.google_product_category_3.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_3 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_2: intermediate_rep.google_product_category_2.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_2 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_1: intermediate_rep.google_product_category_1.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_1 missing in CatalogsProductGroupFilterKeys".to_string())?,
            google_product_category_0: intermediate_rep.google_product_category_0.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_0 missing in CatalogsProductGroupFilterKeys".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFilterKeys> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFilterKeys>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFilterKeys>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFilterKeys - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFilterKeys> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFilterKeys as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFilterKeys - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Object holding a group of filters for a catalog product group
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFilters {
    #[serde(rename = "any_of")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub any_of: Option<Vec<models::CatalogsProductGroupFilterKeys>>,

    #[serde(rename = "all_of")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub all_of: Option<Vec<models::CatalogsProductGroupFilterKeys>>,

}

impl CatalogsProductGroupFilters {
    pub fn new() -> CatalogsProductGroupFilters {
        CatalogsProductGroupFilters {
            any_of: None,
            all_of: None,
        }
    }
}

/// Converts the CatalogsProductGroupFilters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupFilters {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping any_of in query parameter serialization

        // Skipping all_of in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFilters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFilters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub any_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
            pub all_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFilters".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "any_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFilters".to_string()),
                    "all_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFilters".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFilters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFilters {
            any_of: intermediate_rep.any_of.into_iter().next(),
            all_of: intermediate_rep.all_of.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFilters> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFilters>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFilters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFilters - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFilters> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFilters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFilters - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFiltersAllOf {
    #[serde(rename = "all_of")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub all_of: Option<Vec<models::CatalogsProductGroupFilterKeys>>,

}

impl CatalogsProductGroupFiltersAllOf {
    pub fn new() -> CatalogsProductGroupFiltersAllOf {
        CatalogsProductGroupFiltersAllOf {
            all_of: None,
        }
    }
}

/// Converts the CatalogsProductGroupFiltersAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupFiltersAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping all_of in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub all_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFiltersAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "all_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFiltersAllOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFiltersAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFiltersAllOf {
            all_of: intermediate_rep.all_of.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFiltersAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFiltersAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFiltersAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFiltersAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupFiltersAnyOf {
    #[serde(rename = "any_of")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub any_of: Option<Vec<models::CatalogsProductGroupFilterKeys>>,

}

impl CatalogsProductGroupFiltersAnyOf {
    pub fn new() -> CatalogsProductGroupFiltersAnyOf {
        CatalogsProductGroupFiltersAnyOf {
            any_of: None,
        }
    }
}

/// Converts the CatalogsProductGroupFiltersAnyOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupFiltersAnyOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping any_of in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupFiltersAnyOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupFiltersAnyOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub any_of: Vec<Vec<models::CatalogsProductGroupFilterKeys>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupFiltersAnyOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "any_of" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupFiltersAnyOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupFiltersAnyOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupFiltersAnyOf {
            any_of: intermediate_rep.any_of.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupFiltersAnyOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupFiltersAnyOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupFiltersAnyOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupFiltersAnyOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupMultipleStringCriteria {
    #[serde(rename = "values")]
    pub values: Vec<String>,

    #[serde(rename = "negated")]
    pub negated: bool,

}

impl CatalogsProductGroupMultipleStringCriteria {
    pub fn new(values: Vec<String>, negated: bool, ) -> CatalogsProductGroupMultipleStringCriteria {
        CatalogsProductGroupMultipleStringCriteria {
            values: values,
            negated: negated,
        }
    }
}

/// Converts the CatalogsProductGroupMultipleStringCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupMultipleStringCriteria {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("values".to_string());
        params.push(self.values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());


        params.push("negated".to_string());
        params.push(self.negated.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupMultipleStringCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupMultipleStringCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub values: Vec<Vec<String>>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupMultipleStringCriteria".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupMultipleStringCriteria".to_string()),
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupMultipleStringCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupMultipleStringCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or("values missing in CatalogsProductGroupMultipleStringCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next().ok_or("negated missing in CatalogsProductGroupMultipleStringCriteria".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupMultipleStringCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupMultipleStringCriteria> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupMultipleStringCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupMultipleStringListCriteria {
    #[serde(rename = "values")]
    pub values: Vec<Vec<String>>,

    #[serde(rename = "negated")]
    pub negated: bool,

}

impl CatalogsProductGroupMultipleStringListCriteria {
    pub fn new(values: Vec<Vec<String>>, negated: bool, ) -> CatalogsProductGroupMultipleStringListCriteria {
        CatalogsProductGroupMultipleStringListCriteria {
            values: values,
            negated: negated,
        }
    }
}

/// Converts the CatalogsProductGroupMultipleStringListCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupMultipleStringListCriteria {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping values in query parameter serialization


        params.push("negated".to_string());
        params.push(self.negated.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupMultipleStringListCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupMultipleStringListCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub values: Vec<Vec<Vec<String>>>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupMultipleStringListCriteria".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in CatalogsProductGroupMultipleStringListCriteria".to_string()),
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupMultipleStringListCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupMultipleStringListCriteria {
            values: intermediate_rep.values.into_iter().next().ok_or("values missing in CatalogsProductGroupMultipleStringListCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next().ok_or("negated missing in CatalogsProductGroupMultipleStringListCriteria".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupMultipleStringListCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupMultipleStringListCriteria> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupMultipleStringListCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupPricingCriteria {
    #[serde(rename = "inclusion")]
    pub inclusion: bool,

    #[serde(rename = "values")]
    pub values: f64,

    #[serde(rename = "negated")]
    pub negated: bool,

}

impl CatalogsProductGroupPricingCriteria {
    pub fn new(inclusion: bool, values: f64, negated: bool, ) -> CatalogsProductGroupPricingCriteria {
        CatalogsProductGroupPricingCriteria {
            inclusion: inclusion,
            values: values,
            negated: negated,
        }
    }
}

/// Converts the CatalogsProductGroupPricingCriteria value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupPricingCriteria {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("inclusion".to_string());
        params.push(self.inclusion.to_string());


        params.push("values".to_string());
        params.push(self.values.to_string());


        params.push("negated".to_string());
        params.push(self.negated.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupPricingCriteria value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupPricingCriteria {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub inclusion: Vec<bool>,
            pub values: Vec<f64>,
            pub negated: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupPricingCriteria".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "inclusion" => intermediate_rep.inclusion.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "values" => intermediate_rep.values.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "negated" => intermediate_rep.negated.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupPricingCriteria".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupPricingCriteria {
            inclusion: intermediate_rep.inclusion.into_iter().next().ok_or("inclusion missing in CatalogsProductGroupPricingCriteria".to_string())?,
            values: intermediate_rep.values.into_iter().next().ok_or("values missing in CatalogsProductGroupPricingCriteria".to_string())?,
            negated: intermediate_rep.negated.into_iter().next().ok_or("negated missing in CatalogsProductGroupPricingCriteria".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupPricingCriteria> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupPricingCriteria>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupPricingCriteria>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupPricingCriteria - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupPricingCriteria> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupPricingCriteria - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsProductGroupStatus {
    #[serde(rename = "ACTIVE")]
    ACTIVE,
    #[serde(rename = "INACTIVE")]
    INACTIVE,
}

impl std::fmt::Display for CatalogsProductGroupStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsProductGroupStatus::ACTIVE => write!(f, "{}", "ACTIVE"),
            CatalogsProductGroupStatus::INACTIVE => write!(f, "{}", "INACTIVE"),
        }
    }
}

impl std::str::FromStr for CatalogsProductGroupStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(CatalogsProductGroupStatus::ACTIVE),
            "INACTIVE" => std::result::Result::Ok(CatalogsProductGroupStatus::INACTIVE),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Catalog product group type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsProductGroupType {
    #[serde(rename = "MERCHANT_CREATED")]
    MERCHANT_CREATED,
    #[serde(rename = "ALL_PRODUCTS")]
    ALL_PRODUCTS,
    #[serde(rename = "BEST_DEALS")]
    BEST_DEALS,
    #[serde(rename = "PINNER_FAVORITES")]
    PINNER_FAVORITES,
    #[serde(rename = "TOP_SELLERS")]
    TOP_SELLERS,
    #[serde(rename = "BACK_IN_STOCK")]
    BACK_IN_STOCK,
    #[serde(rename = "NEW_ARRIVALS")]
    NEW_ARRIVALS,
}

impl std::fmt::Display for CatalogsProductGroupType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsProductGroupType::MERCHANT_CREATED => write!(f, "{}", "MERCHANT_CREATED"),
            CatalogsProductGroupType::ALL_PRODUCTS => write!(f, "{}", "ALL_PRODUCTS"),
            CatalogsProductGroupType::BEST_DEALS => write!(f, "{}", "BEST_DEALS"),
            CatalogsProductGroupType::PINNER_FAVORITES => write!(f, "{}", "PINNER_FAVORITES"),
            CatalogsProductGroupType::TOP_SELLERS => write!(f, "{}", "TOP_SELLERS"),
            CatalogsProductGroupType::BACK_IN_STOCK => write!(f, "{}", "BACK_IN_STOCK"),
            CatalogsProductGroupType::NEW_ARRIVALS => write!(f, "{}", "NEW_ARRIVALS"),
        }
    }
}

impl std::str::FromStr for CatalogsProductGroupType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "MERCHANT_CREATED" => std::result::Result::Ok(CatalogsProductGroupType::MERCHANT_CREATED),
            "ALL_PRODUCTS" => std::result::Result::Ok(CatalogsProductGroupType::ALL_PRODUCTS),
            "BEST_DEALS" => std::result::Result::Ok(CatalogsProductGroupType::BEST_DEALS),
            "PINNER_FAVORITES" => std::result::Result::Ok(CatalogsProductGroupType::PINNER_FAVORITES),
            "TOP_SELLERS" => std::result::Result::Ok(CatalogsProductGroupType::TOP_SELLERS),
            "BACK_IN_STOCK" => std::result::Result::Ok(CatalogsProductGroupType::BACK_IN_STOCK),
            "NEW_ARRIVALS" => std::result::Result::Ok(CatalogsProductGroupType::NEW_ARRIVALS),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Request object for updating a product group.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CatalogsProductGroupUpdateRequest {
    /// Catalog Feed id pertaining to the catalog product group.
    #[serde(rename = "feed_id")]
    pub feed_id: String,

    #[serde(rename = "name")]
    pub name: String,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    #[serde(rename = "filters")]
    pub filters: models::CatalogsProductGroupFilters,

}

impl CatalogsProductGroupUpdateRequest {
    pub fn new(feed_id: String, name: String, filters: models::CatalogsProductGroupFilters, ) -> CatalogsProductGroupUpdateRequest {
        CatalogsProductGroupUpdateRequest {
            feed_id: feed_id,
            name: name,
            description: None,
            filters: filters,
        }
    }
}

/// Converts the CatalogsProductGroupUpdateRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CatalogsProductGroupUpdateRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("feed_id".to_string());
        params.push(self.feed_id.to_string());


        params.push("name".to_string());
        params.push(self.name.to_string());


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping filters in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CatalogsProductGroupUpdateRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CatalogsProductGroupUpdateRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub feed_id: Vec<String>,
            pub name: Vec<String>,
            pub description: Vec<String>,
            pub filters: Vec<models::CatalogsProductGroupFilters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CatalogsProductGroupUpdateRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "feed_id" => intermediate_rep.feed_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in CatalogsProductGroupUpdateRequest".to_string()),
                    "filters" => intermediate_rep.filters.push(<models::CatalogsProductGroupFilters as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CatalogsProductGroupUpdateRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CatalogsProductGroupUpdateRequest {
            feed_id: intermediate_rep.feed_id.into_iter().next().ok_or("feed_id missing in CatalogsProductGroupUpdateRequest".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or("name missing in CatalogsProductGroupUpdateRequest".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in CatalogsProductGroupUpdateRequest".to_string())?,
            filters: intermediate_rep.filters.into_iter().next().ok_or("filters missing in CatalogsProductGroupUpdateRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CatalogsProductGroupUpdateRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CatalogsProductGroupUpdateRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CatalogsProductGroupUpdateRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CatalogsProductGroupUpdateRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CatalogsProductGroupUpdateRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CatalogsProductGroupUpdateRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CatalogsProductGroupUpdateRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Status for catalogs entities. Present in catalogs_feed values. When a feed is deleted, the response will inform DELETED as status.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum CatalogsStatus {
    #[serde(rename = "ACTIVE")]
    ACTIVE,
    #[serde(rename = "INACTIVE")]
    INACTIVE,
}

impl std::fmt::Display for CatalogsStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            CatalogsStatus::ACTIVE => write!(f, "{}", "ACTIVE"),
            CatalogsStatus::INACTIVE => write!(f, "{}", "INACTIVE"),
        }
    }
}

impl std::str::FromStr for CatalogsStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(CatalogsStatus::ACTIVE),
            "INACTIVE" => std::result::Result::Ok(CatalogsStatus::INACTIVE),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ConditionFilter {
    #[serde(rename = "CONDITION")]
    pub condition: models::CatalogsProductGroupMultipleStringCriteria,

}

impl ConditionFilter {
    pub fn new(condition: models::CatalogsProductGroupMultipleStringCriteria, ) -> ConditionFilter {
        ConditionFilter {
            condition: condition,
        }
    }
}

/// Converts the ConditionFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ConditionFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CONDITION in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ConditionFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ConditionFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub condition: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ConditionFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CONDITION" => intermediate_rep.condition.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ConditionFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ConditionFilter {
            condition: intermediate_rep.condition.into_iter().next().ok_or("CONDITION missing in ConditionFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ConditionFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ConditionFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ConditionFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ConditionFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ConditionFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ConditionFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ConditionFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionAttributionWindowDays {
    #[serde(rename = "1")]
    _1,
    #[serde(rename = "7")]
    _7,
    #[serde(rename = "30")]
    _30,
    #[serde(rename = "60")]
    _60,
}

impl std::fmt::Display for ConversionAttributionWindowDays {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionAttributionWindowDays::_1 => write!(f, "{}", "1"),
            ConversionAttributionWindowDays::_7 => write!(f, "{}", "7"),
            ConversionAttributionWindowDays::_30 => write!(f, "{}", "30"),
            ConversionAttributionWindowDays::_60 => write!(f, "{}", "60"),
        }
    }
}

impl std::str::FromStr for ConversionAttributionWindowDays {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "1" => std::result::Result::Ok(ConversionAttributionWindowDays::_1),
            "7" => std::result::Result::Ok(ConversionAttributionWindowDays::_7),
            "30" => std::result::Result::Ok(ConversionAttributionWindowDays::_30),
            "60" => std::result::Result::Ok(ConversionAttributionWindowDays::_60),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Attribution type. Refers to the Pinterest Tag endpoints
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionReportAttributionType {
    #[serde(rename = "INDIVIDUAL")]
    INDIVIDUAL,
    #[serde(rename = "HOUSEHOLD")]
    HOUSEHOLD,
}

impl std::fmt::Display for ConversionReportAttributionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionReportAttributionType::INDIVIDUAL => write!(f, "{}", "INDIVIDUAL"),
            ConversionReportAttributionType::HOUSEHOLD => write!(f, "{}", "HOUSEHOLD"),
        }
    }
}

impl std::str::FromStr for ConversionReportAttributionType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "INDIVIDUAL" => std::result::Result::Ok(ConversionReportAttributionType::INDIVIDUAL),
            "HOUSEHOLD" => std::result::Result::Ok(ConversionReportAttributionType::HOUSEHOLD),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Conversion report time type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ConversionReportTimeType {
    #[serde(rename = "TIME_OF_AD_ACTION")]
    AD_ACTION,
    #[serde(rename = "TIME_OF_CONVERSION")]
    CONVERSION,
}

impl std::fmt::Display for ConversionReportTimeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ConversionReportTimeType::AD_ACTION => write!(f, "{}", "TIME_OF_AD_ACTION"),
            ConversionReportTimeType::CONVERSION => write!(f, "{}", "TIME_OF_CONVERSION"),
        }
    }
}

impl std::str::FromStr for ConversionReportTimeType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TIME_OF_AD_ACTION" => std::result::Result::Ok(ConversionReportTimeType::AD_ACTION),
            "TIME_OF_CONVERSION" => std::result::Result::Ok(ConversionReportTimeType::CONVERSION),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Country ID from ISO 3166-1 alpha-2.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Country {
    #[serde(rename = "AD")]
    AD,
    #[serde(rename = "AE")]
    AE,
    #[serde(rename = "AF")]
    AF,
    #[serde(rename = "AG")]
    AG,
    #[serde(rename = "AI")]
    AI,
    #[serde(rename = "AL")]
    AL,
    #[serde(rename = "AM")]
    AM,
    #[serde(rename = "AO")]
    AO,
    #[serde(rename = "AQ")]
    AQ,
    #[serde(rename = "AR")]
    AR,
    #[serde(rename = "AS")]
    AS,
    #[serde(rename = "AT")]
    AT,
    #[serde(rename = "AU")]
    AU,
    #[serde(rename = "AW")]
    AW,
    #[serde(rename = "AX")]
    AX,
    #[serde(rename = "AZ")]
    AZ,
    #[serde(rename = "BA")]
    BA,
    #[serde(rename = "BB")]
    BB,
    #[serde(rename = "BD")]
    BD,
    #[serde(rename = "BE")]
    BE,
    #[serde(rename = "BF")]
    BF,
    #[serde(rename = "BG")]
    BG,
    #[serde(rename = "BH")]
    BH,
    #[serde(rename = "BI")]
    BI,
    #[serde(rename = "BJ")]
    BJ,
    #[serde(rename = "BL")]
    BL,
    #[serde(rename = "BM")]
    BM,
    #[serde(rename = "BN")]
    BN,
    #[serde(rename = "BO")]
    BO,
    #[serde(rename = "BQ")]
    BQ,
    #[serde(rename = "BR")]
    BR,
    #[serde(rename = "BS")]
    BS,
    #[serde(rename = "BT")]
    BT,
    #[serde(rename = "BV")]
    BV,
    #[serde(rename = "BW")]
    BW,
    #[serde(rename = "BY")]
    BY,
    #[serde(rename = "BZ")]
    BZ,
    #[serde(rename = "CA")]
    CA,
    #[serde(rename = "CC")]
    CC,
    #[serde(rename = "CD")]
    CD,
    #[serde(rename = "CF")]
    CF,
    #[serde(rename = "CG")]
    CG,
    #[serde(rename = "CH")]
    CH,
    #[serde(rename = "CI")]
    CI,
    #[serde(rename = "CK")]
    CK,
    #[serde(rename = "CL")]
    CL,
    #[serde(rename = "CM")]
    CM,
    #[serde(rename = "CO")]
    CO,
    #[serde(rename = "CR")]
    CR,
    #[serde(rename = "CU")]
    CU,
    #[serde(rename = "CV")]
    CV,
    #[serde(rename = "CW")]
    CW,
    #[serde(rename = "CX")]
    CX,
    #[serde(rename = "CY")]
    CY,
    #[serde(rename = "CZ")]
    CZ,
    #[serde(rename = "DE")]
    DE,
    #[serde(rename = "DJ")]
    DJ,
    #[serde(rename = "DK")]
    DK,
    #[serde(rename = "DM")]
    DM,
    #[serde(rename = "DO")]
    DO,
    #[serde(rename = "DZ")]
    DZ,
    #[serde(rename = "EC")]
    EC,
    #[serde(rename = "EE")]
    EE,
    #[serde(rename = "EG")]
    EG,
    #[serde(rename = "EH")]
    EH,
    #[serde(rename = "ER")]
    ER,
    #[serde(rename = "ES")]
    ES,
    #[serde(rename = "ET")]
    ET,
    #[serde(rename = "FI")]
    FI,
    #[serde(rename = "FJ")]
    FJ,
    #[serde(rename = "FK")]
    FK,
    #[serde(rename = "FM")]
    FM,
    #[serde(rename = "FO")]
    FO,
    #[serde(rename = "FR")]
    FR,
    #[serde(rename = "GA")]
    GA,
    #[serde(rename = "GB")]
    GB,
    #[serde(rename = "GD")]
    GD,
    #[serde(rename = "GE")]
    GE,
    #[serde(rename = "GF")]
    GF,
    #[serde(rename = "GG")]
    GG,
    #[serde(rename = "GH")]
    GH,
    #[serde(rename = "GI")]
    GI,
    #[serde(rename = "GL")]
    GL,
    #[serde(rename = "GM")]
    GM,
    #[serde(rename = "GN")]
    GN,
    #[serde(rename = "GP")]
    GP,
    #[serde(rename = "GQ")]
    GQ,
    #[serde(rename = "GR")]
    GR,
    #[serde(rename = "GS")]
    GS,
    #[serde(rename = "GT")]
    GT,
    #[serde(rename = "GU")]
    GU,
    #[serde(rename = "GW")]
    GW,
    #[serde(rename = "GY")]
    GY,
    #[serde(rename = "HK")]
    HK,
    #[serde(rename = "HM")]
    HM,
    #[serde(rename = "HN")]
    HN,
    #[serde(rename = "HR")]
    HR,
    #[serde(rename = "HT")]
    HT,
    #[serde(rename = "HU")]
    HU,
    #[serde(rename = "ID")]
    ID,
    #[serde(rename = "IE")]
    IE,
    #[serde(rename = "IL")]
    IL,
    #[serde(rename = "IM")]
    IM,
    #[serde(rename = "IN")]
    IN,
    #[serde(rename = "IO")]
    IO,
    #[serde(rename = "IQ")]
    IQ,
    #[serde(rename = "IR")]
    IR,
    #[serde(rename = "IS")]
    IS,
    #[serde(rename = "IT")]
    IT,
    #[serde(rename = "JE")]
    JE,
    #[serde(rename = "JM")]
    JM,
    #[serde(rename = "JO")]
    JO,
    #[serde(rename = "JP")]
    JP,
    #[serde(rename = "KE")]
    KE,
    #[serde(rename = "KG")]
    KG,
    #[serde(rename = "KH")]
    KH,
    #[serde(rename = "KI")]
    KI,
    #[serde(rename = "KM")]
    KM,
    #[serde(rename = "KN")]
    KN,
    #[serde(rename = "KR")]
    KR,
    #[serde(rename = "KW")]
    KW,
    #[serde(rename = "KY")]
    KY,
    #[serde(rename = "KZ")]
    KZ,
    #[serde(rename = "LA")]
    LA,
    #[serde(rename = "LB")]
    LB,
    #[serde(rename = "LC")]
    LC,
    #[serde(rename = "LI")]
    LI,
    #[serde(rename = "LK")]
    LK,
    #[serde(rename = "LR")]
    LR,
    #[serde(rename = "LS")]
    LS,
    #[serde(rename = "LT")]
    LT,
    #[serde(rename = "LU")]
    LU,
    #[serde(rename = "LV")]
    LV,
    #[serde(rename = "LY")]
    LY,
    #[serde(rename = "MA")]
    MA,
    #[serde(rename = "MC")]
    MC,
    #[serde(rename = "MD")]
    MD,
    #[serde(rename = "ME")]
    ME,
    #[serde(rename = "MF")]
    MF,
    #[serde(rename = "MG")]
    MG,
    #[serde(rename = "MH")]
    MH,
    #[serde(rename = "MK")]
    MK,
    #[serde(rename = "ML")]
    ML,
    #[serde(rename = "MM")]
    MM,
    #[serde(rename = "MN")]
    MN,
    #[serde(rename = "MO")]
    MO,
    #[serde(rename = "MP")]
    MP,
    #[serde(rename = "MQ")]
    MQ,
    #[serde(rename = "MR")]
    MR,
    #[serde(rename = "MS")]
    MS,
    #[serde(rename = "MT")]
    MT,
    #[serde(rename = "MU")]
    MU,
    #[serde(rename = "MV")]
    MV,
    #[serde(rename = "MW")]
    MW,
    #[serde(rename = "MX")]
    MX,
    #[serde(rename = "MY")]
    MY,
    #[serde(rename = "MZ")]
    MZ,
    #[serde(rename = "NA")]
    NA,
    #[serde(rename = "NC")]
    NC,
    #[serde(rename = "NE")]
    NE,
    #[serde(rename = "NF")]
    NF,
    #[serde(rename = "NG")]
    NG,
    #[serde(rename = "NI")]
    NI,
    #[serde(rename = "NL")]
    NL,
    #[serde(rename = "NO")]
    NO,
    #[serde(rename = "NP")]
    NP,
    #[serde(rename = "NR")]
    NR,
    #[serde(rename = "NU")]
    NU,
    #[serde(rename = "NZ")]
    NZ,
    #[serde(rename = "OM")]
    OM,
    #[serde(rename = "PA")]
    PA,
    #[serde(rename = "PE")]
    PE,
    #[serde(rename = "PF")]
    PF,
    #[serde(rename = "PG")]
    PG,
    #[serde(rename = "PH")]
    PH,
    #[serde(rename = "PK")]
    PK,
    #[serde(rename = "PL")]
    PL,
    #[serde(rename = "PM")]
    PM,
    #[serde(rename = "PN")]
    PN,
    #[serde(rename = "PR")]
    PR,
    #[serde(rename = "PS")]
    PS,
    #[serde(rename = "PT")]
    PT,
    #[serde(rename = "PW")]
    PW,
    #[serde(rename = "PY")]
    PY,
    #[serde(rename = "QA")]
    QA,
    #[serde(rename = "RE")]
    RE,
    #[serde(rename = "RO")]
    RO,
    #[serde(rename = "RS")]
    RS,
    #[serde(rename = "RU")]
    RU,
    #[serde(rename = "RW")]
    RW,
    #[serde(rename = "SA")]
    SA,
    #[serde(rename = "SB")]
    SB,
    #[serde(rename = "SC")]
    SC,
    #[serde(rename = "SD")]
    SD,
    #[serde(rename = "SE")]
    SE,
    #[serde(rename = "SG")]
    SG,
    #[serde(rename = "SH")]
    SH,
    #[serde(rename = "SI")]
    SI,
    #[serde(rename = "SJ")]
    SJ,
    #[serde(rename = "SK")]
    SK,
    #[serde(rename = "SL")]
    SL,
    #[serde(rename = "SM")]
    SM,
    #[serde(rename = "SN")]
    SN,
    #[serde(rename = "SO")]
    SO,
    #[serde(rename = "SR")]
    SR,
    #[serde(rename = "SS")]
    SS,
    #[serde(rename = "ST")]
    ST,
    #[serde(rename = "SV")]
    SV,
    #[serde(rename = "SX")]
    SX,
    #[serde(rename = "SY")]
    SY,
    #[serde(rename = "SZ")]
    SZ,
    #[serde(rename = "TC")]
    TC,
    #[serde(rename = "TD")]
    TD,
    #[serde(rename = "TF")]
    TF,
    #[serde(rename = "TG")]
    TG,
    #[serde(rename = "TH")]
    TH,
    #[serde(rename = "TJ")]
    TJ,
    #[serde(rename = "TK")]
    TK,
    #[serde(rename = "TL")]
    TL,
    #[serde(rename = "TM")]
    TM,
    #[serde(rename = "TN")]
    TN,
    #[serde(rename = "TO")]
    TO,
    #[serde(rename = "TR")]
    TR,
    #[serde(rename = "TT")]
    TT,
    #[serde(rename = "TV")]
    TV,
    #[serde(rename = "TW")]
    TW,
    #[serde(rename = "TZ")]
    TZ,
    #[serde(rename = "UA")]
    UA,
    #[serde(rename = "UG")]
    UG,
    #[serde(rename = "UM")]
    UM,
    #[serde(rename = "US")]
    US,
    #[serde(rename = "UY")]
    UY,
    #[serde(rename = "UZ")]
    UZ,
    #[serde(rename = "VA")]
    VA,
    #[serde(rename = "VC")]
    VC,
    #[serde(rename = "VE")]
    VE,
    #[serde(rename = "VG")]
    VG,
    #[serde(rename = "VI")]
    VI,
    #[serde(rename = "VN")]
    VN,
    #[serde(rename = "VU")]
    VU,
    #[serde(rename = "WF")]
    WF,
    #[serde(rename = "WS")]
    WS,
    #[serde(rename = "YE")]
    YE,
    #[serde(rename = "YT")]
    YT,
    #[serde(rename = "ZA")]
    ZA,
    #[serde(rename = "ZM")]
    ZM,
    #[serde(rename = "ZW")]
    ZW,
}

impl std::fmt::Display for Country {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Country::AD => write!(f, "{}", "AD"),
            Country::AE => write!(f, "{}", "AE"),
            Country::AF => write!(f, "{}", "AF"),
            Country::AG => write!(f, "{}", "AG"),
            Country::AI => write!(f, "{}", "AI"),
            Country::AL => write!(f, "{}", "AL"),
            Country::AM => write!(f, "{}", "AM"),
            Country::AO => write!(f, "{}", "AO"),
            Country::AQ => write!(f, "{}", "AQ"),
            Country::AR => write!(f, "{}", "AR"),
            Country::AS => write!(f, "{}", "AS"),
            Country::AT => write!(f, "{}", "AT"),
            Country::AU => write!(f, "{}", "AU"),
            Country::AW => write!(f, "{}", "AW"),
            Country::AX => write!(f, "{}", "AX"),
            Country::AZ => write!(f, "{}", "AZ"),
            Country::BA => write!(f, "{}", "BA"),
            Country::BB => write!(f, "{}", "BB"),
            Country::BD => write!(f, "{}", "BD"),
            Country::BE => write!(f, "{}", "BE"),
            Country::BF => write!(f, "{}", "BF"),
            Country::BG => write!(f, "{}", "BG"),
            Country::BH => write!(f, "{}", "BH"),
            Country::BI => write!(f, "{}", "BI"),
            Country::BJ => write!(f, "{}", "BJ"),
            Country::BL => write!(f, "{}", "BL"),
            Country::BM => write!(f, "{}", "BM"),
            Country::BN => write!(f, "{}", "BN"),
            Country::BO => write!(f, "{}", "BO"),
            Country::BQ => write!(f, "{}", "BQ"),
            Country::BR => write!(f, "{}", "BR"),
            Country::BS => write!(f, "{}", "BS"),
            Country::BT => write!(f, "{}", "BT"),
            Country::BV => write!(f, "{}", "BV"),
            Country::BW => write!(f, "{}", "BW"),
            Country::BY => write!(f, "{}", "BY"),
            Country::BZ => write!(f, "{}", "BZ"),
            Country::CA => write!(f, "{}", "CA"),
            Country::CC => write!(f, "{}", "CC"),
            Country::CD => write!(f, "{}", "CD"),
            Country::CF => write!(f, "{}", "CF"),
            Country::CG => write!(f, "{}", "CG"),
            Country::CH => write!(f, "{}", "CH"),
            Country::CI => write!(f, "{}", "CI"),
            Country::CK => write!(f, "{}", "CK"),
            Country::CL => write!(f, "{}", "CL"),
            Country::CM => write!(f, "{}", "CM"),
            Country::CO => write!(f, "{}", "CO"),
            Country::CR => write!(f, "{}", "CR"),
            Country::CU => write!(f, "{}", "CU"),
            Country::CV => write!(f, "{}", "CV"),
            Country::CW => write!(f, "{}", "CW"),
            Country::CX => write!(f, "{}", "CX"),
            Country::CY => write!(f, "{}", "CY"),
            Country::CZ => write!(f, "{}", "CZ"),
            Country::DE => write!(f, "{}", "DE"),
            Country::DJ => write!(f, "{}", "DJ"),
            Country::DK => write!(f, "{}", "DK"),
            Country::DM => write!(f, "{}", "DM"),
            Country::DO => write!(f, "{}", "DO"),
            Country::DZ => write!(f, "{}", "DZ"),
            Country::EC => write!(f, "{}", "EC"),
            Country::EE => write!(f, "{}", "EE"),
            Country::EG => write!(f, "{}", "EG"),
            Country::EH => write!(f, "{}", "EH"),
            Country::ER => write!(f, "{}", "ER"),
            Country::ES => write!(f, "{}", "ES"),
            Country::ET => write!(f, "{}", "ET"),
            Country::FI => write!(f, "{}", "FI"),
            Country::FJ => write!(f, "{}", "FJ"),
            Country::FK => write!(f, "{}", "FK"),
            Country::FM => write!(f, "{}", "FM"),
            Country::FO => write!(f, "{}", "FO"),
            Country::FR => write!(f, "{}", "FR"),
            Country::GA => write!(f, "{}", "GA"),
            Country::GB => write!(f, "{}", "GB"),
            Country::GD => write!(f, "{}", "GD"),
            Country::GE => write!(f, "{}", "GE"),
            Country::GF => write!(f, "{}", "GF"),
            Country::GG => write!(f, "{}", "GG"),
            Country::GH => write!(f, "{}", "GH"),
            Country::GI => write!(f, "{}", "GI"),
            Country::GL => write!(f, "{}", "GL"),
            Country::GM => write!(f, "{}", "GM"),
            Country::GN => write!(f, "{}", "GN"),
            Country::GP => write!(f, "{}", "GP"),
            Country::GQ => write!(f, "{}", "GQ"),
            Country::GR => write!(f, "{}", "GR"),
            Country::GS => write!(f, "{}", "GS"),
            Country::GT => write!(f, "{}", "GT"),
            Country::GU => write!(f, "{}", "GU"),
            Country::GW => write!(f, "{}", "GW"),
            Country::GY => write!(f, "{}", "GY"),
            Country::HK => write!(f, "{}", "HK"),
            Country::HM => write!(f, "{}", "HM"),
            Country::HN => write!(f, "{}", "HN"),
            Country::HR => write!(f, "{}", "HR"),
            Country::HT => write!(f, "{}", "HT"),
            Country::HU => write!(f, "{}", "HU"),
            Country::ID => write!(f, "{}", "ID"),
            Country::IE => write!(f, "{}", "IE"),
            Country::IL => write!(f, "{}", "IL"),
            Country::IM => write!(f, "{}", "IM"),
            Country::IN => write!(f, "{}", "IN"),
            Country::IO => write!(f, "{}", "IO"),
            Country::IQ => write!(f, "{}", "IQ"),
            Country::IR => write!(f, "{}", "IR"),
            Country::IS => write!(f, "{}", "IS"),
            Country::IT => write!(f, "{}", "IT"),
            Country::JE => write!(f, "{}", "JE"),
            Country::JM => write!(f, "{}", "JM"),
            Country::JO => write!(f, "{}", "JO"),
            Country::JP => write!(f, "{}", "JP"),
            Country::KE => write!(f, "{}", "KE"),
            Country::KG => write!(f, "{}", "KG"),
            Country::KH => write!(f, "{}", "KH"),
            Country::KI => write!(f, "{}", "KI"),
            Country::KM => write!(f, "{}", "KM"),
            Country::KN => write!(f, "{}", "KN"),
            Country::KR => write!(f, "{}", "KR"),
            Country::KW => write!(f, "{}", "KW"),
            Country::KY => write!(f, "{}", "KY"),
            Country::KZ => write!(f, "{}", "KZ"),
            Country::LA => write!(f, "{}", "LA"),
            Country::LB => write!(f, "{}", "LB"),
            Country::LC => write!(f, "{}", "LC"),
            Country::LI => write!(f, "{}", "LI"),
            Country::LK => write!(f, "{}", "LK"),
            Country::LR => write!(f, "{}", "LR"),
            Country::LS => write!(f, "{}", "LS"),
            Country::LT => write!(f, "{}", "LT"),
            Country::LU => write!(f, "{}", "LU"),
            Country::LV => write!(f, "{}", "LV"),
            Country::LY => write!(f, "{}", "LY"),
            Country::MA => write!(f, "{}", "MA"),
            Country::MC => write!(f, "{}", "MC"),
            Country::MD => write!(f, "{}", "MD"),
            Country::ME => write!(f, "{}", "ME"),
            Country::MF => write!(f, "{}", "MF"),
            Country::MG => write!(f, "{}", "MG"),
            Country::MH => write!(f, "{}", "MH"),
            Country::MK => write!(f, "{}", "MK"),
            Country::ML => write!(f, "{}", "ML"),
            Country::MM => write!(f, "{}", "MM"),
            Country::MN => write!(f, "{}", "MN"),
            Country::MO => write!(f, "{}", "MO"),
            Country::MP => write!(f, "{}", "MP"),
            Country::MQ => write!(f, "{}", "MQ"),
            Country::MR => write!(f, "{}", "MR"),
            Country::MS => write!(f, "{}", "MS"),
            Country::MT => write!(f, "{}", "MT"),
            Country::MU => write!(f, "{}", "MU"),
            Country::MV => write!(f, "{}", "MV"),
            Country::MW => write!(f, "{}", "MW"),
            Country::MX => write!(f, "{}", "MX"),
            Country::MY => write!(f, "{}", "MY"),
            Country::MZ => write!(f, "{}", "MZ"),
            Country::NA => write!(f, "{}", "NA"),
            Country::NC => write!(f, "{}", "NC"),
            Country::NE => write!(f, "{}", "NE"),
            Country::NF => write!(f, "{}", "NF"),
            Country::NG => write!(f, "{}", "NG"),
            Country::NI => write!(f, "{}", "NI"),
            Country::NL => write!(f, "{}", "NL"),
            Country::NO => write!(f, "{}", "NO"),
            Country::NP => write!(f, "{}", "NP"),
            Country::NR => write!(f, "{}", "NR"),
            Country::NU => write!(f, "{}", "NU"),
            Country::NZ => write!(f, "{}", "NZ"),
            Country::OM => write!(f, "{}", "OM"),
            Country::PA => write!(f, "{}", "PA"),
            Country::PE => write!(f, "{}", "PE"),
            Country::PF => write!(f, "{}", "PF"),
            Country::PG => write!(f, "{}", "PG"),
            Country::PH => write!(f, "{}", "PH"),
            Country::PK => write!(f, "{}", "PK"),
            Country::PL => write!(f, "{}", "PL"),
            Country::PM => write!(f, "{}", "PM"),
            Country::PN => write!(f, "{}", "PN"),
            Country::PR => write!(f, "{}", "PR"),
            Country::PS => write!(f, "{}", "PS"),
            Country::PT => write!(f, "{}", "PT"),
            Country::PW => write!(f, "{}", "PW"),
            Country::PY => write!(f, "{}", "PY"),
            Country::QA => write!(f, "{}", "QA"),
            Country::RE => write!(f, "{}", "RE"),
            Country::RO => write!(f, "{}", "RO"),
            Country::RS => write!(f, "{}", "RS"),
            Country::RU => write!(f, "{}", "RU"),
            Country::RW => write!(f, "{}", "RW"),
            Country::SA => write!(f, "{}", "SA"),
            Country::SB => write!(f, "{}", "SB"),
            Country::SC => write!(f, "{}", "SC"),
            Country::SD => write!(f, "{}", "SD"),
            Country::SE => write!(f, "{}", "SE"),
            Country::SG => write!(f, "{}", "SG"),
            Country::SH => write!(f, "{}", "SH"),
            Country::SI => write!(f, "{}", "SI"),
            Country::SJ => write!(f, "{}", "SJ"),
            Country::SK => write!(f, "{}", "SK"),
            Country::SL => write!(f, "{}", "SL"),
            Country::SM => write!(f, "{}", "SM"),
            Country::SN => write!(f, "{}", "SN"),
            Country::SO => write!(f, "{}", "SO"),
            Country::SR => write!(f, "{}", "SR"),
            Country::SS => write!(f, "{}", "SS"),
            Country::ST => write!(f, "{}", "ST"),
            Country::SV => write!(f, "{}", "SV"),
            Country::SX => write!(f, "{}", "SX"),
            Country::SY => write!(f, "{}", "SY"),
            Country::SZ => write!(f, "{}", "SZ"),
            Country::TC => write!(f, "{}", "TC"),
            Country::TD => write!(f, "{}", "TD"),
            Country::TF => write!(f, "{}", "TF"),
            Country::TG => write!(f, "{}", "TG"),
            Country::TH => write!(f, "{}", "TH"),
            Country::TJ => write!(f, "{}", "TJ"),
            Country::TK => write!(f, "{}", "TK"),
            Country::TL => write!(f, "{}", "TL"),
            Country::TM => write!(f, "{}", "TM"),
            Country::TN => write!(f, "{}", "TN"),
            Country::TO => write!(f, "{}", "TO"),
            Country::TR => write!(f, "{}", "TR"),
            Country::TT => write!(f, "{}", "TT"),
            Country::TV => write!(f, "{}", "TV"),
            Country::TW => write!(f, "{}", "TW"),
            Country::TZ => write!(f, "{}", "TZ"),
            Country::UA => write!(f, "{}", "UA"),
            Country::UG => write!(f, "{}", "UG"),
            Country::UM => write!(f, "{}", "UM"),
            Country::US => write!(f, "{}", "US"),
            Country::UY => write!(f, "{}", "UY"),
            Country::UZ => write!(f, "{}", "UZ"),
            Country::VA => write!(f, "{}", "VA"),
            Country::VC => write!(f, "{}", "VC"),
            Country::VE => write!(f, "{}", "VE"),
            Country::VG => write!(f, "{}", "VG"),
            Country::VI => write!(f, "{}", "VI"),
            Country::VN => write!(f, "{}", "VN"),
            Country::VU => write!(f, "{}", "VU"),
            Country::WF => write!(f, "{}", "WF"),
            Country::WS => write!(f, "{}", "WS"),
            Country::YE => write!(f, "{}", "YE"),
            Country::YT => write!(f, "{}", "YT"),
            Country::ZA => write!(f, "{}", "ZA"),
            Country::ZM => write!(f, "{}", "ZM"),
            Country::ZW => write!(f, "{}", "ZW"),
        }
    }
}

impl std::str::FromStr for Country {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AD" => std::result::Result::Ok(Country::AD),
            "AE" => std::result::Result::Ok(Country::AE),
            "AF" => std::result::Result::Ok(Country::AF),
            "AG" => std::result::Result::Ok(Country::AG),
            "AI" => std::result::Result::Ok(Country::AI),
            "AL" => std::result::Result::Ok(Country::AL),
            "AM" => std::result::Result::Ok(Country::AM),
            "AO" => std::result::Result::Ok(Country::AO),
            "AQ" => std::result::Result::Ok(Country::AQ),
            "AR" => std::result::Result::Ok(Country::AR),
            "AS" => std::result::Result::Ok(Country::AS),
            "AT" => std::result::Result::Ok(Country::AT),
            "AU" => std::result::Result::Ok(Country::AU),
            "AW" => std::result::Result::Ok(Country::AW),
            "AX" => std::result::Result::Ok(Country::AX),
            "AZ" => std::result::Result::Ok(Country::AZ),
            "BA" => std::result::Result::Ok(Country::BA),
            "BB" => std::result::Result::Ok(Country::BB),
            "BD" => std::result::Result::Ok(Country::BD),
            "BE" => std::result::Result::Ok(Country::BE),
            "BF" => std::result::Result::Ok(Country::BF),
            "BG" => std::result::Result::Ok(Country::BG),
            "BH" => std::result::Result::Ok(Country::BH),
            "BI" => std::result::Result::Ok(Country::BI),
            "BJ" => std::result::Result::Ok(Country::BJ),
            "BL" => std::result::Result::Ok(Country::BL),
            "BM" => std::result::Result::Ok(Country::BM),
            "BN" => std::result::Result::Ok(Country::BN),
            "BO" => std::result::Result::Ok(Country::BO),
            "BQ" => std::result::Result::Ok(Country::BQ),
            "BR" => std::result::Result::Ok(Country::BR),
            "BS" => std::result::Result::Ok(Country::BS),
            "BT" => std::result::Result::Ok(Country::BT),
            "BV" => std::result::Result::Ok(Country::BV),
            "BW" => std::result::Result::Ok(Country::BW),
            "BY" => std::result::Result::Ok(Country::BY),
            "BZ" => std::result::Result::Ok(Country::BZ),
            "CA" => std::result::Result::Ok(Country::CA),
            "CC" => std::result::Result::Ok(Country::CC),
            "CD" => std::result::Result::Ok(Country::CD),
            "CF" => std::result::Result::Ok(Country::CF),
            "CG" => std::result::Result::Ok(Country::CG),
            "CH" => std::result::Result::Ok(Country::CH),
            "CI" => std::result::Result::Ok(Country::CI),
            "CK" => std::result::Result::Ok(Country::CK),
            "CL" => std::result::Result::Ok(Country::CL),
            "CM" => std::result::Result::Ok(Country::CM),
            "CO" => std::result::Result::Ok(Country::CO),
            "CR" => std::result::Result::Ok(Country::CR),
            "CU" => std::result::Result::Ok(Country::CU),
            "CV" => std::result::Result::Ok(Country::CV),
            "CW" => std::result::Result::Ok(Country::CW),
            "CX" => std::result::Result::Ok(Country::CX),
            "CY" => std::result::Result::Ok(Country::CY),
            "CZ" => std::result::Result::Ok(Country::CZ),
            "DE" => std::result::Result::Ok(Country::DE),
            "DJ" => std::result::Result::Ok(Country::DJ),
            "DK" => std::result::Result::Ok(Country::DK),
            "DM" => std::result::Result::Ok(Country::DM),
            "DO" => std::result::Result::Ok(Country::DO),
            "DZ" => std::result::Result::Ok(Country::DZ),
            "EC" => std::result::Result::Ok(Country::EC),
            "EE" => std::result::Result::Ok(Country::EE),
            "EG" => std::result::Result::Ok(Country::EG),
            "EH" => std::result::Result::Ok(Country::EH),
            "ER" => std::result::Result::Ok(Country::ER),
            "ES" => std::result::Result::Ok(Country::ES),
            "ET" => std::result::Result::Ok(Country::ET),
            "FI" => std::result::Result::Ok(Country::FI),
            "FJ" => std::result::Result::Ok(Country::FJ),
            "FK" => std::result::Result::Ok(Country::FK),
            "FM" => std::result::Result::Ok(Country::FM),
            "FO" => std::result::Result::Ok(Country::FO),
            "FR" => std::result::Result::Ok(Country::FR),
            "GA" => std::result::Result::Ok(Country::GA),
            "GB" => std::result::Result::Ok(Country::GB),
            "GD" => std::result::Result::Ok(Country::GD),
            "GE" => std::result::Result::Ok(Country::GE),
            "GF" => std::result::Result::Ok(Country::GF),
            "GG" => std::result::Result::Ok(Country::GG),
            "GH" => std::result::Result::Ok(Country::GH),
            "GI" => std::result::Result::Ok(Country::GI),
            "GL" => std::result::Result::Ok(Country::GL),
            "GM" => std::result::Result::Ok(Country::GM),
            "GN" => std::result::Result::Ok(Country::GN),
            "GP" => std::result::Result::Ok(Country::GP),
            "GQ" => std::result::Result::Ok(Country::GQ),
            "GR" => std::result::Result::Ok(Country::GR),
            "GS" => std::result::Result::Ok(Country::GS),
            "GT" => std::result::Result::Ok(Country::GT),
            "GU" => std::result::Result::Ok(Country::GU),
            "GW" => std::result::Result::Ok(Country::GW),
            "GY" => std::result::Result::Ok(Country::GY),
            "HK" => std::result::Result::Ok(Country::HK),
            "HM" => std::result::Result::Ok(Country::HM),
            "HN" => std::result::Result::Ok(Country::HN),
            "HR" => std::result::Result::Ok(Country::HR),
            "HT" => std::result::Result::Ok(Country::HT),
            "HU" => std::result::Result::Ok(Country::HU),
            "ID" => std::result::Result::Ok(Country::ID),
            "IE" => std::result::Result::Ok(Country::IE),
            "IL" => std::result::Result::Ok(Country::IL),
            "IM" => std::result::Result::Ok(Country::IM),
            "IN" => std::result::Result::Ok(Country::IN),
            "IO" => std::result::Result::Ok(Country::IO),
            "IQ" => std::result::Result::Ok(Country::IQ),
            "IR" => std::result::Result::Ok(Country::IR),
            "IS" => std::result::Result::Ok(Country::IS),
            "IT" => std::result::Result::Ok(Country::IT),
            "JE" => std::result::Result::Ok(Country::JE),
            "JM" => std::result::Result::Ok(Country::JM),
            "JO" => std::result::Result::Ok(Country::JO),
            "JP" => std::result::Result::Ok(Country::JP),
            "KE" => std::result::Result::Ok(Country::KE),
            "KG" => std::result::Result::Ok(Country::KG),
            "KH" => std::result::Result::Ok(Country::KH),
            "KI" => std::result::Result::Ok(Country::KI),
            "KM" => std::result::Result::Ok(Country::KM),
            "KN" => std::result::Result::Ok(Country::KN),
            "KR" => std::result::Result::Ok(Country::KR),
            "KW" => std::result::Result::Ok(Country::KW),
            "KY" => std::result::Result::Ok(Country::KY),
            "KZ" => std::result::Result::Ok(Country::KZ),
            "LA" => std::result::Result::Ok(Country::LA),
            "LB" => std::result::Result::Ok(Country::LB),
            "LC" => std::result::Result::Ok(Country::LC),
            "LI" => std::result::Result::Ok(Country::LI),
            "LK" => std::result::Result::Ok(Country::LK),
            "LR" => std::result::Result::Ok(Country::LR),
            "LS" => std::result::Result::Ok(Country::LS),
            "LT" => std::result::Result::Ok(Country::LT),
            "LU" => std::result::Result::Ok(Country::LU),
            "LV" => std::result::Result::Ok(Country::LV),
            "LY" => std::result::Result::Ok(Country::LY),
            "MA" => std::result::Result::Ok(Country::MA),
            "MC" => std::result::Result::Ok(Country::MC),
            "MD" => std::result::Result::Ok(Country::MD),
            "ME" => std::result::Result::Ok(Country::ME),
            "MF" => std::result::Result::Ok(Country::MF),
            "MG" => std::result::Result::Ok(Country::MG),
            "MH" => std::result::Result::Ok(Country::MH),
            "MK" => std::result::Result::Ok(Country::MK),
            "ML" => std::result::Result::Ok(Country::ML),
            "MM" => std::result::Result::Ok(Country::MM),
            "MN" => std::result::Result::Ok(Country::MN),
            "MO" => std::result::Result::Ok(Country::MO),
            "MP" => std::result::Result::Ok(Country::MP),
            "MQ" => std::result::Result::Ok(Country::MQ),
            "MR" => std::result::Result::Ok(Country::MR),
            "MS" => std::result::Result::Ok(Country::MS),
            "MT" => std::result::Result::Ok(Country::MT),
            "MU" => std::result::Result::Ok(Country::MU),
            "MV" => std::result::Result::Ok(Country::MV),
            "MW" => std::result::Result::Ok(Country::MW),
            "MX" => std::result::Result::Ok(Country::MX),
            "MY" => std::result::Result::Ok(Country::MY),
            "MZ" => std::result::Result::Ok(Country::MZ),
            "NA" => std::result::Result::Ok(Country::NA),
            "NC" => std::result::Result::Ok(Country::NC),
            "NE" => std::result::Result::Ok(Country::NE),
            "NF" => std::result::Result::Ok(Country::NF),
            "NG" => std::result::Result::Ok(Country::NG),
            "NI" => std::result::Result::Ok(Country::NI),
            "NL" => std::result::Result::Ok(Country::NL),
            "NO" => std::result::Result::Ok(Country::NO),
            "NP" => std::result::Result::Ok(Country::NP),
            "NR" => std::result::Result::Ok(Country::NR),
            "NU" => std::result::Result::Ok(Country::NU),
            "NZ" => std::result::Result::Ok(Country::NZ),
            "OM" => std::result::Result::Ok(Country::OM),
            "PA" => std::result::Result::Ok(Country::PA),
            "PE" => std::result::Result::Ok(Country::PE),
            "PF" => std::result::Result::Ok(Country::PF),
            "PG" => std::result::Result::Ok(Country::PG),
            "PH" => std::result::Result::Ok(Country::PH),
            "PK" => std::result::Result::Ok(Country::PK),
            "PL" => std::result::Result::Ok(Country::PL),
            "PM" => std::result::Result::Ok(Country::PM),
            "PN" => std::result::Result::Ok(Country::PN),
            "PR" => std::result::Result::Ok(Country::PR),
            "PS" => std::result::Result::Ok(Country::PS),
            "PT" => std::result::Result::Ok(Country::PT),
            "PW" => std::result::Result::Ok(Country::PW),
            "PY" => std::result::Result::Ok(Country::PY),
            "QA" => std::result::Result::Ok(Country::QA),
            "RE" => std::result::Result::Ok(Country::RE),
            "RO" => std::result::Result::Ok(Country::RO),
            "RS" => std::result::Result::Ok(Country::RS),
            "RU" => std::result::Result::Ok(Country::RU),
            "RW" => std::result::Result::Ok(Country::RW),
            "SA" => std::result::Result::Ok(Country::SA),
            "SB" => std::result::Result::Ok(Country::SB),
            "SC" => std::result::Result::Ok(Country::SC),
            "SD" => std::result::Result::Ok(Country::SD),
            "SE" => std::result::Result::Ok(Country::SE),
            "SG" => std::result::Result::Ok(Country::SG),
            "SH" => std::result::Result::Ok(Country::SH),
            "SI" => std::result::Result::Ok(Country::SI),
            "SJ" => std::result::Result::Ok(Country::SJ),
            "SK" => std::result::Result::Ok(Country::SK),
            "SL" => std::result::Result::Ok(Country::SL),
            "SM" => std::result::Result::Ok(Country::SM),
            "SN" => std::result::Result::Ok(Country::SN),
            "SO" => std::result::Result::Ok(Country::SO),
            "SR" => std::result::Result::Ok(Country::SR),
            "SS" => std::result::Result::Ok(Country::SS),
            "ST" => std::result::Result::Ok(Country::ST),
            "SV" => std::result::Result::Ok(Country::SV),
            "SX" => std::result::Result::Ok(Country::SX),
            "SY" => std::result::Result::Ok(Country::SY),
            "SZ" => std::result::Result::Ok(Country::SZ),
            "TC" => std::result::Result::Ok(Country::TC),
            "TD" => std::result::Result::Ok(Country::TD),
            "TF" => std::result::Result::Ok(Country::TF),
            "TG" => std::result::Result::Ok(Country::TG),
            "TH" => std::result::Result::Ok(Country::TH),
            "TJ" => std::result::Result::Ok(Country::TJ),
            "TK" => std::result::Result::Ok(Country::TK),
            "TL" => std::result::Result::Ok(Country::TL),
            "TM" => std::result::Result::Ok(Country::TM),
            "TN" => std::result::Result::Ok(Country::TN),
            "TO" => std::result::Result::Ok(Country::TO),
            "TR" => std::result::Result::Ok(Country::TR),
            "TT" => std::result::Result::Ok(Country::TT),
            "TV" => std::result::Result::Ok(Country::TV),
            "TW" => std::result::Result::Ok(Country::TW),
            "TZ" => std::result::Result::Ok(Country::TZ),
            "UA" => std::result::Result::Ok(Country::UA),
            "UG" => std::result::Result::Ok(Country::UG),
            "UM" => std::result::Result::Ok(Country::UM),
            "US" => std::result::Result::Ok(Country::US),
            "UY" => std::result::Result::Ok(Country::UY),
            "UZ" => std::result::Result::Ok(Country::UZ),
            "VA" => std::result::Result::Ok(Country::VA),
            "VC" => std::result::Result::Ok(Country::VC),
            "VE" => std::result::Result::Ok(Country::VE),
            "VG" => std::result::Result::Ok(Country::VG),
            "VI" => std::result::Result::Ok(Country::VI),
            "VN" => std::result::Result::Ok(Country::VN),
            "VU" => std::result::Result::Ok(Country::VU),
            "WF" => std::result::Result::Ok(Country::WF),
            "WS" => std::result::Result::Ok(Country::WS),
            "YE" => std::result::Result::Ok(Country::YE),
            "YT" => std::result::Result::Ok(Country::YT),
            "ZA" => std::result::Result::Ok(Country::ZA),
            "ZM" => std::result::Result::Ok(Country::ZM),
            "ZW" => std::result::Result::Ok(Country::ZW),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Currency Codes from ISO 4217
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Currency {
    #[serde(rename = "UNK")]
    UNK,
    #[serde(rename = "USD")]
    USD,
    #[serde(rename = "GBP")]
    GBP,
    #[serde(rename = "CAD")]
    CAD,
    #[serde(rename = "EUR")]
    EUR,
    #[serde(rename = "AUD")]
    AUD,
    #[serde(rename = "NZD")]
    NZD,
    #[serde(rename = "SEK")]
    SEK,
    #[serde(rename = "ILS")]
    ILS,
    #[serde(rename = "CHF")]
    CHF,
    #[serde(rename = "HKD")]
    HKD,
    #[serde(rename = "JPY")]
    JPY,
    #[serde(rename = "SGD")]
    SGD,
    #[serde(rename = "KRW")]
    KRW,
    #[serde(rename = "NOK")]
    NOK,
    #[serde(rename = "DKK")]
    DKK,
    #[serde(rename = "PLN")]
    PLN,
    #[serde(rename = "RON")]
    RON,
    #[serde(rename = "HUF")]
    HUF,
    #[serde(rename = "CZK")]
    CZK,
    #[serde(rename = "BRL")]
    BRL,
    #[serde(rename = "MXN")]
    MXN,
    #[serde(rename = "ARS")]
    ARS,
    #[serde(rename = "CLP")]
    CLP,
    #[serde(rename = "COP")]
    COP,
}

impl std::fmt::Display for Currency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Currency::UNK => write!(f, "{}", "UNK"),
            Currency::USD => write!(f, "{}", "USD"),
            Currency::GBP => write!(f, "{}", "GBP"),
            Currency::CAD => write!(f, "{}", "CAD"),
            Currency::EUR => write!(f, "{}", "EUR"),
            Currency::AUD => write!(f, "{}", "AUD"),
            Currency::NZD => write!(f, "{}", "NZD"),
            Currency::SEK => write!(f, "{}", "SEK"),
            Currency::ILS => write!(f, "{}", "ILS"),
            Currency::CHF => write!(f, "{}", "CHF"),
            Currency::HKD => write!(f, "{}", "HKD"),
            Currency::JPY => write!(f, "{}", "JPY"),
            Currency::SGD => write!(f, "{}", "SGD"),
            Currency::KRW => write!(f, "{}", "KRW"),
            Currency::NOK => write!(f, "{}", "NOK"),
            Currency::DKK => write!(f, "{}", "DKK"),
            Currency::PLN => write!(f, "{}", "PLN"),
            Currency::RON => write!(f, "{}", "RON"),
            Currency::HUF => write!(f, "{}", "HUF"),
            Currency::CZK => write!(f, "{}", "CZK"),
            Currency::BRL => write!(f, "{}", "BRL"),
            Currency::MXN => write!(f, "{}", "MXN"),
            Currency::ARS => write!(f, "{}", "ARS"),
            Currency::CLP => write!(f, "{}", "CLP"),
            Currency::COP => write!(f, "{}", "COP"),
        }
    }
}

impl std::str::FromStr for Currency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "UNK" => std::result::Result::Ok(Currency::UNK),
            "USD" => std::result::Result::Ok(Currency::USD),
            "GBP" => std::result::Result::Ok(Currency::GBP),
            "CAD" => std::result::Result::Ok(Currency::CAD),
            "EUR" => std::result::Result::Ok(Currency::EUR),
            "AUD" => std::result::Result::Ok(Currency::AUD),
            "NZD" => std::result::Result::Ok(Currency::NZD),
            "SEK" => std::result::Result::Ok(Currency::SEK),
            "ILS" => std::result::Result::Ok(Currency::ILS),
            "CHF" => std::result::Result::Ok(Currency::CHF),
            "HKD" => std::result::Result::Ok(Currency::HKD),
            "JPY" => std::result::Result::Ok(Currency::JPY),
            "SGD" => std::result::Result::Ok(Currency::SGD),
            "KRW" => std::result::Result::Ok(Currency::KRW),
            "NOK" => std::result::Result::Ok(Currency::NOK),
            "DKK" => std::result::Result::Ok(Currency::DKK),
            "PLN" => std::result::Result::Ok(Currency::PLN),
            "RON" => std::result::Result::Ok(Currency::RON),
            "HUF" => std::result::Result::Ok(Currency::HUF),
            "CZK" => std::result::Result::Ok(Currency::CZK),
            "BRL" => std::result::Result::Ok(Currency::BRL),
            "MXN" => std::result::Result::Ok(Currency::MXN),
            "ARS" => std::result::Result::Ok(Currency::ARS),
            "CLP" => std::result::Result::Ok(Currency::CLP),
            "COP" => std::result::Result::Ok(Currency::COP),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CurrencyFilter {
    #[serde(rename = "CURRENCY")]
    pub currency: models::CatalogsProductGroupCurrencyCriteria,

}

impl CurrencyFilter {
    pub fn new(currency: models::CatalogsProductGroupCurrencyCriteria, ) -> CurrencyFilter {
        CurrencyFilter {
            currency: currency,
        }
    }
}

/// Converts the CurrencyFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CurrencyFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CURRENCY in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CurrencyFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CurrencyFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub currency: Vec<models::CatalogsProductGroupCurrencyCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CurrencyFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CURRENCY" => intermediate_rep.currency.push(<models::CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CurrencyFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CurrencyFilter {
            currency: intermediate_rep.currency.into_iter().next().ok_or("CURRENCY missing in CurrencyFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CurrencyFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CurrencyFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CurrencyFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CurrencyFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CurrencyFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CurrencyFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CurrencyFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel0Filter {
    #[serde(rename = "CUSTOM_LABEL_0")]
    pub custom_label_0: models::CatalogsProductGroupMultipleStringCriteria,

}

impl CustomLabel0Filter {
    pub fn new(custom_label_0: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel0Filter {
        CustomLabel0Filter {
            custom_label_0: custom_label_0,
        }
    }
}

/// Converts the CustomLabel0Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CustomLabel0Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CUSTOM_LABEL_0 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel0Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel0Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub custom_label_0: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel0Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CUSTOM_LABEL_0" => intermediate_rep.custom_label_0.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel0Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel0Filter {
            custom_label_0: intermediate_rep.custom_label_0.into_iter().next().ok_or("CUSTOM_LABEL_0 missing in CustomLabel0Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel0Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel0Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel0Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel0Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CustomLabel0Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel0Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel0Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel1Filter {
    #[serde(rename = "CUSTOM_LABEL_1")]
    pub custom_label_1: models::CatalogsProductGroupMultipleStringCriteria,

}

impl CustomLabel1Filter {
    pub fn new(custom_label_1: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel1Filter {
        CustomLabel1Filter {
            custom_label_1: custom_label_1,
        }
    }
}

/// Converts the CustomLabel1Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CustomLabel1Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CUSTOM_LABEL_1 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel1Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel1Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub custom_label_1: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel1Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CUSTOM_LABEL_1" => intermediate_rep.custom_label_1.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel1Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel1Filter {
            custom_label_1: intermediate_rep.custom_label_1.into_iter().next().ok_or("CUSTOM_LABEL_1 missing in CustomLabel1Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel1Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel1Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel1Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel1Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CustomLabel1Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel1Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel1Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel2Filter {
    #[serde(rename = "CUSTOM_LABEL_2")]
    pub custom_label_2: models::CatalogsProductGroupMultipleStringCriteria,

}

impl CustomLabel2Filter {
    pub fn new(custom_label_2: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel2Filter {
        CustomLabel2Filter {
            custom_label_2: custom_label_2,
        }
    }
}

/// Converts the CustomLabel2Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CustomLabel2Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CUSTOM_LABEL_2 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel2Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel2Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub custom_label_2: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel2Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CUSTOM_LABEL_2" => intermediate_rep.custom_label_2.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel2Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel2Filter {
            custom_label_2: intermediate_rep.custom_label_2.into_iter().next().ok_or("CUSTOM_LABEL_2 missing in CustomLabel2Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel2Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel2Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel2Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel2Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CustomLabel2Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel2Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel2Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel3Filter {
    #[serde(rename = "CUSTOM_LABEL_3")]
    pub custom_label_3: models::CatalogsProductGroupMultipleStringCriteria,

}

impl CustomLabel3Filter {
    pub fn new(custom_label_3: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel3Filter {
        CustomLabel3Filter {
            custom_label_3: custom_label_3,
        }
    }
}

/// Converts the CustomLabel3Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CustomLabel3Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CUSTOM_LABEL_3 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel3Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel3Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub custom_label_3: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel3Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CUSTOM_LABEL_3" => intermediate_rep.custom_label_3.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel3Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel3Filter {
            custom_label_3: intermediate_rep.custom_label_3.into_iter().next().ok_or("CUSTOM_LABEL_3 missing in CustomLabel3Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel3Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel3Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel3Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel3Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CustomLabel3Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel3Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel3Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CustomLabel4Filter {
    #[serde(rename = "CUSTOM_LABEL_4")]
    pub custom_label_4: models::CatalogsProductGroupMultipleStringCriteria,

}

impl CustomLabel4Filter {
    pub fn new(custom_label_4: models::CatalogsProductGroupMultipleStringCriteria, ) -> CustomLabel4Filter {
        CustomLabel4Filter {
            custom_label_4: custom_label_4,
        }
    }
}

/// Converts the CustomLabel4Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for CustomLabel4Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping CUSTOM_LABEL_4 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CustomLabel4Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CustomLabel4Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub custom_label_4: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CustomLabel4Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "CUSTOM_LABEL_4" => intermediate_rep.custom_label_4.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CustomLabel4Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CustomLabel4Filter {
            custom_label_4: intermediate_rep.custom_label_4.into_iter().next().ok_or("CUSTOM_LABEL_4 missing in CustomLabel4Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CustomLabel4Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<CustomLabel4Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CustomLabel4Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for CustomLabel4Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<CustomLabel4Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CustomLabel4Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into CustomLabel4Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Format of generated report
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum DataOutputFormat {
    #[serde(rename = "JSON")]
    JSON,
    #[serde(rename = "CSV")]
    CSV,
}

impl std::fmt::Display for DataOutputFormat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            DataOutputFormat::JSON => write!(f, "{}", "JSON"),
            DataOutputFormat::CSV => write!(f, "{}", "CSV"),
        }
    }
}

impl std::str::FromStr for DataOutputFormat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "JSON" => std::result::Result::Ok(DataOutputFormat::JSON),
            "CSV" => std::result::Result::Ok(DataOutputFormat::CSV),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Entity status
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum EntityStatus {
    #[serde(rename = "ACTIVE")]
    ACTIVE,
    #[serde(rename = "PAUSED")]
    PAUSED,
    #[serde(rename = "ARCHIVED")]
    ARCHIVED,
}

impl std::fmt::Display for EntityStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            EntityStatus::ACTIVE => write!(f, "{}", "ACTIVE"),
            EntityStatus::PAUSED => write!(f, "{}", "PAUSED"),
            EntityStatus::ARCHIVED => write!(f, "{}", "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for EntityStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ACTIVE" => std::result::Result::Ok(EntityStatus::ACTIVE),
            "PAUSED" => std::result::Result::Ok(EntityStatus::PAUSED),
            "ARCHIVED" => std::result::Result::Ok(EntityStatus::ARCHIVED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Error {
    #[serde(rename = "code")]
    pub code: isize,

    #[serde(rename = "message")]
    pub message: String,

}

impl Error {
    pub fn new(code: isize, message: String, ) -> Error {
        Error {
            code: code,
            message: message,
        }
    }
}

/// Converts the Error value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Error {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("code".to_string());
        params.push(self.code.to_string());


        params.push("message".to_string());
        params.push(self.message.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Error value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Error {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub code: Vec<isize>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Error".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "code" => intermediate_rep.code.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Error".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Error {
            code: intermediate_rep.code.into_iter().next().ok_or("code missing in Error".to_string())?,
            message: intermediate_rep.message.into_iter().next().ok_or("message missing in Error".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Error> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Error>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Error>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Error - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Error> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Error as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Error - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct FeedFields {
    #[serde(rename = "default_country")]
    pub default_country: models::Country,

    #[serde(rename = "default_availability")]
    pub default_availability: swagger::Nullable<models::ProductAvailabilityType>,

    #[serde(rename = "default_currency")]
    pub default_currency: swagger::Nullable<models::NullableCurrency>,

    /// A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
    #[serde(rename = "name")]
    pub name: swagger::Nullable<String>,

    #[serde(rename = "format")]
    pub format: models::CatalogsFormat,

    /// The locale used within a feed for product descriptions.
    #[serde(rename = "default_locale")]
    pub default_locale: String,

    #[serde(rename = "credentials")]
    pub credentials: swagger::Nullable<models::CatalogsFeedCredentials>,

    /// The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
    #[serde(rename = "location")]
    pub location: String,

    #[serde(rename = "preferred_processing_schedule")]
    pub preferred_processing_schedule: swagger::Nullable<models::CatalogsFeedProcessingSchedule>,

    #[serde(rename = "status")]
    pub status: models::CatalogsStatus,

}

impl FeedFields {
    pub fn new(default_country: models::Country, default_availability: swagger::Nullable<models::ProductAvailabilityType>, default_currency: swagger::Nullable<models::NullableCurrency>, name: swagger::Nullable<String>, format: models::CatalogsFormat, default_locale: String, credentials: swagger::Nullable<models::CatalogsFeedCredentials>, location: String, preferred_processing_schedule: swagger::Nullable<models::CatalogsFeedProcessingSchedule>, status: models::CatalogsStatus, ) -> FeedFields {
        FeedFields {
            default_country: default_country,
            default_availability: default_availability,
            default_currency: default_currency,
            name: name,
            format: format,
            default_locale: default_locale,
            credentials: credentials,
            location: location,
            preferred_processing_schedule: preferred_processing_schedule,
            status: status,
        }
    }
}

/// Converts the FeedFields value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for FeedFields {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping default_country in query parameter serialization

        // Skipping default_availability in query parameter serialization

        // Skipping default_currency in query parameter serialization


        params.push("name".to_string());
        params.push(self.name.as_ref().map_or("null".to_string(), |x| x.to_string()));

        // Skipping format in query parameter serialization


        params.push("default_locale".to_string());
        params.push(self.default_locale.to_string());

        // Skipping credentials in query parameter serialization


        params.push("location".to_string());
        params.push(self.location.to_string());

        // Skipping preferred_processing_schedule in query parameter serialization

        // Skipping status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a FeedFields value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for FeedFields {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub default_country: Vec<models::Country>,
            pub default_availability: Vec<models::ProductAvailabilityType>,
            pub default_currency: Vec<models::NullableCurrency>,
            pub name: Vec<String>,
            pub format: Vec<models::CatalogsFormat>,
            pub default_locale: Vec<String>,
            pub credentials: Vec<models::CatalogsFeedCredentials>,
            pub location: Vec<String>,
            pub preferred_processing_schedule: Vec<models::CatalogsFeedProcessingSchedule>,
            pub status: Vec<models::CatalogsStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing FeedFields".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "default_country" => intermediate_rep.default_country.push(<models::Country as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_availability" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedFields".to_string()),
                    "default_currency" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedFields".to_string()),
                    "name" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedFields".to_string()),
                    "format" => intermediate_rep.format.push(<models::CatalogsFormat as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "default_locale" => intermediate_rep.default_locale.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "credentials" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedFields".to_string()),
                    "location" => intermediate_rep.location.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "preferred_processing_schedule" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in FeedFields".to_string()),
                    "status" => intermediate_rep.status.push(<models::CatalogsStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing FeedFields".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(FeedFields {
            default_country: intermediate_rep.default_country.into_iter().next().ok_or("default_country missing in FeedFields".to_string())?,
            default_availability: std::result::Result::Err("Nullable types not supported in FeedFields".to_string())?,
            default_currency: std::result::Result::Err("Nullable types not supported in FeedFields".to_string())?,
            name: std::result::Result::Err("Nullable types not supported in FeedFields".to_string())?,
            format: intermediate_rep.format.into_iter().next().ok_or("format missing in FeedFields".to_string())?,
            default_locale: intermediate_rep.default_locale.into_iter().next().ok_or("default_locale missing in FeedFields".to_string())?,
            credentials: std::result::Result::Err("Nullable types not supported in FeedFields".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or("location missing in FeedFields".to_string())?,
            preferred_processing_schedule: std::result::Result::Err("Nullable types not supported in FeedFields".to_string())?,
            status: intermediate_rep.status.into_iter().next().ok_or("status missing in FeedFields".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<FeedFields> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<FeedFields>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<FeedFields>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for FeedFields - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<FeedFields> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <FeedFields as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into FeedFields - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenderFilter {
    #[serde(rename = "GENDER")]
    pub gender: models::CatalogsProductGroupMultipleStringCriteria,

}

impl GenderFilter {
    pub fn new(gender: models::CatalogsProductGroupMultipleStringCriteria, ) -> GenderFilter {
        GenderFilter {
            gender: gender,
        }
    }
}

/// Converts the GenderFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GenderFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GENDER in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenderFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenderFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub gender: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenderFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GENDER" => intermediate_rep.gender.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenderFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenderFilter {
            gender: intermediate_rep.gender.into_iter().next().ok_or("GENDER missing in GenderFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenderFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GenderFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenderFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GenderFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GenderFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenderFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GenderFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory0Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_0")]
    pub google_product_category_0: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory0Filter {
    pub fn new(google_product_category_0: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory0Filter {
        GoogleProductCategory0Filter {
            google_product_category_0: google_product_category_0,
        }
    }
}

/// Converts the GoogleProductCategory0Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory0Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_0 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory0Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory0Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_0: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory0Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_0" => intermediate_rep.google_product_category_0.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory0Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory0Filter {
            google_product_category_0: intermediate_rep.google_product_category_0.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_0 missing in GoogleProductCategory0Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory0Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory0Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory0Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory0Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory0Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory0Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory0Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory1Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_1")]
    pub google_product_category_1: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory1Filter {
    pub fn new(google_product_category_1: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory1Filter {
        GoogleProductCategory1Filter {
            google_product_category_1: google_product_category_1,
        }
    }
}

/// Converts the GoogleProductCategory1Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory1Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_1 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory1Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory1Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_1: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory1Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_1" => intermediate_rep.google_product_category_1.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory1Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory1Filter {
            google_product_category_1: intermediate_rep.google_product_category_1.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_1 missing in GoogleProductCategory1Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory1Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory1Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory1Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory1Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory1Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory1Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory1Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory2Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_2")]
    pub google_product_category_2: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory2Filter {
    pub fn new(google_product_category_2: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory2Filter {
        GoogleProductCategory2Filter {
            google_product_category_2: google_product_category_2,
        }
    }
}

/// Converts the GoogleProductCategory2Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory2Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_2 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory2Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory2Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_2: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory2Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_2" => intermediate_rep.google_product_category_2.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory2Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory2Filter {
            google_product_category_2: intermediate_rep.google_product_category_2.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_2 missing in GoogleProductCategory2Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory2Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory2Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory2Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory2Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory2Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory2Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory2Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory3Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_3")]
    pub google_product_category_3: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory3Filter {
    pub fn new(google_product_category_3: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory3Filter {
        GoogleProductCategory3Filter {
            google_product_category_3: google_product_category_3,
        }
    }
}

/// Converts the GoogleProductCategory3Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory3Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_3 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory3Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory3Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_3: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory3Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_3" => intermediate_rep.google_product_category_3.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory3Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory3Filter {
            google_product_category_3: intermediate_rep.google_product_category_3.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_3 missing in GoogleProductCategory3Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory3Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory3Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory3Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory3Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory3Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory3Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory3Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory4Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_4")]
    pub google_product_category_4: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory4Filter {
    pub fn new(google_product_category_4: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory4Filter {
        GoogleProductCategory4Filter {
            google_product_category_4: google_product_category_4,
        }
    }
}

/// Converts the GoogleProductCategory4Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory4Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_4 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory4Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory4Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_4: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory4Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_4" => intermediate_rep.google_product_category_4.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory4Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory4Filter {
            google_product_category_4: intermediate_rep.google_product_category_4.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_4 missing in GoogleProductCategory4Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory4Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory4Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory4Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory4Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory4Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory4Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory4Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory5Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_5")]
    pub google_product_category_5: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory5Filter {
    pub fn new(google_product_category_5: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory5Filter {
        GoogleProductCategory5Filter {
            google_product_category_5: google_product_category_5,
        }
    }
}

/// Converts the GoogleProductCategory5Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory5Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_5 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory5Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory5Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_5: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory5Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_5" => intermediate_rep.google_product_category_5.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory5Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory5Filter {
            google_product_category_5: intermediate_rep.google_product_category_5.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_5 missing in GoogleProductCategory5Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory5Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory5Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory5Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory5Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory5Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory5Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory5Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GoogleProductCategory6Filter {
    #[serde(rename = "GOOGLE_PRODUCT_CATEGORY_6")]
    pub google_product_category_6: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl GoogleProductCategory6Filter {
    pub fn new(google_product_category_6: models::CatalogsProductGroupMultipleStringListCriteria, ) -> GoogleProductCategory6Filter {
        GoogleProductCategory6Filter {
            google_product_category_6: google_product_category_6,
        }
    }
}

/// Converts the GoogleProductCategory6Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for GoogleProductCategory6Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping GOOGLE_PRODUCT_CATEGORY_6 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GoogleProductCategory6Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GoogleProductCategory6Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub google_product_category_6: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GoogleProductCategory6Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "GOOGLE_PRODUCT_CATEGORY_6" => intermediate_rep.google_product_category_6.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GoogleProductCategory6Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GoogleProductCategory6Filter {
            google_product_category_6: intermediate_rep.google_product_category_6.into_iter().next().ok_or("GOOGLE_PRODUCT_CATEGORY_6 missing in GoogleProductCategory6Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GoogleProductCategory6Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<GoogleProductCategory6Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GoogleProductCategory6Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for GoogleProductCategory6Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<GoogleProductCategory6Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GoogleProductCategory6Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into GoogleProductCategory6Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Granularity {
    #[serde(rename = "TOTAL")]
    TOTAL,
    #[serde(rename = "DAY")]
    DAY,
    #[serde(rename = "HOUR")]
    HOUR,
    #[serde(rename = "WEEK")]
    WEEK,
    #[serde(rename = "MONTH")]
    MONTH,
}

impl std::fmt::Display for Granularity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Granularity::TOTAL => write!(f, "{}", "TOTAL"),
            Granularity::DAY => write!(f, "{}", "DAY"),
            Granularity::HOUR => write!(f, "{}", "HOUR"),
            Granularity::WEEK => write!(f, "{}", "WEEK"),
            Granularity::MONTH => write!(f, "{}", "MONTH"),
        }
    }
}

impl std::str::FromStr for Granularity {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "TOTAL" => std::result::Result::Ok(Granularity::TOTAL),
            "DAY" => std::result::Result::Ok(Granularity::DAY),
            "HOUR" => std::result::Result::Ok(Granularity::HOUR),
            "WEEK" => std::result::Result::Ok(Granularity::WEEK),
            "MONTH" => std::result::Result::Ok(Granularity::MONTH),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ImageDetails {
    #[serde(rename = "width")]
    pub width: usize,

    #[serde(rename = "height")]
    pub height: swagger::Nullable<usize>,

    #[serde(rename = "url")]
    pub url: String,

}

impl ImageDetails {
    pub fn new(width: usize, height: swagger::Nullable<usize>, url: String, ) -> ImageDetails {
        ImageDetails {
            width: width,
            height: height,
            url: url,
        }
    }
}

/// Converts the ImageDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ImageDetails {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("width".to_string());
        params.push(self.width.to_string());


        params.push("height".to_string());
        params.push(self.height.as_ref().map_or("null".to_string(), |x| x.to_string()));


        params.push("url".to_string());
        params.push(self.url.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ImageDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ImageDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub width: Vec<usize>,
            pub height: Vec<usize>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ImageDetails".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "width" => intermediate_rep.width.push(<usize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "height" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ImageDetails".to_string()),
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ImageDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ImageDetails {
            width: intermediate_rep.width.into_iter().next().ok_or("width missing in ImageDetails".to_string())?,
            height: std::result::Result::Err("Nullable types not supported in ImageDetails".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or("url missing in ImageDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ImageDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ImageDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ImageDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ImageDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ImageDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ImageDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ImageDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemAttributes {
    /// Allows advertisers to specify a separate URL that can be used to track traffic coming from Pinterest shopping ads. Must send full URL including trackingdo not send tracking parameters only. At this time we do not support impression tracking. Must begin with http:// or https://.
    #[serde(rename = "ad_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ad_link: Option<String>,

    /// The links to additional images for your product. Up to five additional images can be used to show a product from different angles or to show different stages. Separate each additional image with a comma. We recommend enclosing the whole string with quotes. Must begin with http:// or https://
    #[serde(rename = "additional_image_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub additional_image_link: Option<Vec<String>>,

    /// Set this attribute to TRUE if you're submitting items that are considered adult. These will not be shown on Pinterest.
    #[serde(rename = "adult")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub adult: Option<bool>,

    /// The age group to apply a demographic range to the product. Must be one of the following values: newborn, infant, toddler, kids, adult.
    #[serde(rename = "age_group")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub age_group: Option<String>,

    /// The availability of the product. Must be one of the following values: in stock, out of stock, preorder.
    #[serde(rename = "availability")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub availability: Option<String>,

    /// Average reviews for the item. Can be a number from 1-5.
    #[serde(rename = "average_review_rating")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub average_review_rating: Option<f64>,

    /// The brand of the product.
    #[serde(rename = "brand")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub brand: Option<String>,

    /// The primary color of the product.
    #[serde(rename = "color")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub color: Option<String>,

    /// The condition of the product. Must be one of the following values: new, used, refurbished.
    #[serde(rename = "condition")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition: Option<String>,

    /// Custom grouping of products.
    #[serde(rename = "custom_label_0")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_0: Option<String>,

    /// Custom grouping of products.
    #[serde(rename = "custom_label_1")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_1: Option<String>,

    /// Custom grouping of products.
    #[serde(rename = "custom_label_2")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_2: Option<String>,

    /// Custom grouping of products.
    #[serde(rename = "custom_label_3")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_3: Option<String>,

    /// Custom grouping of products.
    #[serde(rename = "custom_label_4")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub custom_label_4: Option<String>,

    /// The description of the product.
    #[serde(rename = "description")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    /// The item is free to ship.
    #[serde(rename = "free_shipping_label")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_shipping_label: Option<bool>,

    /// The minimum order purchase necessary for the customer to get free shipping. Only relevant if free shipping is offered.
    #[serde(rename = "free_shipping_limit")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub free_shipping_limit: Option<String>,

    /// The gender associated with the product. Must be one of the following values: male, female, unisex.
    #[serde(rename = "gender")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender: Option<String>,

    /// The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
    #[serde(rename = "google_product_category")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub google_product_category: Option<String>,

    /// The unique universal product identifier.
    #[serde(rename = "gtin")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gtin: Option<isize>,

    /// The user-created unique ID that represents the product. Only Unicode characters are accepted.
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    /// The link to the main product images. Images should be at least 75x75 pixels to avoid errors. Use the additional_image_link field to add more images of your product. The URL of your image_link must be accessible by the Pinterest user-agent, and send the accurate images. Please make sure there are no template or placeholder images at the link. Must start with http:// or https://
    #[serde(rename = "image_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub image_link: Option<Vec<String>>,

    /// The parent ID of the product.
    #[serde(rename = "item_group_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_group_id: Option<String>,

    /// The millisecond timestamp when the item was lastly modified by the merchant.
    #[serde(rename = "last_updated_time")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub last_updated_time: Option<i64>,

    /// The landing page for the product.
    #[serde(rename = "link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<String>,

    /// The material used to make the product.
    #[serde(rename = "material")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub material: Option<String>,

    /// The minimum advertised price of the product. It supports the following formats, \"19.99 USD\", \"19.99USD\" and \"19.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "min_ad_price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_ad_price: Option<String>,

    /// The mobile-optimized version of your landing page. Must begin with http:// or https://.
    #[serde(rename = "mobile_link")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mobile_link: Option<String>,

    /// Manufacturer Part Number are alpha-numeric codes created by the manufacturer of a product to uniquely identify it among all products from the same manufacturer.
    #[serde(rename = "mpn")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub mpn: Option<String>,

    /// The number of ratings for the item.
    #[serde(rename = "number_of_ratings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_ratings: Option<isize>,

    /// The number of reviews available for the item.
    #[serde(rename = "number_of_reviews")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub number_of_reviews: Option<isize>,

    /// The description of the pattern used for the product.
    #[serde(rename = "pattern")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pattern: Option<String>,

    /// The price of the product. It supports the following formats, \"24.99 USD\", \"24.99USD\" and \"24.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub price: Option<String>,

    /// The categorization of your product based on your custom product taxonomy. Subcategories must be sent separated by  > . The > must be wrapped by spaces. We do not recognize any other delimiters such as comma or pipe.
    #[serde(rename = "product_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub product_type: Option<String>,

    /// The discounted price of the product. The sale_price must be lower than the price. It supports the following formats, \"14.99 USD\", \"14.99USD\" and \"14.99\". If the currency is not included, we default to US dollars.
    #[serde(rename = "sale_price")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub sale_price: Option<String>,

    /// Shipping consists of one group of up to four elements, country, region, service (all optional) and price (required). All colons, even for blank values, are required.
    #[serde(rename = "shipping")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping: Option<String>,

    /// The height of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_height")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_height: Option<String>,

    /// The weight of the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_weight")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_weight: Option<String>,

    /// The width of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
    #[serde(rename = "shipping_width")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub shipping_width: Option<String>,

    /// The size of the product.
    #[serde(rename = "size")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size: Option<String>,

    /// Indicates the countrys sizing system in which you are submitting your product.
    #[serde(rename = "size_system")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_system: Option<String>,

    /// Additional description for the size. Must be one of the following values: regular, petite, plus, big_and_tall, maternity.
    #[serde(rename = "size_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub size_type: Option<String>,

    /// Tax consists of one group of up to four elements, country, region, rate (all required) and tax_ship (optional). All colons, even for blank values, are required.
    #[serde(rename = "tax")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub tax: Option<String>,

    /// The name of the product.
    #[serde(rename = "title")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<String>,

}

impl ItemAttributes {
    pub fn new() -> ItemAttributes {
        ItemAttributes {
            ad_link: None,
            additional_image_link: None,
            adult: None,
            age_group: None,
            availability: None,
            average_review_rating: None,
            brand: None,
            color: None,
            condition: None,
            custom_label_0: None,
            custom_label_1: None,
            custom_label_2: None,
            custom_label_3: None,
            custom_label_4: None,
            description: None,
            free_shipping_label: None,
            free_shipping_limit: None,
            gender: None,
            google_product_category: None,
            gtin: None,
            id: None,
            image_link: None,
            item_group_id: None,
            last_updated_time: None,
            link: None,
            material: None,
            min_ad_price: None,
            mobile_link: None,
            mpn: None,
            number_of_ratings: None,
            number_of_reviews: None,
            pattern: None,
            price: None,
            product_type: None,
            sale_price: None,
            shipping: None,
            shipping_height: None,
            shipping_weight: None,
            shipping_width: None,
            size: None,
            size_system: None,
            size_type: None,
            tax: None,
            title: None,
        }
    }
}

/// Converts the ItemAttributes value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ItemAttributes {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref ad_link) = self.ad_link {
            params.push("ad_link".to_string());
            params.push(ad_link.to_string());
        }


        if let Some(ref additional_image_link) = self.additional_image_link {
            params.push("additional_image_link".to_string());
            params.push(additional_image_link.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref adult) = self.adult {
            params.push("adult".to_string());
            params.push(adult.to_string());
        }


        if let Some(ref age_group) = self.age_group {
            params.push("age_group".to_string());
            params.push(age_group.to_string());
        }


        if let Some(ref availability) = self.availability {
            params.push("availability".to_string());
            params.push(availability.to_string());
        }


        if let Some(ref average_review_rating) = self.average_review_rating {
            params.push("average_review_rating".to_string());
            params.push(average_review_rating.to_string());
        }


        if let Some(ref brand) = self.brand {
            params.push("brand".to_string());
            params.push(brand.to_string());
        }


        if let Some(ref color) = self.color {
            params.push("color".to_string());
            params.push(color.to_string());
        }


        if let Some(ref condition) = self.condition {
            params.push("condition".to_string());
            params.push(condition.to_string());
        }


        if let Some(ref custom_label_0) = self.custom_label_0 {
            params.push("custom_label_0".to_string());
            params.push(custom_label_0.to_string());
        }


        if let Some(ref custom_label_1) = self.custom_label_1 {
            params.push("custom_label_1".to_string());
            params.push(custom_label_1.to_string());
        }


        if let Some(ref custom_label_2) = self.custom_label_2 {
            params.push("custom_label_2".to_string());
            params.push(custom_label_2.to_string());
        }


        if let Some(ref custom_label_3) = self.custom_label_3 {
            params.push("custom_label_3".to_string());
            params.push(custom_label_3.to_string());
        }


        if let Some(ref custom_label_4) = self.custom_label_4 {
            params.push("custom_label_4".to_string());
            params.push(custom_label_4.to_string());
        }


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.to_string());
        }


        if let Some(ref free_shipping_label) = self.free_shipping_label {
            params.push("free_shipping_label".to_string());
            params.push(free_shipping_label.to_string());
        }


        if let Some(ref free_shipping_limit) = self.free_shipping_limit {
            params.push("free_shipping_limit".to_string());
            params.push(free_shipping_limit.to_string());
        }


        if let Some(ref gender) = self.gender {
            params.push("gender".to_string());
            params.push(gender.to_string());
        }


        if let Some(ref google_product_category) = self.google_product_category {
            params.push("google_product_category".to_string());
            params.push(google_product_category.to_string());
        }


        if let Some(ref gtin) = self.gtin {
            params.push("gtin".to_string());
            params.push(gtin.to_string());
        }


        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }


        if let Some(ref image_link) = self.image_link {
            params.push("image_link".to_string());
            params.push(image_link.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref item_group_id) = self.item_group_id {
            params.push("item_group_id".to_string());
            params.push(item_group_id.to_string());
        }


        if let Some(ref last_updated_time) = self.last_updated_time {
            params.push("last_updated_time".to_string());
            params.push(last_updated_time.to_string());
        }


        if let Some(ref link) = self.link {
            params.push("link".to_string());
            params.push(link.to_string());
        }


        if let Some(ref material) = self.material {
            params.push("material".to_string());
            params.push(material.to_string());
        }


        if let Some(ref min_ad_price) = self.min_ad_price {
            params.push("min_ad_price".to_string());
            params.push(min_ad_price.to_string());
        }


        if let Some(ref mobile_link) = self.mobile_link {
            params.push("mobile_link".to_string());
            params.push(mobile_link.to_string());
        }


        if let Some(ref mpn) = self.mpn {
            params.push("mpn".to_string());
            params.push(mpn.to_string());
        }


        if let Some(ref number_of_ratings) = self.number_of_ratings {
            params.push("number_of_ratings".to_string());
            params.push(number_of_ratings.to_string());
        }


        if let Some(ref number_of_reviews) = self.number_of_reviews {
            params.push("number_of_reviews".to_string());
            params.push(number_of_reviews.to_string());
        }


        if let Some(ref pattern) = self.pattern {
            params.push("pattern".to_string());
            params.push(pattern.to_string());
        }


        if let Some(ref price) = self.price {
            params.push("price".to_string());
            params.push(price.to_string());
        }


        if let Some(ref product_type) = self.product_type {
            params.push("product_type".to_string());
            params.push(product_type.to_string());
        }


        if let Some(ref sale_price) = self.sale_price {
            params.push("sale_price".to_string());
            params.push(sale_price.to_string());
        }


        if let Some(ref shipping) = self.shipping {
            params.push("shipping".to_string());
            params.push(shipping.to_string());
        }


        if let Some(ref shipping_height) = self.shipping_height {
            params.push("shipping_height".to_string());
            params.push(shipping_height.to_string());
        }


        if let Some(ref shipping_weight) = self.shipping_weight {
            params.push("shipping_weight".to_string());
            params.push(shipping_weight.to_string());
        }


        if let Some(ref shipping_width) = self.shipping_width {
            params.push("shipping_width".to_string());
            params.push(shipping_width.to_string());
        }


        if let Some(ref size) = self.size {
            params.push("size".to_string());
            params.push(size.to_string());
        }


        if let Some(ref size_system) = self.size_system {
            params.push("size_system".to_string());
            params.push(size_system.to_string());
        }


        if let Some(ref size_type) = self.size_type {
            params.push("size_type".to_string());
            params.push(size_type.to_string());
        }


        if let Some(ref tax) = self.tax {
            params.push("tax".to_string());
            params.push(tax.to_string());
        }


        if let Some(ref title) = self.title {
            params.push("title".to_string());
            params.push(title.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemAttributes value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemAttributes {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub ad_link: Vec<String>,
            pub additional_image_link: Vec<Vec<String>>,
            pub adult: Vec<bool>,
            pub age_group: Vec<String>,
            pub availability: Vec<String>,
            pub average_review_rating: Vec<f64>,
            pub brand: Vec<String>,
            pub color: Vec<String>,
            pub condition: Vec<String>,
            pub custom_label_0: Vec<String>,
            pub custom_label_1: Vec<String>,
            pub custom_label_2: Vec<String>,
            pub custom_label_3: Vec<String>,
            pub custom_label_4: Vec<String>,
            pub description: Vec<String>,
            pub free_shipping_label: Vec<bool>,
            pub free_shipping_limit: Vec<String>,
            pub gender: Vec<String>,
            pub google_product_category: Vec<String>,
            pub gtin: Vec<isize>,
            pub id: Vec<String>,
            pub image_link: Vec<Vec<String>>,
            pub item_group_id: Vec<String>,
            pub last_updated_time: Vec<i64>,
            pub link: Vec<String>,
            pub material: Vec<String>,
            pub min_ad_price: Vec<String>,
            pub mobile_link: Vec<String>,
            pub mpn: Vec<String>,
            pub number_of_ratings: Vec<isize>,
            pub number_of_reviews: Vec<isize>,
            pub pattern: Vec<String>,
            pub price: Vec<String>,
            pub product_type: Vec<String>,
            pub sale_price: Vec<String>,
            pub shipping: Vec<String>,
            pub shipping_height: Vec<String>,
            pub shipping_weight: Vec<String>,
            pub shipping_width: Vec<String>,
            pub size: Vec<String>,
            pub size_system: Vec<String>,
            pub size_type: Vec<String>,
            pub tax: Vec<String>,
            pub title: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemAttributes".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ad_link" => intermediate_rep.ad_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "additional_image_link" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributes".to_string()),
                    "adult" => intermediate_rep.adult.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "age_group" => intermediate_rep.age_group.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "availability" => intermediate_rep.availability.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "average_review_rating" => intermediate_rep.average_review_rating.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "brand" => intermediate_rep.brand.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "color" => intermediate_rep.color.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "condition" => intermediate_rep.condition.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "custom_label_0" => intermediate_rep.custom_label_0.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "custom_label_1" => intermediate_rep.custom_label_1.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "custom_label_2" => intermediate_rep.custom_label_2.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "custom_label_3" => intermediate_rep.custom_label_3.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "custom_label_4" => intermediate_rep.custom_label_4.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "free_shipping_label" => intermediate_rep.free_shipping_label.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "free_shipping_limit" => intermediate_rep.free_shipping_limit.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "gender" => intermediate_rep.gender.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "google_product_category" => intermediate_rep.google_product_category.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "gtin" => intermediate_rep.gtin.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "image_link" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributes".to_string()),
                    "item_group_id" => intermediate_rep.item_group_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "last_updated_time" => intermediate_rep.last_updated_time.push(<i64 as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "link" => intermediate_rep.link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "material" => intermediate_rep.material.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "min_ad_price" => intermediate_rep.min_ad_price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "mobile_link" => intermediate_rep.mobile_link.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "mpn" => intermediate_rep.mpn.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "number_of_ratings" => intermediate_rep.number_of_ratings.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "number_of_reviews" => intermediate_rep.number_of_reviews.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "pattern" => intermediate_rep.pattern.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "price" => intermediate_rep.price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "product_type" => intermediate_rep.product_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "sale_price" => intermediate_rep.sale_price.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shipping" => intermediate_rep.shipping.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shipping_height" => intermediate_rep.shipping_height.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shipping_weight" => intermediate_rep.shipping_weight.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "shipping_width" => intermediate_rep.shipping_width.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "size" => intermediate_rep.size.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "size_system" => intermediate_rep.size_system.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "size_type" => intermediate_rep.size_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "tax" => intermediate_rep.tax.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "title" => intermediate_rep.title.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemAttributes".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemAttributes {
            ad_link: intermediate_rep.ad_link.into_iter().next(),
            additional_image_link: intermediate_rep.additional_image_link.into_iter().next(),
            adult: intermediate_rep.adult.into_iter().next(),
            age_group: intermediate_rep.age_group.into_iter().next(),
            availability: intermediate_rep.availability.into_iter().next(),
            average_review_rating: intermediate_rep.average_review_rating.into_iter().next(),
            brand: intermediate_rep.brand.into_iter().next(),
            color: intermediate_rep.color.into_iter().next(),
            condition: intermediate_rep.condition.into_iter().next(),
            custom_label_0: intermediate_rep.custom_label_0.into_iter().next(),
            custom_label_1: intermediate_rep.custom_label_1.into_iter().next(),
            custom_label_2: intermediate_rep.custom_label_2.into_iter().next(),
            custom_label_3: intermediate_rep.custom_label_3.into_iter().next(),
            custom_label_4: intermediate_rep.custom_label_4.into_iter().next(),
            description: intermediate_rep.description.into_iter().next(),
            free_shipping_label: intermediate_rep.free_shipping_label.into_iter().next(),
            free_shipping_limit: intermediate_rep.free_shipping_limit.into_iter().next(),
            gender: intermediate_rep.gender.into_iter().next(),
            google_product_category: intermediate_rep.google_product_category.into_iter().next(),
            gtin: intermediate_rep.gtin.into_iter().next(),
            id: intermediate_rep.id.into_iter().next(),
            image_link: intermediate_rep.image_link.into_iter().next(),
            item_group_id: intermediate_rep.item_group_id.into_iter().next(),
            last_updated_time: intermediate_rep.last_updated_time.into_iter().next(),
            link: intermediate_rep.link.into_iter().next(),
            material: intermediate_rep.material.into_iter().next(),
            min_ad_price: intermediate_rep.min_ad_price.into_iter().next(),
            mobile_link: intermediate_rep.mobile_link.into_iter().next(),
            mpn: intermediate_rep.mpn.into_iter().next(),
            number_of_ratings: intermediate_rep.number_of_ratings.into_iter().next(),
            number_of_reviews: intermediate_rep.number_of_reviews.into_iter().next(),
            pattern: intermediate_rep.pattern.into_iter().next(),
            price: intermediate_rep.price.into_iter().next(),
            product_type: intermediate_rep.product_type.into_iter().next(),
            sale_price: intermediate_rep.sale_price.into_iter().next(),
            shipping: intermediate_rep.shipping.into_iter().next(),
            shipping_height: intermediate_rep.shipping_height.into_iter().next(),
            shipping_weight: intermediate_rep.shipping_weight.into_iter().next(),
            shipping_width: intermediate_rep.shipping_width.into_iter().next(),
            size: intermediate_rep.size.into_iter().next(),
            size_system: intermediate_rep.size_system.into_iter().next(),
            size_type: intermediate_rep.size_type.into_iter().next(),
            tax: intermediate_rep.tax.into_iter().next(),
            title: intermediate_rep.title.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemAttributes> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemAttributes>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemAttributes>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemAttributes - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ItemAttributes> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemAttributes as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemAttributes - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Object describing an item batch record
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemBatchRecord {
    /// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

    #[serde(rename = "attributes")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attributes: Option<models::ItemAttributes>,

}

impl ItemBatchRecord {
    pub fn new() -> ItemBatchRecord {
        ItemBatchRecord {
            item_id: None,
            attributes: None,
        }
    }
}

/// Converts the ItemBatchRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ItemBatchRecord {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref item_id) = self.item_id {
            params.push("item_id".to_string());
            params.push(item_id.to_string());
        }

        // Skipping attributes in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemBatchRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemBatchRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub attributes: Vec<models::ItemAttributes>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemBatchRecord".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "attributes" => intermediate_rep.attributes.push(<models::ItemAttributes as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemBatchRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemBatchRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
            attributes: intermediate_rep.attributes.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemBatchRecord> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemBatchRecord>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemBatchRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemBatchRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ItemBatchRecord> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemBatchRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemBatchRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemGroupIdFilter {
    #[serde(rename = "ITEM_GROUP_ID")]
    pub item_group_id: models::CatalogsProductGroupMultipleStringCriteria,

}

impl ItemGroupIdFilter {
    pub fn new(item_group_id: models::CatalogsProductGroupMultipleStringCriteria, ) -> ItemGroupIdFilter {
        ItemGroupIdFilter {
            item_group_id: item_group_id,
        }
    }
}

/// Converts the ItemGroupIdFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ItemGroupIdFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping ITEM_GROUP_ID in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemGroupIdFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemGroupIdFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub item_group_id: Vec<models::CatalogsProductGroupMultipleStringCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemGroupIdFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ITEM_GROUP_ID" => intermediate_rep.item_group_id.push(<models::CatalogsProductGroupMultipleStringCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemGroupIdFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemGroupIdFilter {
            item_group_id: intermediate_rep.item_group_id.into_iter().next().ok_or("ITEM_GROUP_ID missing in ItemGroupIdFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemGroupIdFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemGroupIdFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemGroupIdFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemGroupIdFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ItemGroupIdFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemGroupIdFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemGroupIdFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemIdFilter {
    #[serde(rename = "ITEM_ID")]
    pub item_id: models::CatalogsProductGroupCurrencyCriteria,

}

impl ItemIdFilter {
    pub fn new(item_id: models::CatalogsProductGroupCurrencyCriteria, ) -> ItemIdFilter {
        ItemIdFilter {
            item_id: item_id,
        }
    }
}

/// Converts the ItemIdFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ItemIdFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping ITEM_ID in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemIdFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemIdFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub item_id: Vec<models::CatalogsProductGroupCurrencyCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemIdFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "ITEM_ID" => intermediate_rep.item_id.push(<models::CatalogsProductGroupCurrencyCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemIdFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemIdFilter {
            item_id: intermediate_rep.item_id.into_iter().next().ok_or("ITEM_ID missing in ItemIdFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemIdFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemIdFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemIdFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemIdFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ItemIdFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemIdFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemIdFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Object describing an item processing record
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemProcessingRecord {
    /// The catalog item id in the merchant namespace
    #[serde(rename = "item_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub item_id: Option<String>,

    /// Array with the validation errors for the item processing record. A non empty errors list causes the item processing to fail.
    #[serde(rename = "errors")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub errors: Option<Vec<models::ItemValidationEvent>>,

    /// Array with the validation warnings for the item processing record
    #[serde(rename = "warnings")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub warnings: Option<Vec<models::ItemValidationEvent>>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<models::ItemProcessingStatus>,

}

impl ItemProcessingRecord {
    pub fn new() -> ItemProcessingRecord {
        ItemProcessingRecord {
            item_id: None,
            errors: None,
            warnings: None,
            status: None,
        }
    }
}

/// Converts the ItemProcessingRecord value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ItemProcessingRecord {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref item_id) = self.item_id {
            params.push("item_id".to_string());
            params.push(item_id.to_string());
        }

        // Skipping errors in query parameter serialization

        // Skipping warnings in query parameter serialization

        // Skipping status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemProcessingRecord value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemProcessingRecord {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub item_id: Vec<String>,
            pub errors: Vec<Vec<models::ItemValidationEvent>>,
            pub warnings: Vec<Vec<models::ItemValidationEvent>>,
            pub status: Vec<models::ItemProcessingStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemProcessingRecord".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "item_id" => intermediate_rep.item_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "errors" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemProcessingRecord".to_string()),
                    "warnings" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemProcessingRecord".to_string()),
                    "status" => intermediate_rep.status.push(<models::ItemProcessingStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemProcessingRecord".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemProcessingRecord {
            item_id: intermediate_rep.item_id.into_iter().next(),
            errors: intermediate_rep.errors.into_iter().next(),
            warnings: intermediate_rep.warnings.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemProcessingRecord> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemProcessingRecord>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemProcessingRecord>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemProcessingRecord - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ItemProcessingRecord> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemProcessingRecord as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemProcessingRecord - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The status of the item processing record
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ItemProcessingStatus {
    #[serde(rename = "SUCCESS")]
    SUCCESS,
    #[serde(rename = "FAILURE")]
    FAILURE,
    #[serde(rename = "PROCESSING")]
    PROCESSING,
}

impl std::fmt::Display for ItemProcessingStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ItemProcessingStatus::SUCCESS => write!(f, "{}", "SUCCESS"),
            ItemProcessingStatus::FAILURE => write!(f, "{}", "FAILURE"),
            ItemProcessingStatus::PROCESSING => write!(f, "{}", "PROCESSING"),
        }
    }
}

impl std::str::FromStr for ItemProcessingStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SUCCESS" => std::result::Result::Ok(ItemProcessingStatus::SUCCESS),
            "FAILURE" => std::result::Result::Ok(ItemProcessingStatus::FAILURE),
            "PROCESSING" => std::result::Result::Ok(ItemProcessingStatus::PROCESSING),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Object describing an item validation event
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemValidationEvent {
    /// The attribute that the item validation event references
    #[serde(rename = "attribute")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub attribute: Option<String>,

    /// The event code that the item validation event references
    #[serde(rename = "code")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub code: Option<isize>,

    /// Title message describing the item validation event
    #[serde(rename = "message")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub message: Option<String>,

}

impl ItemValidationEvent {
    pub fn new() -> ItemValidationEvent {
        ItemValidationEvent {
            attribute: None,
            code: None,
            message: None,
        }
    }
}

/// Converts the ItemValidationEvent value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ItemValidationEvent {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref attribute) = self.attribute {
            params.push("attribute".to_string());
            params.push(attribute.to_string());
        }


        if let Some(ref code) = self.code {
            params.push("code".to_string());
            params.push(code.to_string());
        }


        if let Some(ref message) = self.message {
            params.push("message".to_string());
            params.push(message.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemValidationEvent value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemValidationEvent {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub attribute: Vec<String>,
            pub code: Vec<isize>,
            pub message: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemValidationEvent".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "attribute" => intermediate_rep.attribute.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "code" => intermediate_rep.code.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "message" => intermediate_rep.message.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemValidationEvent".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemValidationEvent {
            attribute: intermediate_rep.attribute.into_iter().next(),
            code: intermediate_rep.code.into_iter().next(),
            message: intermediate_rep.message.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemValidationEvent> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemValidationEvent>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemValidationEvent>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ItemValidationEvent - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ItemValidationEvent> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemValidationEvent as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ItemValidationEvent - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Language code, which is among the offical ISO 639-1 language list.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum Language {
    #[serde(rename = "AM")]
    AM,
    #[serde(rename = "AR")]
    AR,
    #[serde(rename = "AZ")]
    AZ,
    #[serde(rename = "BG")]
    BG,
    #[serde(rename = "BN")]
    BN,
    #[serde(rename = "BS")]
    BS,
    #[serde(rename = "CA")]
    CA,
    #[serde(rename = "CS")]
    CS,
    #[serde(rename = "DA")]
    DA,
    #[serde(rename = "DV")]
    DV,
    #[serde(rename = "DZ")]
    DZ,
    #[serde(rename = "DE")]
    DE,
    #[serde(rename = "EL")]
    EL,
    #[serde(rename = "EN")]
    EN,
    #[serde(rename = "ES")]
    ES,
    #[serde(rename = "ET")]
    ET,
    #[serde(rename = "FA")]
    FA,
    #[serde(rename = "FI")]
    FI,
    #[serde(rename = "FR")]
    FR,
    #[serde(rename = "HE")]
    HE,
    #[serde(rename = "HI")]
    HI,
    #[serde(rename = "HR")]
    HR,
    #[serde(rename = "HU")]
    HU,
    #[serde(rename = "HY")]
    HY,
    #[serde(rename = "ID")]
    ID,
    #[serde(rename = "IN")]
    IN,
    #[serde(rename = "IS")]
    IS,
    #[serde(rename = "IT")]
    IT,
    #[serde(rename = "IW")]
    IW,
    #[serde(rename = "JA")]
    JA,
    #[serde(rename = "KA")]
    KA,
    #[serde(rename = "KM")]
    KM,
    #[serde(rename = "KO")]
    KO,
    #[serde(rename = "LO")]
    LO,
    #[serde(rename = "LT")]
    LT,
    #[serde(rename = "LV")]
    LV,
    #[serde(rename = "MK")]
    MK,
    #[serde(rename = "MN")]
    MN,
    #[serde(rename = "MS")]
    MS,
    #[serde(rename = "MY")]
    MY,
    #[serde(rename = "NB")]
    NB,
    #[serde(rename = "NE")]
    NE,
    #[serde(rename = "NL")]
    NL,
    #[serde(rename = "NO")]
    NO,
    #[serde(rename = "PL")]
    PL,
    #[serde(rename = "PT")]
    PT,
    #[serde(rename = "RO")]
    RO,
    #[serde(rename = "RU")]
    RU,
    #[serde(rename = "SK")]
    SK,
    #[serde(rename = "SL")]
    SL,
    #[serde(rename = "SQ")]
    SQ,
    #[serde(rename = "SR")]
    SR,
    #[serde(rename = "SV")]
    SV,
    #[serde(rename = "TL")]
    TL,
    #[serde(rename = "UK")]
    UK,
    #[serde(rename = "VI")]
    VI,
    #[serde(rename = "TE")]
    TE,
    #[serde(rename = "TH")]
    TH,
    #[serde(rename = "TR")]
    TR,
    #[serde(rename = "XX")]
    XX,
    #[serde(rename = "ZH")]
    ZH,
}

impl std::fmt::Display for Language {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            Language::AM => write!(f, "{}", "AM"),
            Language::AR => write!(f, "{}", "AR"),
            Language::AZ => write!(f, "{}", "AZ"),
            Language::BG => write!(f, "{}", "BG"),
            Language::BN => write!(f, "{}", "BN"),
            Language::BS => write!(f, "{}", "BS"),
            Language::CA => write!(f, "{}", "CA"),
            Language::CS => write!(f, "{}", "CS"),
            Language::DA => write!(f, "{}", "DA"),
            Language::DV => write!(f, "{}", "DV"),
            Language::DZ => write!(f, "{}", "DZ"),
            Language::DE => write!(f, "{}", "DE"),
            Language::EL => write!(f, "{}", "EL"),
            Language::EN => write!(f, "{}", "EN"),
            Language::ES => write!(f, "{}", "ES"),
            Language::ET => write!(f, "{}", "ET"),
            Language::FA => write!(f, "{}", "FA"),
            Language::FI => write!(f, "{}", "FI"),
            Language::FR => write!(f, "{}", "FR"),
            Language::HE => write!(f, "{}", "HE"),
            Language::HI => write!(f, "{}", "HI"),
            Language::HR => write!(f, "{}", "HR"),
            Language::HU => write!(f, "{}", "HU"),
            Language::HY => write!(f, "{}", "HY"),
            Language::ID => write!(f, "{}", "ID"),
            Language::IN => write!(f, "{}", "IN"),
            Language::IS => write!(f, "{}", "IS"),
            Language::IT => write!(f, "{}", "IT"),
            Language::IW => write!(f, "{}", "IW"),
            Language::JA => write!(f, "{}", "JA"),
            Language::KA => write!(f, "{}", "KA"),
            Language::KM => write!(f, "{}", "KM"),
            Language::KO => write!(f, "{}", "KO"),
            Language::LO => write!(f, "{}", "LO"),
            Language::LT => write!(f, "{}", "LT"),
            Language::LV => write!(f, "{}", "LV"),
            Language::MK => write!(f, "{}", "MK"),
            Language::MN => write!(f, "{}", "MN"),
            Language::MS => write!(f, "{}", "MS"),
            Language::MY => write!(f, "{}", "MY"),
            Language::NB => write!(f, "{}", "NB"),
            Language::NE => write!(f, "{}", "NE"),
            Language::NL => write!(f, "{}", "NL"),
            Language::NO => write!(f, "{}", "NO"),
            Language::PL => write!(f, "{}", "PL"),
            Language::PT => write!(f, "{}", "PT"),
            Language::RO => write!(f, "{}", "RO"),
            Language::RU => write!(f, "{}", "RU"),
            Language::SK => write!(f, "{}", "SK"),
            Language::SL => write!(f, "{}", "SL"),
            Language::SQ => write!(f, "{}", "SQ"),
            Language::SR => write!(f, "{}", "SR"),
            Language::SV => write!(f, "{}", "SV"),
            Language::TL => write!(f, "{}", "TL"),
            Language::UK => write!(f, "{}", "UK"),
            Language::VI => write!(f, "{}", "VI"),
            Language::TE => write!(f, "{}", "TE"),
            Language::TH => write!(f, "{}", "TH"),
            Language::TR => write!(f, "{}", "TR"),
            Language::XX => write!(f, "{}", "XX"),
            Language::ZH => write!(f, "{}", "ZH"),
        }
    }
}

impl std::str::FromStr for Language {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AM" => std::result::Result::Ok(Language::AM),
            "AR" => std::result::Result::Ok(Language::AR),
            "AZ" => std::result::Result::Ok(Language::AZ),
            "BG" => std::result::Result::Ok(Language::BG),
            "BN" => std::result::Result::Ok(Language::BN),
            "BS" => std::result::Result::Ok(Language::BS),
            "CA" => std::result::Result::Ok(Language::CA),
            "CS" => std::result::Result::Ok(Language::CS),
            "DA" => std::result::Result::Ok(Language::DA),
            "DV" => std::result::Result::Ok(Language::DV),
            "DZ" => std::result::Result::Ok(Language::DZ),
            "DE" => std::result::Result::Ok(Language::DE),
            "EL" => std::result::Result::Ok(Language::EL),
            "EN" => std::result::Result::Ok(Language::EN),
            "ES" => std::result::Result::Ok(Language::ES),
            "ET" => std::result::Result::Ok(Language::ET),
            "FA" => std::result::Result::Ok(Language::FA),
            "FI" => std::result::Result::Ok(Language::FI),
            "FR" => std::result::Result::Ok(Language::FR),
            "HE" => std::result::Result::Ok(Language::HE),
            "HI" => std::result::Result::Ok(Language::HI),
            "HR" => std::result::Result::Ok(Language::HR),
            "HU" => std::result::Result::Ok(Language::HU),
            "HY" => std::result::Result::Ok(Language::HY),
            "ID" => std::result::Result::Ok(Language::ID),
            "IN" => std::result::Result::Ok(Language::IN),
            "IS" => std::result::Result::Ok(Language::IS),
            "IT" => std::result::Result::Ok(Language::IT),
            "IW" => std::result::Result::Ok(Language::IW),
            "JA" => std::result::Result::Ok(Language::JA),
            "KA" => std::result::Result::Ok(Language::KA),
            "KM" => std::result::Result::Ok(Language::KM),
            "KO" => std::result::Result::Ok(Language::KO),
            "LO" => std::result::Result::Ok(Language::LO),
            "LT" => std::result::Result::Ok(Language::LT),
            "LV" => std::result::Result::Ok(Language::LV),
            "MK" => std::result::Result::Ok(Language::MK),
            "MN" => std::result::Result::Ok(Language::MN),
            "MS" => std::result::Result::Ok(Language::MS),
            "MY" => std::result::Result::Ok(Language::MY),
            "NB" => std::result::Result::Ok(Language::NB),
            "NE" => std::result::Result::Ok(Language::NE),
            "NL" => std::result::Result::Ok(Language::NL),
            "NO" => std::result::Result::Ok(Language::NO),
            "PL" => std::result::Result::Ok(Language::PL),
            "PT" => std::result::Result::Ok(Language::PT),
            "RO" => std::result::Result::Ok(Language::RO),
            "RU" => std::result::Result::Ok(Language::RU),
            "SK" => std::result::Result::Ok(Language::SK),
            "SL" => std::result::Result::Ok(Language::SL),
            "SQ" => std::result::Result::Ok(Language::SQ),
            "SR" => std::result::Result::Ok(Language::SR),
            "SV" => std::result::Result::Ok(Language::SV),
            "TL" => std::result::Result::Ok(Language::TL),
            "UK" => std::result::Result::Ok(Language::UK),
            "VI" => std::result::Result::Ok(Language::VI),
            "TE" => std::result::Result::Ok(Language::TE),
            "TH" => std::result::Result::Ok(Language::TH),
            "TR" => std::result::Result::Ok(Language::TR),
            "XX" => std::result::Result::Ok(Language::XX),
            "ZH" => std::result::Result::Ok(Language::ZH),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MaxPriceFilter {
    #[serde(rename = "MAX_PRICE")]
    pub max_price: models::CatalogsProductGroupPricingCriteria,

}

impl MaxPriceFilter {
    pub fn new(max_price: models::CatalogsProductGroupPricingCriteria, ) -> MaxPriceFilter {
        MaxPriceFilter {
            max_price: max_price,
        }
    }
}

/// Converts the MaxPriceFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MaxPriceFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping MAX_PRICE in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MaxPriceFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MaxPriceFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub max_price: Vec<models::CatalogsProductGroupPricingCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MaxPriceFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "MAX_PRICE" => intermediate_rep.max_price.push(<models::CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MaxPriceFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MaxPriceFilter {
            max_price: intermediate_rep.max_price.into_iter().next().ok_or("MAX_PRICE missing in MaxPriceFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MaxPriceFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MaxPriceFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MaxPriceFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MaxPriceFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MaxPriceFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MaxPriceFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MaxPriceFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Media upload that has been registered but not uploaded/processed yet.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUpload {
    /// Unique identifier for this media upload. Used to track status and for attaching during Pin creation.
    #[serde(rename = "media_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_id: Option<String>,

    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<MediaUploadType>,

    /// The URL where you will POST your media file.
    #[serde(rename = "upload_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_url: Option<String>,

    #[serde(rename = "upload_parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_parameters: Option<models::MediaUploadAllOfUploadParameters>,

}

impl MediaUpload {
    pub fn new() -> MediaUpload {
        MediaUpload {
            media_id: None,
            media_type: None,
            upload_url: None,
            upload_parameters: None,
        }
    }
}

/// Converts the MediaUpload value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MediaUpload {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref media_id) = self.media_id {
            params.push("media_id".to_string());
            params.push(media_id.to_string());
        }

        // Skipping media_type in query parameter serialization


        if let Some(ref upload_url) = self.upload_url {
            params.push("upload_url".to_string());
            params.push(upload_url.to_string());
        }

        // Skipping upload_parameters in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUpload value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUpload {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub media_id: Vec<String>,
            pub media_type: Vec<MediaUploadType>,
            pub upload_url: Vec<String>,
            pub upload_parameters: Vec<models::MediaUploadAllOfUploadParameters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUpload".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media_type" => intermediate_rep.media_type.push(<MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "upload_url" => intermediate_rep.upload_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "upload_parameters" => intermediate_rep.upload_parameters.push(<models::MediaUploadAllOfUploadParameters as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUpload".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUpload {
            media_id: intermediate_rep.media_id.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            upload_url: intermediate_rep.upload_url.into_iter().next(),
            upload_parameters: intermediate_rep.upload_parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUpload> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUpload>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUpload>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUpload - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MediaUpload> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUpload as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUpload - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadAllOf {
    /// Unique identifier for this media upload. Used to track status and for attaching during Pin creation.
    #[serde(rename = "media_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_id: Option<String>,

    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<MediaUploadType>,

    /// The URL where you will POST your media file.
    #[serde(rename = "upload_url")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_url: Option<String>,

    #[serde(rename = "upload_parameters")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub upload_parameters: Option<models::MediaUploadAllOfUploadParameters>,

}

impl MediaUploadAllOf {
    pub fn new() -> MediaUploadAllOf {
        MediaUploadAllOf {
            media_id: None,
            media_type: None,
            upload_url: None,
            upload_parameters: None,
        }
    }
}

/// Converts the MediaUploadAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MediaUploadAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref media_id) = self.media_id {
            params.push("media_id".to_string());
            params.push(media_id.to_string());
        }

        // Skipping media_type in query parameter serialization


        if let Some(ref upload_url) = self.upload_url {
            params.push("upload_url".to_string());
            params.push(upload_url.to_string());
        }

        // Skipping upload_parameters in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub media_id: Vec<String>,
            pub media_type: Vec<MediaUploadType>,
            pub upload_url: Vec<String>,
            pub upload_parameters: Vec<models::MediaUploadAllOfUploadParameters>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media_type" => intermediate_rep.media_type.push(<MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "upload_url" => intermediate_rep.upload_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "upload_parameters" => intermediate_rep.upload_parameters.push(<models::MediaUploadAllOfUploadParameters as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadAllOf {
            media_id: intermediate_rep.media_id.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            upload_url: intermediate_rep.upload_url.into_iter().next(),
            upload_parameters: intermediate_rep.upload_parameters.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MediaUploadAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// The list of parameter key/value pairs you will need to send with your POST request to upload your media file.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadAllOfUploadParameters {
    #[serde(rename = "x-amz-date")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_date: Option<String>,

    #[serde(rename = "x-amz-signature")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_signature: Option<String>,

    #[serde(rename = "x-amz-security-token")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_security_token: Option<String>,

    #[serde(rename = "x-amz-algorithm")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_algorithm: Option<String>,

    #[serde(rename = "key")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub key: Option<String>,

    #[serde(rename = "policy")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub policy: Option<String>,

    #[serde(rename = "x-amz-credential")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub x_amz_credential: Option<String>,

    #[serde(rename = "Content-Type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub content_type: Option<String>,

}

impl MediaUploadAllOfUploadParameters {
    pub fn new() -> MediaUploadAllOfUploadParameters {
        MediaUploadAllOfUploadParameters {
            x_amz_date: None,
            x_amz_signature: None,
            x_amz_security_token: None,
            x_amz_algorithm: None,
            key: None,
            policy: None,
            x_amz_credential: None,
            content_type: None,
        }
    }
}

/// Converts the MediaUploadAllOfUploadParameters value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MediaUploadAllOfUploadParameters {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref x_amz_date) = self.x_amz_date {
            params.push("x-amz-date".to_string());
            params.push(x_amz_date.to_string());
        }


        if let Some(ref x_amz_signature) = self.x_amz_signature {
            params.push("x-amz-signature".to_string());
            params.push(x_amz_signature.to_string());
        }


        if let Some(ref x_amz_security_token) = self.x_amz_security_token {
            params.push("x-amz-security-token".to_string());
            params.push(x_amz_security_token.to_string());
        }


        if let Some(ref x_amz_algorithm) = self.x_amz_algorithm {
            params.push("x-amz-algorithm".to_string());
            params.push(x_amz_algorithm.to_string());
        }


        if let Some(ref key) = self.key {
            params.push("key".to_string());
            params.push(key.to_string());
        }


        if let Some(ref policy) = self.policy {
            params.push("policy".to_string());
            params.push(policy.to_string());
        }


        if let Some(ref x_amz_credential) = self.x_amz_credential {
            params.push("x-amz-credential".to_string());
            params.push(x_amz_credential.to_string());
        }


        if let Some(ref content_type) = self.content_type {
            params.push("Content-Type".to_string());
            params.push(content_type.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadAllOfUploadParameters value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadAllOfUploadParameters {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub x_amz_date: Vec<String>,
            pub x_amz_signature: Vec<String>,
            pub x_amz_security_token: Vec<String>,
            pub x_amz_algorithm: Vec<String>,
            pub key: Vec<String>,
            pub policy: Vec<String>,
            pub x_amz_credential: Vec<String>,
            pub content_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadAllOfUploadParameters".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "x-amz-date" => intermediate_rep.x_amz_date.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "x-amz-signature" => intermediate_rep.x_amz_signature.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "x-amz-security-token" => intermediate_rep.x_amz_security_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "x-amz-algorithm" => intermediate_rep.x_amz_algorithm.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "key" => intermediate_rep.key.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "policy" => intermediate_rep.policy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "x-amz-credential" => intermediate_rep.x_amz_credential.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "Content-Type" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadAllOfUploadParameters".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadAllOfUploadParameters {
            x_amz_date: intermediate_rep.x_amz_date.into_iter().next(),
            x_amz_signature: intermediate_rep.x_amz_signature.into_iter().next(),
            x_amz_security_token: intermediate_rep.x_amz_security_token.into_iter().next(),
            x_amz_algorithm: intermediate_rep.x_amz_algorithm.into_iter().next(),
            key: intermediate_rep.key.into_iter().next(),
            policy: intermediate_rep.policy.into_iter().next(),
            x_amz_credential: intermediate_rep.x_amz_credential.into_iter().next(),
            content_type: intermediate_rep.content_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadAllOfUploadParameters> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadAllOfUploadParameters>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadAllOfUploadParameters>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadAllOfUploadParameters - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MediaUploadAllOfUploadParameters> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadAllOfUploadParameters as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadAllOfUploadParameters - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Media upload details
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadDetails {
    #[serde(rename = "media_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_id: Option<String>,

    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<MediaUploadType>,

    #[serde(rename = "status")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub status: Option<MediaUploadStatus>,

}

impl MediaUploadDetails {
    pub fn new() -> MediaUploadDetails {
        MediaUploadDetails {
            media_id: None,
            media_type: None,
            status: None,
        }
    }
}

/// Converts the MediaUploadDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MediaUploadDetails {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref media_id) = self.media_id {
            params.push("media_id".to_string());
            params.push(media_id.to_string());
        }

        // Skipping media_type in query parameter serialization

        // Skipping status in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub media_id: Vec<String>,
            pub media_type: Vec<MediaUploadType>,
            pub status: Vec<MediaUploadStatus>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadDetails".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media_type" => intermediate_rep.media_type.push(<MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "status" => intermediate_rep.status.push(<MediaUploadStatus as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadDetails {
            media_id: intermediate_rep.media_id.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
            status: intermediate_rep.status.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadDetails> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadDetails>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadDetails - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MediaUploadDetails> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadDetails - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Media upload request
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MediaUploadRequest {
    #[serde(rename = "media_type")]
    pub media_type: MediaUploadType,

}

impl MediaUploadRequest {
    pub fn new(media_type: MediaUploadType, ) -> MediaUploadRequest {
        MediaUploadRequest {
            media_type: media_type,
        }
    }
}

/// Converts the MediaUploadRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MediaUploadRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping media_type in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MediaUploadRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MediaUploadRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub media_type: Vec<MediaUploadType>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MediaUploadRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "media_type" => intermediate_rep.media_type.push(<MediaUploadType as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MediaUploadRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MediaUploadRequest {
            media_type: intermediate_rep.media_type.into_iter().next().ok_or("media_type missing in MediaUploadRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MediaUploadRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MediaUploadRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MediaUploadRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MediaUploadRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MediaUploadRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MediaUploadRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MediaUploadRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Media upload status
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MediaUploadStatus {
    #[serde(rename = "registered")]
    REGISTERED,
    #[serde(rename = "processing")]
    PROCESSING,
    #[serde(rename = "succeeded")]
    SUCCEEDED,
    #[serde(rename = "failed")]
    FAILED,
}

impl std::fmt::Display for MediaUploadStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MediaUploadStatus::REGISTERED => write!(f, "{}", "registered"),
            MediaUploadStatus::PROCESSING => write!(f, "{}", "processing"),
            MediaUploadStatus::SUCCEEDED => write!(f, "{}", "succeeded"),
            MediaUploadStatus::FAILED => write!(f, "{}", "failed"),
        }
    }
}

impl std::str::FromStr for MediaUploadStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "registered" => std::result::Result::Ok(MediaUploadStatus::REGISTERED),
            "processing" => std::result::Result::Ok(MediaUploadStatus::PROCESSING),
            "succeeded" => std::result::Result::Ok(MediaUploadStatus::SUCCEEDED),
            "failed" => std::result::Result::Ok(MediaUploadStatus::FAILED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MediaUploadType {
    #[serde(rename = "video")]
    VIDEO,
}

impl std::fmt::Display for MediaUploadType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MediaUploadType::VIDEO => write!(f, "{}", "video"),
        }
    }
}

impl std::str::FromStr for MediaUploadType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "video" => std::result::Result::Ok(MediaUploadType::VIDEO),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Level of the reporting request
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum MetricsReportingLevel {
    #[serde(rename = "ADVERTISER")]
    ADVERTISER,
    #[serde(rename = "ADVERTISER_TARGETING")]
    ADVERTISER_TARGETING,
    #[serde(rename = "CAMPAIGN")]
    CAMPAIGN,
    #[serde(rename = "CAMPAIGN_TARGETING")]
    CAMPAIGN_TARGETING,
    #[serde(rename = "AD_GROUP")]
    AD_GROUP,
    #[serde(rename = "AD_GROUP_TARGETING")]
    AD_GROUP_TARGETING,
    #[serde(rename = "PIN_PROMOTION")]
    PIN_PROMOTION,
    #[serde(rename = "PIN_PROMOTION_TARGETING")]
    PIN_PROMOTION_TARGETING,
    #[serde(rename = "KEYWORD")]
    KEYWORD,
    #[serde(rename = "PRODUCT_GROUP")]
    PRODUCT_GROUP,
    #[serde(rename = "PRODUCT_GROUP_TARGETING")]
    PRODUCT_GROUP_TARGETING,
    #[serde(rename = "PRODUCT_ITEM")]
    PRODUCT_ITEM,
}

impl std::fmt::Display for MetricsReportingLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            MetricsReportingLevel::ADVERTISER => write!(f, "{}", "ADVERTISER"),
            MetricsReportingLevel::ADVERTISER_TARGETING => write!(f, "{}", "ADVERTISER_TARGETING"),
            MetricsReportingLevel::CAMPAIGN => write!(f, "{}", "CAMPAIGN"),
            MetricsReportingLevel::CAMPAIGN_TARGETING => write!(f, "{}", "CAMPAIGN_TARGETING"),
            MetricsReportingLevel::AD_GROUP => write!(f, "{}", "AD_GROUP"),
            MetricsReportingLevel::AD_GROUP_TARGETING => write!(f, "{}", "AD_GROUP_TARGETING"),
            MetricsReportingLevel::PIN_PROMOTION => write!(f, "{}", "PIN_PROMOTION"),
            MetricsReportingLevel::PIN_PROMOTION_TARGETING => write!(f, "{}", "PIN_PROMOTION_TARGETING"),
            MetricsReportingLevel::KEYWORD => write!(f, "{}", "KEYWORD"),
            MetricsReportingLevel::PRODUCT_GROUP => write!(f, "{}", "PRODUCT_GROUP"),
            MetricsReportingLevel::PRODUCT_GROUP_TARGETING => write!(f, "{}", "PRODUCT_GROUP_TARGETING"),
            MetricsReportingLevel::PRODUCT_ITEM => write!(f, "{}", "PRODUCT_ITEM"),
        }
    }
}

impl std::str::FromStr for MetricsReportingLevel {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ADVERTISER" => std::result::Result::Ok(MetricsReportingLevel::ADVERTISER),
            "ADVERTISER_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::ADVERTISER_TARGETING),
            "CAMPAIGN" => std::result::Result::Ok(MetricsReportingLevel::CAMPAIGN),
            "CAMPAIGN_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::CAMPAIGN_TARGETING),
            "AD_GROUP" => std::result::Result::Ok(MetricsReportingLevel::AD_GROUP),
            "AD_GROUP_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::AD_GROUP_TARGETING),
            "PIN_PROMOTION" => std::result::Result::Ok(MetricsReportingLevel::PIN_PROMOTION),
            "PIN_PROMOTION_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::PIN_PROMOTION_TARGETING),
            "KEYWORD" => std::result::Result::Ok(MetricsReportingLevel::KEYWORD),
            "PRODUCT_GROUP" => std::result::Result::Ok(MetricsReportingLevel::PRODUCT_GROUP),
            "PRODUCT_GROUP_TARGETING" => std::result::Result::Ok(MetricsReportingLevel::PRODUCT_GROUP_TARGETING),
            "PRODUCT_ITEM" => std::result::Result::Ok(MetricsReportingLevel::PRODUCT_ITEM),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MinPriceFilter {
    #[serde(rename = "MIN_PRICE")]
    pub min_price: models::CatalogsProductGroupPricingCriteria,

}

impl MinPriceFilter {
    pub fn new(min_price: models::CatalogsProductGroupPricingCriteria, ) -> MinPriceFilter {
        MinPriceFilter {
            min_price: min_price,
        }
    }
}

/// Converts the MinPriceFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for MinPriceFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping MIN_PRICE in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MinPriceFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MinPriceFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub min_price: Vec<models::CatalogsProductGroupPricingCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MinPriceFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "MIN_PRICE" => intermediate_rep.min_price.push(<models::CatalogsProductGroupPricingCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MinPriceFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MinPriceFilter {
            min_price: intermediate_rep.min_price.into_iter().next().ok_or("MIN_PRICE missing in MinPriceFilter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MinPriceFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<MinPriceFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MinPriceFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for MinPriceFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<MinPriceFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MinPriceFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into MinPriceFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Currency Codes from ISO 4217.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NonNullableCatalogsCurrency {
    #[serde(rename = "AED")]
    AED,
    #[serde(rename = "AFN")]
    AFN,
    #[serde(rename = "ALL")]
    ALL,
    #[serde(rename = "AMD")]
    AMD,
    #[serde(rename = "ANG")]
    ANG,
    #[serde(rename = "AOA")]
    AOA,
    #[serde(rename = "ARS")]
    ARS,
    #[serde(rename = "AUD")]
    AUD,
    #[serde(rename = "AWG")]
    AWG,
    #[serde(rename = "AZN")]
    AZN,
    #[serde(rename = "BAM")]
    BAM,
    #[serde(rename = "BBD")]
    BBD,
    #[serde(rename = "BDT")]
    BDT,
    #[serde(rename = "BGN")]
    BGN,
    #[serde(rename = "BHD")]
    BHD,
    #[serde(rename = "BIF")]
    BIF,
    #[serde(rename = "BMD")]
    BMD,
    #[serde(rename = "BND")]
    BND,
    #[serde(rename = "BOB")]
    BOB,
    #[serde(rename = "BRL")]
    BRL,
    #[serde(rename = "BSD")]
    BSD,
    #[serde(rename = "BTN")]
    BTN,
    #[serde(rename = "BWP")]
    BWP,
    #[serde(rename = "BYN")]
    BYN,
    #[serde(rename = "BYR")]
    BYR,
    #[serde(rename = "BZD")]
    BZD,
    #[serde(rename = "CAD")]
    CAD,
    #[serde(rename = "CDF")]
    CDF,
    #[serde(rename = "CHF")]
    CHF,
    #[serde(rename = "CLP")]
    CLP,
    #[serde(rename = "CNY")]
    CNY,
    #[serde(rename = "COP")]
    COP,
    #[serde(rename = "CRC")]
    CRC,
    #[serde(rename = "CUC")]
    CUC,
    #[serde(rename = "CUP")]
    CUP,
    #[serde(rename = "CVE")]
    CVE,
    #[serde(rename = "CZK")]
    CZK,
    #[serde(rename = "DJF")]
    DJF,
    #[serde(rename = "DKK")]
    DKK,
    #[serde(rename = "DOP")]
    DOP,
    #[serde(rename = "DZD")]
    DZD,
    #[serde(rename = "EGP")]
    EGP,
    #[serde(rename = "ERN")]
    ERN,
    #[serde(rename = "ETB")]
    ETB,
    #[serde(rename = "EUR")]
    EUR,
    #[serde(rename = "FJD")]
    FJD,
    #[serde(rename = "FKP")]
    FKP,
    #[serde(rename = "GBP")]
    GBP,
    #[serde(rename = "GEL")]
    GEL,
    #[serde(rename = "GGP")]
    GGP,
    #[serde(rename = "GHS")]
    GHS,
    #[serde(rename = "GIP")]
    GIP,
    #[serde(rename = "GMD")]
    GMD,
    #[serde(rename = "GNF")]
    GNF,
    #[serde(rename = "GTQ")]
    GTQ,
    #[serde(rename = "GYD")]
    GYD,
    #[serde(rename = "HKD")]
    HKD,
    #[serde(rename = "HNL")]
    HNL,
    #[serde(rename = "HRK")]
    HRK,
    #[serde(rename = "HTG")]
    HTG,
    #[serde(rename = "HUF")]
    HUF,
    #[serde(rename = "IDR")]
    IDR,
    #[serde(rename = "ILS")]
    ILS,
    #[serde(rename = "IMP")]
    IMP,
    #[serde(rename = "INR")]
    INR,
    #[serde(rename = "IQD")]
    IQD,
    #[serde(rename = "IRR")]
    IRR,
    #[serde(rename = "ISK")]
    ISK,
    #[serde(rename = "JEP")]
    JEP,
    #[serde(rename = "JMD")]
    JMD,
    #[serde(rename = "JOD")]
    JOD,
    #[serde(rename = "JPY")]
    JPY,
    #[serde(rename = "KES")]
    KES,
    #[serde(rename = "KGS")]
    KGS,
    #[serde(rename = "KHR")]
    KHR,
    #[serde(rename = "KMF")]
    KMF,
    #[serde(rename = "KPW")]
    KPW,
    #[serde(rename = "KRW")]
    KRW,
    #[serde(rename = "KWD")]
    KWD,
    #[serde(rename = "KYD")]
    KYD,
    #[serde(rename = "KZT")]
    KZT,
    #[serde(rename = "LAK")]
    LAK,
    #[serde(rename = "LBP")]
    LBP,
    #[serde(rename = "LKR")]
    LKR,
    #[serde(rename = "LRD")]
    LRD,
    #[serde(rename = "LSL")]
    LSL,
    #[serde(rename = "LYD")]
    LYD,
    #[serde(rename = "MAD")]
    MAD,
    #[serde(rename = "MDL")]
    MDL,
    #[serde(rename = "MGA")]
    MGA,
    #[serde(rename = "MKD")]
    MKD,
    #[serde(rename = "MMK")]
    MMK,
    #[serde(rename = "MNT")]
    MNT,
    #[serde(rename = "MOP")]
    MOP,
    #[serde(rename = "MRO")]
    MRO,
    #[serde(rename = "MUR")]
    MUR,
    #[serde(rename = "MVR")]
    MVR,
    #[serde(rename = "MWK")]
    MWK,
    #[serde(rename = "MXN")]
    MXN,
    #[serde(rename = "MYR")]
    MYR,
    #[serde(rename = "MZN")]
    MZN,
    #[serde(rename = "NAD")]
    NAD,
    #[serde(rename = "NGN")]
    NGN,
    #[serde(rename = "NIO")]
    NIO,
    #[serde(rename = "NOK")]
    NOK,
    #[serde(rename = "NPR")]
    NPR,
    #[serde(rename = "NZD")]
    NZD,
    #[serde(rename = "OMR")]
    OMR,
    #[serde(rename = "PAB")]
    PAB,
    #[serde(rename = "PEN")]
    PEN,
    #[serde(rename = "PGK")]
    PGK,
    #[serde(rename = "PHP")]
    PHP,
    #[serde(rename = "PKR")]
    PKR,
    #[serde(rename = "PLN")]
    PLN,
    #[serde(rename = "PYG")]
    PYG,
    #[serde(rename = "QAR")]
    QAR,
    #[serde(rename = "RON")]
    RON,
    #[serde(rename = "RSD")]
    RSD,
    #[serde(rename = "RUB")]
    RUB,
    #[serde(rename = "RWF")]
    RWF,
    #[serde(rename = "SAR")]
    SAR,
    #[serde(rename = "SBD")]
    SBD,
    #[serde(rename = "SCR")]
    SCR,
    #[serde(rename = "SDG")]
    SDG,
    #[serde(rename = "SEK")]
    SEK,
    #[serde(rename = "SGD")]
    SGD,
    #[serde(rename = "SHP")]
    SHP,
    #[serde(rename = "SLL")]
    SLL,
    #[serde(rename = "SOS")]
    SOS,
    #[serde(rename = "SPL")]
    SPL,
    #[serde(rename = "SRD")]
    SRD,
    #[serde(rename = "STD")]
    STD,
    #[serde(rename = "SVC")]
    SVC,
    #[serde(rename = "SYP")]
    SYP,
    #[serde(rename = "SZL")]
    SZL,
    #[serde(rename = "THB")]
    THB,
    #[serde(rename = "TJS")]
    TJS,
    #[serde(rename = "TMT")]
    TMT,
    #[serde(rename = "TND")]
    TND,
    #[serde(rename = "TOP")]
    TOP,
    #[serde(rename = "TRY")]
    TRY,
    #[serde(rename = "TTD")]
    TTD,
    #[serde(rename = "TVD")]
    TVD,
    #[serde(rename = "TWD")]
    TWD,
    #[serde(rename = "TZS")]
    TZS,
    #[serde(rename = "UAH")]
    UAH,
    #[serde(rename = "UGX")]
    UGX,
    #[serde(rename = "USD")]
    USD,
    #[serde(rename = "UYU")]
    UYU,
    #[serde(rename = "UZS")]
    UZS,
    #[serde(rename = "VEF")]
    VEF,
    #[serde(rename = "VND")]
    VND,
    #[serde(rename = "VUV")]
    VUV,
    #[serde(rename = "WST")]
    WST,
    #[serde(rename = "XAF")]
    XAF,
    #[serde(rename = "XCD")]
    XCD,
    #[serde(rename = "XDR")]
    XDR,
    #[serde(rename = "XOF")]
    XOF,
    #[serde(rename = "XPF")]
    XPF,
    #[serde(rename = "YER")]
    YER,
    #[serde(rename = "ZAR")]
    ZAR,
    #[serde(rename = "ZMW")]
    ZMW,
    #[serde(rename = "ZWD")]
    ZWD,
}

impl std::fmt::Display for NonNullableCatalogsCurrency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NonNullableCatalogsCurrency::AED => write!(f, "{}", "AED"),
            NonNullableCatalogsCurrency::AFN => write!(f, "{}", "AFN"),
            NonNullableCatalogsCurrency::ALL => write!(f, "{}", "ALL"),
            NonNullableCatalogsCurrency::AMD => write!(f, "{}", "AMD"),
            NonNullableCatalogsCurrency::ANG => write!(f, "{}", "ANG"),
            NonNullableCatalogsCurrency::AOA => write!(f, "{}", "AOA"),
            NonNullableCatalogsCurrency::ARS => write!(f, "{}", "ARS"),
            NonNullableCatalogsCurrency::AUD => write!(f, "{}", "AUD"),
            NonNullableCatalogsCurrency::AWG => write!(f, "{}", "AWG"),
            NonNullableCatalogsCurrency::AZN => write!(f, "{}", "AZN"),
            NonNullableCatalogsCurrency::BAM => write!(f, "{}", "BAM"),
            NonNullableCatalogsCurrency::BBD => write!(f, "{}", "BBD"),
            NonNullableCatalogsCurrency::BDT => write!(f, "{}", "BDT"),
            NonNullableCatalogsCurrency::BGN => write!(f, "{}", "BGN"),
            NonNullableCatalogsCurrency::BHD => write!(f, "{}", "BHD"),
            NonNullableCatalogsCurrency::BIF => write!(f, "{}", "BIF"),
            NonNullableCatalogsCurrency::BMD => write!(f, "{}", "BMD"),
            NonNullableCatalogsCurrency::BND => write!(f, "{}", "BND"),
            NonNullableCatalogsCurrency::BOB => write!(f, "{}", "BOB"),
            NonNullableCatalogsCurrency::BRL => write!(f, "{}", "BRL"),
            NonNullableCatalogsCurrency::BSD => write!(f, "{}", "BSD"),
            NonNullableCatalogsCurrency::BTN => write!(f, "{}", "BTN"),
            NonNullableCatalogsCurrency::BWP => write!(f, "{}", "BWP"),
            NonNullableCatalogsCurrency::BYN => write!(f, "{}", "BYN"),
            NonNullableCatalogsCurrency::BYR => write!(f, "{}", "BYR"),
            NonNullableCatalogsCurrency::BZD => write!(f, "{}", "BZD"),
            NonNullableCatalogsCurrency::CAD => write!(f, "{}", "CAD"),
            NonNullableCatalogsCurrency::CDF => write!(f, "{}", "CDF"),
            NonNullableCatalogsCurrency::CHF => write!(f, "{}", "CHF"),
            NonNullableCatalogsCurrency::CLP => write!(f, "{}", "CLP"),
            NonNullableCatalogsCurrency::CNY => write!(f, "{}", "CNY"),
            NonNullableCatalogsCurrency::COP => write!(f, "{}", "COP"),
            NonNullableCatalogsCurrency::CRC => write!(f, "{}", "CRC"),
            NonNullableCatalogsCurrency::CUC => write!(f, "{}", "CUC"),
            NonNullableCatalogsCurrency::CUP => write!(f, "{}", "CUP"),
            NonNullableCatalogsCurrency::CVE => write!(f, "{}", "CVE"),
            NonNullableCatalogsCurrency::CZK => write!(f, "{}", "CZK"),
            NonNullableCatalogsCurrency::DJF => write!(f, "{}", "DJF"),
            NonNullableCatalogsCurrency::DKK => write!(f, "{}", "DKK"),
            NonNullableCatalogsCurrency::DOP => write!(f, "{}", "DOP"),
            NonNullableCatalogsCurrency::DZD => write!(f, "{}", "DZD"),
            NonNullableCatalogsCurrency::EGP => write!(f, "{}", "EGP"),
            NonNullableCatalogsCurrency::ERN => write!(f, "{}", "ERN"),
            NonNullableCatalogsCurrency::ETB => write!(f, "{}", "ETB"),
            NonNullableCatalogsCurrency::EUR => write!(f, "{}", "EUR"),
            NonNullableCatalogsCurrency::FJD => write!(f, "{}", "FJD"),
            NonNullableCatalogsCurrency::FKP => write!(f, "{}", "FKP"),
            NonNullableCatalogsCurrency::GBP => write!(f, "{}", "GBP"),
            NonNullableCatalogsCurrency::GEL => write!(f, "{}", "GEL"),
            NonNullableCatalogsCurrency::GGP => write!(f, "{}", "GGP"),
            NonNullableCatalogsCurrency::GHS => write!(f, "{}", "GHS"),
            NonNullableCatalogsCurrency::GIP => write!(f, "{}", "GIP"),
            NonNullableCatalogsCurrency::GMD => write!(f, "{}", "GMD"),
            NonNullableCatalogsCurrency::GNF => write!(f, "{}", "GNF"),
            NonNullableCatalogsCurrency::GTQ => write!(f, "{}", "GTQ"),
            NonNullableCatalogsCurrency::GYD => write!(f, "{}", "GYD"),
            NonNullableCatalogsCurrency::HKD => write!(f, "{}", "HKD"),
            NonNullableCatalogsCurrency::HNL => write!(f, "{}", "HNL"),
            NonNullableCatalogsCurrency::HRK => write!(f, "{}", "HRK"),
            NonNullableCatalogsCurrency::HTG => write!(f, "{}", "HTG"),
            NonNullableCatalogsCurrency::HUF => write!(f, "{}", "HUF"),
            NonNullableCatalogsCurrency::IDR => write!(f, "{}", "IDR"),
            NonNullableCatalogsCurrency::ILS => write!(f, "{}", "ILS"),
            NonNullableCatalogsCurrency::IMP => write!(f, "{}", "IMP"),
            NonNullableCatalogsCurrency::INR => write!(f, "{}", "INR"),
            NonNullableCatalogsCurrency::IQD => write!(f, "{}", "IQD"),
            NonNullableCatalogsCurrency::IRR => write!(f, "{}", "IRR"),
            NonNullableCatalogsCurrency::ISK => write!(f, "{}", "ISK"),
            NonNullableCatalogsCurrency::JEP => write!(f, "{}", "JEP"),
            NonNullableCatalogsCurrency::JMD => write!(f, "{}", "JMD"),
            NonNullableCatalogsCurrency::JOD => write!(f, "{}", "JOD"),
            NonNullableCatalogsCurrency::JPY => write!(f, "{}", "JPY"),
            NonNullableCatalogsCurrency::KES => write!(f, "{}", "KES"),
            NonNullableCatalogsCurrency::KGS => write!(f, "{}", "KGS"),
            NonNullableCatalogsCurrency::KHR => write!(f, "{}", "KHR"),
            NonNullableCatalogsCurrency::KMF => write!(f, "{}", "KMF"),
            NonNullableCatalogsCurrency::KPW => write!(f, "{}", "KPW"),
            NonNullableCatalogsCurrency::KRW => write!(f, "{}", "KRW"),
            NonNullableCatalogsCurrency::KWD => write!(f, "{}", "KWD"),
            NonNullableCatalogsCurrency::KYD => write!(f, "{}", "KYD"),
            NonNullableCatalogsCurrency::KZT => write!(f, "{}", "KZT"),
            NonNullableCatalogsCurrency::LAK => write!(f, "{}", "LAK"),
            NonNullableCatalogsCurrency::LBP => write!(f, "{}", "LBP"),
            NonNullableCatalogsCurrency::LKR => write!(f, "{}", "LKR"),
            NonNullableCatalogsCurrency::LRD => write!(f, "{}", "LRD"),
            NonNullableCatalogsCurrency::LSL => write!(f, "{}", "LSL"),
            NonNullableCatalogsCurrency::LYD => write!(f, "{}", "LYD"),
            NonNullableCatalogsCurrency::MAD => write!(f, "{}", "MAD"),
            NonNullableCatalogsCurrency::MDL => write!(f, "{}", "MDL"),
            NonNullableCatalogsCurrency::MGA => write!(f, "{}", "MGA"),
            NonNullableCatalogsCurrency::MKD => write!(f, "{}", "MKD"),
            NonNullableCatalogsCurrency::MMK => write!(f, "{}", "MMK"),
            NonNullableCatalogsCurrency::MNT => write!(f, "{}", "MNT"),
            NonNullableCatalogsCurrency::MOP => write!(f, "{}", "MOP"),
            NonNullableCatalogsCurrency::MRO => write!(f, "{}", "MRO"),
            NonNullableCatalogsCurrency::MUR => write!(f, "{}", "MUR"),
            NonNullableCatalogsCurrency::MVR => write!(f, "{}", "MVR"),
            NonNullableCatalogsCurrency::MWK => write!(f, "{}", "MWK"),
            NonNullableCatalogsCurrency::MXN => write!(f, "{}", "MXN"),
            NonNullableCatalogsCurrency::MYR => write!(f, "{}", "MYR"),
            NonNullableCatalogsCurrency::MZN => write!(f, "{}", "MZN"),
            NonNullableCatalogsCurrency::NAD => write!(f, "{}", "NAD"),
            NonNullableCatalogsCurrency::NGN => write!(f, "{}", "NGN"),
            NonNullableCatalogsCurrency::NIO => write!(f, "{}", "NIO"),
            NonNullableCatalogsCurrency::NOK => write!(f, "{}", "NOK"),
            NonNullableCatalogsCurrency::NPR => write!(f, "{}", "NPR"),
            NonNullableCatalogsCurrency::NZD => write!(f, "{}", "NZD"),
            NonNullableCatalogsCurrency::OMR => write!(f, "{}", "OMR"),
            NonNullableCatalogsCurrency::PAB => write!(f, "{}", "PAB"),
            NonNullableCatalogsCurrency::PEN => write!(f, "{}", "PEN"),
            NonNullableCatalogsCurrency::PGK => write!(f, "{}", "PGK"),
            NonNullableCatalogsCurrency::PHP => write!(f, "{}", "PHP"),
            NonNullableCatalogsCurrency::PKR => write!(f, "{}", "PKR"),
            NonNullableCatalogsCurrency::PLN => write!(f, "{}", "PLN"),
            NonNullableCatalogsCurrency::PYG => write!(f, "{}", "PYG"),
            NonNullableCatalogsCurrency::QAR => write!(f, "{}", "QAR"),
            NonNullableCatalogsCurrency::RON => write!(f, "{}", "RON"),
            NonNullableCatalogsCurrency::RSD => write!(f, "{}", "RSD"),
            NonNullableCatalogsCurrency::RUB => write!(f, "{}", "RUB"),
            NonNullableCatalogsCurrency::RWF => write!(f, "{}", "RWF"),
            NonNullableCatalogsCurrency::SAR => write!(f, "{}", "SAR"),
            NonNullableCatalogsCurrency::SBD => write!(f, "{}", "SBD"),
            NonNullableCatalogsCurrency::SCR => write!(f, "{}", "SCR"),
            NonNullableCatalogsCurrency::SDG => write!(f, "{}", "SDG"),
            NonNullableCatalogsCurrency::SEK => write!(f, "{}", "SEK"),
            NonNullableCatalogsCurrency::SGD => write!(f, "{}", "SGD"),
            NonNullableCatalogsCurrency::SHP => write!(f, "{}", "SHP"),
            NonNullableCatalogsCurrency::SLL => write!(f, "{}", "SLL"),
            NonNullableCatalogsCurrency::SOS => write!(f, "{}", "SOS"),
            NonNullableCatalogsCurrency::SPL => write!(f, "{}", "SPL"),
            NonNullableCatalogsCurrency::SRD => write!(f, "{}", "SRD"),
            NonNullableCatalogsCurrency::STD => write!(f, "{}", "STD"),
            NonNullableCatalogsCurrency::SVC => write!(f, "{}", "SVC"),
            NonNullableCatalogsCurrency::SYP => write!(f, "{}", "SYP"),
            NonNullableCatalogsCurrency::SZL => write!(f, "{}", "SZL"),
            NonNullableCatalogsCurrency::THB => write!(f, "{}", "THB"),
            NonNullableCatalogsCurrency::TJS => write!(f, "{}", "TJS"),
            NonNullableCatalogsCurrency::TMT => write!(f, "{}", "TMT"),
            NonNullableCatalogsCurrency::TND => write!(f, "{}", "TND"),
            NonNullableCatalogsCurrency::TOP => write!(f, "{}", "TOP"),
            NonNullableCatalogsCurrency::TRY => write!(f, "{}", "TRY"),
            NonNullableCatalogsCurrency::TTD => write!(f, "{}", "TTD"),
            NonNullableCatalogsCurrency::TVD => write!(f, "{}", "TVD"),
            NonNullableCatalogsCurrency::TWD => write!(f, "{}", "TWD"),
            NonNullableCatalogsCurrency::TZS => write!(f, "{}", "TZS"),
            NonNullableCatalogsCurrency::UAH => write!(f, "{}", "UAH"),
            NonNullableCatalogsCurrency::UGX => write!(f, "{}", "UGX"),
            NonNullableCatalogsCurrency::USD => write!(f, "{}", "USD"),
            NonNullableCatalogsCurrency::UYU => write!(f, "{}", "UYU"),
            NonNullableCatalogsCurrency::UZS => write!(f, "{}", "UZS"),
            NonNullableCatalogsCurrency::VEF => write!(f, "{}", "VEF"),
            NonNullableCatalogsCurrency::VND => write!(f, "{}", "VND"),
            NonNullableCatalogsCurrency::VUV => write!(f, "{}", "VUV"),
            NonNullableCatalogsCurrency::WST => write!(f, "{}", "WST"),
            NonNullableCatalogsCurrency::XAF => write!(f, "{}", "XAF"),
            NonNullableCatalogsCurrency::XCD => write!(f, "{}", "XCD"),
            NonNullableCatalogsCurrency::XDR => write!(f, "{}", "XDR"),
            NonNullableCatalogsCurrency::XOF => write!(f, "{}", "XOF"),
            NonNullableCatalogsCurrency::XPF => write!(f, "{}", "XPF"),
            NonNullableCatalogsCurrency::YER => write!(f, "{}", "YER"),
            NonNullableCatalogsCurrency::ZAR => write!(f, "{}", "ZAR"),
            NonNullableCatalogsCurrency::ZMW => write!(f, "{}", "ZMW"),
            NonNullableCatalogsCurrency::ZWD => write!(f, "{}", "ZWD"),
        }
    }
}

impl std::str::FromStr for NonNullableCatalogsCurrency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AED" => std::result::Result::Ok(NonNullableCatalogsCurrency::AED),
            "AFN" => std::result::Result::Ok(NonNullableCatalogsCurrency::AFN),
            "ALL" => std::result::Result::Ok(NonNullableCatalogsCurrency::ALL),
            "AMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::AMD),
            "ANG" => std::result::Result::Ok(NonNullableCatalogsCurrency::ANG),
            "AOA" => std::result::Result::Ok(NonNullableCatalogsCurrency::AOA),
            "ARS" => std::result::Result::Ok(NonNullableCatalogsCurrency::ARS),
            "AUD" => std::result::Result::Ok(NonNullableCatalogsCurrency::AUD),
            "AWG" => std::result::Result::Ok(NonNullableCatalogsCurrency::AWG),
            "AZN" => std::result::Result::Ok(NonNullableCatalogsCurrency::AZN),
            "BAM" => std::result::Result::Ok(NonNullableCatalogsCurrency::BAM),
            "BBD" => std::result::Result::Ok(NonNullableCatalogsCurrency::BBD),
            "BDT" => std::result::Result::Ok(NonNullableCatalogsCurrency::BDT),
            "BGN" => std::result::Result::Ok(NonNullableCatalogsCurrency::BGN),
            "BHD" => std::result::Result::Ok(NonNullableCatalogsCurrency::BHD),
            "BIF" => std::result::Result::Ok(NonNullableCatalogsCurrency::BIF),
            "BMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::BMD),
            "BND" => std::result::Result::Ok(NonNullableCatalogsCurrency::BND),
            "BOB" => std::result::Result::Ok(NonNullableCatalogsCurrency::BOB),
            "BRL" => std::result::Result::Ok(NonNullableCatalogsCurrency::BRL),
            "BSD" => std::result::Result::Ok(NonNullableCatalogsCurrency::BSD),
            "BTN" => std::result::Result::Ok(NonNullableCatalogsCurrency::BTN),
            "BWP" => std::result::Result::Ok(NonNullableCatalogsCurrency::BWP),
            "BYN" => std::result::Result::Ok(NonNullableCatalogsCurrency::BYN),
            "BYR" => std::result::Result::Ok(NonNullableCatalogsCurrency::BYR),
            "BZD" => std::result::Result::Ok(NonNullableCatalogsCurrency::BZD),
            "CAD" => std::result::Result::Ok(NonNullableCatalogsCurrency::CAD),
            "CDF" => std::result::Result::Ok(NonNullableCatalogsCurrency::CDF),
            "CHF" => std::result::Result::Ok(NonNullableCatalogsCurrency::CHF),
            "CLP" => std::result::Result::Ok(NonNullableCatalogsCurrency::CLP),
            "CNY" => std::result::Result::Ok(NonNullableCatalogsCurrency::CNY),
            "COP" => std::result::Result::Ok(NonNullableCatalogsCurrency::COP),
            "CRC" => std::result::Result::Ok(NonNullableCatalogsCurrency::CRC),
            "CUC" => std::result::Result::Ok(NonNullableCatalogsCurrency::CUC),
            "CUP" => std::result::Result::Ok(NonNullableCatalogsCurrency::CUP),
            "CVE" => std::result::Result::Ok(NonNullableCatalogsCurrency::CVE),
            "CZK" => std::result::Result::Ok(NonNullableCatalogsCurrency::CZK),
            "DJF" => std::result::Result::Ok(NonNullableCatalogsCurrency::DJF),
            "DKK" => std::result::Result::Ok(NonNullableCatalogsCurrency::DKK),
            "DOP" => std::result::Result::Ok(NonNullableCatalogsCurrency::DOP),
            "DZD" => std::result::Result::Ok(NonNullableCatalogsCurrency::DZD),
            "EGP" => std::result::Result::Ok(NonNullableCatalogsCurrency::EGP),
            "ERN" => std::result::Result::Ok(NonNullableCatalogsCurrency::ERN),
            "ETB" => std::result::Result::Ok(NonNullableCatalogsCurrency::ETB),
            "EUR" => std::result::Result::Ok(NonNullableCatalogsCurrency::EUR),
            "FJD" => std::result::Result::Ok(NonNullableCatalogsCurrency::FJD),
            "FKP" => std::result::Result::Ok(NonNullableCatalogsCurrency::FKP),
            "GBP" => std::result::Result::Ok(NonNullableCatalogsCurrency::GBP),
            "GEL" => std::result::Result::Ok(NonNullableCatalogsCurrency::GEL),
            "GGP" => std::result::Result::Ok(NonNullableCatalogsCurrency::GGP),
            "GHS" => std::result::Result::Ok(NonNullableCatalogsCurrency::GHS),
            "GIP" => std::result::Result::Ok(NonNullableCatalogsCurrency::GIP),
            "GMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::GMD),
            "GNF" => std::result::Result::Ok(NonNullableCatalogsCurrency::GNF),
            "GTQ" => std::result::Result::Ok(NonNullableCatalogsCurrency::GTQ),
            "GYD" => std::result::Result::Ok(NonNullableCatalogsCurrency::GYD),
            "HKD" => std::result::Result::Ok(NonNullableCatalogsCurrency::HKD),
            "HNL" => std::result::Result::Ok(NonNullableCatalogsCurrency::HNL),
            "HRK" => std::result::Result::Ok(NonNullableCatalogsCurrency::HRK),
            "HTG" => std::result::Result::Ok(NonNullableCatalogsCurrency::HTG),
            "HUF" => std::result::Result::Ok(NonNullableCatalogsCurrency::HUF),
            "IDR" => std::result::Result::Ok(NonNullableCatalogsCurrency::IDR),
            "ILS" => std::result::Result::Ok(NonNullableCatalogsCurrency::ILS),
            "IMP" => std::result::Result::Ok(NonNullableCatalogsCurrency::IMP),
            "INR" => std::result::Result::Ok(NonNullableCatalogsCurrency::INR),
            "IQD" => std::result::Result::Ok(NonNullableCatalogsCurrency::IQD),
            "IRR" => std::result::Result::Ok(NonNullableCatalogsCurrency::IRR),
            "ISK" => std::result::Result::Ok(NonNullableCatalogsCurrency::ISK),
            "JEP" => std::result::Result::Ok(NonNullableCatalogsCurrency::JEP),
            "JMD" => std::result::Result::Ok(NonNullableCatalogsCurrency::JMD),
            "JOD" => std::result::Result::Ok(NonNullableCatalogsCurrency::JOD),
            "JPY" => std::result::Result::Ok(NonNullableCatalogsCurrency::JPY),
            "KES" => std::result::Result::Ok(NonNullableCatalogsCurrency::KES),
            "KGS" => std::result::Result::Ok(NonNullableCatalogsCurrency::KGS),
            "KHR" => std::result::Result::Ok(NonNullableCatalogsCurrency::KHR),
            "KMF" => std::result::Result::Ok(NonNullableCatalogsCurrency::KMF),
            "KPW" => std::result::Result::Ok(NonNullableCatalogsCurrency::KPW),
            "KRW" => std::result::Result::Ok(NonNullableCatalogsCurrency::KRW),
            "KWD" => std::result::Result::Ok(NonNullableCatalogsCurrency::KWD),
            "KYD" => std::result::Result::Ok(NonNullableCatalogsCurrency::KYD),
            "KZT" => std::result::Result::Ok(NonNullableCatalogsCurrency::KZT),
            "LAK" => std::result::Result::Ok(NonNullableCatalogsCurrency::LAK),
            "LBP" => std::result::Result::Ok(NonNullableCatalogsCurrency::LBP),
            "LKR" => std::result::Result::Ok(NonNullableCatalogsCurrency::LKR),
            "LRD" => std::result::Result::Ok(NonNullableCatalogsCurrency::LRD),
            "LSL" => std::result::Result::Ok(NonNullableCatalogsCurrency::LSL),
            "LYD" => std::result::Result::Ok(NonNullableCatalogsCurrency::LYD),
            "MAD" => std::result::Result::Ok(NonNullableCatalogsCurrency::MAD),
            "MDL" => std::result::Result::Ok(NonNullableCatalogsCurrency::MDL),
            "MGA" => std::result::Result::Ok(NonNullableCatalogsCurrency::MGA),
            "MKD" => std::result::Result::Ok(NonNullableCatalogsCurrency::MKD),
            "MMK" => std::result::Result::Ok(NonNullableCatalogsCurrency::MMK),
            "MNT" => std::result::Result::Ok(NonNullableCatalogsCurrency::MNT),
            "MOP" => std::result::Result::Ok(NonNullableCatalogsCurrency::MOP),
            "MRO" => std::result::Result::Ok(NonNullableCatalogsCurrency::MRO),
            "MUR" => std::result::Result::Ok(NonNullableCatalogsCurrency::MUR),
            "MVR" => std::result::Result::Ok(NonNullableCatalogsCurrency::MVR),
            "MWK" => std::result::Result::Ok(NonNullableCatalogsCurrency::MWK),
            "MXN" => std::result::Result::Ok(NonNullableCatalogsCurrency::MXN),
            "MYR" => std::result::Result::Ok(NonNullableCatalogsCurrency::MYR),
            "MZN" => std::result::Result::Ok(NonNullableCatalogsCurrency::MZN),
            "NAD" => std::result::Result::Ok(NonNullableCatalogsCurrency::NAD),
            "NGN" => std::result::Result::Ok(NonNullableCatalogsCurrency::NGN),
            "NIO" => std::result::Result::Ok(NonNullableCatalogsCurrency::NIO),
            "NOK" => std::result::Result::Ok(NonNullableCatalogsCurrency::NOK),
            "NPR" => std::result::Result::Ok(NonNullableCatalogsCurrency::NPR),
            "NZD" => std::result::Result::Ok(NonNullableCatalogsCurrency::NZD),
            "OMR" => std::result::Result::Ok(NonNullableCatalogsCurrency::OMR),
            "PAB" => std::result::Result::Ok(NonNullableCatalogsCurrency::PAB),
            "PEN" => std::result::Result::Ok(NonNullableCatalogsCurrency::PEN),
            "PGK" => std::result::Result::Ok(NonNullableCatalogsCurrency::PGK),
            "PHP" => std::result::Result::Ok(NonNullableCatalogsCurrency::PHP),
            "PKR" => std::result::Result::Ok(NonNullableCatalogsCurrency::PKR),
            "PLN" => std::result::Result::Ok(NonNullableCatalogsCurrency::PLN),
            "PYG" => std::result::Result::Ok(NonNullableCatalogsCurrency::PYG),
            "QAR" => std::result::Result::Ok(NonNullableCatalogsCurrency::QAR),
            "RON" => std::result::Result::Ok(NonNullableCatalogsCurrency::RON),
            "RSD" => std::result::Result::Ok(NonNullableCatalogsCurrency::RSD),
            "RUB" => std::result::Result::Ok(NonNullableCatalogsCurrency::RUB),
            "RWF" => std::result::Result::Ok(NonNullableCatalogsCurrency::RWF),
            "SAR" => std::result::Result::Ok(NonNullableCatalogsCurrency::SAR),
            "SBD" => std::result::Result::Ok(NonNullableCatalogsCurrency::SBD),
            "SCR" => std::result::Result::Ok(NonNullableCatalogsCurrency::SCR),
            "SDG" => std::result::Result::Ok(NonNullableCatalogsCurrency::SDG),
            "SEK" => std::result::Result::Ok(NonNullableCatalogsCurrency::SEK),
            "SGD" => std::result::Result::Ok(NonNullableCatalogsCurrency::SGD),
            "SHP" => std::result::Result::Ok(NonNullableCatalogsCurrency::SHP),
            "SLL" => std::result::Result::Ok(NonNullableCatalogsCurrency::SLL),
            "SOS" => std::result::Result::Ok(NonNullableCatalogsCurrency::SOS),
            "SPL" => std::result::Result::Ok(NonNullableCatalogsCurrency::SPL),
            "SRD" => std::result::Result::Ok(NonNullableCatalogsCurrency::SRD),
            "STD" => std::result::Result::Ok(NonNullableCatalogsCurrency::STD),
            "SVC" => std::result::Result::Ok(NonNullableCatalogsCurrency::SVC),
            "SYP" => std::result::Result::Ok(NonNullableCatalogsCurrency::SYP),
            "SZL" => std::result::Result::Ok(NonNullableCatalogsCurrency::SZL),
            "THB" => std::result::Result::Ok(NonNullableCatalogsCurrency::THB),
            "TJS" => std::result::Result::Ok(NonNullableCatalogsCurrency::TJS),
            "TMT" => std::result::Result::Ok(NonNullableCatalogsCurrency::TMT),
            "TND" => std::result::Result::Ok(NonNullableCatalogsCurrency::TND),
            "TOP" => std::result::Result::Ok(NonNullableCatalogsCurrency::TOP),
            "TRY" => std::result::Result::Ok(NonNullableCatalogsCurrency::TRY),
            "TTD" => std::result::Result::Ok(NonNullableCatalogsCurrency::TTD),
            "TVD" => std::result::Result::Ok(NonNullableCatalogsCurrency::TVD),
            "TWD" => std::result::Result::Ok(NonNullableCatalogsCurrency::TWD),
            "TZS" => std::result::Result::Ok(NonNullableCatalogsCurrency::TZS),
            "UAH" => std::result::Result::Ok(NonNullableCatalogsCurrency::UAH),
            "UGX" => std::result::Result::Ok(NonNullableCatalogsCurrency::UGX),
            "USD" => std::result::Result::Ok(NonNullableCatalogsCurrency::USD),
            "UYU" => std::result::Result::Ok(NonNullableCatalogsCurrency::UYU),
            "UZS" => std::result::Result::Ok(NonNullableCatalogsCurrency::UZS),
            "VEF" => std::result::Result::Ok(NonNullableCatalogsCurrency::VEF),
            "VND" => std::result::Result::Ok(NonNullableCatalogsCurrency::VND),
            "VUV" => std::result::Result::Ok(NonNullableCatalogsCurrency::VUV),
            "WST" => std::result::Result::Ok(NonNullableCatalogsCurrency::WST),
            "XAF" => std::result::Result::Ok(NonNullableCatalogsCurrency::XAF),
            "XCD" => std::result::Result::Ok(NonNullableCatalogsCurrency::XCD),
            "XDR" => std::result::Result::Ok(NonNullableCatalogsCurrency::XDR),
            "XOF" => std::result::Result::Ok(NonNullableCatalogsCurrency::XOF),
            "XPF" => std::result::Result::Ok(NonNullableCatalogsCurrency::XPF),
            "YER" => std::result::Result::Ok(NonNullableCatalogsCurrency::YER),
            "ZAR" => std::result::Result::Ok(NonNullableCatalogsCurrency::ZAR),
            "ZMW" => std::result::Result::Ok(NonNullableCatalogsCurrency::ZMW),
            "ZWD" => std::result::Result::Ok(NonNullableCatalogsCurrency::ZWD),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Currency Codes from ISO 4217.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum NullableCurrency {
    #[serde(rename = "AED")]
    AED,
    #[serde(rename = "AFN")]
    AFN,
    #[serde(rename = "ALL")]
    ALL,
    #[serde(rename = "AMD")]
    AMD,
    #[serde(rename = "ANG")]
    ANG,
    #[serde(rename = "AOA")]
    AOA,
    #[serde(rename = "ARS")]
    ARS,
    #[serde(rename = "AUD")]
    AUD,
    #[serde(rename = "AWG")]
    AWG,
    #[serde(rename = "AZN")]
    AZN,
    #[serde(rename = "BAM")]
    BAM,
    #[serde(rename = "BBD")]
    BBD,
    #[serde(rename = "BDT")]
    BDT,
    #[serde(rename = "BGN")]
    BGN,
    #[serde(rename = "BHD")]
    BHD,
    #[serde(rename = "BIF")]
    BIF,
    #[serde(rename = "BMD")]
    BMD,
    #[serde(rename = "BND")]
    BND,
    #[serde(rename = "BOB")]
    BOB,
    #[serde(rename = "BRL")]
    BRL,
    #[serde(rename = "BSD")]
    BSD,
    #[serde(rename = "BTN")]
    BTN,
    #[serde(rename = "BWP")]
    BWP,
    #[serde(rename = "BYN")]
    BYN,
    #[serde(rename = "BYR")]
    BYR,
    #[serde(rename = "BZD")]
    BZD,
    #[serde(rename = "CAD")]
    CAD,
    #[serde(rename = "CDF")]
    CDF,
    #[serde(rename = "CHF")]
    CHF,
    #[serde(rename = "CLP")]
    CLP,
    #[serde(rename = "CNY")]
    CNY,
    #[serde(rename = "COP")]
    COP,
    #[serde(rename = "CRC")]
    CRC,
    #[serde(rename = "CUC")]
    CUC,
    #[serde(rename = "CUP")]
    CUP,
    #[serde(rename = "CVE")]
    CVE,
    #[serde(rename = "CZK")]
    CZK,
    #[serde(rename = "DJF")]
    DJF,
    #[serde(rename = "DKK")]
    DKK,
    #[serde(rename = "DOP")]
    DOP,
    #[serde(rename = "DZD")]
    DZD,
    #[serde(rename = "EGP")]
    EGP,
    #[serde(rename = "ERN")]
    ERN,
    #[serde(rename = "ETB")]
    ETB,
    #[serde(rename = "EUR")]
    EUR,
    #[serde(rename = "FJD")]
    FJD,
    #[serde(rename = "FKP")]
    FKP,
    #[serde(rename = "GBP")]
    GBP,
    #[serde(rename = "GEL")]
    GEL,
    #[serde(rename = "GGP")]
    GGP,
    #[serde(rename = "GHS")]
    GHS,
    #[serde(rename = "GIP")]
    GIP,
    #[serde(rename = "GMD")]
    GMD,
    #[serde(rename = "GNF")]
    GNF,
    #[serde(rename = "GTQ")]
    GTQ,
    #[serde(rename = "GYD")]
    GYD,
    #[serde(rename = "HKD")]
    HKD,
    #[serde(rename = "HNL")]
    HNL,
    #[serde(rename = "HRK")]
    HRK,
    #[serde(rename = "HTG")]
    HTG,
    #[serde(rename = "HUF")]
    HUF,
    #[serde(rename = "IDR")]
    IDR,
    #[serde(rename = "ILS")]
    ILS,
    #[serde(rename = "IMP")]
    IMP,
    #[serde(rename = "INR")]
    INR,
    #[serde(rename = "IQD")]
    IQD,
    #[serde(rename = "IRR")]
    IRR,
    #[serde(rename = "ISK")]
    ISK,
    #[serde(rename = "JEP")]
    JEP,
    #[serde(rename = "JMD")]
    JMD,
    #[serde(rename = "JOD")]
    JOD,
    #[serde(rename = "JPY")]
    JPY,
    #[serde(rename = "KES")]
    KES,
    #[serde(rename = "KGS")]
    KGS,
    #[serde(rename = "KHR")]
    KHR,
    #[serde(rename = "KMF")]
    KMF,
    #[serde(rename = "KPW")]
    KPW,
    #[serde(rename = "KRW")]
    KRW,
    #[serde(rename = "KWD")]
    KWD,
    #[serde(rename = "KYD")]
    KYD,
    #[serde(rename = "KZT")]
    KZT,
    #[serde(rename = "LAK")]
    LAK,
    #[serde(rename = "LBP")]
    LBP,
    #[serde(rename = "LKR")]
    LKR,
    #[serde(rename = "LRD")]
    LRD,
    #[serde(rename = "LSL")]
    LSL,
    #[serde(rename = "LYD")]
    LYD,
    #[serde(rename = "MAD")]
    MAD,
    #[serde(rename = "MDL")]
    MDL,
    #[serde(rename = "MGA")]
    MGA,
    #[serde(rename = "MKD")]
    MKD,
    #[serde(rename = "MMK")]
    MMK,
    #[serde(rename = "MNT")]
    MNT,
    #[serde(rename = "MOP")]
    MOP,
    #[serde(rename = "MRO")]
    MRO,
    #[serde(rename = "MUR")]
    MUR,
    #[serde(rename = "MVR")]
    MVR,
    #[serde(rename = "MWK")]
    MWK,
    #[serde(rename = "MXN")]
    MXN,
    #[serde(rename = "MYR")]
    MYR,
    #[serde(rename = "MZN")]
    MZN,
    #[serde(rename = "NAD")]
    NAD,
    #[serde(rename = "NGN")]
    NGN,
    #[serde(rename = "NIO")]
    NIO,
    #[serde(rename = "NOK")]
    NOK,
    #[serde(rename = "NPR")]
    NPR,
    #[serde(rename = "NZD")]
    NZD,
    #[serde(rename = "OMR")]
    OMR,
    #[serde(rename = "PAB")]
    PAB,
    #[serde(rename = "PEN")]
    PEN,
    #[serde(rename = "PGK")]
    PGK,
    #[serde(rename = "PHP")]
    PHP,
    #[serde(rename = "PKR")]
    PKR,
    #[serde(rename = "PLN")]
    PLN,
    #[serde(rename = "PYG")]
    PYG,
    #[serde(rename = "QAR")]
    QAR,
    #[serde(rename = "RON")]
    RON,
    #[serde(rename = "RSD")]
    RSD,
    #[serde(rename = "RUB")]
    RUB,
    #[serde(rename = "RWF")]
    RWF,
    #[serde(rename = "SAR")]
    SAR,
    #[serde(rename = "SBD")]
    SBD,
    #[serde(rename = "SCR")]
    SCR,
    #[serde(rename = "SDG")]
    SDG,
    #[serde(rename = "SEK")]
    SEK,
    #[serde(rename = "SGD")]
    SGD,
    #[serde(rename = "SHP")]
    SHP,
    #[serde(rename = "SLL")]
    SLL,
    #[serde(rename = "SOS")]
    SOS,
    #[serde(rename = "SPL")]
    SPL,
    #[serde(rename = "SRD")]
    SRD,
    #[serde(rename = "STD")]
    STD,
    #[serde(rename = "SVC")]
    SVC,
    #[serde(rename = "SYP")]
    SYP,
    #[serde(rename = "SZL")]
    SZL,
    #[serde(rename = "THB")]
    THB,
    #[serde(rename = "TJS")]
    TJS,
    #[serde(rename = "TMT")]
    TMT,
    #[serde(rename = "TND")]
    TND,
    #[serde(rename = "TOP")]
    TOP,
    #[serde(rename = "TRY")]
    TRY,
    #[serde(rename = "TTD")]
    TTD,
    #[serde(rename = "TVD")]
    TVD,
    #[serde(rename = "TWD")]
    TWD,
    #[serde(rename = "TZS")]
    TZS,
    #[serde(rename = "UAH")]
    UAH,
    #[serde(rename = "UGX")]
    UGX,
    #[serde(rename = "USD")]
    USD,
    #[serde(rename = "UYU")]
    UYU,
    #[serde(rename = "UZS")]
    UZS,
    #[serde(rename = "VEF")]
    VEF,
    #[serde(rename = "VND")]
    VND,
    #[serde(rename = "VUV")]
    VUV,
    #[serde(rename = "WST")]
    WST,
    #[serde(rename = "XAF")]
    XAF,
    #[serde(rename = "XCD")]
    XCD,
    #[serde(rename = "XDR")]
    XDR,
    #[serde(rename = "XOF")]
    XOF,
    #[serde(rename = "XPF")]
    XPF,
    #[serde(rename = "YER")]
    YER,
    #[serde(rename = "ZAR")]
    ZAR,
    #[serde(rename = "ZMW")]
    ZMW,
    #[serde(rename = "ZWD")]
    ZWD,
    #[serde(rename = "null")]
    NULL,
}

impl std::fmt::Display for NullableCurrency {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            NullableCurrency::AED => write!(f, "{}", "AED"),
            NullableCurrency::AFN => write!(f, "{}", "AFN"),
            NullableCurrency::ALL => write!(f, "{}", "ALL"),
            NullableCurrency::AMD => write!(f, "{}", "AMD"),
            NullableCurrency::ANG => write!(f, "{}", "ANG"),
            NullableCurrency::AOA => write!(f, "{}", "AOA"),
            NullableCurrency::ARS => write!(f, "{}", "ARS"),
            NullableCurrency::AUD => write!(f, "{}", "AUD"),
            NullableCurrency::AWG => write!(f, "{}", "AWG"),
            NullableCurrency::AZN => write!(f, "{}", "AZN"),
            NullableCurrency::BAM => write!(f, "{}", "BAM"),
            NullableCurrency::BBD => write!(f, "{}", "BBD"),
            NullableCurrency::BDT => write!(f, "{}", "BDT"),
            NullableCurrency::BGN => write!(f, "{}", "BGN"),
            NullableCurrency::BHD => write!(f, "{}", "BHD"),
            NullableCurrency::BIF => write!(f, "{}", "BIF"),
            NullableCurrency::BMD => write!(f, "{}", "BMD"),
            NullableCurrency::BND => write!(f, "{}", "BND"),
            NullableCurrency::BOB => write!(f, "{}", "BOB"),
            NullableCurrency::BRL => write!(f, "{}", "BRL"),
            NullableCurrency::BSD => write!(f, "{}", "BSD"),
            NullableCurrency::BTN => write!(f, "{}", "BTN"),
            NullableCurrency::BWP => write!(f, "{}", "BWP"),
            NullableCurrency::BYN => write!(f, "{}", "BYN"),
            NullableCurrency::BYR => write!(f, "{}", "BYR"),
            NullableCurrency::BZD => write!(f, "{}", "BZD"),
            NullableCurrency::CAD => write!(f, "{}", "CAD"),
            NullableCurrency::CDF => write!(f, "{}", "CDF"),
            NullableCurrency::CHF => write!(f, "{}", "CHF"),
            NullableCurrency::CLP => write!(f, "{}", "CLP"),
            NullableCurrency::CNY => write!(f, "{}", "CNY"),
            NullableCurrency::COP => write!(f, "{}", "COP"),
            NullableCurrency::CRC => write!(f, "{}", "CRC"),
            NullableCurrency::CUC => write!(f, "{}", "CUC"),
            NullableCurrency::CUP => write!(f, "{}", "CUP"),
            NullableCurrency::CVE => write!(f, "{}", "CVE"),
            NullableCurrency::CZK => write!(f, "{}", "CZK"),
            NullableCurrency::DJF => write!(f, "{}", "DJF"),
            NullableCurrency::DKK => write!(f, "{}", "DKK"),
            NullableCurrency::DOP => write!(f, "{}", "DOP"),
            NullableCurrency::DZD => write!(f, "{}", "DZD"),
            NullableCurrency::EGP => write!(f, "{}", "EGP"),
            NullableCurrency::ERN => write!(f, "{}", "ERN"),
            NullableCurrency::ETB => write!(f, "{}", "ETB"),
            NullableCurrency::EUR => write!(f, "{}", "EUR"),
            NullableCurrency::FJD => write!(f, "{}", "FJD"),
            NullableCurrency::FKP => write!(f, "{}", "FKP"),
            NullableCurrency::GBP => write!(f, "{}", "GBP"),
            NullableCurrency::GEL => write!(f, "{}", "GEL"),
            NullableCurrency::GGP => write!(f, "{}", "GGP"),
            NullableCurrency::GHS => write!(f, "{}", "GHS"),
            NullableCurrency::GIP => write!(f, "{}", "GIP"),
            NullableCurrency::GMD => write!(f, "{}", "GMD"),
            NullableCurrency::GNF => write!(f, "{}", "GNF"),
            NullableCurrency::GTQ => write!(f, "{}", "GTQ"),
            NullableCurrency::GYD => write!(f, "{}", "GYD"),
            NullableCurrency::HKD => write!(f, "{}", "HKD"),
            NullableCurrency::HNL => write!(f, "{}", "HNL"),
            NullableCurrency::HRK => write!(f, "{}", "HRK"),
            NullableCurrency::HTG => write!(f, "{}", "HTG"),
            NullableCurrency::HUF => write!(f, "{}", "HUF"),
            NullableCurrency::IDR => write!(f, "{}", "IDR"),
            NullableCurrency::ILS => write!(f, "{}", "ILS"),
            NullableCurrency::IMP => write!(f, "{}", "IMP"),
            NullableCurrency::INR => write!(f, "{}", "INR"),
            NullableCurrency::IQD => write!(f, "{}", "IQD"),
            NullableCurrency::IRR => write!(f, "{}", "IRR"),
            NullableCurrency::ISK => write!(f, "{}", "ISK"),
            NullableCurrency::JEP => write!(f, "{}", "JEP"),
            NullableCurrency::JMD => write!(f, "{}", "JMD"),
            NullableCurrency::JOD => write!(f, "{}", "JOD"),
            NullableCurrency::JPY => write!(f, "{}", "JPY"),
            NullableCurrency::KES => write!(f, "{}", "KES"),
            NullableCurrency::KGS => write!(f, "{}", "KGS"),
            NullableCurrency::KHR => write!(f, "{}", "KHR"),
            NullableCurrency::KMF => write!(f, "{}", "KMF"),
            NullableCurrency::KPW => write!(f, "{}", "KPW"),
            NullableCurrency::KRW => write!(f, "{}", "KRW"),
            NullableCurrency::KWD => write!(f, "{}", "KWD"),
            NullableCurrency::KYD => write!(f, "{}", "KYD"),
            NullableCurrency::KZT => write!(f, "{}", "KZT"),
            NullableCurrency::LAK => write!(f, "{}", "LAK"),
            NullableCurrency::LBP => write!(f, "{}", "LBP"),
            NullableCurrency::LKR => write!(f, "{}", "LKR"),
            NullableCurrency::LRD => write!(f, "{}", "LRD"),
            NullableCurrency::LSL => write!(f, "{}", "LSL"),
            NullableCurrency::LYD => write!(f, "{}", "LYD"),
            NullableCurrency::MAD => write!(f, "{}", "MAD"),
            NullableCurrency::MDL => write!(f, "{}", "MDL"),
            NullableCurrency::MGA => write!(f, "{}", "MGA"),
            NullableCurrency::MKD => write!(f, "{}", "MKD"),
            NullableCurrency::MMK => write!(f, "{}", "MMK"),
            NullableCurrency::MNT => write!(f, "{}", "MNT"),
            NullableCurrency::MOP => write!(f, "{}", "MOP"),
            NullableCurrency::MRO => write!(f, "{}", "MRO"),
            NullableCurrency::MUR => write!(f, "{}", "MUR"),
            NullableCurrency::MVR => write!(f, "{}", "MVR"),
            NullableCurrency::MWK => write!(f, "{}", "MWK"),
            NullableCurrency::MXN => write!(f, "{}", "MXN"),
            NullableCurrency::MYR => write!(f, "{}", "MYR"),
            NullableCurrency::MZN => write!(f, "{}", "MZN"),
            NullableCurrency::NAD => write!(f, "{}", "NAD"),
            NullableCurrency::NGN => write!(f, "{}", "NGN"),
            NullableCurrency::NIO => write!(f, "{}", "NIO"),
            NullableCurrency::NOK => write!(f, "{}", "NOK"),
            NullableCurrency::NPR => write!(f, "{}", "NPR"),
            NullableCurrency::NZD => write!(f, "{}", "NZD"),
            NullableCurrency::OMR => write!(f, "{}", "OMR"),
            NullableCurrency::PAB => write!(f, "{}", "PAB"),
            NullableCurrency::PEN => write!(f, "{}", "PEN"),
            NullableCurrency::PGK => write!(f, "{}", "PGK"),
            NullableCurrency::PHP => write!(f, "{}", "PHP"),
            NullableCurrency::PKR => write!(f, "{}", "PKR"),
            NullableCurrency::PLN => write!(f, "{}", "PLN"),
            NullableCurrency::PYG => write!(f, "{}", "PYG"),
            NullableCurrency::QAR => write!(f, "{}", "QAR"),
            NullableCurrency::RON => write!(f, "{}", "RON"),
            NullableCurrency::RSD => write!(f, "{}", "RSD"),
            NullableCurrency::RUB => write!(f, "{}", "RUB"),
            NullableCurrency::RWF => write!(f, "{}", "RWF"),
            NullableCurrency::SAR => write!(f, "{}", "SAR"),
            NullableCurrency::SBD => write!(f, "{}", "SBD"),
            NullableCurrency::SCR => write!(f, "{}", "SCR"),
            NullableCurrency::SDG => write!(f, "{}", "SDG"),
            NullableCurrency::SEK => write!(f, "{}", "SEK"),
            NullableCurrency::SGD => write!(f, "{}", "SGD"),
            NullableCurrency::SHP => write!(f, "{}", "SHP"),
            NullableCurrency::SLL => write!(f, "{}", "SLL"),
            NullableCurrency::SOS => write!(f, "{}", "SOS"),
            NullableCurrency::SPL => write!(f, "{}", "SPL"),
            NullableCurrency::SRD => write!(f, "{}", "SRD"),
            NullableCurrency::STD => write!(f, "{}", "STD"),
            NullableCurrency::SVC => write!(f, "{}", "SVC"),
            NullableCurrency::SYP => write!(f, "{}", "SYP"),
            NullableCurrency::SZL => write!(f, "{}", "SZL"),
            NullableCurrency::THB => write!(f, "{}", "THB"),
            NullableCurrency::TJS => write!(f, "{}", "TJS"),
            NullableCurrency::TMT => write!(f, "{}", "TMT"),
            NullableCurrency::TND => write!(f, "{}", "TND"),
            NullableCurrency::TOP => write!(f, "{}", "TOP"),
            NullableCurrency::TRY => write!(f, "{}", "TRY"),
            NullableCurrency::TTD => write!(f, "{}", "TTD"),
            NullableCurrency::TVD => write!(f, "{}", "TVD"),
            NullableCurrency::TWD => write!(f, "{}", "TWD"),
            NullableCurrency::TZS => write!(f, "{}", "TZS"),
            NullableCurrency::UAH => write!(f, "{}", "UAH"),
            NullableCurrency::UGX => write!(f, "{}", "UGX"),
            NullableCurrency::USD => write!(f, "{}", "USD"),
            NullableCurrency::UYU => write!(f, "{}", "UYU"),
            NullableCurrency::UZS => write!(f, "{}", "UZS"),
            NullableCurrency::VEF => write!(f, "{}", "VEF"),
            NullableCurrency::VND => write!(f, "{}", "VND"),
            NullableCurrency::VUV => write!(f, "{}", "VUV"),
            NullableCurrency::WST => write!(f, "{}", "WST"),
            NullableCurrency::XAF => write!(f, "{}", "XAF"),
            NullableCurrency::XCD => write!(f, "{}", "XCD"),
            NullableCurrency::XDR => write!(f, "{}", "XDR"),
            NullableCurrency::XOF => write!(f, "{}", "XOF"),
            NullableCurrency::XPF => write!(f, "{}", "XPF"),
            NullableCurrency::YER => write!(f, "{}", "YER"),
            NullableCurrency::ZAR => write!(f, "{}", "ZAR"),
            NullableCurrency::ZMW => write!(f, "{}", "ZMW"),
            NullableCurrency::ZWD => write!(f, "{}", "ZWD"),
            NullableCurrency::NULL => write!(f, "{}", "null"),
        }
    }
}

impl std::str::FromStr for NullableCurrency {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AED" => std::result::Result::Ok(NullableCurrency::AED),
            "AFN" => std::result::Result::Ok(NullableCurrency::AFN),
            "ALL" => std::result::Result::Ok(NullableCurrency::ALL),
            "AMD" => std::result::Result::Ok(NullableCurrency::AMD),
            "ANG" => std::result::Result::Ok(NullableCurrency::ANG),
            "AOA" => std::result::Result::Ok(NullableCurrency::AOA),
            "ARS" => std::result::Result::Ok(NullableCurrency::ARS),
            "AUD" => std::result::Result::Ok(NullableCurrency::AUD),
            "AWG" => std::result::Result::Ok(NullableCurrency::AWG),
            "AZN" => std::result::Result::Ok(NullableCurrency::AZN),
            "BAM" => std::result::Result::Ok(NullableCurrency::BAM),
            "BBD" => std::result::Result::Ok(NullableCurrency::BBD),
            "BDT" => std::result::Result::Ok(NullableCurrency::BDT),
            "BGN" => std::result::Result::Ok(NullableCurrency::BGN),
            "BHD" => std::result::Result::Ok(NullableCurrency::BHD),
            "BIF" => std::result::Result::Ok(NullableCurrency::BIF),
            "BMD" => std::result::Result::Ok(NullableCurrency::BMD),
            "BND" => std::result::Result::Ok(NullableCurrency::BND),
            "BOB" => std::result::Result::Ok(NullableCurrency::BOB),
            "BRL" => std::result::Result::Ok(NullableCurrency::BRL),
            "BSD" => std::result::Result::Ok(NullableCurrency::BSD),
            "BTN" => std::result::Result::Ok(NullableCurrency::BTN),
            "BWP" => std::result::Result::Ok(NullableCurrency::BWP),
            "BYN" => std::result::Result::Ok(NullableCurrency::BYN),
            "BYR" => std::result::Result::Ok(NullableCurrency::BYR),
            "BZD" => std::result::Result::Ok(NullableCurrency::BZD),
            "CAD" => std::result::Result::Ok(NullableCurrency::CAD),
            "CDF" => std::result::Result::Ok(NullableCurrency::CDF),
            "CHF" => std::result::Result::Ok(NullableCurrency::CHF),
            "CLP" => std::result::Result::Ok(NullableCurrency::CLP),
            "CNY" => std::result::Result::Ok(NullableCurrency::CNY),
            "COP" => std::result::Result::Ok(NullableCurrency::COP),
            "CRC" => std::result::Result::Ok(NullableCurrency::CRC),
            "CUC" => std::result::Result::Ok(NullableCurrency::CUC),
            "CUP" => std::result::Result::Ok(NullableCurrency::CUP),
            "CVE" => std::result::Result::Ok(NullableCurrency::CVE),
            "CZK" => std::result::Result::Ok(NullableCurrency::CZK),
            "DJF" => std::result::Result::Ok(NullableCurrency::DJF),
            "DKK" => std::result::Result::Ok(NullableCurrency::DKK),
            "DOP" => std::result::Result::Ok(NullableCurrency::DOP),
            "DZD" => std::result::Result::Ok(NullableCurrency::DZD),
            "EGP" => std::result::Result::Ok(NullableCurrency::EGP),
            "ERN" => std::result::Result::Ok(NullableCurrency::ERN),
            "ETB" => std::result::Result::Ok(NullableCurrency::ETB),
            "EUR" => std::result::Result::Ok(NullableCurrency::EUR),
            "FJD" => std::result::Result::Ok(NullableCurrency::FJD),
            "FKP" => std::result::Result::Ok(NullableCurrency::FKP),
            "GBP" => std::result::Result::Ok(NullableCurrency::GBP),
            "GEL" => std::result::Result::Ok(NullableCurrency::GEL),
            "GGP" => std::result::Result::Ok(NullableCurrency::GGP),
            "GHS" => std::result::Result::Ok(NullableCurrency::GHS),
            "GIP" => std::result::Result::Ok(NullableCurrency::GIP),
            "GMD" => std::result::Result::Ok(NullableCurrency::GMD),
            "GNF" => std::result::Result::Ok(NullableCurrency::GNF),
            "GTQ" => std::result::Result::Ok(NullableCurrency::GTQ),
            "GYD" => std::result::Result::Ok(NullableCurrency::GYD),
            "HKD" => std::result::Result::Ok(NullableCurrency::HKD),
            "HNL" => std::result::Result::Ok(NullableCurrency::HNL),
            "HRK" => std::result::Result::Ok(NullableCurrency::HRK),
            "HTG" => std::result::Result::Ok(NullableCurrency::HTG),
            "HUF" => std::result::Result::Ok(NullableCurrency::HUF),
            "IDR" => std::result::Result::Ok(NullableCurrency::IDR),
            "ILS" => std::result::Result::Ok(NullableCurrency::ILS),
            "IMP" => std::result::Result::Ok(NullableCurrency::IMP),
            "INR" => std::result::Result::Ok(NullableCurrency::INR),
            "IQD" => std::result::Result::Ok(NullableCurrency::IQD),
            "IRR" => std::result::Result::Ok(NullableCurrency::IRR),
            "ISK" => std::result::Result::Ok(NullableCurrency::ISK),
            "JEP" => std::result::Result::Ok(NullableCurrency::JEP),
            "JMD" => std::result::Result::Ok(NullableCurrency::JMD),
            "JOD" => std::result::Result::Ok(NullableCurrency::JOD),
            "JPY" => std::result::Result::Ok(NullableCurrency::JPY),
            "KES" => std::result::Result::Ok(NullableCurrency::KES),
            "KGS" => std::result::Result::Ok(NullableCurrency::KGS),
            "KHR" => std::result::Result::Ok(NullableCurrency::KHR),
            "KMF" => std::result::Result::Ok(NullableCurrency::KMF),
            "KPW" => std::result::Result::Ok(NullableCurrency::KPW),
            "KRW" => std::result::Result::Ok(NullableCurrency::KRW),
            "KWD" => std::result::Result::Ok(NullableCurrency::KWD),
            "KYD" => std::result::Result::Ok(NullableCurrency::KYD),
            "KZT" => std::result::Result::Ok(NullableCurrency::KZT),
            "LAK" => std::result::Result::Ok(NullableCurrency::LAK),
            "LBP" => std::result::Result::Ok(NullableCurrency::LBP),
            "LKR" => std::result::Result::Ok(NullableCurrency::LKR),
            "LRD" => std::result::Result::Ok(NullableCurrency::LRD),
            "LSL" => std::result::Result::Ok(NullableCurrency::LSL),
            "LYD" => std::result::Result::Ok(NullableCurrency::LYD),
            "MAD" => std::result::Result::Ok(NullableCurrency::MAD),
            "MDL" => std::result::Result::Ok(NullableCurrency::MDL),
            "MGA" => std::result::Result::Ok(NullableCurrency::MGA),
            "MKD" => std::result::Result::Ok(NullableCurrency::MKD),
            "MMK" => std::result::Result::Ok(NullableCurrency::MMK),
            "MNT" => std::result::Result::Ok(NullableCurrency::MNT),
            "MOP" => std::result::Result::Ok(NullableCurrency::MOP),
            "MRO" => std::result::Result::Ok(NullableCurrency::MRO),
            "MUR" => std::result::Result::Ok(NullableCurrency::MUR),
            "MVR" => std::result::Result::Ok(NullableCurrency::MVR),
            "MWK" => std::result::Result::Ok(NullableCurrency::MWK),
            "MXN" => std::result::Result::Ok(NullableCurrency::MXN),
            "MYR" => std::result::Result::Ok(NullableCurrency::MYR),
            "MZN" => std::result::Result::Ok(NullableCurrency::MZN),
            "NAD" => std::result::Result::Ok(NullableCurrency::NAD),
            "NGN" => std::result::Result::Ok(NullableCurrency::NGN),
            "NIO" => std::result::Result::Ok(NullableCurrency::NIO),
            "NOK" => std::result::Result::Ok(NullableCurrency::NOK),
            "NPR" => std::result::Result::Ok(NullableCurrency::NPR),
            "NZD" => std::result::Result::Ok(NullableCurrency::NZD),
            "OMR" => std::result::Result::Ok(NullableCurrency::OMR),
            "PAB" => std::result::Result::Ok(NullableCurrency::PAB),
            "PEN" => std::result::Result::Ok(NullableCurrency::PEN),
            "PGK" => std::result::Result::Ok(NullableCurrency::PGK),
            "PHP" => std::result::Result::Ok(NullableCurrency::PHP),
            "PKR" => std::result::Result::Ok(NullableCurrency::PKR),
            "PLN" => std::result::Result::Ok(NullableCurrency::PLN),
            "PYG" => std::result::Result::Ok(NullableCurrency::PYG),
            "QAR" => std::result::Result::Ok(NullableCurrency::QAR),
            "RON" => std::result::Result::Ok(NullableCurrency::RON),
            "RSD" => std::result::Result::Ok(NullableCurrency::RSD),
            "RUB" => std::result::Result::Ok(NullableCurrency::RUB),
            "RWF" => std::result::Result::Ok(NullableCurrency::RWF),
            "SAR" => std::result::Result::Ok(NullableCurrency::SAR),
            "SBD" => std::result::Result::Ok(NullableCurrency::SBD),
            "SCR" => std::result::Result::Ok(NullableCurrency::SCR),
            "SDG" => std::result::Result::Ok(NullableCurrency::SDG),
            "SEK" => std::result::Result::Ok(NullableCurrency::SEK),
            "SGD" => std::result::Result::Ok(NullableCurrency::SGD),
            "SHP" => std::result::Result::Ok(NullableCurrency::SHP),
            "SLL" => std::result::Result::Ok(NullableCurrency::SLL),
            "SOS" => std::result::Result::Ok(NullableCurrency::SOS),
            "SPL" => std::result::Result::Ok(NullableCurrency::SPL),
            "SRD" => std::result::Result::Ok(NullableCurrency::SRD),
            "STD" => std::result::Result::Ok(NullableCurrency::STD),
            "SVC" => std::result::Result::Ok(NullableCurrency::SVC),
            "SYP" => std::result::Result::Ok(NullableCurrency::SYP),
            "SZL" => std::result::Result::Ok(NullableCurrency::SZL),
            "THB" => std::result::Result::Ok(NullableCurrency::THB),
            "TJS" => std::result::Result::Ok(NullableCurrency::TJS),
            "TMT" => std::result::Result::Ok(NullableCurrency::TMT),
            "TND" => std::result::Result::Ok(NullableCurrency::TND),
            "TOP" => std::result::Result::Ok(NullableCurrency::TOP),
            "TRY" => std::result::Result::Ok(NullableCurrency::TRY),
            "TTD" => std::result::Result::Ok(NullableCurrency::TTD),
            "TVD" => std::result::Result::Ok(NullableCurrency::TVD),
            "TWD" => std::result::Result::Ok(NullableCurrency::TWD),
            "TZS" => std::result::Result::Ok(NullableCurrency::TZS),
            "UAH" => std::result::Result::Ok(NullableCurrency::UAH),
            "UGX" => std::result::Result::Ok(NullableCurrency::UGX),
            "USD" => std::result::Result::Ok(NullableCurrency::USD),
            "UYU" => std::result::Result::Ok(NullableCurrency::UYU),
            "UZS" => std::result::Result::Ok(NullableCurrency::UZS),
            "VEF" => std::result::Result::Ok(NullableCurrency::VEF),
            "VND" => std::result::Result::Ok(NullableCurrency::VND),
            "VUV" => std::result::Result::Ok(NullableCurrency::VUV),
            "WST" => std::result::Result::Ok(NullableCurrency::WST),
            "XAF" => std::result::Result::Ok(NullableCurrency::XAF),
            "XCD" => std::result::Result::Ok(NullableCurrency::XCD),
            "XDR" => std::result::Result::Ok(NullableCurrency::XDR),
            "XOF" => std::result::Result::Ok(NullableCurrency::XOF),
            "XPF" => std::result::Result::Ok(NullableCurrency::XPF),
            "YER" => std::result::Result::Ok(NullableCurrency::YER),
            "ZAR" => std::result::Result::Ok(NullableCurrency::ZAR),
            "ZMW" => std::result::Result::Ok(NullableCurrency::ZMW),
            "ZWD" => std::result::Result::Ok(NullableCurrency::ZWD),
            "null" => std::result::Result::Ok(NullableCurrency::NULL),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Describes the valid schema for possible OAuth access token requests.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequest {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

}

impl OauthAccessTokenRequest {
    pub fn new(grant_type: String, ) -> OauthAccessTokenRequest {
        OauthAccessTokenRequest {
            grant_type: grant_type,
        }
    }
}

/// Converts the OauthAccessTokenRequest value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenRequest {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("grant_type".to_string());
        params.push(self.grant_type.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequest value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequest {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub grant_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequest".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "grant_type" => intermediate_rep.grant_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequest".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequest {
            grant_type: intermediate_rep.grant_type.into_iter().next().ok_or("grant_type missing in OauthAccessTokenRequest".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequest> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequest>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequest>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequest - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequest> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequest as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequest - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A request to exchange an authorization code for an access token.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequestCode {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    #[serde(rename = "code")]
    pub code: String,

    #[serde(rename = "redirect_uri")]
    pub redirect_uri: String,

}

impl OauthAccessTokenRequestCode {
    pub fn new(grant_type: String, code: String, redirect_uri: String, ) -> OauthAccessTokenRequestCode {
        OauthAccessTokenRequestCode {
            grant_type: grant_type,
            code: code,
            redirect_uri: redirect_uri,
        }
    }
}

/// Converts the OauthAccessTokenRequestCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenRequestCode {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("grant_type".to_string());
        params.push(self.grant_type.to_string());


        params.push("code".to_string());
        params.push(self.code.to_string());


        params.push("redirect_uri".to_string());
        params.push(self.redirect_uri.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequestCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequestCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub code: Vec<String>,
            pub redirect_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequestCode".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "grant_type" => intermediate_rep.grant_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "redirect_uri" => intermediate_rep.redirect_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequestCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequestCode {
            grant_type: intermediate_rep.grant_type.into_iter().next().ok_or("grant_type missing in OauthAccessTokenRequestCode".to_string())?,
            code: intermediate_rep.code.into_iter().next().ok_or("code missing in OauthAccessTokenRequestCode".to_string())?,
            redirect_uri: intermediate_rep.redirect_uri.into_iter().next().ok_or("redirect_uri missing in OauthAccessTokenRequestCode".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequestCode> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequestCode>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequestCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequestCode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequestCode> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequestCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequestCode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequestCodeAllOf {
    #[serde(rename = "code")]
    pub code: String,

    #[serde(rename = "redirect_uri")]
    pub redirect_uri: String,

}

impl OauthAccessTokenRequestCodeAllOf {
    pub fn new(code: String, redirect_uri: String, ) -> OauthAccessTokenRequestCodeAllOf {
        OauthAccessTokenRequestCodeAllOf {
            code: code,
            redirect_uri: redirect_uri,
        }
    }
}

/// Converts the OauthAccessTokenRequestCodeAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenRequestCodeAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("code".to_string());
        params.push(self.code.to_string());


        params.push("redirect_uri".to_string());
        params.push(self.redirect_uri.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequestCodeAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequestCodeAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub code: Vec<String>,
            pub redirect_uri: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequestCodeAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "code" => intermediate_rep.code.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "redirect_uri" => intermediate_rep.redirect_uri.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequestCodeAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequestCodeAllOf {
            code: intermediate_rep.code.into_iter().next().ok_or("code missing in OauthAccessTokenRequestCodeAllOf".to_string())?,
            redirect_uri: intermediate_rep.redirect_uri.into_iter().next().ok_or("redirect_uri missing in OauthAccessTokenRequestCodeAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequestCodeAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequestCodeAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequestCodeAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequestCodeAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequestCodeAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequestCodeAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequestCodeAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A request to exchange a refresh token for a new access token.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequestRefresh {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "grant_type")]
    pub grant_type: String,

    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

}

impl OauthAccessTokenRequestRefresh {
    pub fn new(grant_type: String, refresh_token: String, ) -> OauthAccessTokenRequestRefresh {
        OauthAccessTokenRequestRefresh {
            grant_type: grant_type,
            refresh_token: refresh_token,
            scope: None,
        }
    }
}

/// Converts the OauthAccessTokenRequestRefresh value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenRequestRefresh {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("grant_type".to_string());
        params.push(self.grant_type.to_string());


        params.push("refresh_token".to_string());
        params.push(self.refresh_token.to_string());


        if let Some(ref scope) = self.scope {
            params.push("scope".to_string());
            params.push(scope.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequestRefresh value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequestRefresh {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub grant_type: Vec<String>,
            pub refresh_token: Vec<String>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequestRefresh".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "grant_type" => intermediate_rep.grant_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequestRefresh".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequestRefresh {
            grant_type: intermediate_rep.grant_type.into_iter().next().ok_or("grant_type missing in OauthAccessTokenRequestRefresh".to_string())?,
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or("refresh_token missing in OauthAccessTokenRequestRefresh".to_string())?,
            scope: intermediate_rep.scope.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequestRefresh> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequestRefresh>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequestRefresh>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequestRefresh - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequestRefresh> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequestRefresh as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequestRefresh - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenRequestRefreshAllOf {
    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "scope")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub scope: Option<String>,

}

impl OauthAccessTokenRequestRefreshAllOf {
    pub fn new(refresh_token: String, ) -> OauthAccessTokenRequestRefreshAllOf {
        OauthAccessTokenRequestRefreshAllOf {
            refresh_token: refresh_token,
            scope: None,
        }
    }
}

/// Converts the OauthAccessTokenRequestRefreshAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenRequestRefreshAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("refresh_token".to_string());
        params.push(self.refresh_token.to_string());


        if let Some(ref scope) = self.scope {
            params.push("scope".to_string());
            params.push(scope.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenRequestRefreshAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenRequestRefreshAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub refresh_token: Vec<String>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenRequestRefreshAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenRequestRefreshAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenRequestRefreshAllOf {
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or("refresh_token missing in OauthAccessTokenRequestRefreshAllOf".to_string())?,
            scope: intermediate_rep.scope.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenRequestRefreshAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenRequestRefreshAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenRequestRefreshAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenRequestRefreshAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenRequestRefreshAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenRequestRefreshAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenRequestRefreshAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A successful OAuth access token response.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponse {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: isize,

    #[serde(rename = "scope")]
    pub scope: String,

}

impl OauthAccessTokenResponse {
    pub fn new(access_token: String, expires_in: isize, scope: String, ) -> OauthAccessTokenResponse {
        OauthAccessTokenResponse {
            response_type: None,
            access_token: access_token,
            token_type: "bearer".to_string(),
            expires_in: expires_in,
            scope: scope,
        }
    }
}

/// Converts the OauthAccessTokenResponse value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenResponse {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref response_type) = self.response_type {
            params.push("response_type".to_string());
            params.push(response_type.to_string());
        }


        params.push("access_token".to_string());
        params.push(self.access_token.to_string());


        params.push("token_type".to_string());
        params.push(self.token_type.to_string());


        params.push("expires_in".to_string());
        params.push(self.expires_in.to_string());


        params.push("scope".to_string());
        params.push(self.scope.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponse value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponse {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<isize>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponse".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "expires_in" => intermediate_rep.expires_in.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponse".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponse {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or("access_token missing in OauthAccessTokenResponse".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or("token_type missing in OauthAccessTokenResponse".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or("expires_in missing in OauthAccessTokenResponse".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or("scope missing in OauthAccessTokenResponse".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponse> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponse>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponse>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponse - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponse> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponse as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponse - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A successful OAuth access token response for the authorization code flow.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseCode {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: isize,

    #[serde(rename = "scope")]
    pub scope: String,

    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "refresh_token_expires_in")]
    pub refresh_token_expires_in: isize,

}

impl OauthAccessTokenResponseCode {
    pub fn new(access_token: String, expires_in: isize, scope: String, refresh_token: String, refresh_token_expires_in: isize, ) -> OauthAccessTokenResponseCode {
        OauthAccessTokenResponseCode {
            response_type: None,
            access_token: access_token,
            token_type: "bearer".to_string(),
            expires_in: expires_in,
            scope: scope,
            refresh_token: refresh_token,
            refresh_token_expires_in: refresh_token_expires_in,
        }
    }
}

/// Converts the OauthAccessTokenResponseCode value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenResponseCode {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref response_type) = self.response_type {
            params.push("response_type".to_string());
            params.push(response_type.to_string());
        }


        params.push("access_token".to_string());
        params.push(self.access_token.to_string());


        params.push("token_type".to_string());
        params.push(self.token_type.to_string());


        params.push("expires_in".to_string());
        params.push(self.expires_in.to_string());


        params.push("scope".to_string());
        params.push(self.scope.to_string());


        params.push("refresh_token".to_string());
        params.push(self.refresh_token.to_string());


        params.push("refresh_token_expires_in".to_string());
        params.push(self.refresh_token_expires_in.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseCode value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseCode {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<isize>,
            pub scope: Vec<String>,
            pub refresh_token: Vec<String>,
            pub refresh_token_expires_in: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseCode".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "expires_in" => intermediate_rep.expires_in.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "refresh_token_expires_in" => intermediate_rep.refresh_token_expires_in.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseCode".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseCode {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or("access_token missing in OauthAccessTokenResponseCode".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or("token_type missing in OauthAccessTokenResponseCode".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or("expires_in missing in OauthAccessTokenResponseCode".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or("scope missing in OauthAccessTokenResponseCode".to_string())?,
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or("refresh_token missing in OauthAccessTokenResponseCode".to_string())?,
            refresh_token_expires_in: intermediate_rep.refresh_token_expires_in.into_iter().next().ok_or("refresh_token_expires_in missing in OauthAccessTokenResponseCode".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseCode> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseCode>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseCode>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseCode - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseCode> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseCode as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseCode - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseCodeAllOf {
    #[serde(rename = "refresh_token")]
    pub refresh_token: String,

    #[serde(rename = "refresh_token_expires_in")]
    pub refresh_token_expires_in: isize,

}

impl OauthAccessTokenResponseCodeAllOf {
    pub fn new(refresh_token: String, refresh_token_expires_in: isize, ) -> OauthAccessTokenResponseCodeAllOf {
        OauthAccessTokenResponseCodeAllOf {
            refresh_token: refresh_token,
            refresh_token_expires_in: refresh_token_expires_in,
        }
    }
}

/// Converts the OauthAccessTokenResponseCodeAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenResponseCodeAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("refresh_token".to_string());
        params.push(self.refresh_token.to_string());


        params.push("refresh_token_expires_in".to_string());
        params.push(self.refresh_token_expires_in.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseCodeAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseCodeAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub refresh_token: Vec<String>,
            pub refresh_token_expires_in: Vec<isize>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseCodeAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "refresh_token" => intermediate_rep.refresh_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "refresh_token_expires_in" => intermediate_rep.refresh_token_expires_in.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseCodeAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseCodeAllOf {
            refresh_token: intermediate_rep.refresh_token.into_iter().next().ok_or("refresh_token missing in OauthAccessTokenResponseCodeAllOf".to_string())?,
            refresh_token_expires_in: intermediate_rep.refresh_token_expires_in.into_iter().next().ok_or("refresh_token_expires_in missing in OauthAccessTokenResponseCodeAllOf".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseCodeAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseCodeAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseCodeAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseCodeAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseCodeAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseCodeAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseCodeAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// A successful OAuth access token response for the refresh token flow.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct OauthAccessTokenResponseRefresh {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "response_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub response_type: Option<String>,

    #[serde(rename = "access_token")]
    pub access_token: String,

    #[serde(rename = "token_type")]
    pub token_type: String,

    #[serde(rename = "expires_in")]
    pub expires_in: isize,

    #[serde(rename = "scope")]
    pub scope: String,

}

impl OauthAccessTokenResponseRefresh {
    pub fn new(access_token: String, expires_in: isize, scope: String, ) -> OauthAccessTokenResponseRefresh {
        OauthAccessTokenResponseRefresh {
            response_type: None,
            access_token: access_token,
            token_type: "bearer".to_string(),
            expires_in: expires_in,
            scope: scope,
        }
    }
}

/// Converts the OauthAccessTokenResponseRefresh value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for OauthAccessTokenResponseRefresh {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref response_type) = self.response_type {
            params.push("response_type".to_string());
            params.push(response_type.to_string());
        }


        params.push("access_token".to_string());
        params.push(self.access_token.to_string());


        params.push("token_type".to_string());
        params.push(self.token_type.to_string());


        params.push("expires_in".to_string());
        params.push(self.expires_in.to_string());


        params.push("scope".to_string());
        params.push(self.scope.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a OauthAccessTokenResponseRefresh value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for OauthAccessTokenResponseRefresh {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub response_type: Vec<String>,
            pub access_token: Vec<String>,
            pub token_type: Vec<String>,
            pub expires_in: Vec<isize>,
            pub scope: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing OauthAccessTokenResponseRefresh".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "response_type" => intermediate_rep.response_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "access_token" => intermediate_rep.access_token.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "token_type" => intermediate_rep.token_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "expires_in" => intermediate_rep.expires_in.push(<isize as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "scope" => intermediate_rep.scope.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing OauthAccessTokenResponseRefresh".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(OauthAccessTokenResponseRefresh {
            response_type: intermediate_rep.response_type.into_iter().next(),
            access_token: intermediate_rep.access_token.into_iter().next().ok_or("access_token missing in OauthAccessTokenResponseRefresh".to_string())?,
            token_type: intermediate_rep.token_type.into_iter().next().ok_or("token_type missing in OauthAccessTokenResponseRefresh".to_string())?,
            expires_in: intermediate_rep.expires_in.into_iter().next().ok_or("expires_in missing in OauthAccessTokenResponseRefresh".to_string())?,
            scope: intermediate_rep.scope.into_iter().next().ok_or("scope missing in OauthAccessTokenResponseRefresh".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<OauthAccessTokenResponseRefresh> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<OauthAccessTokenResponseRefresh>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<OauthAccessTokenResponseRefresh>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for OauthAccessTokenResponseRefresh - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<OauthAccessTokenResponseRefresh> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <OauthAccessTokenResponseRefresh as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into OauthAccessTokenResponseRefresh - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Campaign objective type.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ObjectiveType {
    #[serde(rename = "AWARENESS")]
    AWARENESS,
    #[serde(rename = "CONSIDERATION")]
    CONSIDERATION,
    #[serde(rename = "VIDEO_VIEW")]
    VIDEO_VIEW,
    #[serde(rename = "WEB_CONVERSION")]
    WEB_CONVERSION,
    #[serde(rename = "CATALOG_SALES")]
    CATALOG_SALES,
    #[serde(rename = "WEB_SESSIONS")]
    WEB_SESSIONS,
    #[serde(rename = "AWARENESS_RESERVED")]
    AWARENESS_RESERVED,
    #[serde(rename = "ENGAGEMENT")]
    ENGAGEMENT,
}

impl std::fmt::Display for ObjectiveType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ObjectiveType::AWARENESS => write!(f, "{}", "AWARENESS"),
            ObjectiveType::CONSIDERATION => write!(f, "{}", "CONSIDERATION"),
            ObjectiveType::VIDEO_VIEW => write!(f, "{}", "VIDEO_VIEW"),
            ObjectiveType::WEB_CONVERSION => write!(f, "{}", "WEB_CONVERSION"),
            ObjectiveType::CATALOG_SALES => write!(f, "{}", "CATALOG_SALES"),
            ObjectiveType::WEB_SESSIONS => write!(f, "{}", "WEB_SESSIONS"),
            ObjectiveType::AWARENESS_RESERVED => write!(f, "{}", "AWARENESS_RESERVED"),
            ObjectiveType::ENGAGEMENT => write!(f, "{}", "ENGAGEMENT"),
        }
    }
}

impl std::str::FromStr for ObjectiveType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "AWARENESS" => std::result::Result::Ok(ObjectiveType::AWARENESS),
            "CONSIDERATION" => std::result::Result::Ok(ObjectiveType::CONSIDERATION),
            "VIDEO_VIEW" => std::result::Result::Ok(ObjectiveType::VIDEO_VIEW),
            "WEB_CONVERSION" => std::result::Result::Ok(ObjectiveType::WEB_CONVERSION),
            "CATALOG_SALES" => std::result::Result::Ok(ObjectiveType::CATALOG_SALES),
            "WEB_SESSIONS" => std::result::Result::Ok(ObjectiveType::WEB_SESSIONS),
            "AWARENESS_RESERVED" => std::result::Result::Ok(ObjectiveType::AWARENESS_RESERVED),
            "ENGAGEMENT" => std::result::Result::Ok(ObjectiveType::ENGAGEMENT),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Ad group pacing delivery type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PacingDeliveryType {
    #[serde(rename = "STANDARD")]
    STANDARD,
    #[serde(rename = "ACCELERATED")]
    ACCELERATED,
}

impl std::fmt::Display for PacingDeliveryType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PacingDeliveryType::STANDARD => write!(f, "{}", "STANDARD"),
            PacingDeliveryType::ACCELERATED => write!(f, "{}", "ACCELERATED"),
        }
    }
}

impl std::str::FromStr for PacingDeliveryType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "STANDARD" => std::result::Result::Ok(PacingDeliveryType::STANDARD),
            "ACCELERATED" => std::result::Result::Ok(PacingDeliveryType::ACCELERATED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Paginated {
    #[serde(rename = "items")]
    pub items: Vec<serde_json::Value>,

    #[serde(rename = "bookmark")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub bookmark: Option<swagger::Nullable<String>>,

}

impl Paginated {
    pub fn new(items: Vec<serde_json::Value>, ) -> Paginated {
        Paginated {
            items: items,
            bookmark: None,
        }
    }
}

/// Converts the Paginated value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Paginated {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping items in query parameter serialization


        if let Some(ref bookmark) = self.bookmark {
            params.push("bookmark".to_string());
            params.push(bookmark.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Paginated value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Paginated {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub items: Vec<Vec<serde_json::Value>>,
            pub bookmark: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Paginated".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in Paginated".to_string()),
                    "bookmark" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Paginated".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing Paginated".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Paginated {
            items: intermediate_rep.items.into_iter().next().ok_or("items missing in Paginated".to_string())?,
            bookmark: std::result::Result::Err("Nullable types not supported in Paginated".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Paginated> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Paginated>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Paginated>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Paginated - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Paginated> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Paginated as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Paginated - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Pin
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Pin {
    #[serde(rename = "id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub id: Option<String>,

    #[serde(rename = "created_at")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub created_at: Option<chrono::DateTime::<chrono::Utc>>,

    #[serde(rename = "link")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub link: Option<swagger::Nullable<String>>,

    #[serde(rename = "title")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub title: Option<swagger::Nullable<String>>,

    #[serde(rename = "description")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<swagger::Nullable<String>>,

    #[serde(rename = "alt_text")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub alt_text: Option<swagger::Nullable<String>>,

    /// The board to which this Pin belongs.
    #[serde(rename = "board_id")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_id: Option<String>,

    /// The board section to which this Pin belongs.
    #[serde(rename = "board_section_id")]
    #[serde(deserialize_with = "swagger::nullable_format::deserialize_optional_nullable")]
    #[serde(default = "swagger::nullable_format::default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_section_id: Option<swagger::Nullable<String>>,

    #[serde(rename = "board_owner")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub board_owner: Option<BoardOwner>,

    #[serde(rename = "media")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media: Option<PinMedia>,

    #[serde(rename = "media_source")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_source: Option<PinMediaSource>,

}

impl Pin {
    pub fn new() -> Pin {
        Pin {
            id: None,
            created_at: None,
            link: None,
            title: None,
            description: None,
            alt_text: None,
            board_id: None,
            board_section_id: None,
            board_owner: None,
            media: None,
            media_source: None,
        }
    }
}

/// Converts the Pin value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for Pin {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref id) = self.id {
            params.push("id".to_string());
            params.push(id.to_string());
        }

        // Skipping created_at in query parameter serialization


        if let Some(ref link) = self.link {
            params.push("link".to_string());
            params.push(link.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref title) = self.title {
            params.push("title".to_string());
            params.push(title.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref description) = self.description {
            params.push("description".to_string());
            params.push(description.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref alt_text) = self.alt_text {
            params.push("alt_text".to_string());
            params.push(alt_text.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }


        if let Some(ref board_id) = self.board_id {
            params.push("board_id".to_string());
            params.push(board_id.to_string());
        }


        if let Some(ref board_section_id) = self.board_section_id {
            params.push("board_section_id".to_string());
            params.push(board_section_id.as_ref().map_or("null".to_string(), |x| x.to_string()));
        }

        // Skipping board_owner in query parameter serialization
        // Skipping board_owner in query parameter serialization

        // Skipping media in query parameter serialization
        // Skipping media in query parameter serialization

        // Skipping media_source in query parameter serialization
        // Skipping media_source in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Pin value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Pin {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub id: Vec<String>,
            pub created_at: Vec<chrono::DateTime::<chrono::Utc>>,
            pub link: Vec<String>,
            pub title: Vec<String>,
            pub description: Vec<String>,
            pub alt_text: Vec<String>,
            pub board_id: Vec<String>,
            pub board_section_id: Vec<String>,
            pub board_owner: Vec<BoardOwner>,
            pub media: Vec<PinMedia>,
            pub media_source: Vec<PinMediaSource>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Pin".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "id" => intermediate_rep.id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "created_at" => intermediate_rep.created_at.push(<chrono::DateTime::<chrono::Utc> as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "link" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "title" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "description" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "alt_text" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "board_id" => intermediate_rep.board_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "board_section_id" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in Pin".to_string()),
                    "board_owner" => intermediate_rep.board_owner.push(<BoardOwner as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media" => intermediate_rep.media.push(<PinMedia as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media_source" => intermediate_rep.media_source.push(<PinMediaSource as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Pin".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Pin {
            id: intermediate_rep.id.into_iter().next(),
            created_at: intermediate_rep.created_at.into_iter().next(),
            link: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            title: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            description: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            alt_text: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            board_id: intermediate_rep.board_id.into_iter().next(),
            board_section_id: std::result::Result::Err("Nullable types not supported in Pin".to_string())?,
            board_owner: intermediate_rep.board_owner.into_iter().next(),
            media: intermediate_rep.media.into_iter().next(),
            media_source: intermediate_rep.media_source.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Pin> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<Pin>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Pin>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for Pin - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<Pin> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Pin as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into Pin - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Pin media objects.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMedia {
    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

}

impl PinMedia {
    pub fn new() -> PinMedia {
        PinMedia {
            media_type: None,
        }
    }
}

/// Converts the PinMedia value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMedia {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref media_type) = self.media_type {
            params.push("media_type".to_string());
            params.push(media_type.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMedia value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMedia {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub media_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMedia".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMedia".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMedia {
            media_type: intermediate_rep.media_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMedia> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMedia>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMedia>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMedia - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMedia> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMedia as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMedia - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Pin media source.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSource {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "content_type")]
    pub content_type: String,

    #[serde(rename = "data")]
    pub data: String,

    #[serde(rename = "url")]
    pub url: String,

    #[serde(rename = "cover_image_url")]
    pub cover_image_url: String,

    #[serde(rename = "media_id")]
    pub media_id: String,

}

impl PinMediaSource {
    pub fn new(source_type: String, content_type: String, data: String, url: String, cover_image_url: String, media_id: String, ) -> PinMediaSource {
        PinMediaSource {
            source_type: source_type,
            content_type: content_type,
            data: data,
            url: url,
            cover_image_url: cover_image_url,
            media_id: media_id,
        }
    }
}

/// Converts the PinMediaSource value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMediaSource {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("source_type".to_string());
        params.push(self.source_type.to_string());


        params.push("content_type".to_string());
        params.push(self.content_type.to_string());


        params.push("data".to_string());
        params.push(self.data.to_string());


        params.push("url".to_string());
        params.push(self.url.to_string());


        params.push("cover_image_url".to_string());
        params.push(self.cover_image_url.to_string());


        params.push("media_id".to_string());
        params.push(self.media_id.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSource value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSource {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub content_type: Vec<String>,
            pub data: Vec<String>,
            pub url: Vec<String>,
            pub cover_image_url: Vec<String>,
            pub media_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSource".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "content_type" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "cover_image_url" => intermediate_rep.cover_image_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSource".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSource {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or("source_type missing in PinMediaSource".to_string())?,
            content_type: intermediate_rep.content_type.into_iter().next().ok_or("content_type missing in PinMediaSource".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or("data missing in PinMediaSource".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or("url missing in PinMediaSource".to_string())?,
            cover_image_url: intermediate_rep.cover_image_url.into_iter().next().ok_or("cover_image_url missing in PinMediaSource".to_string())?,
            media_id: intermediate_rep.media_id.into_iter().next().ok_or("media_id missing in PinMediaSource".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSource> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSource>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSource>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSource - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMediaSource> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSource as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSource - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Base64-encoded image media source
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImageBase64 {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "content_type")]
    pub content_type: String,

    #[serde(rename = "data")]
    pub data: String,

}

impl PinMediaSourceImageBase64 {
    pub fn new(source_type: String, content_type: String, data: String, ) -> PinMediaSourceImageBase64 {
        PinMediaSourceImageBase64 {
            source_type: source_type,
            content_type: content_type,
            data: data,
        }
    }
}

/// Converts the PinMediaSourceImageBase64 value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMediaSourceImageBase64 {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("source_type".to_string());
        params.push(self.source_type.to_string());


        params.push("content_type".to_string());
        params.push(self.content_type.to_string());


        params.push("data".to_string());
        params.push(self.data.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImageBase64 value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImageBase64 {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub content_type: Vec<String>,
            pub data: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImageBase64".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "content_type" => intermediate_rep.content_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "data" => intermediate_rep.data.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImageBase64".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImageBase64 {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or("source_type missing in PinMediaSourceImageBase64".to_string())?,
            content_type: intermediate_rep.content_type.into_iter().next().ok_or("content_type missing in PinMediaSourceImageBase64".to_string())?,
            data: intermediate_rep.data.into_iter().next().ok_or("data missing in PinMediaSourceImageBase64".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImageBase64> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImageBase64>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImageBase64>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImageBase64 - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMediaSourceImageBase64> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImageBase64 as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImageBase64 - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Image URL-based media source
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceImageUrl {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

    #[serde(rename = "url")]
    pub url: String,

}

impl PinMediaSourceImageUrl {
    pub fn new(source_type: String, url: String, ) -> PinMediaSourceImageUrl {
        PinMediaSourceImageUrl {
            source_type: source_type,
            url: url,
        }
    }
}

/// Converts the PinMediaSourceImageUrl value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMediaSourceImageUrl {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("source_type".to_string());
        params.push(self.source_type.to_string());


        params.push("url".to_string());
        params.push(self.url.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceImageUrl value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceImageUrl {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceImageUrl".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceImageUrl".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceImageUrl {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or("source_type missing in PinMediaSourceImageUrl".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or("url missing in PinMediaSourceImageUrl".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceImageUrl> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceImageUrl>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceImageUrl>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceImageUrl - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMediaSourceImageUrl> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceImageUrl as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceImageUrl - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Video ID-based media source
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaSourceVideoId {
    // Note: inline enums are not fully supported by openapi-generator
    #[serde(rename = "source_type")]
    pub source_type: String,

    #[serde(rename = "cover_image_url")]
    pub cover_image_url: String,

    #[serde(rename = "media_id")]
    pub media_id: String,

}

impl PinMediaSourceVideoId {
    pub fn new(source_type: String, cover_image_url: String, media_id: String, ) -> PinMediaSourceVideoId {
        PinMediaSourceVideoId {
            source_type: source_type,
            cover_image_url: cover_image_url,
            media_id: media_id,
        }
    }
}

/// Converts the PinMediaSourceVideoId value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMediaSourceVideoId {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        params.push("source_type".to_string());
        params.push(self.source_type.to_string());


        params.push("cover_image_url".to_string());
        params.push(self.cover_image_url.to_string());


        params.push("media_id".to_string());
        params.push(self.media_id.to_string());

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaSourceVideoId value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaSourceVideoId {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub source_type: Vec<String>,
            pub cover_image_url: Vec<String>,
            pub media_id: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaSourceVideoId".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "source_type" => intermediate_rep.source_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "cover_image_url" => intermediate_rep.cover_image_url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    "media_id" => intermediate_rep.media_id.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaSourceVideoId".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaSourceVideoId {
            source_type: intermediate_rep.source_type.into_iter().next().ok_or("source_type missing in PinMediaSourceVideoId".to_string())?,
            cover_image_url: intermediate_rep.cover_image_url.into_iter().next().ok_or("cover_image_url missing in PinMediaSourceVideoId".to_string())?,
            media_id: intermediate_rep.media_id.into_iter().next().ok_or("media_id missing in PinMediaSourceVideoId".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaSourceVideoId> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaSourceVideoId>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaSourceVideoId>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaSourceVideoId - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMediaSourceVideoId> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaSourceVideoId as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaSourceVideoId - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Pin with image.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithImage {
    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<std::collections::HashMap<String, models::ImageDetails>>,

    #[serde(rename = "media_type")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub media_type: Option<String>,

}

impl PinMediaWithImage {
    pub fn new() -> PinMediaWithImage {
        PinMediaWithImage {
            images: None,
            media_type: None,
        }
    }
}

/// Converts the PinMediaWithImage value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMediaWithImage {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping images in query parameter serialization
        // Skipping images in query parameter serialization


        if let Some(ref media_type) = self.media_type {
            params.push("media_type".to_string());
            params.push(media_type.to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithImage value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithImage {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub images: Vec<std::collections::HashMap<String, models::ImageDetails>>,
            pub media_type: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithImage".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaWithImage".to_string()),
                    "media_type" => intermediate_rep.media_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithImage".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithImage {
            images: intermediate_rep.images.into_iter().next(),
            media_type: intermediate_rep.media_type.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithImage> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithImage>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithImage>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithImage - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMediaWithImage> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithImage as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithImage - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PinMediaWithImageAllOf {
    #[serde(rename = "images")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub images: Option<std::collections::HashMap<String, models::ImageDetails>>,

}

impl PinMediaWithImageAllOf {
    pub fn new() -> PinMediaWithImageAllOf {
        PinMediaWithImageAllOf {
            images: None,
        }
    }
}

/// Converts the PinMediaWithImageAllOf value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for PinMediaWithImageAllOf {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping images in query parameter serialization
        // Skipping images in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PinMediaWithImageAllOf value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PinMediaWithImageAllOf {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub images: Vec<std::collections::HashMap<String, models::ImageDetails>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PinMediaWithImageAllOf".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "images" => return std::result::Result::Err("Parsing a container in this style is not supported in PinMediaWithImageAllOf".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PinMediaWithImageAllOf".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PinMediaWithImageAllOf {
            images: intermediate_rep.images.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PinMediaWithImageAllOf> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<PinMediaWithImageAllOf>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PinMediaWithImageAllOf>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for PinMediaWithImageAllOf - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<PinMediaWithImageAllOf> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PinMediaWithImageAllOf as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into PinMediaWithImageAllOf - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Summary status for pin promotions
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PinPromotionSummaryStatus {
    #[serde(rename = "APPROVED")]
    APPROVED,
    #[serde(rename = "PAUSED")]
    PAUSED,
    #[serde(rename = "PENDING")]
    PENDING,
    #[serde(rename = "REJECTED")]
    REJECTED,
    #[serde(rename = "ADVERTISER_DISABLED")]
    ADVERTISER_DISABLED,
    #[serde(rename = "ARCHIVED")]
    ARCHIVED,
}

impl std::fmt::Display for PinPromotionSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PinPromotionSummaryStatus::APPROVED => write!(f, "{}", "APPROVED"),
            PinPromotionSummaryStatus::PAUSED => write!(f, "{}", "PAUSED"),
            PinPromotionSummaryStatus::PENDING => write!(f, "{}", "PENDING"),
            PinPromotionSummaryStatus::REJECTED => write!(f, "{}", "REJECTED"),
            PinPromotionSummaryStatus::ADVERTISER_DISABLED => write!(f, "{}", "ADVERTISER_DISABLED"),
            PinPromotionSummaryStatus::ARCHIVED => write!(f, "{}", "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for PinPromotionSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "APPROVED" => std::result::Result::Ok(PinPromotionSummaryStatus::APPROVED),
            "PAUSED" => std::result::Result::Ok(PinPromotionSummaryStatus::PAUSED),
            "PENDING" => std::result::Result::Ok(PinPromotionSummaryStatus::PENDING),
            "REJECTED" => std::result::Result::Ok(PinPromotionSummaryStatus::REJECTED),
            "ADVERTISER_DISABLED" => std::result::Result::Ok(PinPromotionSummaryStatus::ADVERTISER_DISABLED),
            "ARCHIVED" => std::result::Result::Ok(PinPromotionSummaryStatus::ARCHIVED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Campaign placement group type
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum PlacementGroupType {
    #[serde(rename = "ALL")]
    ALL,
    #[serde(rename = "SEARCH")]
    SEARCH,
    #[serde(rename = "BROWSE")]
    BROWSE,
    #[serde(rename = "OTHER")]
    OTHER,
}

impl std::fmt::Display for PlacementGroupType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            PlacementGroupType::ALL => write!(f, "{}", "ALL"),
            PlacementGroupType::SEARCH => write!(f, "{}", "SEARCH"),
            PlacementGroupType::BROWSE => write!(f, "{}", "BROWSE"),
            PlacementGroupType::OTHER => write!(f, "{}", "OTHER"),
        }
    }
}

impl std::str::FromStr for PlacementGroupType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "ALL" => std::result::Result::Ok(PlacementGroupType::ALL),
            "SEARCH" => std::result::Result::Ok(PlacementGroupType::SEARCH),
            "BROWSE" => std::result::Result::Ok(PlacementGroupType::BROWSE),
            "OTHER" => std::result::Result::Ok(PlacementGroupType::OTHER),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Default availability for products in a feed.
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ProductAvailabilityType {
    #[serde(rename = "IN_STOCK")]
    IN_STOCK,
    #[serde(rename = "OUT_OF_STOCK")]
    OUT_OF_STOCK,
    #[serde(rename = "PREORDER")]
    PREORDER,
    #[serde(rename = "null")]
    NULL,
}

impl std::fmt::Display for ProductAvailabilityType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProductAvailabilityType::IN_STOCK => write!(f, "{}", "IN_STOCK"),
            ProductAvailabilityType::OUT_OF_STOCK => write!(f, "{}", "OUT_OF_STOCK"),
            ProductAvailabilityType::PREORDER => write!(f, "{}", "PREORDER"),
            ProductAvailabilityType::NULL => write!(f, "{}", "null"),
        }
    }
}

impl std::str::FromStr for ProductAvailabilityType {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "IN_STOCK" => std::result::Result::Ok(ProductAvailabilityType::IN_STOCK),
            "OUT_OF_STOCK" => std::result::Result::Ok(ProductAvailabilityType::OUT_OF_STOCK),
            "PREORDER" => std::result::Result::Ok(ProductAvailabilityType::PREORDER),
            "null" => std::result::Result::Ok(ProductAvailabilityType::NULL),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

/// Summary status for product group
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ProductGroupSummaryStatus {
    #[serde(rename = "RUNNING")]
    RUNNING,
    #[serde(rename = "PAUSED")]
    PAUSED,
    #[serde(rename = "EXCLUDED")]
    EXCLUDED,
    #[serde(rename = "ARCHIVED")]
    ARCHIVED,
}

impl std::fmt::Display for ProductGroupSummaryStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ProductGroupSummaryStatus::RUNNING => write!(f, "{}", "RUNNING"),
            ProductGroupSummaryStatus::PAUSED => write!(f, "{}", "PAUSED"),
            ProductGroupSummaryStatus::EXCLUDED => write!(f, "{}", "EXCLUDED"),
            ProductGroupSummaryStatus::ARCHIVED => write!(f, "{}", "ARCHIVED"),
        }
    }
}

impl std::str::FromStr for ProductGroupSummaryStatus {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "RUNNING" => std::result::Result::Ok(ProductGroupSummaryStatus::RUNNING),
            "PAUSED" => std::result::Result::Ok(ProductGroupSummaryStatus::PAUSED),
            "EXCLUDED" => std::result::Result::Ok(ProductGroupSummaryStatus::EXCLUDED),
            "ARCHIVED" => std::result::Result::Ok(ProductGroupSummaryStatus::ARCHIVED),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType0Filter {
    #[serde(rename = "PRODUCT_TYPE_0")]
    pub product_type_0: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl ProductType0Filter {
    pub fn new(product_type_0: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType0Filter {
        ProductType0Filter {
            product_type_0: product_type_0,
        }
    }
}

/// Converts the ProductType0Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProductType0Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping PRODUCT_TYPE_0 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType0Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType0Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub product_type_0: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType0Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "PRODUCT_TYPE_0" => intermediate_rep.product_type_0.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType0Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType0Filter {
            product_type_0: intermediate_rep.product_type_0.into_iter().next().ok_or("PRODUCT_TYPE_0 missing in ProductType0Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType0Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType0Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType0Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType0Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProductType0Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType0Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType0Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType1Filter {
    #[serde(rename = "PRODUCT_TYPE_1")]
    pub product_type_1: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl ProductType1Filter {
    pub fn new(product_type_1: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType1Filter {
        ProductType1Filter {
            product_type_1: product_type_1,
        }
    }
}

/// Converts the ProductType1Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProductType1Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping PRODUCT_TYPE_1 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType1Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType1Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub product_type_1: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType1Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "PRODUCT_TYPE_1" => intermediate_rep.product_type_1.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType1Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType1Filter {
            product_type_1: intermediate_rep.product_type_1.into_iter().next().ok_or("PRODUCT_TYPE_1 missing in ProductType1Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType1Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType1Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType1Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType1Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProductType1Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType1Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType1Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType2Filter {
    #[serde(rename = "PRODUCT_TYPE_2")]
    pub product_type_2: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl ProductType2Filter {
    pub fn new(product_type_2: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType2Filter {
        ProductType2Filter {
            product_type_2: product_type_2,
        }
    }
}

/// Converts the ProductType2Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProductType2Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping PRODUCT_TYPE_2 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType2Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType2Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub product_type_2: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType2Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "PRODUCT_TYPE_2" => intermediate_rep.product_type_2.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType2Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType2Filter {
            product_type_2: intermediate_rep.product_type_2.into_iter().next().ok_or("PRODUCT_TYPE_2 missing in ProductType2Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType2Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType2Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType2Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType2Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProductType2Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType2Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType2Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType3Filter {
    #[serde(rename = "PRODUCT_TYPE_3")]
    pub product_type_3: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl ProductType3Filter {
    pub fn new(product_type_3: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType3Filter {
        ProductType3Filter {
            product_type_3: product_type_3,
        }
    }
}

/// Converts the ProductType3Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProductType3Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping PRODUCT_TYPE_3 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType3Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType3Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub product_type_3: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType3Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "PRODUCT_TYPE_3" => intermediate_rep.product_type_3.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType3Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType3Filter {
            product_type_3: intermediate_rep.product_type_3.into_iter().next().ok_or("PRODUCT_TYPE_3 missing in ProductType3Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType3Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType3Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType3Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType3Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProductType3Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType3Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType3Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ProductType4Filter {
    #[serde(rename = "PRODUCT_TYPE_4")]
    pub product_type_4: models::CatalogsProductGroupMultipleStringListCriteria,

}

impl ProductType4Filter {
    pub fn new(product_type_4: models::CatalogsProductGroupMultipleStringListCriteria, ) -> ProductType4Filter {
        ProductType4Filter {
            product_type_4: product_type_4,
        }
    }
}

/// Converts the ProductType4Filter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for ProductType4Filter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping PRODUCT_TYPE_4 in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ProductType4Filter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ProductType4Filter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub product_type_4: Vec<models::CatalogsProductGroupMultipleStringListCriteria>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ProductType4Filter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "PRODUCT_TYPE_4" => intermediate_rep.product_type_4.push(<models::CatalogsProductGroupMultipleStringListCriteria as std::str::FromStr>::from_str(val).map_err(|x| format!("{}", x))?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ProductType4Filter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ProductType4Filter {
            product_type_4: intermediate_rep.product_type_4.into_iter().next().ok_or("PRODUCT_TYPE_4 missing in ProductType4Filter".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ProductType4Filter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<ProductType4Filter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ProductType4Filter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for ProductType4Filter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<ProductType4Filter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ProductType4Filter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into ProductType4Filter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Reporting columns
/// Enumeration of values.
/// Since this enum's variants do not hold data, we can easily define them them as `#[repr(C)]`
/// which helps with FFI.
#[allow(non_camel_case_types)]
#[repr(C)]
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk_enum_derive::LabelledGenericEnum))]
pub enum ReportingColumnAsync {
    #[serde(rename = "SPEND_IN_MICRO_DOLLAR")]
    SPEND_IN_MICRO_DOLLAR,
    #[serde(rename = "PAID_IMPRESSION")]
    PAID_IMPRESSION,
    #[serde(rename = "CPC_IN_MICRO_DOLLAR")]
    CPC_IN_MICRO_DOLLAR,
    #[serde(rename = "ECPC_IN_MICRO_DOLLAR")]
    ECPC_IN_MICRO_DOLLAR,
    #[serde(rename = "CTR")]
    CTR,
    #[serde(rename = "ECTR")]
    ECTR,
    #[serde(rename = "CAMPAIGN_NAME")]
    CAMPAIGN_NAME,
    #[serde(rename = "CAMPAIGN_STATUS")]
    CAMPAIGN_STATUS,
    #[serde(rename = "AD_STATUS")]
    AD_STATUS,
    #[serde(rename = "PIN_PROMOTION_STATUS")]
    PIN_PROMOTION_STATUS,
    #[serde(rename = "PIN_ID")]
    PIN_ID,
    #[serde(rename = "TOTAL_ENGAGEMENT")]
    TOTAL_ENGAGEMENT,
    #[serde(rename = "ENGAGEMENT_1")]
    ENGAGEMENT_1,
    #[serde(rename = "ENGAGEMENT_2")]
    ENGAGEMENT_2,
    #[serde(rename = "ECPM_IN_MICRO_DOLLAR")]
    ECPM_IN_MICRO_DOLLAR,
    #[serde(rename = "CTR_2")]
    CTR_2,
    #[serde(rename = "CAMPAIGN_ID")]
    CAMPAIGN_ID,
    #[serde(rename = "ADVERTISER_ID")]
    ADVERTISER_ID,
    #[serde(rename = "AD_ACCOUNT_ID")]
    AD_ACCOUNT_ID,
    #[serde(rename = "PIN_PROMOTION_ID")]
    PIN_PROMOTION_ID,
    #[serde(rename = "AD_ID")]
    AD_ID,
    #[serde(rename = "AD_GROUP_ID")]
    AD_GROUP_ID,
    #[serde(rename = "CAMPAIGN_MANAGED_STATUS")]
    CAMPAIGN_MANAGED_STATUS,
    #[serde(rename = "CPM_IN_MICRO_DOLLAR")]
    CPM_IN_MICRO_DOLLAR,
    #[serde(rename = "AD_GROUP_NAME")]
    AD_GROUP_NAME,
    #[serde(rename = "AD_GROUP_STATUS")]
    AD_GROUP_STATUS,
    #[serde(rename = "PRODUCT_GROUP_ID")]
    PRODUCT_GROUP_ID,
    #[serde(rename = "CLICKTHROUGH_1")]
    CLICKTHROUGH_1,
    #[serde(rename = "REPIN_1")]
    REPIN_1,
    #[serde(rename = "IMPRESSION_1")]
    IMPRESSION_1,
    #[serde(rename = "IMPRESSION_1_GROSS")]
    IMPRESSION_1_GROSS,
    #[serde(rename = "CLICKTHROUGH_1_GROSS")]
    CLICKTHROUGH_1_GROSS,
    #[serde(rename = "OUTBOUND_CLICK_1")]
    OUTBOUND_CLICK_1,
    #[serde(rename = "CLICKTHROUGH_2")]
    CLICKTHROUGH_2,
    #[serde(rename = "REPIN_2")]
    REPIN_2,
    #[serde(rename = "IMPRESSION_2")]
    IMPRESSION_2,
    #[serde(rename = "OUTBOUND_CLICK_2")]
    OUTBOUND_CLICK_2,
    #[serde(rename = "TOTAL_IMPRESSION_USER")]
    TOTAL_IMPRESSION_USER,
    #[serde(rename = "TOTAL_IMPRESSION_FREQUENCY")]
    TOTAL_IMPRESSION_FREQUENCY,
    #[serde(rename = "TOTAL_ENGAGEMENT_PAGE_VISIT")]
    TOTAL_ENGAGEMENT_PAGE_VISIT,
    #[serde(rename = "TOTAL_ENGAGEMENT_SIGNUP")]
    TOTAL_ENGAGEMENT_SIGNUP,
    #[serde(rename = "TOTAL_ENGAGEMENT_CHECKOUT")]
    TOTAL_ENGAGEMENT_CHECKOUT,
    #[serde(rename = "TOTAL_ENGAGEMENT_CUSTOM")]
    TOTAL_ENGAGEMENT_CUSTOM,
    #[serde(rename = "TOTAL_ENGAGEMENT_ADD_TO_CART")]
    TOTAL_ENGAGEMENT_ADD_TO_CART,
    #[serde(rename = "TOTAL_ENGAGEMENT_LEAD")]
    TOTAL_ENGAGEMENT_LEAD,
    #[serde(rename = "TOTAL_ENGAGEMENT_SEARCH")]
    TOTAL_ENGAGEMENT_SEARCH,
    #[serde(rename = "TOTAL_ENGAGEMENT_WATCH_VIDEO")]
    TOTAL_ENGAGEMENT_WATCH_VIDEO,
    #[serde(rename = "TOTAL_ENGAGEMENT_VIEW_CATEGORY")]
    TOTAL_ENGAGEMENT_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_ENGAGEMENT_APP_INSTALL")]
    TOTAL_ENGAGEMENT_APP_INSTALL,
    #[serde(rename = "TOTAL_ENGAGEMENT_UNKNOWN")]
    TOTAL_ENGAGEMENT_UNKNOWN,
    #[serde(rename = "TOTAL_CLICK_PAGE_VISIT")]
    TOTAL_CLICK_PAGE_VISIT,
    #[serde(rename = "TOTAL_CLICK_SIGNUP")]
    TOTAL_CLICK_SIGNUP,
    #[serde(rename = "TOTAL_CLICK_CHECKOUT")]
    TOTAL_CLICK_CHECKOUT,
    #[serde(rename = "TOTAL_CLICK_CUSTOM")]
    TOTAL_CLICK_CUSTOM,
    #[serde(rename = "TOTAL_CLICK_ADD_TO_CART")]
    TOTAL_CLICK_ADD_TO_CART,
    #[serde(rename = "TOTAL_CLICK_LEAD")]
    TOTAL_CLICK_LEAD,
    #[serde(rename = "TOTAL_CLICK_SEARCH")]
    TOTAL_CLICK_SEARCH,
    #[serde(rename = "TOTAL_CLICK_WATCH_VIDEO")]
    TOTAL_CLICK_WATCH_VIDEO,
    #[serde(rename = "TOTAL_CLICK_VIEW_CATEGORY")]
    TOTAL_CLICK_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_CLICK_APP_INSTALL")]
    TOTAL_CLICK_APP_INSTALL,
    #[serde(rename = "TOTAL_CLICK_UNKNOWN")]
    TOTAL_CLICK_UNKNOWN,
    #[serde(rename = "TOTAL_VIEW_PAGE_VISIT")]
    TOTAL_VIEW_PAGE_VISIT,
    #[serde(rename = "TOTAL_VIEW_SIGNUP")]
    TOTAL_VIEW_SIGNUP,
    #[serde(rename = "TOTAL_VIEW_CHECKOUT")]
    TOTAL_VIEW_CHECKOUT,
    #[serde(rename = "TOTAL_VIEW_CUSTOM")]
    TOTAL_VIEW_CUSTOM,
    #[serde(rename = "TOTAL_VIEW_ADD_TO_CART")]
    TOTAL_VIEW_ADD_TO_CART,
    #[serde(rename = "TOTAL_VIEW_LEAD")]
    TOTAL_VIEW_LEAD,
    #[serde(rename = "TOTAL_VIEW_SEARCH")]
    TOTAL_VIEW_SEARCH,
    #[serde(rename = "TOTAL_VIEW_WATCH_VIDEO")]
    TOTAL_VIEW_WATCH_VIDEO,
    #[serde(rename = "TOTAL_VIEW_VIEW_CATEGORY")]
    TOTAL_VIEW_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_VIEW_APP_INSTALL")]
    TOTAL_VIEW_APP_INSTALL,
    #[serde(rename = "TOTAL_VIEW_UNKNOWN")]
    TOTAL_VIEW_UNKNOWN,
    #[serde(rename = "TOTAL_CONVERSIONS")]
    TOTAL_CONVERSIONS,
    #[serde(rename = "TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY")]
    TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_SIGNUP_QUANTITY")]
    TOTAL_ENGAGEMENT_SIGNUP_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY")]
    TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_CUSTOM_QUANTITY")]
    TOTAL_ENGAGEMENT_CUSTOM_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY")]
    TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_LEAD_QUANTITY")]
    TOTAL_ENGAGEMENT_LEAD_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_SEARCH_QUANTITY")]
    TOTAL_ENGAGEMENT_SEARCH_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY")]
    TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY")]
    TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY,
    #[serde(rename = "TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY")]
    TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_PAGE_VISIT_QUANTITY")]
    TOTAL_CLICK_PAGE_VISIT_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_SIGNUP_QUANTITY")]
    TOTAL_CLICK_SIGNUP_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_CHECKOUT_QUANTITY")]
    TOTAL_CLICK_CHECKOUT_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_CUSTOM_QUANTITY")]
    TOTAL_CLICK_CUSTOM_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_ADD_TO_CART_QUANTITY")]
    TOTAL_CLICK_ADD_TO_CART_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_LEAD_QUANTITY")]
    TOTAL_CLICK_LEAD_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_SEARCH_QUANTITY")]
    TOTAL_CLICK_SEARCH_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_WATCH_VIDEO_QUANTITY")]
    TOTAL_CLICK_WATCH_VIDEO_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_VIEW_CATEGORY_QUANTITY")]
    TOTAL_CLICK_VIEW_CATEGORY_QUANTITY,
    #[serde(rename = "TOTAL_CLICK_UNKNOWN_QUANTITY")]
    TOTAL_CLICK_UNKNOWN_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_PAGE_VISIT_QUANTITY")]
    TOTAL_VIEW_PAGE_VISIT_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_SIGNUP_QUANTITY")]
    TOTAL_VIEW_SIGNUP_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_CHECKOUT_QUANTITY")]
    TOTAL_VIEW_CHECKOUT_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_CUSTOM_QUANTITY")]
    TOTAL_VIEW_CUSTOM_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_ADD_TO_CART_QUANTITY")]
    TOTAL_VIEW_ADD_TO_CART_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_LEAD_QUANTITY")]
    TOTAL_VIEW_LEAD_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_SEARCH_QUANTITY")]
    TOTAL_VIEW_SEARCH_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_WATCH_VIDEO_QUANTITY")]
    TOTAL_VIEW_WATCH_VIDEO_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_VIEW_CATEGORY_QUANTITY")]
    TOTAL_VIEW_VIEW_CATEGORY_QUANTITY,
    #[serde(rename = "TOTAL_VIEW_UNKNOWN_QUANTITY")]
    TOTAL_VIEW_UNKNOWN_QUANTITY,
    #[serde(rename = "TOTAL_CONVERSIONS_QUANTITY")]
    TOTAL_CONVERSIONS_QUANTITY,
    #[serde(rename = "ONSITE_CHECKOUTS_1")]
    ONSITE_CHECKOUTS_1,
    #[serde(rename = "PIN_PROMOTION_NAME")]
    PIN_PROMOTION_NAME,
    #[serde(rename = "AD_NAME")]
    AD_NAME,
    #[serde(rename = "CAMPAIGN_LIFETIME_SPEND_CAP")]
    CAMPAIGN_LIFETIME_SPEND_CAP,
    #[serde(rename = "CAMPAIGN_DAILY_SPEND_CAP")]
    CAMPAIGN_DAILY_SPEND_CAP,
    #[serde(rename = "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION")]
    TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION")]
    TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION,
    #[serde(rename = "TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION")]
    TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION,
    #[serde(rename = "TOTAL_CHECKOUT")]
    TOTAL_CHECKOUT,
    #[serde(rename = "TOTAL_CUSTOM")]
    TOTAL_CUSTOM,
    #[serde(rename = "TOTAL_LEAD")]
    TOTAL_LEAD,
    #[serde(rename = "TOTAL_APP_INSTALL")]
    TOTAL_APP_INSTALL,
    #[serde(rename = "TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_CHECKOUT_QUANTITY")]
    TOTAL_CHECKOUT_QUANTITY,
    #[serde(rename = "APP_INSTALL_COST_PER_ACTION")]
    APP_INSTALL_COST_PER_ACTION,
    #[serde(rename = "VIDEO_3SEC_VIEWS_1")]
    VIDEO_3SEC_VIEWS_1,
    #[serde(rename = "VIDEO_P100_COMPLETE_1")]
    VIDEO_P100_COMPLETE_1,
    #[serde(rename = "VIDEO_P0_COMBINED_1")]
    VIDEO_P0_COMBINED_1,
    #[serde(rename = "VIDEO_P25_COMBINED_1")]
    VIDEO_P25_COMBINED_1,
    #[serde(rename = "VIDEO_P50_COMBINED_1")]
    VIDEO_P50_COMBINED_1,
    #[serde(rename = "VIDEO_P75_COMBINED_1")]
    VIDEO_P75_COMBINED_1,
    #[serde(rename = "VIDEO_P95_COMBINED_1")]
    VIDEO_P95_COMBINED_1,
    #[serde(rename = "VIDEO_MRC_VIEWS_1")]
    VIDEO_MRC_VIEWS_1,
    #[serde(rename = "VIDEO_3SEC_VIEWS_2")]
    VIDEO_3SEC_VIEWS_2,
    #[serde(rename = "VIDEO_P100_COMPLETE_2")]
    VIDEO_P100_COMPLETE_2,
    #[serde(rename = "VIDEO_P0_COMBINED_2")]
    VIDEO_P0_COMBINED_2,
    #[serde(rename = "VIDEO_P25_COMBINED_2")]
    VIDEO_P25_COMBINED_2,
    #[serde(rename = "VIDEO_P50_COMBINED_2")]
    VIDEO_P50_COMBINED_2,
    #[serde(rename = "VIDEO_P75_COMBINED_2")]
    VIDEO_P75_COMBINED_2,
    #[serde(rename = "VIDEO_P95_COMBINED_2")]
    VIDEO_P95_COMBINED_2,
    #[serde(rename = "VIDEO_MRC_VIEWS_2")]
    VIDEO_MRC_VIEWS_2,
    #[serde(rename = "VIDEO_LENGTH")]
    VIDEO_LENGTH,
    #[serde(rename = "CPV_IN_MICRO_DOLLAR")]
    CPV_IN_MICRO_DOLLAR,
    #[serde(rename = "CPCV_IN_MICRO_DOLLAR")]
    CPCV_IN_MICRO_DOLLAR,
    #[serde(rename = "CPCV_P95_IN_MICRO_DOLLAR")]
    CPCV_P95_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_VIDEO_3SEC_VIEWS")]
    TOTAL_VIDEO_3SEC_VIEWS,
    #[serde(rename = "VIDEO_AVG_WATCHTIME_IN_SECOND_1")]
    VIDEO_AVG_WATCHTIME_IN_SECOND_1,
    #[serde(rename = "VIDEO_AVG_WATCHTIME_IN_SECOND_2")]
    VIDEO_AVG_WATCHTIME_IN_SECOND_2,
    #[serde(rename = "TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND")]
    TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND,
    #[serde(rename = "WEB_CHECKOUT_COST_PER_ACTION")]
    WEB_CHECKOUT_COST_PER_ACTION,
    #[serde(rename = "WEB_CHECKOUT_ROAS")]
    WEB_CHECKOUT_ROAS,
    #[serde(rename = "TOTAL_WEB_CHECKOUT")]
    TOTAL_WEB_CHECKOUT,
    #[serde(rename = "TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_CHECKOUT")]
    TOTAL_WEB_CLICK_CHECKOUT,
    #[serde(rename = "TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CHECKOUT")]
    TOTAL_WEB_ENGAGEMENT_CHECKOUT,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_CHECKOUT")]
    TOTAL_WEB_VIEW_CHECKOUT,
    #[serde(rename = "TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "INAPP_CHECKOUT_COST_PER_ACTION")]
    INAPP_CHECKOUT_COST_PER_ACTION,
    #[serde(rename = "INAPP_CHECKOUT_ROAS")]
    INAPP_CHECKOUT_ROAS,
    #[serde(rename = "TOTAL_INAPP_CHECKOUT")]
    TOTAL_INAPP_CHECKOUT,
    #[serde(rename = "TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_CLICK_CHECKOUT")]
    TOTAL_INAPP_CLICK_CHECKOUT,
    #[serde(rename = "TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_CHECKOUT")]
    TOTAL_INAPP_ENGAGEMENT_CHECKOUT,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_VIEW_CHECKOUT")]
    TOTAL_INAPP_VIEW_CHECKOUT,
    #[serde(rename = "TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "OFFLINE_CHECKOUT_COST_PER_ACTION")]
    OFFLINE_CHECKOUT_COST_PER_ACTION,
    #[serde(rename = "OFFLINE_CHECKOUT_ROAS")]
    OFFLINE_CHECKOUT_ROAS,
    #[serde(rename = "TOTAL_OFFLINE_CHECKOUT")]
    TOTAL_OFFLINE_CHECKOUT,
    #[serde(rename = "TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CHECKOUT")]
    TOTAL_OFFLINE_CLICK_CHECKOUT,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT")]
    TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CHECKOUT")]
    TOTAL_OFFLINE_VIEW_CHECKOUT,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_ADD_TO_CART_COST_PER_ACTION")]
    WEB_ADD_TO_CART_COST_PER_ACTION,
    #[serde(rename = "WEB_ADD_TO_CART_ROAS")]
    WEB_ADD_TO_CART_ROAS,
    #[serde(rename = "TOTAL_WEB_ADD_TO_CART")]
    TOTAL_WEB_ADD_TO_CART,
    #[serde(rename = "TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_ADD_TO_CART")]
    TOTAL_WEB_CLICK_ADD_TO_CART,
    #[serde(rename = "TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART")]
    TOTAL_WEB_ENGAGEMENT_ADD_TO_CART,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_ADD_TO_CART")]
    TOTAL_WEB_VIEW_ADD_TO_CART,
    #[serde(rename = "TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "INAPP_ADD_TO_CART_COST_PER_ACTION")]
    INAPP_ADD_TO_CART_COST_PER_ACTION,
    #[serde(rename = "INAPP_ADD_TO_CART_ROAS")]
    INAPP_ADD_TO_CART_ROAS,
    #[serde(rename = "TOTAL_INAPP_ADD_TO_CART")]
    TOTAL_INAPP_ADD_TO_CART,
    #[serde(rename = "TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_CLICK_ADD_TO_CART")]
    TOTAL_INAPP_CLICK_ADD_TO_CART,
    #[serde(rename = "TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART")]
    TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_VIEW_ADD_TO_CART")]
    TOTAL_INAPP_VIEW_ADD_TO_CART,
    #[serde(rename = "TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_PAGE_VISIT_COST_PER_ACTION")]
    WEB_PAGE_VISIT_COST_PER_ACTION,
    #[serde(rename = "WEB_PAGE_VISIT_ROAS")]
    WEB_PAGE_VISIT_ROAS,
    #[serde(rename = "TOTAL_WEB_PAGE_VISIT")]
    TOTAL_WEB_PAGE_VISIT,
    #[serde(rename = "TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_PAGE_VISIT")]
    TOTAL_WEB_CLICK_PAGE_VISIT,
    #[serde(rename = "TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT")]
    TOTAL_WEB_ENGAGEMENT_PAGE_VISIT,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_PAGE_VISIT")]
    TOTAL_WEB_VIEW_PAGE_VISIT,
    #[serde(rename = "TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_SIGNUP_COST_PER_ACTION")]
    WEB_SIGNUP_COST_PER_ACTION,
    #[serde(rename = "WEB_SIGNUP_ROAS")]
    WEB_SIGNUP_ROAS,
    #[serde(rename = "TOTAL_WEB_SIGNUP")]
    TOTAL_WEB_SIGNUP,
    #[serde(rename = "TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_SIGNUP")]
    TOTAL_WEB_CLICK_SIGNUP,
    #[serde(rename = "TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SIGNUP")]
    TOTAL_WEB_ENGAGEMENT_SIGNUP,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_SIGNUP")]
    TOTAL_WEB_VIEW_SIGNUP,
    #[serde(rename = "TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "INAPP_SIGNUP_COST_PER_ACTION")]
    INAPP_SIGNUP_COST_PER_ACTION,
    #[serde(rename = "INAPP_SIGNUP_ROAS")]
    INAPP_SIGNUP_ROAS,
    #[serde(rename = "TOTAL_INAPP_SIGNUP")]
    TOTAL_INAPP_SIGNUP,
    #[serde(rename = "TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_CLICK_SIGNUP")]
    TOTAL_INAPP_CLICK_SIGNUP,
    #[serde(rename = "TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SIGNUP")]
    TOTAL_INAPP_ENGAGEMENT_SIGNUP,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_VIEW_SIGNUP")]
    TOTAL_INAPP_VIEW_SIGNUP,
    #[serde(rename = "TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "OFFLINE_SIGNUP_COST_PER_ACTION")]
    OFFLINE_SIGNUP_COST_PER_ACTION,
    #[serde(rename = "OFFLINE_SIGNUP_ROAS")]
    OFFLINE_SIGNUP_ROAS,
    #[serde(rename = "TOTAL_OFFLINE_SIGNUP")]
    TOTAL_OFFLINE_SIGNUP,
    #[serde(rename = "TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_SIGNUP")]
    TOTAL_OFFLINE_CLICK_SIGNUP,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP")]
    TOTAL_OFFLINE_ENGAGEMENT_SIGNUP,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_SIGNUP")]
    TOTAL_OFFLINE_VIEW_SIGNUP,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_WATCH_VIDEO_COST_PER_ACTION")]
    WEB_WATCH_VIDEO_COST_PER_ACTION,
    #[serde(rename = "WEB_WATCH_VIDEO_ROAS")]
    WEB_WATCH_VIDEO_ROAS,
    #[serde(rename = "TOTAL_WEB_WATCH_VIDEO")]
    TOTAL_WEB_WATCH_VIDEO,
    #[serde(rename = "TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_WATCH_VIDEO")]
    TOTAL_WEB_CLICK_WATCH_VIDEO,
    #[serde(rename = "TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO")]
    TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_WATCH_VIDEO")]
    TOTAL_WEB_VIEW_WATCH_VIDEO,
    #[serde(rename = "TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_LEAD_COST_PER_ACTION")]
    WEB_LEAD_COST_PER_ACTION,
    #[serde(rename = "WEB_LEAD_ROAS")]
    WEB_LEAD_ROAS,
    #[serde(rename = "TOTAL_WEB_LEAD")]
    TOTAL_WEB_LEAD,
    #[serde(rename = "TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_LEAD")]
    TOTAL_WEB_CLICK_LEAD,
    #[serde(rename = "TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_LEAD")]
    TOTAL_WEB_ENGAGEMENT_LEAD,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_LEAD")]
    TOTAL_WEB_VIEW_LEAD,
    #[serde(rename = "TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "OFFLINE_LEAD_COST_PER_ACTION")]
    OFFLINE_LEAD_COST_PER_ACTION,
    #[serde(rename = "OFFLINE_LEAD_ROAS")]
    OFFLINE_LEAD_ROAS,
    #[serde(rename = "TOTAL_OFFLINE_LEAD")]
    TOTAL_OFFLINE_LEAD,
    #[serde(rename = "TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_LEAD")]
    TOTAL_OFFLINE_CLICK_LEAD,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_LEAD")]
    TOTAL_OFFLINE_ENGAGEMENT_LEAD,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_LEAD")]
    TOTAL_OFFLINE_VIEW_LEAD,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_SEARCH_COST_PER_ACTION")]
    WEB_SEARCH_COST_PER_ACTION,
    #[serde(rename = "WEB_SEARCH_ROAS")]
    WEB_SEARCH_ROAS,
    #[serde(rename = "TOTAL_WEB_SEARCH")]
    TOTAL_WEB_SEARCH,
    #[serde(rename = "TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_SEARCH")]
    TOTAL_WEB_CLICK_SEARCH,
    #[serde(rename = "TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SEARCH")]
    TOTAL_WEB_ENGAGEMENT_SEARCH,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_SEARCH")]
    TOTAL_WEB_VIEW_SEARCH,
    #[serde(rename = "TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "INAPP_SEARCH_COST_PER_ACTION")]
    INAPP_SEARCH_COST_PER_ACTION,
    #[serde(rename = "INAPP_SEARCH_ROAS")]
    INAPP_SEARCH_ROAS,
    #[serde(rename = "TOTAL_INAPP_SEARCH")]
    TOTAL_INAPP_SEARCH,
    #[serde(rename = "TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_CLICK_SEARCH")]
    TOTAL_INAPP_CLICK_SEARCH,
    #[serde(rename = "TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SEARCH")]
    TOTAL_INAPP_ENGAGEMENT_SEARCH,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_VIEW_SEARCH")]
    TOTAL_INAPP_VIEW_SEARCH,
    #[serde(rename = "TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_VIEW_CATEGORY_COST_PER_ACTION")]
    WEB_VIEW_CATEGORY_COST_PER_ACTION,
    #[serde(rename = "WEB_VIEW_CATEGORY_ROAS")]
    WEB_VIEW_CATEGORY_ROAS,
    #[serde(rename = "TOTAL_WEB_VIEW_CATEGORY")]
    TOTAL_WEB_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_VIEW_CATEGORY")]
    TOTAL_WEB_CLICK_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY")]
    TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_VIEW_CATEGORY")]
    TOTAL_WEB_VIEW_VIEW_CATEGORY,
    #[serde(rename = "TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_CUSTOM_COST_PER_ACTION")]
    WEB_CUSTOM_COST_PER_ACTION,
    #[serde(rename = "WEB_CUSTOM_ROAS")]
    WEB_CUSTOM_ROAS,
    #[serde(rename = "TOTAL_WEB_CUSTOM")]
    TOTAL_WEB_CUSTOM,
    #[serde(rename = "TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_CUSTOM")]
    TOTAL_WEB_CLICK_CUSTOM,
    #[serde(rename = "TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CUSTOM")]
    TOTAL_WEB_ENGAGEMENT_CUSTOM,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_CUSTOM")]
    TOTAL_WEB_VIEW_CUSTOM,
    #[serde(rename = "TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "OFFLINE_CUSTOM_COST_PER_ACTION")]
    OFFLINE_CUSTOM_COST_PER_ACTION,
    #[serde(rename = "OFFLINE_CUSTOM_ROAS")]
    OFFLINE_CUSTOM_ROAS,
    #[serde(rename = "TOTAL_OFFLINE_CUSTOM")]
    TOTAL_OFFLINE_CUSTOM,
    #[serde(rename = "TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CUSTOM")]
    TOTAL_OFFLINE_CLICK_CUSTOM,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM")]
    TOTAL_OFFLINE_ENGAGEMENT_CUSTOM,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CUSTOM")]
    TOTAL_OFFLINE_VIEW_CUSTOM,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "WEB_UNKNOWN_COST_PER_ACTION")]
    WEB_UNKNOWN_COST_PER_ACTION,
    #[serde(rename = "WEB_UNKNOWN_ROAS")]
    WEB_UNKNOWN_ROAS,
    #[serde(rename = "TOTAL_WEB_UNKNOWN")]
    TOTAL_WEB_UNKNOWN,
    #[serde(rename = "TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_CLICK_UNKNOWN")]
    TOTAL_WEB_CLICK_UNKNOWN,
    #[serde(rename = "TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_UNKNOWN")]
    TOTAL_WEB_ENGAGEMENT_UNKNOWN,
    #[serde(rename = "TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_WEB_VIEW_UNKNOWN")]
    TOTAL_WEB_VIEW_UNKNOWN,
    #[serde(rename = "TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "INAPP_UNKNOWN_COST_PER_ACTION")]
    INAPP_UNKNOWN_COST_PER_ACTION,
    #[serde(rename = "INAPP_UNKNOWN_ROAS")]
    INAPP_UNKNOWN_ROAS,
    #[serde(rename = "TOTAL_INAPP_UNKNOWN")]
    TOTAL_INAPP_UNKNOWN,
    #[serde(rename = "TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_CLICK_UNKNOWN")]
    TOTAL_INAPP_CLICK_UNKNOWN,
    #[serde(rename = "TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_UNKNOWN")]
    TOTAL_INAPP_ENGAGEMENT_UNKNOWN,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_VIEW_UNKNOWN")]
    TOTAL_INAPP_VIEW_UNKNOWN,
    #[serde(rename = "TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "OFFLINE_UNKNOWN_COST_PER_ACTION")]
    OFFLINE_UNKNOWN_COST_PER_ACTION,
    #[serde(rename = "OFFLINE_UNKNOWN_ROAS")]
    OFFLINE_UNKNOWN_ROAS,
    #[serde(rename = "TOTAL_OFFLINE_UNKNOWN")]
    TOTAL_OFFLINE_UNKNOWN,
    #[serde(rename = "TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_UNKNOWN")]
    TOTAL_OFFLINE_CLICK_UNKNOWN,
    #[serde(rename = "TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN")]
    TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN,
    #[serde(rename = "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_UNKNOWN")]
    TOTAL_OFFLINE_VIEW_UNKNOWN,
    #[serde(rename = "TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "INAPP_APP_INSTALL_COST_PER_ACTION")]
    INAPP_APP_INSTALL_COST_PER_ACTION,
    #[serde(rename = "INAPP_APP_INSTALL_ROAS")]
    INAPP_APP_INSTALL_ROAS,
    #[serde(rename = "TOTAL_INAPP_APP_INSTALL")]
    TOTAL_INAPP_APP_INSTALL,
    #[serde(rename = "TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_CLICK_APP_INSTALL")]
    TOTAL_INAPP_CLICK_APP_INSTALL,
    #[serde(rename = "TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL")]
    TOTAL_INAPP_ENGAGEMENT_APP_INSTALL,
    #[serde(rename = "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "TOTAL_INAPP_VIEW_APP_INSTALL")]
    TOTAL_INAPP_VIEW_APP_INSTALL,
    #[serde(rename = "TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "IDEA_PIN_PRODUCT_TAG_VISIT_1")]
    IDEA_PIN_PRODUCT_TAG_VISIT_1,
    #[serde(rename = "IDEA_PIN_PRODUCT_TAG_VISIT_2")]
    IDEA_PIN_PRODUCT_TAG_VISIT_2,
    #[serde(rename = "REPIN_RATE")]
    REPIN_RATE,
    #[serde(rename = "TOTAL_VIDEO_P95_COMBINED")]
    TOTAL_VIDEO_P95_COMBINED,
    #[serde(rename = "AD_GROUP_ENTITY_STATUS")]
    AD_GROUP_ENTITY_STATUS,
    #[serde(rename = "ECPCV_P95_IN_DOLLAR")]
    ECPCV_P95_IN_DOLLAR,
    #[serde(rename = "ENGAGEMENT_RATE")]
    ENGAGEMENT_RATE,
    #[serde(rename = "PAGE_VISIT_COST_PER_ACTION")]
    PAGE_VISIT_COST_PER_ACTION,
    #[serde(rename = "TOTAL_PAGE_VISIT")]
    TOTAL_PAGE_VISIT,
    #[serde(rename = "CHECKOUT_ROAS")]
    CHECKOUT_ROAS,
    #[serde(rename = "TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR")]
    TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR,
    #[serde(rename = "ECPCV_IN_DOLLAR")]
    ECPCV_IN_DOLLAR,
    #[serde(rename = "TOTAL_VIDEO_P75_COMBINED")]
    TOTAL_VIDEO_P75_COMBINED,
    #[serde(rename = "TOTAL_VIDEO_P50_COMBINED")]
    TOTAL_VIDEO_P50_COMBINED,
    #[serde(rename = "TOTAL_SIGNUP")]
    TOTAL_SIGNUP,
    #[serde(rename = "TOTAL_VIDEO_P0_COMBINED")]
    TOTAL_VIDEO_P0_COMBINED,
    #[serde(rename = "SPEND_IN_DOLLAR")]
    SPEND_IN_DOLLAR,
    #[serde(rename = "EENGAGEMENT_RATE")]
    EENGAGEMENT_RATE,
    #[serde(rename = "TOTAL_VIDEO_P25_COMBINED")]
    TOTAL_VIDEO_P25_COMBINED,
    #[serde(rename = "CPM_IN_DOLLAR")]
    CPM_IN_DOLLAR,
    #[serde(rename = "ECPV_IN_DOLLAR")]
    ECPV_IN_DOLLAR,
    #[serde(rename = "TOTAL_CLICKTHROUGH")]
    TOTAL_CLICKTHROUGH,
    #[serde(rename = "ECPE_IN_DOLLAR")]
    ECPE_IN_DOLLAR,
    #[serde(rename = "TOTAL_VIDEO_P100_COMPLETE")]
    TOTAL_VIDEO_P100_COMPLETE,
    #[serde(rename = "CAMPAIGN_ENTITY_STATUS")]
    CAMPAIGN_ENTITY_STATUS,
    #[serde(rename = "PAGE_VISIT_ROAS")]
    PAGE_VISIT_ROAS,
    #[serde(rename = "TOTAL_REPIN_RATE")]
    TOTAL_REPIN_RATE,
    #[serde(rename = "TOTAL_VIDEO_MRC_VIEWS")]
    TOTAL_VIDEO_MRC_VIEWS,
    #[serde(rename = "TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT")]
    TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT,
    #[serde(rename = "ECPC_IN_DOLLAR")]
    ECPC_IN_DOLLAR,
}

impl std::fmt::Display for ReportingColumnAsync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match *self {
            ReportingColumnAsync::SPEND_IN_MICRO_DOLLAR => write!(f, "{}", "SPEND_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::PAID_IMPRESSION => write!(f, "{}", "PAID_IMPRESSION"),
            ReportingColumnAsync::CPC_IN_MICRO_DOLLAR => write!(f, "{}", "CPC_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::ECPC_IN_MICRO_DOLLAR => write!(f, "{}", "ECPC_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::CTR => write!(f, "{}", "CTR"),
            ReportingColumnAsync::ECTR => write!(f, "{}", "ECTR"),
            ReportingColumnAsync::CAMPAIGN_NAME => write!(f, "{}", "CAMPAIGN_NAME"),
            ReportingColumnAsync::CAMPAIGN_STATUS => write!(f, "{}", "CAMPAIGN_STATUS"),
            ReportingColumnAsync::AD_STATUS => write!(f, "{}", "AD_STATUS"),
            ReportingColumnAsync::PIN_PROMOTION_STATUS => write!(f, "{}", "PIN_PROMOTION_STATUS"),
            ReportingColumnAsync::PIN_ID => write!(f, "{}", "PIN_ID"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT => write!(f, "{}", "TOTAL_ENGAGEMENT"),
            ReportingColumnAsync::ENGAGEMENT_1 => write!(f, "{}", "ENGAGEMENT_1"),
            ReportingColumnAsync::ENGAGEMENT_2 => write!(f, "{}", "ENGAGEMENT_2"),
            ReportingColumnAsync::ECPM_IN_MICRO_DOLLAR => write!(f, "{}", "ECPM_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::CTR_2 => write!(f, "{}", "CTR_2"),
            ReportingColumnAsync::CAMPAIGN_ID => write!(f, "{}", "CAMPAIGN_ID"),
            ReportingColumnAsync::ADVERTISER_ID => write!(f, "{}", "ADVERTISER_ID"),
            ReportingColumnAsync::AD_ACCOUNT_ID => write!(f, "{}", "AD_ACCOUNT_ID"),
            ReportingColumnAsync::PIN_PROMOTION_ID => write!(f, "{}", "PIN_PROMOTION_ID"),
            ReportingColumnAsync::AD_ID => write!(f, "{}", "AD_ID"),
            ReportingColumnAsync::AD_GROUP_ID => write!(f, "{}", "AD_GROUP_ID"),
            ReportingColumnAsync::CAMPAIGN_MANAGED_STATUS => write!(f, "{}", "CAMPAIGN_MANAGED_STATUS"),
            ReportingColumnAsync::CPM_IN_MICRO_DOLLAR => write!(f, "{}", "CPM_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::AD_GROUP_NAME => write!(f, "{}", "AD_GROUP_NAME"),
            ReportingColumnAsync::AD_GROUP_STATUS => write!(f, "{}", "AD_GROUP_STATUS"),
            ReportingColumnAsync::PRODUCT_GROUP_ID => write!(f, "{}", "PRODUCT_GROUP_ID"),
            ReportingColumnAsync::CLICKTHROUGH_1 => write!(f, "{}", "CLICKTHROUGH_1"),
            ReportingColumnAsync::REPIN_1 => write!(f, "{}", "REPIN_1"),
            ReportingColumnAsync::IMPRESSION_1 => write!(f, "{}", "IMPRESSION_1"),
            ReportingColumnAsync::IMPRESSION_1_GROSS => write!(f, "{}", "IMPRESSION_1_GROSS"),
            ReportingColumnAsync::CLICKTHROUGH_1_GROSS => write!(f, "{}", "CLICKTHROUGH_1_GROSS"),
            ReportingColumnAsync::OUTBOUND_CLICK_1 => write!(f, "{}", "OUTBOUND_CLICK_1"),
            ReportingColumnAsync::CLICKTHROUGH_2 => write!(f, "{}", "CLICKTHROUGH_2"),
            ReportingColumnAsync::REPIN_2 => write!(f, "{}", "REPIN_2"),
            ReportingColumnAsync::IMPRESSION_2 => write!(f, "{}", "IMPRESSION_2"),
            ReportingColumnAsync::OUTBOUND_CLICK_2 => write!(f, "{}", "OUTBOUND_CLICK_2"),
            ReportingColumnAsync::TOTAL_IMPRESSION_USER => write!(f, "{}", "TOTAL_IMPRESSION_USER"),
            ReportingColumnAsync::TOTAL_IMPRESSION_FREQUENCY => write!(f, "{}", "TOTAL_IMPRESSION_FREQUENCY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_PAGE_VISIT => write!(f, "{}", "TOTAL_ENGAGEMENT_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_SIGNUP => write!(f, "{}", "TOTAL_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_CHECKOUT => write!(f, "{}", "TOTAL_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_CUSTOM => write!(f, "{}", "TOTAL_ENGAGEMENT_CUSTOM"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_ADD_TO_CART => write!(f, "{}", "TOTAL_ENGAGEMENT_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_LEAD => write!(f, "{}", "TOTAL_ENGAGEMENT_LEAD"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_SEARCH => write!(f, "{}", "TOTAL_ENGAGEMENT_SEARCH"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_WATCH_VIDEO => write!(f, "{}", "TOTAL_ENGAGEMENT_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_VIEW_CATEGORY => write!(f, "{}", "TOTAL_ENGAGEMENT_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_APP_INSTALL => write!(f, "{}", "TOTAL_ENGAGEMENT_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_UNKNOWN => write!(f, "{}", "TOTAL_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TOTAL_CLICK_PAGE_VISIT => write!(f, "{}", "TOTAL_CLICK_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_CLICK_SIGNUP => write!(f, "{}", "TOTAL_CLICK_SIGNUP"),
            ReportingColumnAsync::TOTAL_CLICK_CHECKOUT => write!(f, "{}", "TOTAL_CLICK_CHECKOUT"),
            ReportingColumnAsync::TOTAL_CLICK_CUSTOM => write!(f, "{}", "TOTAL_CLICK_CUSTOM"),
            ReportingColumnAsync::TOTAL_CLICK_ADD_TO_CART => write!(f, "{}", "TOTAL_CLICK_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_CLICK_LEAD => write!(f, "{}", "TOTAL_CLICK_LEAD"),
            ReportingColumnAsync::TOTAL_CLICK_SEARCH => write!(f, "{}", "TOTAL_CLICK_SEARCH"),
            ReportingColumnAsync::TOTAL_CLICK_WATCH_VIDEO => write!(f, "{}", "TOTAL_CLICK_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_CLICK_VIEW_CATEGORY => write!(f, "{}", "TOTAL_CLICK_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_CLICK_APP_INSTALL => write!(f, "{}", "TOTAL_CLICK_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_CLICK_UNKNOWN => write!(f, "{}", "TOTAL_CLICK_UNKNOWN"),
            ReportingColumnAsync::TOTAL_VIEW_PAGE_VISIT => write!(f, "{}", "TOTAL_VIEW_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_VIEW_SIGNUP => write!(f, "{}", "TOTAL_VIEW_SIGNUP"),
            ReportingColumnAsync::TOTAL_VIEW_CHECKOUT => write!(f, "{}", "TOTAL_VIEW_CHECKOUT"),
            ReportingColumnAsync::TOTAL_VIEW_CUSTOM => write!(f, "{}", "TOTAL_VIEW_CUSTOM"),
            ReportingColumnAsync::TOTAL_VIEW_ADD_TO_CART => write!(f, "{}", "TOTAL_VIEW_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_VIEW_LEAD => write!(f, "{}", "TOTAL_VIEW_LEAD"),
            ReportingColumnAsync::TOTAL_VIEW_SEARCH => write!(f, "{}", "TOTAL_VIEW_SEARCH"),
            ReportingColumnAsync::TOTAL_VIEW_WATCH_VIDEO => write!(f, "{}", "TOTAL_VIEW_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_VIEW_VIEW_CATEGORY => write!(f, "{}", "TOTAL_VIEW_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_VIEW_APP_INSTALL => write!(f, "{}", "TOTAL_VIEW_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_VIEW_UNKNOWN => write!(f, "{}", "TOTAL_VIEW_UNKNOWN"),
            ReportingColumnAsync::TOTAL_CONVERSIONS => write!(f, "{}", "TOTAL_CONVERSIONS"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_SIGNUP_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_SIGNUP_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_CUSTOM_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_CUSTOM_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_LEAD_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_LEAD_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_SEARCH_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_SEARCH_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY"),
            ReportingColumnAsync::TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY => write!(f, "{}", "TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_PAGE_VISIT_QUANTITY => write!(f, "{}", "TOTAL_CLICK_PAGE_VISIT_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_SIGNUP_QUANTITY => write!(f, "{}", "TOTAL_CLICK_SIGNUP_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_CHECKOUT_QUANTITY => write!(f, "{}", "TOTAL_CLICK_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_CUSTOM_QUANTITY => write!(f, "{}", "TOTAL_CLICK_CUSTOM_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_ADD_TO_CART_QUANTITY => write!(f, "{}", "TOTAL_CLICK_ADD_TO_CART_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_LEAD_QUANTITY => write!(f, "{}", "TOTAL_CLICK_LEAD_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_SEARCH_QUANTITY => write!(f, "{}", "TOTAL_CLICK_SEARCH_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_WATCH_VIDEO_QUANTITY => write!(f, "{}", "TOTAL_CLICK_WATCH_VIDEO_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_VIEW_CATEGORY_QUANTITY => write!(f, "{}", "TOTAL_CLICK_VIEW_CATEGORY_QUANTITY"),
            ReportingColumnAsync::TOTAL_CLICK_UNKNOWN_QUANTITY => write!(f, "{}", "TOTAL_CLICK_UNKNOWN_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_PAGE_VISIT_QUANTITY => write!(f, "{}", "TOTAL_VIEW_PAGE_VISIT_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_SIGNUP_QUANTITY => write!(f, "{}", "TOTAL_VIEW_SIGNUP_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_CHECKOUT_QUANTITY => write!(f, "{}", "TOTAL_VIEW_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_CUSTOM_QUANTITY => write!(f, "{}", "TOTAL_VIEW_CUSTOM_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_ADD_TO_CART_QUANTITY => write!(f, "{}", "TOTAL_VIEW_ADD_TO_CART_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_LEAD_QUANTITY => write!(f, "{}", "TOTAL_VIEW_LEAD_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_SEARCH_QUANTITY => write!(f, "{}", "TOTAL_VIEW_SEARCH_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_WATCH_VIDEO_QUANTITY => write!(f, "{}", "TOTAL_VIEW_WATCH_VIDEO_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_VIEW_CATEGORY_QUANTITY => write!(f, "{}", "TOTAL_VIEW_VIEW_CATEGORY_QUANTITY"),
            ReportingColumnAsync::TOTAL_VIEW_UNKNOWN_QUANTITY => write!(f, "{}", "TOTAL_VIEW_UNKNOWN_QUANTITY"),
            ReportingColumnAsync::TOTAL_CONVERSIONS_QUANTITY => write!(f, "{}", "TOTAL_CONVERSIONS_QUANTITY"),
            ReportingColumnAsync::ONSITE_CHECKOUTS_1 => write!(f, "{}", "ONSITE_CHECKOUTS_1"),
            ReportingColumnAsync::PIN_PROMOTION_NAME => write!(f, "{}", "PIN_PROMOTION_NAME"),
            ReportingColumnAsync::AD_NAME => write!(f, "{}", "AD_NAME"),
            ReportingColumnAsync::CAMPAIGN_LIFETIME_SPEND_CAP => write!(f, "{}", "CAMPAIGN_LIFETIME_SPEND_CAP"),
            ReportingColumnAsync::CAMPAIGN_DAILY_SPEND_CAP => write!(f, "{}", "CAMPAIGN_DAILY_SPEND_CAP"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION"),
            ReportingColumnAsync::TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION => write!(f, "{}", "TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION"),
            ReportingColumnAsync::TOTAL_CHECKOUT => write!(f, "{}", "TOTAL_CHECKOUT"),
            ReportingColumnAsync::TOTAL_CUSTOM => write!(f, "{}", "TOTAL_CUSTOM"),
            ReportingColumnAsync::TOTAL_LEAD => write!(f, "{}", "TOTAL_LEAD"),
            ReportingColumnAsync::TOTAL_APP_INSTALL => write!(f, "{}", "TOTAL_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_CHECKOUT_QUANTITY => write!(f, "{}", "TOTAL_CHECKOUT_QUANTITY"),
            ReportingColumnAsync::APP_INSTALL_COST_PER_ACTION => write!(f, "{}", "APP_INSTALL_COST_PER_ACTION"),
            ReportingColumnAsync::VIDEO_3SEC_VIEWS_1 => write!(f, "{}", "VIDEO_3SEC_VIEWS_1"),
            ReportingColumnAsync::VIDEO_P100_COMPLETE_1 => write!(f, "{}", "VIDEO_P100_COMPLETE_1"),
            ReportingColumnAsync::VIDEO_P0_COMBINED_1 => write!(f, "{}", "VIDEO_P0_COMBINED_1"),
            ReportingColumnAsync::VIDEO_P25_COMBINED_1 => write!(f, "{}", "VIDEO_P25_COMBINED_1"),
            ReportingColumnAsync::VIDEO_P50_COMBINED_1 => write!(f, "{}", "VIDEO_P50_COMBINED_1"),
            ReportingColumnAsync::VIDEO_P75_COMBINED_1 => write!(f, "{}", "VIDEO_P75_COMBINED_1"),
            ReportingColumnAsync::VIDEO_P95_COMBINED_1 => write!(f, "{}", "VIDEO_P95_COMBINED_1"),
            ReportingColumnAsync::VIDEO_MRC_VIEWS_1 => write!(f, "{}", "VIDEO_MRC_VIEWS_1"),
            ReportingColumnAsync::VIDEO_3SEC_VIEWS_2 => write!(f, "{}", "VIDEO_3SEC_VIEWS_2"),
            ReportingColumnAsync::VIDEO_P100_COMPLETE_2 => write!(f, "{}", "VIDEO_P100_COMPLETE_2"),
            ReportingColumnAsync::VIDEO_P0_COMBINED_2 => write!(f, "{}", "VIDEO_P0_COMBINED_2"),
            ReportingColumnAsync::VIDEO_P25_COMBINED_2 => write!(f, "{}", "VIDEO_P25_COMBINED_2"),
            ReportingColumnAsync::VIDEO_P50_COMBINED_2 => write!(f, "{}", "VIDEO_P50_COMBINED_2"),
            ReportingColumnAsync::VIDEO_P75_COMBINED_2 => write!(f, "{}", "VIDEO_P75_COMBINED_2"),
            ReportingColumnAsync::VIDEO_P95_COMBINED_2 => write!(f, "{}", "VIDEO_P95_COMBINED_2"),
            ReportingColumnAsync::VIDEO_MRC_VIEWS_2 => write!(f, "{}", "VIDEO_MRC_VIEWS_2"),
            ReportingColumnAsync::VIDEO_LENGTH => write!(f, "{}", "VIDEO_LENGTH"),
            ReportingColumnAsync::CPV_IN_MICRO_DOLLAR => write!(f, "{}", "CPV_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::CPCV_IN_MICRO_DOLLAR => write!(f, "{}", "CPCV_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::CPCV_P95_IN_MICRO_DOLLAR => write!(f, "{}", "CPCV_P95_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIDEO_3SEC_VIEWS => write!(f, "{}", "TOTAL_VIDEO_3SEC_VIEWS"),
            ReportingColumnAsync::VIDEO_AVG_WATCHTIME_IN_SECOND_1 => write!(f, "{}", "VIDEO_AVG_WATCHTIME_IN_SECOND_1"),
            ReportingColumnAsync::VIDEO_AVG_WATCHTIME_IN_SECOND_2 => write!(f, "{}", "VIDEO_AVG_WATCHTIME_IN_SECOND_2"),
            ReportingColumnAsync::TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND => write!(f, "{}", "TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND"),
            ReportingColumnAsync::WEB_CHECKOUT_COST_PER_ACTION => write!(f, "{}", "WEB_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_CHECKOUT_ROAS => write!(f, "{}", "WEB_CHECKOUT_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_CHECKOUT => write!(f, "{}", "TOTAL_WEB_CHECKOUT"),
            ReportingColumnAsync::TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_CHECKOUT => write!(f, "{}", "TOTAL_WEB_CLICK_CHECKOUT"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CHECKOUT => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_CHECKOUT => write!(f, "{}", "TOTAL_WEB_VIEW_CHECKOUT"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::INAPP_CHECKOUT_COST_PER_ACTION => write!(f, "{}", "INAPP_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::INAPP_CHECKOUT_ROAS => write!(f, "{}", "INAPP_CHECKOUT_ROAS"),
            ReportingColumnAsync::TOTAL_INAPP_CHECKOUT => write!(f, "{}", "TOTAL_INAPP_CHECKOUT"),
            ReportingColumnAsync::TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_CHECKOUT => write!(f, "{}", "TOTAL_INAPP_CLICK_CHECKOUT"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_CHECKOUT => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_CHECKOUT => write!(f, "{}", "TOTAL_INAPP_VIEW_CHECKOUT"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OFFLINE_CHECKOUT_COST_PER_ACTION => write!(f, "{}", "OFFLINE_CHECKOUT_COST_PER_ACTION"),
            ReportingColumnAsync::OFFLINE_CHECKOUT_ROAS => write!(f, "{}", "OFFLINE_CHECKOUT_ROAS"),
            ReportingColumnAsync::TOTAL_OFFLINE_CHECKOUT => write!(f, "{}", "TOTAL_OFFLINE_CHECKOUT"),
            ReportingColumnAsync::TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CHECKOUT => write!(f, "{}", "TOTAL_OFFLINE_CLICK_CHECKOUT"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CHECKOUT => write!(f, "{}", "TOTAL_OFFLINE_VIEW_CHECKOUT"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_ADD_TO_CART_COST_PER_ACTION => write!(f, "{}", "WEB_ADD_TO_CART_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_ADD_TO_CART_ROAS => write!(f, "{}", "WEB_ADD_TO_CART_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_ADD_TO_CART => write!(f, "{}", "TOTAL_WEB_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_ADD_TO_CART => write!(f, "{}", "TOTAL_WEB_CLICK_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_ADD_TO_CART => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_ADD_TO_CART => write!(f, "{}", "TOTAL_WEB_VIEW_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::INAPP_ADD_TO_CART_COST_PER_ACTION => write!(f, "{}", "INAPP_ADD_TO_CART_COST_PER_ACTION"),
            ReportingColumnAsync::INAPP_ADD_TO_CART_ROAS => write!(f, "{}", "INAPP_ADD_TO_CART_ROAS"),
            ReportingColumnAsync::TOTAL_INAPP_ADD_TO_CART => write!(f, "{}", "TOTAL_INAPP_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_ADD_TO_CART => write!(f, "{}", "TOTAL_INAPP_CLICK_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_ADD_TO_CART => write!(f, "{}", "TOTAL_INAPP_VIEW_ADD_TO_CART"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_PAGE_VISIT_COST_PER_ACTION => write!(f, "{}", "WEB_PAGE_VISIT_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_PAGE_VISIT_ROAS => write!(f, "{}", "WEB_PAGE_VISIT_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_PAGE_VISIT => write!(f, "{}", "TOTAL_WEB_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_PAGE_VISIT => write!(f, "{}", "TOTAL_WEB_CLICK_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_PAGE_VISIT => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_PAGE_VISIT => write!(f, "{}", "TOTAL_WEB_VIEW_PAGE_VISIT"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_SIGNUP_COST_PER_ACTION => write!(f, "{}", "WEB_SIGNUP_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_SIGNUP_ROAS => write!(f, "{}", "WEB_SIGNUP_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_SIGNUP => write!(f, "{}", "TOTAL_WEB_SIGNUP"),
            ReportingColumnAsync::TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_SIGNUP => write!(f, "{}", "TOTAL_WEB_CLICK_SIGNUP"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SIGNUP => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_SIGNUP => write!(f, "{}", "TOTAL_WEB_VIEW_SIGNUP"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::INAPP_SIGNUP_COST_PER_ACTION => write!(f, "{}", "INAPP_SIGNUP_COST_PER_ACTION"),
            ReportingColumnAsync::INAPP_SIGNUP_ROAS => write!(f, "{}", "INAPP_SIGNUP_ROAS"),
            ReportingColumnAsync::TOTAL_INAPP_SIGNUP => write!(f, "{}", "TOTAL_INAPP_SIGNUP"),
            ReportingColumnAsync::TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_SIGNUP => write!(f, "{}", "TOTAL_INAPP_CLICK_SIGNUP"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SIGNUP => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_SIGNUP => write!(f, "{}", "TOTAL_INAPP_VIEW_SIGNUP"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OFFLINE_SIGNUP_COST_PER_ACTION => write!(f, "{}", "OFFLINE_SIGNUP_COST_PER_ACTION"),
            ReportingColumnAsync::OFFLINE_SIGNUP_ROAS => write!(f, "{}", "OFFLINE_SIGNUP_ROAS"),
            ReportingColumnAsync::TOTAL_OFFLINE_SIGNUP => write!(f, "{}", "TOTAL_OFFLINE_SIGNUP"),
            ReportingColumnAsync::TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_SIGNUP => write!(f, "{}", "TOTAL_OFFLINE_CLICK_SIGNUP"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_SIGNUP => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_SIGNUP => write!(f, "{}", "TOTAL_OFFLINE_VIEW_SIGNUP"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_WATCH_VIDEO_COST_PER_ACTION => write!(f, "{}", "WEB_WATCH_VIDEO_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_WATCH_VIDEO_ROAS => write!(f, "{}", "WEB_WATCH_VIDEO_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_WATCH_VIDEO => write!(f, "{}", "TOTAL_WEB_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_WATCH_VIDEO => write!(f, "{}", "TOTAL_WEB_CLICK_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_WATCH_VIDEO => write!(f, "{}", "TOTAL_WEB_VIEW_WATCH_VIDEO"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_LEAD_COST_PER_ACTION => write!(f, "{}", "WEB_LEAD_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_LEAD_ROAS => write!(f, "{}", "WEB_LEAD_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_LEAD => write!(f, "{}", "TOTAL_WEB_LEAD"),
            ReportingColumnAsync::TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_LEAD => write!(f, "{}", "TOTAL_WEB_CLICK_LEAD"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_LEAD => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_LEAD"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_LEAD => write!(f, "{}", "TOTAL_WEB_VIEW_LEAD"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OFFLINE_LEAD_COST_PER_ACTION => write!(f, "{}", "OFFLINE_LEAD_COST_PER_ACTION"),
            ReportingColumnAsync::OFFLINE_LEAD_ROAS => write!(f, "{}", "OFFLINE_LEAD_ROAS"),
            ReportingColumnAsync::TOTAL_OFFLINE_LEAD => write!(f, "{}", "TOTAL_OFFLINE_LEAD"),
            ReportingColumnAsync::TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_LEAD => write!(f, "{}", "TOTAL_OFFLINE_CLICK_LEAD"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_LEAD => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_LEAD"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_LEAD => write!(f, "{}", "TOTAL_OFFLINE_VIEW_LEAD"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_SEARCH_COST_PER_ACTION => write!(f, "{}", "WEB_SEARCH_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_SEARCH_ROAS => write!(f, "{}", "WEB_SEARCH_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_SEARCH => write!(f, "{}", "TOTAL_WEB_SEARCH"),
            ReportingColumnAsync::TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_SEARCH => write!(f, "{}", "TOTAL_WEB_CLICK_SEARCH"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SEARCH => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_SEARCH"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_SEARCH => write!(f, "{}", "TOTAL_WEB_VIEW_SEARCH"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::INAPP_SEARCH_COST_PER_ACTION => write!(f, "{}", "INAPP_SEARCH_COST_PER_ACTION"),
            ReportingColumnAsync::INAPP_SEARCH_ROAS => write!(f, "{}", "INAPP_SEARCH_ROAS"),
            ReportingColumnAsync::TOTAL_INAPP_SEARCH => write!(f, "{}", "TOTAL_INAPP_SEARCH"),
            ReportingColumnAsync::TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_SEARCH => write!(f, "{}", "TOTAL_INAPP_CLICK_SEARCH"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SEARCH => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_SEARCH"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_SEARCH => write!(f, "{}", "TOTAL_INAPP_VIEW_SEARCH"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_VIEW_CATEGORY_COST_PER_ACTION => write!(f, "{}", "WEB_VIEW_CATEGORY_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_VIEW_CATEGORY_ROAS => write!(f, "{}", "WEB_VIEW_CATEGORY_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_CATEGORY => write!(f, "{}", "TOTAL_WEB_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_VIEW_CATEGORY => write!(f, "{}", "TOTAL_WEB_CLICK_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_VIEW_CATEGORY => write!(f, "{}", "TOTAL_WEB_VIEW_VIEW_CATEGORY"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_CUSTOM_COST_PER_ACTION => write!(f, "{}", "WEB_CUSTOM_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_CUSTOM_ROAS => write!(f, "{}", "WEB_CUSTOM_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_CUSTOM => write!(f, "{}", "TOTAL_WEB_CUSTOM"),
            ReportingColumnAsync::TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_CUSTOM => write!(f, "{}", "TOTAL_WEB_CLICK_CUSTOM"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CUSTOM => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_CUSTOM"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_CUSTOM => write!(f, "{}", "TOTAL_WEB_VIEW_CUSTOM"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OFFLINE_CUSTOM_COST_PER_ACTION => write!(f, "{}", "OFFLINE_CUSTOM_COST_PER_ACTION"),
            ReportingColumnAsync::OFFLINE_CUSTOM_ROAS => write!(f, "{}", "OFFLINE_CUSTOM_ROAS"),
            ReportingColumnAsync::TOTAL_OFFLINE_CUSTOM => write!(f, "{}", "TOTAL_OFFLINE_CUSTOM"),
            ReportingColumnAsync::TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CUSTOM => write!(f, "{}", "TOTAL_OFFLINE_CLICK_CUSTOM"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CUSTOM => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CUSTOM => write!(f, "{}", "TOTAL_OFFLINE_VIEW_CUSTOM"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::WEB_UNKNOWN_COST_PER_ACTION => write!(f, "{}", "WEB_UNKNOWN_COST_PER_ACTION"),
            ReportingColumnAsync::WEB_UNKNOWN_ROAS => write!(f, "{}", "WEB_UNKNOWN_ROAS"),
            ReportingColumnAsync::TOTAL_WEB_UNKNOWN => write!(f, "{}", "TOTAL_WEB_UNKNOWN"),
            ReportingColumnAsync::TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_UNKNOWN => write!(f, "{}", "TOTAL_WEB_CLICK_UNKNOWN"),
            ReportingColumnAsync::TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_UNKNOWN => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_UNKNOWN => write!(f, "{}", "TOTAL_WEB_VIEW_UNKNOWN"),
            ReportingColumnAsync::TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::INAPP_UNKNOWN_COST_PER_ACTION => write!(f, "{}", "INAPP_UNKNOWN_COST_PER_ACTION"),
            ReportingColumnAsync::INAPP_UNKNOWN_ROAS => write!(f, "{}", "INAPP_UNKNOWN_ROAS"),
            ReportingColumnAsync::TOTAL_INAPP_UNKNOWN => write!(f, "{}", "TOTAL_INAPP_UNKNOWN"),
            ReportingColumnAsync::TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_UNKNOWN => write!(f, "{}", "TOTAL_INAPP_CLICK_UNKNOWN"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_UNKNOWN => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_UNKNOWN => write!(f, "{}", "TOTAL_INAPP_VIEW_UNKNOWN"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::OFFLINE_UNKNOWN_COST_PER_ACTION => write!(f, "{}", "OFFLINE_UNKNOWN_COST_PER_ACTION"),
            ReportingColumnAsync::OFFLINE_UNKNOWN_ROAS => write!(f, "{}", "OFFLINE_UNKNOWN_ROAS"),
            ReportingColumnAsync::TOTAL_OFFLINE_UNKNOWN => write!(f, "{}", "TOTAL_OFFLINE_UNKNOWN"),
            ReportingColumnAsync::TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_UNKNOWN => write!(f, "{}", "TOTAL_OFFLINE_CLICK_UNKNOWN"),
            ReportingColumnAsync::TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN"),
            ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_UNKNOWN => write!(f, "{}", "TOTAL_OFFLINE_VIEW_UNKNOWN"),
            ReportingColumnAsync::TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::INAPP_APP_INSTALL_COST_PER_ACTION => write!(f, "{}", "INAPP_APP_INSTALL_COST_PER_ACTION"),
            ReportingColumnAsync::INAPP_APP_INSTALL_ROAS => write!(f, "{}", "INAPP_APP_INSTALL_ROAS"),
            ReportingColumnAsync::TOTAL_INAPP_APP_INSTALL => write!(f, "{}", "TOTAL_INAPP_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_APP_INSTALL => write!(f, "{}", "TOTAL_INAPP_CLICK_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_APP_INSTALL => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_APP_INSTALL => write!(f, "{}", "TOTAL_INAPP_VIEW_APP_INSTALL"),
            ReportingColumnAsync::TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::IDEA_PIN_PRODUCT_TAG_VISIT_1 => write!(f, "{}", "IDEA_PIN_PRODUCT_TAG_VISIT_1"),
            ReportingColumnAsync::IDEA_PIN_PRODUCT_TAG_VISIT_2 => write!(f, "{}", "IDEA_PIN_PRODUCT_TAG_VISIT_2"),
            ReportingColumnAsync::REPIN_RATE => write!(f, "{}", "REPIN_RATE"),
            ReportingColumnAsync::TOTAL_VIDEO_P95_COMBINED => write!(f, "{}", "TOTAL_VIDEO_P95_COMBINED"),
            ReportingColumnAsync::AD_GROUP_ENTITY_STATUS => write!(f, "{}", "AD_GROUP_ENTITY_STATUS"),
            ReportingColumnAsync::ECPCV_P95_IN_DOLLAR => write!(f, "{}", "ECPCV_P95_IN_DOLLAR"),
            ReportingColumnAsync::ENGAGEMENT_RATE => write!(f, "{}", "ENGAGEMENT_RATE"),
            ReportingColumnAsync::PAGE_VISIT_COST_PER_ACTION => write!(f, "{}", "PAGE_VISIT_COST_PER_ACTION"),
            ReportingColumnAsync::TOTAL_PAGE_VISIT => write!(f, "{}", "TOTAL_PAGE_VISIT"),
            ReportingColumnAsync::CHECKOUT_ROAS => write!(f, "{}", "CHECKOUT_ROAS"),
            ReportingColumnAsync::TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR => write!(f, "{}", "TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR"),
            ReportingColumnAsync::ECPCV_IN_DOLLAR => write!(f, "{}", "ECPCV_IN_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIDEO_P75_COMBINED => write!(f, "{}", "TOTAL_VIDEO_P75_COMBINED"),
            ReportingColumnAsync::TOTAL_VIDEO_P50_COMBINED => write!(f, "{}", "TOTAL_VIDEO_P50_COMBINED"),
            ReportingColumnAsync::TOTAL_SIGNUP => write!(f, "{}", "TOTAL_SIGNUP"),
            ReportingColumnAsync::TOTAL_VIDEO_P0_COMBINED => write!(f, "{}", "TOTAL_VIDEO_P0_COMBINED"),
            ReportingColumnAsync::SPEND_IN_DOLLAR => write!(f, "{}", "SPEND_IN_DOLLAR"),
            ReportingColumnAsync::EENGAGEMENT_RATE => write!(f, "{}", "EENGAGEMENT_RATE"),
            ReportingColumnAsync::TOTAL_VIDEO_P25_COMBINED => write!(f, "{}", "TOTAL_VIDEO_P25_COMBINED"),
            ReportingColumnAsync::CPM_IN_DOLLAR => write!(f, "{}", "CPM_IN_DOLLAR"),
            ReportingColumnAsync::ECPV_IN_DOLLAR => write!(f, "{}", "ECPV_IN_DOLLAR"),
            ReportingColumnAsync::TOTAL_CLICKTHROUGH => write!(f, "{}", "TOTAL_CLICKTHROUGH"),
            ReportingColumnAsync::ECPE_IN_DOLLAR => write!(f, "{}", "ECPE_IN_DOLLAR"),
            ReportingColumnAsync::TOTAL_VIDEO_P100_COMPLETE => write!(f, "{}", "TOTAL_VIDEO_P100_COMPLETE"),
            ReportingColumnAsync::CAMPAIGN_ENTITY_STATUS => write!(f, "{}", "CAMPAIGN_ENTITY_STATUS"),
            ReportingColumnAsync::PAGE_VISIT_ROAS => write!(f, "{}", "PAGE_VISIT_ROAS"),
            ReportingColumnAsync::TOTAL_REPIN_RATE => write!(f, "{}", "TOTAL_REPIN_RATE"),
            ReportingColumnAsync::TOTAL_VIDEO_MRC_VIEWS => write!(f, "{}", "TOTAL_VIDEO_MRC_VIEWS"),
            ReportingColumnAsync::TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT => write!(f, "{}", "TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT"),
            ReportingColumnAsync::ECPC_IN_DOLLAR => write!(f, "{}", "ECPC_IN_DOLLAR"),
        }
    }
}

impl std::str::FromStr for ReportingColumnAsync {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        match s {
            "SPEND_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::SPEND_IN_MICRO_DOLLAR),
            "PAID_IMPRESSION" => std::result::Result::Ok(ReportingColumnAsync::PAID_IMPRESSION),
            "CPC_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CPC_IN_MICRO_DOLLAR),
            "ECPC_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPC_IN_MICRO_DOLLAR),
            "CTR" => std::result::Result::Ok(ReportingColumnAsync::CTR),
            "ECTR" => std::result::Result::Ok(ReportingColumnAsync::ECTR),
            "CAMPAIGN_NAME" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_NAME),
            "CAMPAIGN_STATUS" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_STATUS),
            "AD_STATUS" => std::result::Result::Ok(ReportingColumnAsync::AD_STATUS),
            "PIN_PROMOTION_STATUS" => std::result::Result::Ok(ReportingColumnAsync::PIN_PROMOTION_STATUS),
            "PIN_ID" => std::result::Result::Ok(ReportingColumnAsync::PIN_ID),
            "TOTAL_ENGAGEMENT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT),
            "ENGAGEMENT_1" => std::result::Result::Ok(ReportingColumnAsync::ENGAGEMENT_1),
            "ENGAGEMENT_2" => std::result::Result::Ok(ReportingColumnAsync::ENGAGEMENT_2),
            "ECPM_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPM_IN_MICRO_DOLLAR),
            "CTR_2" => std::result::Result::Ok(ReportingColumnAsync::CTR_2),
            "CAMPAIGN_ID" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_ID),
            "ADVERTISER_ID" => std::result::Result::Ok(ReportingColumnAsync::ADVERTISER_ID),
            "AD_ACCOUNT_ID" => std::result::Result::Ok(ReportingColumnAsync::AD_ACCOUNT_ID),
            "PIN_PROMOTION_ID" => std::result::Result::Ok(ReportingColumnAsync::PIN_PROMOTION_ID),
            "AD_ID" => std::result::Result::Ok(ReportingColumnAsync::AD_ID),
            "AD_GROUP_ID" => std::result::Result::Ok(ReportingColumnAsync::AD_GROUP_ID),
            "CAMPAIGN_MANAGED_STATUS" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_MANAGED_STATUS),
            "CPM_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CPM_IN_MICRO_DOLLAR),
            "AD_GROUP_NAME" => std::result::Result::Ok(ReportingColumnAsync::AD_GROUP_NAME),
            "AD_GROUP_STATUS" => std::result::Result::Ok(ReportingColumnAsync::AD_GROUP_STATUS),
            "PRODUCT_GROUP_ID" => std::result::Result::Ok(ReportingColumnAsync::PRODUCT_GROUP_ID),
            "CLICKTHROUGH_1" => std::result::Result::Ok(ReportingColumnAsync::CLICKTHROUGH_1),
            "REPIN_1" => std::result::Result::Ok(ReportingColumnAsync::REPIN_1),
            "IMPRESSION_1" => std::result::Result::Ok(ReportingColumnAsync::IMPRESSION_1),
            "IMPRESSION_1_GROSS" => std::result::Result::Ok(ReportingColumnAsync::IMPRESSION_1_GROSS),
            "CLICKTHROUGH_1_GROSS" => std::result::Result::Ok(ReportingColumnAsync::CLICKTHROUGH_1_GROSS),
            "OUTBOUND_CLICK_1" => std::result::Result::Ok(ReportingColumnAsync::OUTBOUND_CLICK_1),
            "CLICKTHROUGH_2" => std::result::Result::Ok(ReportingColumnAsync::CLICKTHROUGH_2),
            "REPIN_2" => std::result::Result::Ok(ReportingColumnAsync::REPIN_2),
            "IMPRESSION_2" => std::result::Result::Ok(ReportingColumnAsync::IMPRESSION_2),
            "OUTBOUND_CLICK_2" => std::result::Result::Ok(ReportingColumnAsync::OUTBOUND_CLICK_2),
            "TOTAL_IMPRESSION_USER" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_IMPRESSION_USER),
            "TOTAL_IMPRESSION_FREQUENCY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_IMPRESSION_FREQUENCY),
            "TOTAL_ENGAGEMENT_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_PAGE_VISIT),
            "TOTAL_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_SIGNUP),
            "TOTAL_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_CHECKOUT),
            "TOTAL_ENGAGEMENT_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_CUSTOM),
            "TOTAL_ENGAGEMENT_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_ADD_TO_CART),
            "TOTAL_ENGAGEMENT_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_LEAD),
            "TOTAL_ENGAGEMENT_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_SEARCH),
            "TOTAL_ENGAGEMENT_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_WATCH_VIDEO),
            "TOTAL_ENGAGEMENT_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_VIEW_CATEGORY),
            "TOTAL_ENGAGEMENT_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_APP_INSTALL),
            "TOTAL_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_UNKNOWN),
            "TOTAL_CLICK_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_PAGE_VISIT),
            "TOTAL_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_SIGNUP),
            "TOTAL_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_CHECKOUT),
            "TOTAL_CLICK_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_CUSTOM),
            "TOTAL_CLICK_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_ADD_TO_CART),
            "TOTAL_CLICK_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_LEAD),
            "TOTAL_CLICK_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_SEARCH),
            "TOTAL_CLICK_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_WATCH_VIDEO),
            "TOTAL_CLICK_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_VIEW_CATEGORY),
            "TOTAL_CLICK_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_APP_INSTALL),
            "TOTAL_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_UNKNOWN),
            "TOTAL_VIEW_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_PAGE_VISIT),
            "TOTAL_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_SIGNUP),
            "TOTAL_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CHECKOUT),
            "TOTAL_VIEW_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CUSTOM),
            "TOTAL_VIEW_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_ADD_TO_CART),
            "TOTAL_VIEW_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_LEAD),
            "TOTAL_VIEW_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_SEARCH),
            "TOTAL_VIEW_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_WATCH_VIDEO),
            "TOTAL_VIEW_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_VIEW_CATEGORY),
            "TOTAL_VIEW_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_APP_INSTALL),
            "TOTAL_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_UNKNOWN),
            "TOTAL_CONVERSIONS" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CONVERSIONS),
            "TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY),
            "TOTAL_ENGAGEMENT_SIGNUP_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_SIGNUP_QUANTITY),
            "TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY),
            "TOTAL_ENGAGEMENT_CUSTOM_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_CUSTOM_QUANTITY),
            "TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY),
            "TOTAL_ENGAGEMENT_LEAD_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_LEAD_QUANTITY),
            "TOTAL_ENGAGEMENT_SEARCH_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_SEARCH_QUANTITY),
            "TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY),
            "TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY),
            "TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY),
            "TOTAL_CLICK_PAGE_VISIT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_PAGE_VISIT_QUANTITY),
            "TOTAL_CLICK_SIGNUP_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_SIGNUP_QUANTITY),
            "TOTAL_CLICK_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_CHECKOUT_QUANTITY),
            "TOTAL_CLICK_CUSTOM_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_CUSTOM_QUANTITY),
            "TOTAL_CLICK_ADD_TO_CART_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_ADD_TO_CART_QUANTITY),
            "TOTAL_CLICK_LEAD_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_LEAD_QUANTITY),
            "TOTAL_CLICK_SEARCH_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_SEARCH_QUANTITY),
            "TOTAL_CLICK_WATCH_VIDEO_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_WATCH_VIDEO_QUANTITY),
            "TOTAL_CLICK_VIEW_CATEGORY_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_VIEW_CATEGORY_QUANTITY),
            "TOTAL_CLICK_UNKNOWN_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICK_UNKNOWN_QUANTITY),
            "TOTAL_VIEW_PAGE_VISIT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_PAGE_VISIT_QUANTITY),
            "TOTAL_VIEW_SIGNUP_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_SIGNUP_QUANTITY),
            "TOTAL_VIEW_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CHECKOUT_QUANTITY),
            "TOTAL_VIEW_CUSTOM_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CUSTOM_QUANTITY),
            "TOTAL_VIEW_ADD_TO_CART_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_ADD_TO_CART_QUANTITY),
            "TOTAL_VIEW_LEAD_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_LEAD_QUANTITY),
            "TOTAL_VIEW_SEARCH_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_SEARCH_QUANTITY),
            "TOTAL_VIEW_WATCH_VIDEO_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_WATCH_VIDEO_QUANTITY),
            "TOTAL_VIEW_VIEW_CATEGORY_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_VIEW_CATEGORY_QUANTITY),
            "TOTAL_VIEW_UNKNOWN_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_UNKNOWN_QUANTITY),
            "TOTAL_CONVERSIONS_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CONVERSIONS_QUANTITY),
            "ONSITE_CHECKOUTS_1" => std::result::Result::Ok(ReportingColumnAsync::ONSITE_CHECKOUTS_1),
            "PIN_PROMOTION_NAME" => std::result::Result::Ok(ReportingColumnAsync::PIN_PROMOTION_NAME),
            "AD_NAME" => std::result::Result::Ok(ReportingColumnAsync::AD_NAME),
            "CAMPAIGN_LIFETIME_SPEND_CAP" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_LIFETIME_SPEND_CAP),
            "CAMPAIGN_DAILY_SPEND_CAP" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_DAILY_SPEND_CAP),
            "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION),
            "TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION),
            "TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION),
            "TOTAL_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT),
            "TOTAL_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CUSTOM),
            "TOTAL_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_LEAD),
            "TOTAL_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL),
            "TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_CHECKOUT_QUANTITY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CHECKOUT_QUANTITY),
            "APP_INSTALL_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::APP_INSTALL_COST_PER_ACTION),
            "VIDEO_3SEC_VIEWS_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_3SEC_VIEWS_1),
            "VIDEO_P100_COMPLETE_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P100_COMPLETE_1),
            "VIDEO_P0_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P0_COMBINED_1),
            "VIDEO_P25_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P25_COMBINED_1),
            "VIDEO_P50_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P50_COMBINED_1),
            "VIDEO_P75_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P75_COMBINED_1),
            "VIDEO_P95_COMBINED_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P95_COMBINED_1),
            "VIDEO_MRC_VIEWS_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_MRC_VIEWS_1),
            "VIDEO_3SEC_VIEWS_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_3SEC_VIEWS_2),
            "VIDEO_P100_COMPLETE_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P100_COMPLETE_2),
            "VIDEO_P0_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P0_COMBINED_2),
            "VIDEO_P25_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P25_COMBINED_2),
            "VIDEO_P50_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P50_COMBINED_2),
            "VIDEO_P75_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P75_COMBINED_2),
            "VIDEO_P95_COMBINED_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_P95_COMBINED_2),
            "VIDEO_MRC_VIEWS_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_MRC_VIEWS_2),
            "VIDEO_LENGTH" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_LENGTH),
            "CPV_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CPV_IN_MICRO_DOLLAR),
            "CPCV_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CPCV_IN_MICRO_DOLLAR),
            "CPCV_P95_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CPCV_P95_IN_MICRO_DOLLAR),
            "TOTAL_VIDEO_3SEC_VIEWS" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_3SEC_VIEWS),
            "VIDEO_AVG_WATCHTIME_IN_SECOND_1" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_AVG_WATCHTIME_IN_SECOND_1),
            "VIDEO_AVG_WATCHTIME_IN_SECOND_2" => std::result::Result::Ok(ReportingColumnAsync::VIDEO_AVG_WATCHTIME_IN_SECOND_2),
            "TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND),
            "WEB_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_CHECKOUT_COST_PER_ACTION),
            "WEB_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_CHECKOUT_ROAS),
            "TOTAL_WEB_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CHECKOUT),
            "TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_CHECKOUT),
            "TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CHECKOUT),
            "TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_CHECKOUT),
            "TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "INAPP_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::INAPP_CHECKOUT_COST_PER_ACTION),
            "INAPP_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::INAPP_CHECKOUT_ROAS),
            "TOTAL_INAPP_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CHECKOUT),
            "TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_CHECKOUT),
            "TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_CHECKOUT),
            "TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_CHECKOUT),
            "TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "OFFLINE_CHECKOUT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_CHECKOUT_COST_PER_ACTION),
            "OFFLINE_CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_CHECKOUT_ROAS),
            "TOTAL_OFFLINE_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CHECKOUT),
            "TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_CLICK_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CHECKOUT),
            "TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT),
            "TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_VIEW_CHECKOUT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CHECKOUT),
            "TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR),
            "WEB_ADD_TO_CART_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_ADD_TO_CART_COST_PER_ACTION),
            "WEB_ADD_TO_CART_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_ADD_TO_CART_ROAS),
            "TOTAL_WEB_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ADD_TO_CART),
            "TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_ADD_TO_CART),
            "TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_ADD_TO_CART),
            "TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_ADD_TO_CART),
            "TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "INAPP_ADD_TO_CART_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::INAPP_ADD_TO_CART_COST_PER_ACTION),
            "INAPP_ADD_TO_CART_ROAS" => std::result::Result::Ok(ReportingColumnAsync::INAPP_ADD_TO_CART_ROAS),
            "TOTAL_INAPP_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ADD_TO_CART),
            "TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_CLICK_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_ADD_TO_CART),
            "TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART),
            "TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_VIEW_ADD_TO_CART" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_ADD_TO_CART),
            "TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR),
            "WEB_PAGE_VISIT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_PAGE_VISIT_COST_PER_ACTION),
            "WEB_PAGE_VISIT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_PAGE_VISIT_ROAS),
            "TOTAL_WEB_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_PAGE_VISIT),
            "TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_PAGE_VISIT),
            "TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_PAGE_VISIT),
            "TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_PAGE_VISIT),
            "TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR),
            "WEB_SIGNUP_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_SIGNUP_COST_PER_ACTION),
            "WEB_SIGNUP_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_SIGNUP_ROAS),
            "TOTAL_WEB_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_SIGNUP),
            "TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_SIGNUP),
            "TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SIGNUP),
            "TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_SIGNUP),
            "TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "INAPP_SIGNUP_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::INAPP_SIGNUP_COST_PER_ACTION),
            "INAPP_SIGNUP_ROAS" => std::result::Result::Ok(ReportingColumnAsync::INAPP_SIGNUP_ROAS),
            "TOTAL_INAPP_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_SIGNUP),
            "TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_SIGNUP),
            "TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SIGNUP),
            "TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_SIGNUP),
            "TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "OFFLINE_SIGNUP_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_SIGNUP_COST_PER_ACTION),
            "OFFLINE_SIGNUP_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_SIGNUP_ROAS),
            "TOTAL_OFFLINE_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_SIGNUP),
            "TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_CLICK_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_SIGNUP),
            "TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_SIGNUP),
            "TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_VIEW_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_SIGNUP),
            "TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "WEB_WATCH_VIDEO_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_WATCH_VIDEO_COST_PER_ACTION),
            "WEB_WATCH_VIDEO_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_WATCH_VIDEO_ROAS),
            "TOTAL_WEB_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_WATCH_VIDEO),
            "TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_WATCH_VIDEO),
            "TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO),
            "TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_WATCH_VIDEO" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_WATCH_VIDEO),
            "TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR),
            "WEB_LEAD_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_LEAD_COST_PER_ACTION),
            "WEB_LEAD_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_LEAD_ROAS),
            "TOTAL_WEB_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_LEAD),
            "TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_LEAD),
            "TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_LEAD),
            "TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_LEAD),
            "TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR),
            "OFFLINE_LEAD_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_LEAD_COST_PER_ACTION),
            "OFFLINE_LEAD_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_LEAD_ROAS),
            "TOTAL_OFFLINE_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_LEAD),
            "TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_CLICK_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_LEAD),
            "TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_ENGAGEMENT_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_LEAD),
            "TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_VIEW_LEAD" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_LEAD),
            "TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR),
            "WEB_SEARCH_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_SEARCH_COST_PER_ACTION),
            "WEB_SEARCH_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_SEARCH_ROAS),
            "TOTAL_WEB_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_SEARCH),
            "TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_SEARCH),
            "TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SEARCH),
            "TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_SEARCH),
            "TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "INAPP_SEARCH_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::INAPP_SEARCH_COST_PER_ACTION),
            "INAPP_SEARCH_ROAS" => std::result::Result::Ok(ReportingColumnAsync::INAPP_SEARCH_ROAS),
            "TOTAL_INAPP_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_SEARCH),
            "TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_CLICK_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_SEARCH),
            "TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_ENGAGEMENT_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SEARCH),
            "TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_VIEW_SEARCH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_SEARCH),
            "TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR),
            "WEB_VIEW_CATEGORY_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_VIEW_CATEGORY_COST_PER_ACTION),
            "WEB_VIEW_CATEGORY_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_VIEW_CATEGORY_ROAS),
            "TOTAL_WEB_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_CATEGORY),
            "TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_VIEW_CATEGORY),
            "TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY),
            "TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_VIEW_CATEGORY" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_VIEW_CATEGORY),
            "TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR),
            "WEB_CUSTOM_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_CUSTOM_COST_PER_ACTION),
            "WEB_CUSTOM_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_CUSTOM_ROAS),
            "TOTAL_WEB_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CUSTOM),
            "TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_CUSTOM),
            "TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CUSTOM),
            "TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_CUSTOM),
            "TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "OFFLINE_CUSTOM_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_CUSTOM_COST_PER_ACTION),
            "OFFLINE_CUSTOM_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_CUSTOM_ROAS),
            "TOTAL_OFFLINE_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CUSTOM),
            "TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_CLICK_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CUSTOM),
            "TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CUSTOM),
            "TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_VIEW_CUSTOM" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CUSTOM),
            "TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR),
            "WEB_UNKNOWN_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::WEB_UNKNOWN_COST_PER_ACTION),
            "WEB_UNKNOWN_ROAS" => std::result::Result::Ok(ReportingColumnAsync::WEB_UNKNOWN_ROAS),
            "TOTAL_WEB_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_UNKNOWN),
            "TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_UNKNOWN),
            "TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_UNKNOWN),
            "TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_WEB_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_UNKNOWN),
            "TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "INAPP_UNKNOWN_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::INAPP_UNKNOWN_COST_PER_ACTION),
            "INAPP_UNKNOWN_ROAS" => std::result::Result::Ok(ReportingColumnAsync::INAPP_UNKNOWN_ROAS),
            "TOTAL_INAPP_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_UNKNOWN),
            "TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_UNKNOWN),
            "TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_UNKNOWN),
            "TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_UNKNOWN),
            "TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "OFFLINE_UNKNOWN_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_UNKNOWN_COST_PER_ACTION),
            "OFFLINE_UNKNOWN_ROAS" => std::result::Result::Ok(ReportingColumnAsync::OFFLINE_UNKNOWN_ROAS),
            "TOTAL_OFFLINE_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_UNKNOWN),
            "TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_CLICK_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_UNKNOWN),
            "TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN),
            "TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_OFFLINE_VIEW_UNKNOWN" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_UNKNOWN),
            "TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR),
            "INAPP_APP_INSTALL_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::INAPP_APP_INSTALL_COST_PER_ACTION),
            "INAPP_APP_INSTALL_ROAS" => std::result::Result::Ok(ReportingColumnAsync::INAPP_APP_INSTALL_ROAS),
            "TOTAL_INAPP_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_APP_INSTALL),
            "TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_CLICK_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_APP_INSTALL),
            "TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_APP_INSTALL),
            "TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "TOTAL_INAPP_VIEW_APP_INSTALL" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_APP_INSTALL),
            "TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR),
            "IDEA_PIN_PRODUCT_TAG_VISIT_1" => std::result::Result::Ok(ReportingColumnAsync::IDEA_PIN_PRODUCT_TAG_VISIT_1),
            "IDEA_PIN_PRODUCT_TAG_VISIT_2" => std::result::Result::Ok(ReportingColumnAsync::IDEA_PIN_PRODUCT_TAG_VISIT_2),
            "REPIN_RATE" => std::result::Result::Ok(ReportingColumnAsync::REPIN_RATE),
            "TOTAL_VIDEO_P95_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_P95_COMBINED),
            "AD_GROUP_ENTITY_STATUS" => std::result::Result::Ok(ReportingColumnAsync::AD_GROUP_ENTITY_STATUS),
            "ECPCV_P95_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPCV_P95_IN_DOLLAR),
            "ENGAGEMENT_RATE" => std::result::Result::Ok(ReportingColumnAsync::ENGAGEMENT_RATE),
            "PAGE_VISIT_COST_PER_ACTION" => std::result::Result::Ok(ReportingColumnAsync::PAGE_VISIT_COST_PER_ACTION),
            "TOTAL_PAGE_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_PAGE_VISIT),
            "CHECKOUT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::CHECKOUT_ROAS),
            "TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR),
            "ECPCV_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPCV_IN_DOLLAR),
            "TOTAL_VIDEO_P75_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_P75_COMBINED),
            "TOTAL_VIDEO_P50_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_P50_COMBINED),
            "TOTAL_SIGNUP" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_SIGNUP),
            "TOTAL_VIDEO_P0_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_P0_COMBINED),
            "SPEND_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::SPEND_IN_DOLLAR),
            "EENGAGEMENT_RATE" => std::result::Result::Ok(ReportingColumnAsync::EENGAGEMENT_RATE),
            "TOTAL_VIDEO_P25_COMBINED" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_P25_COMBINED),
            "CPM_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::CPM_IN_DOLLAR),
            "ECPV_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPV_IN_DOLLAR),
            "TOTAL_CLICKTHROUGH" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_CLICKTHROUGH),
            "ECPE_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPE_IN_DOLLAR),
            "TOTAL_VIDEO_P100_COMPLETE" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_P100_COMPLETE),
            "CAMPAIGN_ENTITY_STATUS" => std::result::Result::Ok(ReportingColumnAsync::CAMPAIGN_ENTITY_STATUS),
            "PAGE_VISIT_ROAS" => std::result::Result::Ok(ReportingColumnAsync::PAGE_VISIT_ROAS),
            "TOTAL_REPIN_RATE" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_REPIN_RATE),
            "TOTAL_VIDEO_MRC_VIEWS" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_VIDEO_MRC_VIEWS),
            "TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT" => std::result::Result::Ok(ReportingColumnAsync::TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT),
            "ECPC_IN_DOLLAR" => std::result::Result::Ok(ReportingColumnAsync::ECPC_IN_DOLLAR),
            _ => std::result::Result::Err(format!("Value not valid: {}", s)),
        }
    }
}

#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TargetingTypeFilter {
    /// List of targeting types
    #[serde(rename = "targeting_types")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub targeting_types: Option<Vec<models::AdsAnalyticsTargetingType>>,

}

impl TargetingTypeFilter {
    pub fn new() -> TargetingTypeFilter {
        TargetingTypeFilter {
            targeting_types: None,
        }
    }
}

/// Converts the TargetingTypeFilter value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TargetingTypeFilter {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];
        // Skipping targeting_types in query parameter serialization

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TargetingTypeFilter value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TargetingTypeFilter {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub targeting_types: Vec<Vec<models::AdsAnalyticsTargetingType>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TargetingTypeFilter".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "targeting_types" => return std::result::Result::Err("Parsing a container in this style is not supported in TargetingTypeFilter".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TargetingTypeFilter".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TargetingTypeFilter {
            targeting_types: intermediate_rep.targeting_types.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TargetingTypeFilter> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TargetingTypeFilter>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TargetingTypeFilter>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TargetingTypeFilter - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TargetingTypeFilter> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TargetingTypeFilter as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TargetingTypeFilter - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}


/// Third-party tracking URLs. Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TrackingUrls {
    #[serde(rename = "impression")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub impression: Option<Vec<String>>,

    #[serde(rename = "click")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub click: Option<Vec<String>>,

    #[serde(rename = "engagement")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub engagement: Option<Vec<String>>,

    #[serde(rename = "buyable_button")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub buyable_button: Option<Vec<String>>,

    #[serde(rename = "audience_verification")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub audience_verification: Option<Vec<String>>,

}

impl TrackingUrls {
    pub fn new() -> TrackingUrls {
        TrackingUrls {
            impression: None,
            click: None,
            engagement: None,
            buyable_button: None,
            audience_verification: None,
        }
    }
}

/// Converts the TrackingUrls value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::string::ToString for TrackingUrls {
    fn to_string(&self) -> String {
        let mut params: Vec<String> = vec![];

        if let Some(ref impression) = self.impression {
            params.push("impression".to_string());
            params.push(impression.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref click) = self.click {
            params.push("click".to_string());
            params.push(click.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref engagement) = self.engagement {
            params.push("engagement".to_string());
            params.push(engagement.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref buyable_button) = self.buyable_button {
            params.push("buyable_button".to_string());
            params.push(buyable_button.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }


        if let Some(ref audience_verification) = self.audience_verification {
            params.push("audience_verification".to_string());
            params.push(audience_verification.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",").to_string());
        }

        params.join(",").to_string()
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TrackingUrls value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TrackingUrls {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        #[derive(Default)]
        // An intermediate representation of the struct to use for parsing.
        struct IntermediateRep {
            pub impression: Vec<Vec<String>>,
            pub click: Vec<Vec<String>>,
            pub engagement: Vec<Vec<String>>,
            pub buyable_button: Vec<Vec<String>>,
            pub audience_verification: Vec<Vec<String>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',').into_iter();
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TrackingUrls".to_string())
            };

            if let Some(key) = key_result {
                match key {
                    "impression" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "click" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "engagement" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "buyable_button" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    "audience_verification" => return std::result::Result::Err("Parsing a container in this style is not supported in TrackingUrls".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TrackingUrls".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TrackingUrls {
            impression: intermediate_rep.impression.into_iter().next(),
            click: intermediate_rep.click.into_iter().next(),
            engagement: intermediate_rep.engagement.into_iter().next(),
            buyable_button: intermediate_rep.buyable_button.into_iter().next(),
            audience_verification: intermediate_rep.audience_verification.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TrackingUrls> and hyper::header::HeaderValue

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<header::IntoHeaderValue<TrackingUrls>> for hyper::header::HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TrackingUrls>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match hyper::header::HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Invalid header value for TrackingUrls - value: {} is invalid {}",
                     hdr_value, e))
        }
    }
}

#[cfg(any(feature = "client", feature = "server"))]
impl std::convert::TryFrom<hyper::header::HeaderValue> for header::IntoHeaderValue<TrackingUrls> {
    type Error = String;

    fn try_from(hdr_value: hyper::header::HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TrackingUrls as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(
                            format!("Unable to convert header value '{}' into TrackingUrls - {}",
                                value, err))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(
                 format!("Unable to convert header: {:?} to string: {}",
                     hdr_value, e))
        }
    }
}

