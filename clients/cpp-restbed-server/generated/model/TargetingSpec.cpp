/**
 * Pinterest REST API
 * Pinterest's REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.9.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "TargetingSpec.h"

#include <string>
#include <vector>
#include <map>
#include <sstream>
#include <stdexcept>
#include <regex>
#include <algorithm>
#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include "helpers.h"

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

TargetingSpec::TargetingSpec(boost::property_tree::ptree const& pt)
{
        fromPropertyTree(pt);
}


std::string TargetingSpec::toJsonString(bool prettyJson /* = false */) const
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
    // workaround inspired by: https://stackoverflow.com/a/56395440
    std::regex reg("\\\"([0-9]+\\.{0,1}[0-9]*)\\\"");
    std::string result = std::regex_replace(ss.str(), reg, "$1");
    return result;
}

void TargetingSpec::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree TargetingSpec::toPropertyTree() const
{
	ptree pt;
	ptree tmp_node;
	// generate tree for AGE_BUCKET
    tmp_node.clear();
	if (!m_AGE_BUCKET.empty()) {
        tmp_node = toPt(m_AGE_BUCKET);
		pt.add_child("AGE_BUCKET", tmp_node);
		tmp_node.clear();
	}
	// generate tree for APPTYPE
    tmp_node.clear();
	if (!m_APPTYPE.empty()) {
        tmp_node = toPt(m_APPTYPE);
		pt.add_child("APPTYPE", tmp_node);
		tmp_node.clear();
	}
	// generate tree for AUDIENCE_EXCLUDE
    tmp_node.clear();
	if (!m_AUDIENCE_EXCLUDE.empty()) {
        tmp_node = toPt(m_AUDIENCE_EXCLUDE);
		pt.add_child("AUDIENCE_EXCLUDE", tmp_node);
		tmp_node.clear();
	}
	// generate tree for AUDIENCE_INCLUDE
    tmp_node.clear();
	if (!m_AUDIENCE_INCLUDE.empty()) {
        tmp_node = toPt(m_AUDIENCE_INCLUDE);
		pt.add_child("AUDIENCE_INCLUDE", tmp_node);
		tmp_node.clear();
	}
	// generate tree for GENDER
    tmp_node.clear();
	if (!m_GENDER.empty()) {
        tmp_node = toPt(m_GENDER);
		pt.add_child("GENDER", tmp_node);
		tmp_node.clear();
	}
	// generate tree for GEO
    tmp_node.clear();
	if (!m_GEO.empty()) {
        tmp_node = toPt(m_GEO);
		pt.add_child("GEO", tmp_node);
		tmp_node.clear();
	}
	// generate tree for INTEREST
    tmp_node.clear();
	if (!m_INTEREST.empty()) {
        tmp_node = toPt(m_INTEREST);
		pt.add_child("INTEREST", tmp_node);
		tmp_node.clear();
	}
	// generate tree for LOCALE
    tmp_node.clear();
	if (!m_LOCALE.empty()) {
        tmp_node = toPt(m_LOCALE);
		pt.add_child("LOCALE", tmp_node);
		tmp_node.clear();
	}
	// generate tree for LOCATION
    tmp_node.clear();
	if (!m_LOCATION.empty()) {
        tmp_node = toPt(m_LOCATION);
		pt.add_child("LOCATION", tmp_node);
		tmp_node.clear();
	}
	// generate tree for SHOPPING_RETARGETING
    tmp_node.clear();
	if (!m_SHOPPING_RETARGETING.empty()) {
        tmp_node = toPt(m_SHOPPING_RETARGETING);
		pt.add_child("SHOPPING_RETARGETING", tmp_node);
		tmp_node.clear();
	}
	// generate tree for TARGETING_STRATEGY
    tmp_node.clear();
	if (!m_TARGETING_STRATEGY.empty()) {
        tmp_node = toPt(m_TARGETING_STRATEGY);
		pt.add_child("TARGETING_STRATEGY", tmp_node);
		tmp_node.clear();
	}
	return pt;
}

void TargetingSpec::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	// push all items of AGE_BUCKET into member
	if (pt.get_child_optional("AGE_BUCKET")) {
        m_AGE_BUCKET = fromPt<std::vector<std::string>>(pt.get_child("AGE_BUCKET"));
	}
	// push all items of APPTYPE into member
	if (pt.get_child_optional("APPTYPE")) {
        m_APPTYPE = fromPt<std::vector<std::string>>(pt.get_child("APPTYPE"));
	}
	// push all items of AUDIENCE_EXCLUDE into member
	if (pt.get_child_optional("AUDIENCE_EXCLUDE")) {
        m_AUDIENCE_EXCLUDE = fromPt<std::vector<std::string>>(pt.get_child("AUDIENCE_EXCLUDE"));
	}
	// push all items of AUDIENCE_INCLUDE into member
	if (pt.get_child_optional("AUDIENCE_INCLUDE")) {
        m_AUDIENCE_INCLUDE = fromPt<std::vector<std::string>>(pt.get_child("AUDIENCE_INCLUDE"));
	}
	// push all items of GENDER into member
	if (pt.get_child_optional("GENDER")) {
        m_GENDER = fromPt<std::vector<std::string>>(pt.get_child("GENDER"));
	}
	// push all items of GEO into member
	if (pt.get_child_optional("GEO")) {
        m_GEO = fromPt<std::vector<std::string>>(pt.get_child("GEO"));
	}
	// push all items of INTEREST into member
	if (pt.get_child_optional("INTEREST")) {
        m_INTEREST = fromPt<std::vector<std::string>>(pt.get_child("INTEREST"));
	}
	// push all items of LOCALE into member
	if (pt.get_child_optional("LOCALE")) {
        m_LOCALE = fromPt<std::vector<std::string>>(pt.get_child("LOCALE"));
	}
	// push all items of LOCATION into member
	if (pt.get_child_optional("LOCATION")) {
        m_LOCATION = fromPt<std::vector<std::string>>(pt.get_child("LOCATION"));
	}
	// push all items of SHOPPING_RETARGETING into member
	if (pt.get_child_optional("SHOPPING_RETARGETING")) {
        m_SHOPPING_RETARGETING = fromPt<std::vector<TargetingSpec_SHOPPING_RETARGETING>>(pt.get_child("SHOPPING_RETARGETING"));
	}
	// push all items of TARGETING_STRATEGY into member
	if (pt.get_child_optional("TARGETING_STRATEGY")) {
        m_TARGETING_STRATEGY = fromPt<std::vector<std::string>>(pt.get_child("TARGETING_STRATEGY"));
	}
}

std::vector<std::string> TargetingSpec::getAGEBUCKET() const
{
    return m_AGE_BUCKET;
}

void TargetingSpec::setAGEBUCKET(std::vector<std::string> value)
{
    static const std::array<std::string, 8> allowedValues = {
        "18-24", "21+", "25-34", "35-44", "45-49", "50-54", "55-64", "65+"
    };

    for (const auto &v: value) {
        if (std::find(allowedValues.begin(), allowedValues.end(), v) == allowedValues.end()) {
            throw std::runtime_error("Value " + boost::lexical_cast<std::string>(v) + " not allowed");
        }
    }
}


std::vector<std::string> TargetingSpec::getAPPTYPE() const
{
    return m_APPTYPE;
}

void TargetingSpec::setAPPTYPE(std::vector<std::string> value)
{
    static const std::array<std::string, 6> allowedValues = {
        "android_mobile", "android_tablet", "ipad", "iphone", "web", "web_mobile"
    };

    for (const auto &v: value) {
        if (std::find(allowedValues.begin(), allowedValues.end(), v) == allowedValues.end()) {
            throw std::runtime_error("Value " + boost::lexical_cast<std::string>(v) + " not allowed");
        }
    }
}


std::vector<std::string> TargetingSpec::getAUDIENCEEXCLUDE() const
{
    return m_AUDIENCE_EXCLUDE;
}

void TargetingSpec::setAUDIENCEEXCLUDE(std::vector<std::string> value)
{
    m_AUDIENCE_EXCLUDE = value;
}


std::vector<std::string> TargetingSpec::getAUDIENCEINCLUDE() const
{
    return m_AUDIENCE_INCLUDE;
}

void TargetingSpec::setAUDIENCEINCLUDE(std::vector<std::string> value)
{
    m_AUDIENCE_INCLUDE = value;
}


std::vector<std::string> TargetingSpec::getGENDER() const
{
    return m_GENDER;
}

void TargetingSpec::setGENDER(std::vector<std::string> value)
{
    static const std::array<std::string, 3> allowedValues = {
        "unknown", "male", "female"
    };

    for (const auto &v: value) {
        if (std::find(allowedValues.begin(), allowedValues.end(), v) == allowedValues.end()) {
            throw std::runtime_error("Value " + boost::lexical_cast<std::string>(v) + " not allowed");
        }
    }
}


std::vector<std::string> TargetingSpec::getGEO() const
{
    return m_GEO;
}

void TargetingSpec::setGEO(std::vector<std::string> value)
{
    m_GEO = value;
}


std::vector<std::string> TargetingSpec::getINTEREST() const
{
    return m_INTEREST;
}

void TargetingSpec::setINTEREST(std::vector<std::string> value)
{
    m_INTEREST = value;
}


std::vector<std::string> TargetingSpec::getLOCALE() const
{
    return m_LOCALE;
}

void TargetingSpec::setLOCALE(std::vector<std::string> value)
{
    m_LOCALE = value;
}


std::vector<std::string> TargetingSpec::getLOCATION() const
{
    return m_LOCATION;
}

void TargetingSpec::setLOCATION(std::vector<std::string> value)
{
    m_LOCATION = value;
}


std::vector<TargetingSpec_SHOPPING_RETARGETING> TargetingSpec::getSHOPPINGRETARGETING() const
{
    return m_SHOPPING_RETARGETING;
}

void TargetingSpec::setSHOPPINGRETARGETING(std::vector<TargetingSpec_SHOPPING_RETARGETING> value)
{
    m_SHOPPING_RETARGETING = value;
}


std::vector<std::string> TargetingSpec::getTARGETINGSTRATEGY() const
{
    return m_TARGETING_STRATEGY;
}

void TargetingSpec::setTARGETINGSTRATEGY(std::vector<std::string> value)
{
    static const std::array<std::string, 3> allowedValues = {
        "CHOOSE_YOUR_OWN", "FIND_NEW_CUSTOMERS", "RECONNECT_WITH_USERS"
    };

    for (const auto &v: value) {
        if (std::find(allowedValues.begin(), allowedValues.end(), v) == allowedValues.end()) {
            throw std::runtime_error("Value " + boost::lexical_cast<std::string>(v) + " not allowed");
        }
    }
}



std::vector<TargetingSpec> createTargetingSpecVectorFromJsonString(const std::string& json)
{
    std::stringstream sstream(json);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream,pt);

    auto vec = std::vector<TargetingSpec>();
    for (const auto& child: pt) {
        vec.emplace_back(TargetingSpec(child.second));
    }

    return vec;
}

}
}
}
}

