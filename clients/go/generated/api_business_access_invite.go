/*
Pinterest REST API

Pinterest's REST API

API version: 5.14.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BusinessAccessInviteAPIService BusinessAccessInviteAPI service
type BusinessAccessInviteAPIService service

type ApiAssetAccessRequestsCreateRequest struct {
	ctx context.Context
	ApiService *BusinessAccessInviteAPIService
	businessId string
	createAssetAccessRequestBody *CreateAssetAccessRequestBody
}

func (r ApiAssetAccessRequestsCreateRequest) CreateAssetAccessRequestBody(createAssetAccessRequestBody CreateAssetAccessRequestBody) ApiAssetAccessRequestsCreateRequest {
	r.createAssetAccessRequestBody = &createAssetAccessRequestBody
	return r
}

func (r ApiAssetAccessRequestsCreateRequest) Execute() (*CreateAssetAccessRequestResponse, *http.Response, error) {
	return r.ApiService.AssetAccessRequestsCreateExecute(r)
}

/*
AssetAccessRequestsCreate Create a request to access an existing partner's assets.

Create a request to access an existing partner's assets with the specified permissions. The request will be sent to the partner for approval. The assets that can be requested are ad accounts and profiles.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiAssetAccessRequestsCreateRequest
*/
func (a *BusinessAccessInviteAPIService) AssetAccessRequestsCreate(ctx context.Context, businessId string) ApiAssetAccessRequestsCreateRequest {
	return ApiAssetAccessRequestsCreateRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return CreateAssetAccessRequestResponse
func (a *BusinessAccessInviteAPIService) AssetAccessRequestsCreateExecute(r ApiAssetAccessRequestsCreateRequest) (*CreateAssetAccessRequestResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateAssetAccessRequestResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessInviteAPIService.AssetAccessRequestsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/requests/assets/access"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.createAssetAccessRequestBody == nil {
		return localVarReturnValue, nil, reportError("createAssetAccessRequestBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetAccessRequestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelInvitesOrRequestsRequest struct {
	ctx context.Context
	ApiService *BusinessAccessInviteAPIService
	businessId string
	cancelInvitesBody *CancelInvitesBody
}

// A list with invite ids
func (r ApiCancelInvitesOrRequestsRequest) CancelInvitesBody(cancelInvitesBody CancelInvitesBody) ApiCancelInvitesOrRequestsRequest {
	r.cancelInvitesBody = &cancelInvitesBody
	return r
}

func (r ApiCancelInvitesOrRequestsRequest) Execute() (*DeleteInvitesResultsResponseArray, *http.Response, error) {
	return r.ApiService.CancelInvitesOrRequestsExecute(r)
}

/*
CancelInvitesOrRequests Cancel invites/requests

Cancel membership/partnership invites and/or requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Business id
 @return ApiCancelInvitesOrRequestsRequest
*/
func (a *BusinessAccessInviteAPIService) CancelInvitesOrRequests(ctx context.Context, businessId string) ApiCancelInvitesOrRequestsRequest {
	return ApiCancelInvitesOrRequestsRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return DeleteInvitesResultsResponseArray
func (a *BusinessAccessInviteAPIService) CancelInvitesOrRequestsExecute(r ApiCancelInvitesOrRequestsRequest) (*DeleteInvitesResultsResponseArray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeleteInvitesResultsResponseArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessInviteAPIService.CancelInvitesOrRequests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/invites"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.cancelInvitesBody == nil {
		return localVarReturnValue, nil, reportError("cancelInvitesBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.cancelInvitesBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAssetInvitesRequest struct {
	ctx context.Context
	ApiService *BusinessAccessInviteAPIService
	businessId string
	createAssetInvitesRequest *CreateAssetInvitesRequest
}

// A list of invites/requests together with the asset permissions to be assigned to the invite/request. 
func (r ApiCreateAssetInvitesRequest) CreateAssetInvitesRequest(createAssetInvitesRequest CreateAssetInvitesRequest) ApiCreateAssetInvitesRequest {
	r.createAssetInvitesRequest = &createAssetInvitesRequest
	return r
}

func (r ApiCreateAssetInvitesRequest) Execute() (*UpdateInvitesResultsResponseArray, *http.Response, error) {
	return r.ApiService.CreateAssetInvitesExecute(r)
}

/*
CreateAssetInvites Update invite/request with an asset permission

Assign asset permissions information to an existing invite/request. Can be used to:
- Request access to a partner's asset. Note: This is only for when no existing partnership exists. If an existing
  partnership exists, use "Create a request to access an existing partner's assets" to request access to your
  partner's assets.
    - invite_type="PARTNER_REQUEST"
- Invite a partner to access your business assets. Note: This is only for when there is no existing partnership.
  If there is an existing partnership, use "Assign/Update partner asset permissions" to assign a partner access to
  new assets.
    - invite_type="PARTNER_INVITE"
- Invite a member to access your business assets. Note: This is only for when there is no existing membership.
  If there is an existing membership, use "Assign/Update member asset permissions" to assign a member access to new
  assets.
    - invite_type="MEMBER_INVITE"

To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiCreateAssetInvitesRequest
*/
func (a *BusinessAccessInviteAPIService) CreateAssetInvites(ctx context.Context, businessId string) ApiCreateAssetInvitesRequest {
	return ApiCreateAssetInvitesRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return UpdateInvitesResultsResponseArray
func (a *BusinessAccessInviteAPIService) CreateAssetInvitesExecute(r ApiCreateAssetInvitesRequest) (*UpdateInvitesResultsResponseArray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateInvitesResultsResponseArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessInviteAPIService.CreateAssetInvites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/invites/assets/access"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.createAssetInvitesRequest == nil {
		return localVarReturnValue, nil, reportError("createAssetInvitesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createAssetInvitesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateMembershipOrPartnershipInvitesRequest struct {
	ctx context.Context
	ApiService *BusinessAccessInviteAPIService
	businessId string
	createMembershipOrPartnershipInvitesBody *CreateMembershipOrPartnershipInvitesBody
}

// An object with the properties: invite_type, partners, members, business_role
func (r ApiCreateMembershipOrPartnershipInvitesRequest) CreateMembershipOrPartnershipInvitesBody(createMembershipOrPartnershipInvitesBody CreateMembershipOrPartnershipInvitesBody) ApiCreateMembershipOrPartnershipInvitesRequest {
	r.createMembershipOrPartnershipInvitesBody = &createMembershipOrPartnershipInvitesBody
	return r
}

func (r ApiCreateMembershipOrPartnershipInvitesRequest) Execute() (*CreateInvitesResultsResponseArray, *http.Response, error) {
	return r.ApiService.CreateMembershipOrPartnershipInvitesExecute(r)
}

/*
CreateMembershipOrPartnershipInvites Create invites or requests

Create batch invites or requests. Can create batch invites or requests as described below.
- Invite members to join the business. This would required specifying the following:
    - invite_type="MEMBER_INVITE"
    - business_role="EMPLOYEE" OR business_role="BIZ_ADMIN" (To learn more about business roles, visit
    https://help.pinterest.com/en/business/article/profile-permissions-in-business-access.)
    - members
- Invite partners to access your business assets. This would require specifying the following:
    - invite_type="PARTNER_INVITE"
    - business_role="PARTNER"
    - partners
- Request to be a partner so you can access their assets. This would require specifying the following:
    - invite_type="PARTNER_REQUEST"
    - business_role="PARTNER"
    - partners

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Business id
 @return ApiCreateMembershipOrPartnershipInvitesRequest
*/
func (a *BusinessAccessInviteAPIService) CreateMembershipOrPartnershipInvites(ctx context.Context, businessId string) ApiCreateMembershipOrPartnershipInvitesRequest {
	return ApiCreateMembershipOrPartnershipInvitesRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return CreateInvitesResultsResponseArray
func (a *BusinessAccessInviteAPIService) CreateMembershipOrPartnershipInvitesExecute(r ApiCreateMembershipOrPartnershipInvitesRequest) (*CreateInvitesResultsResponseArray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateInvitesResultsResponseArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessInviteAPIService.CreateMembershipOrPartnershipInvites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/invites"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.createMembershipOrPartnershipInvitesBody == nil {
		return localVarReturnValue, nil, reportError("createMembershipOrPartnershipInvitesBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createMembershipOrPartnershipInvitesBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvitesRequest struct {
	ctx context.Context
	ApiService *BusinessAccessInviteAPIService
	businessId string
	isMember *bool
	inviteStatus *[]string
	inviteType *InviteType
	bookmark *string
	pageSize *int32
}

// A boolean field to indicate whether the invite is to create a partnership or a membership.
func (r ApiGetInvitesRequest) IsMember(isMember bool) ApiGetInvitesRequest {
	r.isMember = &isMember
	return r
}

// A list of invite statuses to filter invites by. Only invites whose status is in the provided statuses will be returned.
func (r ApiGetInvitesRequest) InviteStatus(inviteStatus []string) ApiGetInvitesRequest {
	r.inviteStatus = &inviteStatus
	return r
}

// Invite type to filter invites by. Only invites of the specified type will be returned.
func (r ApiGetInvitesRequest) InviteType(inviteType InviteType) ApiGetInvitesRequest {
	r.inviteType = &inviteType
	return r
}

// Cursor used to fetch the next page of items
func (r ApiGetInvitesRequest) Bookmark(bookmark string) ApiGetInvitesRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiGetInvitesRequest) PageSize(pageSize int32) ApiGetInvitesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetInvitesRequest) Execute() (*GetInvites200Response, *http.Response, error) {
	return r.ApiService.GetInvitesExecute(r)
}

/*
GetInvites Get invites/requests

Get the membership/partnership invites and/or requests for the authorized user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiGetInvitesRequest
*/
func (a *BusinessAccessInviteAPIService) GetInvites(ctx context.Context, businessId string) ApiGetInvitesRequest {
	return ApiGetInvitesRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return GetInvites200Response
func (a *BusinessAccessInviteAPIService) GetInvitesExecute(r ApiGetInvitesRequest) (*GetInvites200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetInvites200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessInviteAPIService.GetInvites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/invites"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}

	if r.isMember != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_member", r.isMember, "form", "")
	} else {
		var defaultValue bool = true
		r.isMember = &defaultValue
	}
	if r.inviteStatus != nil {
		t := *r.inviteStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "invite_status", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "invite_status", t, "form", "multi")
		}
	}
	if r.inviteType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "invite_type", r.inviteType, "form", "")
	}
	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRespondBusinessAccessInvitesRequest struct {
	ctx context.Context
	ApiService *BusinessAccessInviteAPIService
	authRespondInvitesBody *AuthRespondInvitesBody
}

func (r ApiRespondBusinessAccessInvitesRequest) AuthRespondInvitesBody(authRespondInvitesBody AuthRespondInvitesBody) ApiRespondBusinessAccessInvitesRequest {
	r.authRespondInvitesBody = &authRespondInvitesBody
	return r
}

func (r ApiRespondBusinessAccessInvitesRequest) Execute() (*RespondToInvitesResponseArray, *http.Response, error) {
	return r.ApiService.RespondBusinessAccessInvitesExecute(r)
}

/*
RespondBusinessAccessInvites Accept or decline an invite/request

Accept or decline invites or requests.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRespondBusinessAccessInvitesRequest
*/
func (a *BusinessAccessInviteAPIService) RespondBusinessAccessInvites(ctx context.Context) ApiRespondBusinessAccessInvitesRequest {
	return ApiRespondBusinessAccessInvitesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return RespondToInvitesResponseArray
func (a *BusinessAccessInviteAPIService) RespondBusinessAccessInvitesExecute(r ApiRespondBusinessAccessInvitesRequest) (*RespondToInvitesResponseArray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RespondToInvitesResponseArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessInviteAPIService.RespondBusinessAccessInvites")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/invites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.authRespondInvitesBody == nil {
		return localVarReturnValue, nil, reportError("authRespondInvitesBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.authRespondInvitesBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
