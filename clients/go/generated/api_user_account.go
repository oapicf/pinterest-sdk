/*
Pinterest REST API

Pinterest's REST API

API version: 5.14.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// UserAccountAPIService UserAccountAPI service
type UserAccountAPIService service

type ApiBoardsUserFollowsListRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	bookmark *string
	pageSize *int32
	explicitFollowing *bool
	adAccountId *string
}

// Cursor used to fetch the next page of items
func (r ApiBoardsUserFollowsListRequest) Bookmark(bookmark string) ApiBoardsUserFollowsListRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiBoardsUserFollowsListRequest) PageSize(pageSize int32) ApiBoardsUserFollowsListRequest {
	r.pageSize = &pageSize
	return r
}

// Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
func (r ApiBoardsUserFollowsListRequest) ExplicitFollowing(explicitFollowing bool) ApiBoardsUserFollowsListRequest {
	r.explicitFollowing = &explicitFollowing
	return r
}

// Unique identifier of an ad account.
func (r ApiBoardsUserFollowsListRequest) AdAccountId(adAccountId string) ApiBoardsUserFollowsListRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiBoardsUserFollowsListRequest) Execute() (*BoardsUserFollowsList200Response, *http.Response, error) {
	return r.ApiService.BoardsUserFollowsListExecute(r)
}

/*
BoardsUserFollowsList List following boards

Get a list of the boards a user follows. The request returns a board summary object array.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBoardsUserFollowsListRequest
*/
func (a *UserAccountAPIService) BoardsUserFollowsList(ctx context.Context) ApiBoardsUserFollowsListRequest {
	return ApiBoardsUserFollowsListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BoardsUserFollowsList200Response
func (a *UserAccountAPIService) BoardsUserFollowsListExecute(r ApiBoardsUserFollowsListRequest) (*BoardsUserFollowsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoardsUserFollowsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.BoardsUserFollowsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/following/boards"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.explicitFollowing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explicit_following", r.explicitFollowing, "form", "")
	} else {
		var defaultValue bool = false
		r.explicitFollowing = &defaultValue
	}
	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowUserUpdateRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	username string
	followUserRequest *FollowUserRequest
}

// Follow a user.
func (r ApiFollowUserUpdateRequest) FollowUserRequest(followUserRequest FollowUserRequest) ApiFollowUserUpdateRequest {
	r.followUserRequest = &followUserRequest
	return r
}

func (r ApiFollowUserUpdateRequest) Execute() (*UserSummary, *http.Response, error) {
	return r.ApiService.FollowUserUpdateExecute(r)
}

/*
FollowUserUpdate Follow user

<strong>This endpoint is currently in beta and not available to all apps. <a href='/docs/getting-started/beta-and-advanced-access/'>Learn more</a>.</strong>

Use this request, as a signed-in user, to follow another user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username A valid username
 @return ApiFollowUserUpdateRequest
*/
func (a *UserAccountAPIService) FollowUserUpdate(ctx context.Context, username string) ApiFollowUserUpdateRequest {
	return ApiFollowUserUpdateRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return UserSummary
func (a *UserAccountAPIService) FollowUserUpdateExecute(r ApiFollowUserUpdateRequest) (*UserSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.FollowUserUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/following/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.followUserRequest == nil {
		return localVarReturnValue, nil, reportError("followUserRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.followUserRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFollowersListRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	bookmark *string
	pageSize *int32
}

// Cursor used to fetch the next page of items
func (r ApiFollowersListRequest) Bookmark(bookmark string) ApiFollowersListRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiFollowersListRequest) PageSize(pageSize int32) ApiFollowersListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiFollowersListRequest) Execute() (*FollowersList200Response, *http.Response, error) {
	return r.ApiService.FollowersListExecute(r)
}

/*
FollowersList List followers

Get a list of your followers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFollowersListRequest
*/
func (a *UserAccountAPIService) FollowersList(ctx context.Context) ApiFollowersListRequest {
	return ApiFollowersListRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return FollowersList200Response
func (a *UserAccountAPIService) FollowersListExecute(r ApiFollowersListRequest) (*FollowersList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FollowersList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.FollowersList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/followers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLinkedBusinessAccountsGetRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
}

func (r ApiLinkedBusinessAccountsGetRequest) Execute() ([]LinkedBusiness, *http.Response, error) {
	return r.ApiService.LinkedBusinessAccountsGetExecute(r)
}

/*
LinkedBusinessAccountsGet List linked businesses

Get a list of your linked business accounts.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLinkedBusinessAccountsGetRequest
*/
func (a *UserAccountAPIService) LinkedBusinessAccountsGet(ctx context.Context) ApiLinkedBusinessAccountsGetRequest {
	return ApiLinkedBusinessAccountsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []LinkedBusiness
func (a *UserAccountAPIService) LinkedBusinessAccountsGetExecute(r ApiLinkedBusinessAccountsGetRequest) ([]LinkedBusiness, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []LinkedBusiness
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.LinkedBusinessAccountsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/businesses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnverifyWebsiteDeleteRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	website *string
}

// Website with path or domain only
func (r ApiUnverifyWebsiteDeleteRequest) Website(website string) ApiUnverifyWebsiteDeleteRequest {
	r.website = &website
	return r
}

func (r ApiUnverifyWebsiteDeleteRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnverifyWebsiteDeleteExecute(r)
}

/*
UnverifyWebsiteDelete Unverify website

Unverifu a website verified by the signed-in user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUnverifyWebsiteDeleteRequest
*/
func (a *UserAccountAPIService) UnverifyWebsiteDelete(ctx context.Context) ApiUnverifyWebsiteDeleteRequest {
	return ApiUnverifyWebsiteDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *UserAccountAPIService) UnverifyWebsiteDeleteExecute(r ApiUnverifyWebsiteDeleteRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UnverifyWebsiteDelete")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/websites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.website == nil {
		return nil, reportError("website is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "website", r.website, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUserAccountAnalyticsRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	startDate *string
	endDate *string
	fromClaimedContent *string
	pinFormat *string
	appTypes *string
	contentType *string
	source *string
	metricTypes *[]string
	splitField *string
	adAccountId *string
}

// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
func (r ApiUserAccountAnalyticsRequest) StartDate(startDate string) ApiUserAccountAnalyticsRequest {
	r.startDate = &startDate
	return r
}

// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
func (r ApiUserAccountAnalyticsRequest) EndDate(endDate string) ApiUserAccountAnalyticsRequest {
	r.endDate = &endDate
	return r
}

// Filter on Pins that match your claimed domain.
func (r ApiUserAccountAnalyticsRequest) FromClaimedContent(fromClaimedContent string) ApiUserAccountAnalyticsRequest {
	r.fromClaimedContent = &fromClaimedContent
	return r
}

// Pin formats to get data for, default is all.
func (r ApiUserAccountAnalyticsRequest) PinFormat(pinFormat string) ApiUserAccountAnalyticsRequest {
	r.pinFormat = &pinFormat
	return r
}

// Apps or devices to get data for, default is all.
func (r ApiUserAccountAnalyticsRequest) AppTypes(appTypes string) ApiUserAccountAnalyticsRequest {
	r.appTypes = &appTypes
	return r
}

// Filter to paid or organic data. Default is all.
func (r ApiUserAccountAnalyticsRequest) ContentType(contentType string) ApiUserAccountAnalyticsRequest {
	r.contentType = &contentType
	return r
}

// Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
func (r ApiUserAccountAnalyticsRequest) Source(source string) ApiUserAccountAnalyticsRequest {
	r.source = &source
	return r
}

// Metric types to get data for, default is all. 
func (r ApiUserAccountAnalyticsRequest) MetricTypes(metricTypes []string) ApiUserAccountAnalyticsRequest {
	r.metricTypes = &metricTypes
	return r
}

// How to split the data into groups. Not including this param means data won&#39;t be split.
func (r ApiUserAccountAnalyticsRequest) SplitField(splitField string) ApiUserAccountAnalyticsRequest {
	r.splitField = &splitField
	return r
}

// Unique identifier of an ad account.
func (r ApiUserAccountAnalyticsRequest) AdAccountId(adAccountId string) ApiUserAccountAnalyticsRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiUserAccountAnalyticsRequest) Execute() (*map[string]AnalyticsMetricsResponse, *http.Response, error) {
	return r.ApiService.UserAccountAnalyticsExecute(r)
}

/*
UserAccountAnalytics Get user account analytics

Get analytics for the "operation user_account"
- By default, the "operation user_account" is the token user_account.

Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the "operation user_account".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserAccountAnalyticsRequest
*/
func (a *UserAccountAPIService) UserAccountAnalytics(ctx context.Context) ApiUserAccountAnalyticsRequest {
	return ApiUserAccountAnalyticsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]AnalyticsMetricsResponse
func (a *UserAccountAPIService) UserAccountAnalyticsExecute(r ApiUserAccountAnalyticsRequest) (*map[string]AnalyticsMetricsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *map[string]AnalyticsMetricsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserAccountAnalytics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/analytics"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	if r.fromClaimedContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_claimed_content", r.fromClaimedContent, "form", "")
	} else {
		var defaultValue string = "BOTH"
		r.fromClaimedContent = &defaultValue
	}
	if r.pinFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pin_format", r.pinFormat, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.pinFormat = &defaultValue
	}
	if r.appTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_types", r.appTypes, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.appTypes = &defaultValue
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "content_type", r.contentType, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.contentType = &defaultValue
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.source = &defaultValue
	}
	if r.metricTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_types", r.metricTypes, "form", "csv")
	}
	if r.splitField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "split_field", r.splitField, "form", "")
	} else {
		var defaultValue string = "NO_SPLIT"
		r.splitField = &defaultValue
	}
	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAccountAnalyticsTopPinsRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	startDate *string
	endDate *string
	sortBy *string
	fromClaimedContent *string
	pinFormat *string
	appTypes *string
	contentType *string
	source *string
	metricTypes *[]string
	numOfPins *int32
	createdInLastNDays *int32
	adAccountId *string
}

// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
func (r ApiUserAccountAnalyticsTopPinsRequest) StartDate(startDate string) ApiUserAccountAnalyticsTopPinsRequest {
	r.startDate = &startDate
	return r
}

// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
func (r ApiUserAccountAnalyticsTopPinsRequest) EndDate(endDate string) ApiUserAccountAnalyticsTopPinsRequest {
	r.endDate = &endDate
	return r
}

// Specify sorting order for metrics
func (r ApiUserAccountAnalyticsTopPinsRequest) SortBy(sortBy string) ApiUserAccountAnalyticsTopPinsRequest {
	r.sortBy = &sortBy
	return r
}

// Filter on Pins that match your claimed domain.
func (r ApiUserAccountAnalyticsTopPinsRequest) FromClaimedContent(fromClaimedContent string) ApiUserAccountAnalyticsTopPinsRequest {
	r.fromClaimedContent = &fromClaimedContent
	return r
}

// Pin formats to get data for, default is all.
func (r ApiUserAccountAnalyticsTopPinsRequest) PinFormat(pinFormat string) ApiUserAccountAnalyticsTopPinsRequest {
	r.pinFormat = &pinFormat
	return r
}

// Apps or devices to get data for, default is all.
func (r ApiUserAccountAnalyticsTopPinsRequest) AppTypes(appTypes string) ApiUserAccountAnalyticsTopPinsRequest {
	r.appTypes = &appTypes
	return r
}

// Filter to paid or organic data. Default is all.
func (r ApiUserAccountAnalyticsTopPinsRequest) ContentType(contentType string) ApiUserAccountAnalyticsTopPinsRequest {
	r.contentType = &contentType
	return r
}

// Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
func (r ApiUserAccountAnalyticsTopPinsRequest) Source(source string) ApiUserAccountAnalyticsTopPinsRequest {
	r.source = &source
	return r
}

// Metric types to get data for, default is all. 
func (r ApiUserAccountAnalyticsTopPinsRequest) MetricTypes(metricTypes []string) ApiUserAccountAnalyticsTopPinsRequest {
	r.metricTypes = &metricTypes
	return r
}

// Number of pins to include, default is 10. Max is 50.
func (r ApiUserAccountAnalyticsTopPinsRequest) NumOfPins(numOfPins int32) ApiUserAccountAnalyticsTopPinsRequest {
	r.numOfPins = &numOfPins
	return r
}

// Get metrics for pins created in the last \&quot;n\&quot; days.
func (r ApiUserAccountAnalyticsTopPinsRequest) CreatedInLastNDays(createdInLastNDays int32) ApiUserAccountAnalyticsTopPinsRequest {
	r.createdInLastNDays = &createdInLastNDays
	return r
}

// Unique identifier of an ad account.
func (r ApiUserAccountAnalyticsTopPinsRequest) AdAccountId(adAccountId string) ApiUserAccountAnalyticsTopPinsRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiUserAccountAnalyticsTopPinsRequest) Execute() (*TopPinsAnalyticsResponse, *http.Response, error) {
	return r.ApiService.UserAccountAnalyticsTopPinsExecute(r)
}

/*
UserAccountAnalyticsTopPins Get user account top pins analytics

Gets analytics data about a user's top pins (limited to the top 50).
- By default, the "operation user_account" is the token user_account.

Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the "operation user_account".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserAccountAnalyticsTopPinsRequest
*/
func (a *UserAccountAPIService) UserAccountAnalyticsTopPins(ctx context.Context) ApiUserAccountAnalyticsTopPinsRequest {
	return ApiUserAccountAnalyticsTopPinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TopPinsAnalyticsResponse
func (a *UserAccountAPIService) UserAccountAnalyticsTopPinsExecute(r ApiUserAccountAnalyticsTopPinsRequest) (*TopPinsAnalyticsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TopPinsAnalyticsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserAccountAnalyticsTopPins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/analytics/top_pins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	if r.fromClaimedContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_claimed_content", r.fromClaimedContent, "form", "")
	} else {
		var defaultValue string = "BOTH"
		r.fromClaimedContent = &defaultValue
	}
	if r.pinFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pin_format", r.pinFormat, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.pinFormat = &defaultValue
	}
	if r.appTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_types", r.appTypes, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.appTypes = &defaultValue
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "content_type", r.contentType, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.contentType = &defaultValue
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.source = &defaultValue
	}
	if r.metricTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_types", r.metricTypes, "form", "csv")
	}
	if r.numOfPins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "num_of_pins", r.numOfPins, "form", "")
	} else {
		var defaultValue int32 = 10
		r.numOfPins = &defaultValue
	}
	if r.createdInLastNDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_in_last_n_days", r.createdInLastNDays, "form", "")
	}
	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAccountAnalyticsTopVideoPinsRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	startDate *string
	endDate *string
	sortBy *string
	fromClaimedContent *string
	pinFormat *string
	appTypes *string
	contentType *string
	source *string
	metricTypes *[]string
	numOfPins *int32
	createdInLastNDays *int32
	adAccountId *string
}

// Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) StartDate(startDate string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.startDate = &startDate
	return r
}

// Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) EndDate(endDate string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.endDate = &endDate
	return r
}

// Specify sorting order for video metrics
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) SortBy(sortBy string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.sortBy = &sortBy
	return r
}

// Filter on Pins that match your claimed domain.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) FromClaimedContent(fromClaimedContent string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.fromClaimedContent = &fromClaimedContent
	return r
}

// Pin formats to get data for, default is all.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) PinFormat(pinFormat string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.pinFormat = &pinFormat
	return r
}

// Apps or devices to get data for, default is all.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) AppTypes(appTypes string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.appTypes = &appTypes
	return r
}

// Filter to paid or organic data. Default is all.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) ContentType(contentType string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.contentType = &contentType
	return r
}

// Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) Source(source string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.source = &source
	return r
}

// Metric types to get video data for, default is all. 
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) MetricTypes(metricTypes []string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.metricTypes = &metricTypes
	return r
}

// Number of pins to include, default is 10. Max is 50.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) NumOfPins(numOfPins int32) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.numOfPins = &numOfPins
	return r
}

// Get metrics for pins created in the last \&quot;n\&quot; days.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) CreatedInLastNDays(createdInLastNDays int32) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.createdInLastNDays = &createdInLastNDays
	return r
}

// Unique identifier of an ad account.
func (r ApiUserAccountAnalyticsTopVideoPinsRequest) AdAccountId(adAccountId string) ApiUserAccountAnalyticsTopVideoPinsRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiUserAccountAnalyticsTopVideoPinsRequest) Execute() (*TopVideoPinsAnalyticsResponse, *http.Response, error) {
	return r.ApiService.UserAccountAnalyticsTopVideoPinsExecute(r)
}

/*
UserAccountAnalyticsTopVideoPins Get user account top video pins analytics

Gets analytics data about a user's top video pins (limited to the top 50).
- By default, the "operation user_account" is the token user_account.

Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the "operation user_account".

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserAccountAnalyticsTopVideoPinsRequest
*/
func (a *UserAccountAPIService) UserAccountAnalyticsTopVideoPins(ctx context.Context) ApiUserAccountAnalyticsTopVideoPinsRequest {
	return ApiUserAccountAnalyticsTopVideoPinsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TopVideoPinsAnalyticsResponse
func (a *UserAccountAPIService) UserAccountAnalyticsTopVideoPinsExecute(r ApiUserAccountAnalyticsTopVideoPinsRequest) (*TopVideoPinsAnalyticsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TopVideoPinsAnalyticsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserAccountAnalyticsTopVideoPins")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/analytics/top_video_pins"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.startDate == nil {
		return localVarReturnValue, nil, reportError("startDate is required and must be specified")
	}
	if r.endDate == nil {
		return localVarReturnValue, nil, reportError("endDate is required and must be specified")
	}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "start_date", r.startDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "end_date", r.endDate, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "form", "")
	if r.fromClaimedContent != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_claimed_content", r.fromClaimedContent, "form", "")
	} else {
		var defaultValue string = "BOTH"
		r.fromClaimedContent = &defaultValue
	}
	if r.pinFormat != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pin_format", r.pinFormat, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.pinFormat = &defaultValue
	}
	if r.appTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "app_types", r.appTypes, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.appTypes = &defaultValue
	}
	if r.contentType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "content_type", r.contentType, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.contentType = &defaultValue
	}
	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "form", "")
	} else {
		var defaultValue string = "ALL"
		r.source = &defaultValue
	}
	if r.metricTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "metric_types", r.metricTypes, "form", "csv")
	}
	if r.numOfPins != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "num_of_pins", r.numOfPins, "form", "")
	} else {
		var defaultValue int32 = 10
		r.numOfPins = &defaultValue
	}
	if r.createdInLastNDays != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_in_last_n_days", r.createdInLastNDays, "form", "")
	}
	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAccountFollowedInterestsRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	username string
	bookmark *string
	pageSize *int32
}

// Cursor used to fetch the next page of items
func (r ApiUserAccountFollowedInterestsRequest) Bookmark(bookmark string) ApiUserAccountFollowedInterestsRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiUserAccountFollowedInterestsRequest) PageSize(pageSize int32) ApiUserAccountFollowedInterestsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiUserAccountFollowedInterestsRequest) Execute() (*UserAccountFollowedInterests200Response, *http.Response, error) {
	return r.ApiService.UserAccountFollowedInterestsExecute(r)
}

/*
UserAccountFollowedInterests List following interests

Get a list of a user's following interests in one place.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username A valid username
 @return ApiUserAccountFollowedInterestsRequest
*/
func (a *UserAccountAPIService) UserAccountFollowedInterests(ctx context.Context, username string) ApiUserAccountFollowedInterestsRequest {
	return ApiUserAccountFollowedInterestsRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return UserAccountFollowedInterests200Response
func (a *UserAccountAPIService) UserAccountFollowedInterestsExecute(r ApiUserAccountFollowedInterestsRequest) (*UserAccountFollowedInterests200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAccountFollowedInterests200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserAccountFollowedInterests")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/users/{username}/interests/follow"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserAccountGetRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	adAccountId *string
}

// Unique identifier of an ad account.
func (r ApiUserAccountGetRequest) AdAccountId(adAccountId string) ApiUserAccountGetRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiUserAccountGetRequest) Execute() (*Account, *http.Response, error) {
	return r.ApiService.UserAccountGetExecute(r)
}

/*
UserAccountGet Get user account

Get account information for the "operation user_account"
- By default, the "operation user_account" is the token user_account.

If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the "operation user_account". See <a href='/docs/getting-started/using-business-access/'>Understanding Business Access</a> for more information.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserAccountGetRequest
*/
func (a *UserAccountAPIService) UserAccountGet(ctx context.Context) ApiUserAccountGetRequest {
	return ApiUserAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Account
func (a *UserAccountAPIService) UserAccountGetExecute(r ApiUserAccountGetRequest) (*Account, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserAccountGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserFollowingGetRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	bookmark *string
	pageSize *int32
	feedType *UserFollowingFeedType
	explicitFollowing *bool
	adAccountId *string
}

// Cursor used to fetch the next page of items
func (r ApiUserFollowingGetRequest) Bookmark(bookmark string) ApiUserFollowingGetRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiUserFollowingGetRequest) PageSize(pageSize int32) ApiUserFollowingGetRequest {
	r.pageSize = &pageSize
	return r
}

// Thrift param specifying what type of followees will be kept. Default to include all followees.
func (r ApiUserFollowingGetRequest) FeedType(feedType UserFollowingFeedType) ApiUserFollowingGetRequest {
	r.feedType = &feedType
	return r
}

// Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
func (r ApiUserFollowingGetRequest) ExplicitFollowing(explicitFollowing bool) ApiUserFollowingGetRequest {
	r.explicitFollowing = &explicitFollowing
	return r
}

// Unique identifier of an ad account.
func (r ApiUserFollowingGetRequest) AdAccountId(adAccountId string) ApiUserFollowingGetRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiUserFollowingGetRequest) Execute() (*UserFollowingGet200Response, *http.Response, error) {
	return r.ApiService.UserFollowingGetExecute(r)
}

/*
UserFollowingGet List following

Get a list of who a certain user follows.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserFollowingGetRequest
*/
func (a *UserAccountAPIService) UserFollowingGet(ctx context.Context) ApiUserFollowingGetRequest {
	return ApiUserFollowingGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserFollowingGet200Response
func (a *UserAccountAPIService) UserFollowingGetExecute(r ApiUserFollowingGetRequest) (*UserFollowingGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserFollowingGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserFollowingGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/following"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.feedType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "feed_type", r.feedType, "form", "")
	} else {
		var defaultValue UserFollowingFeedType = "ALL"
		r.feedType = &defaultValue
	}
	if r.explicitFollowing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explicit_following", r.explicitFollowing, "form", "")
	} else {
		var defaultValue bool = false
		r.explicitFollowing = &defaultValue
	}
	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUserWebsitesGetRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	bookmark *string
	pageSize *int32
}

// Cursor used to fetch the next page of items
func (r ApiUserWebsitesGetRequest) Bookmark(bookmark string) ApiUserWebsitesGetRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiUserWebsitesGetRequest) PageSize(pageSize int32) ApiUserWebsitesGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiUserWebsitesGetRequest) Execute() (*UserWebsitesGet200Response, *http.Response, error) {
	return r.ApiService.UserWebsitesGetExecute(r)
}

/*
UserWebsitesGet Get user websites

Get user websites, claimed or not

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUserWebsitesGetRequest
*/
func (a *UserAccountAPIService) UserWebsitesGet(ctx context.Context) ApiUserWebsitesGetRequest {
	return ApiUserWebsitesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserWebsitesGet200Response
func (a *UserAccountAPIService) UserWebsitesGetExecute(r ApiUserWebsitesGetRequest) (*UserWebsitesGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserWebsitesGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.UserWebsitesGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/websites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiVerifyWebsiteUpdateRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	userWebsiteVerifyRequest *UserWebsiteVerifyRequest
	adAccountId *string
}

// Verify a website.
func (r ApiVerifyWebsiteUpdateRequest) UserWebsiteVerifyRequest(userWebsiteVerifyRequest UserWebsiteVerifyRequest) ApiVerifyWebsiteUpdateRequest {
	r.userWebsiteVerifyRequest = &userWebsiteVerifyRequest
	return r
}

// Unique identifier of an ad account.
func (r ApiVerifyWebsiteUpdateRequest) AdAccountId(adAccountId string) ApiVerifyWebsiteUpdateRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiVerifyWebsiteUpdateRequest) Execute() (*UserWebsiteSummary, *http.Response, error) {
	return r.ApiService.VerifyWebsiteUpdateExecute(r)
}

/*
VerifyWebsiteUpdate Verify website

Verify a website as a signed-in user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiVerifyWebsiteUpdateRequest
*/
func (a *UserAccountAPIService) VerifyWebsiteUpdate(ctx context.Context) ApiVerifyWebsiteUpdateRequest {
	return ApiVerifyWebsiteUpdateRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserWebsiteSummary
func (a *UserAccountAPIService) VerifyWebsiteUpdateExecute(r ApiVerifyWebsiteUpdateRequest) (*UserWebsiteSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserWebsiteSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.VerifyWebsiteUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/websites"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userWebsiteVerifyRequest == nil {
		return localVarReturnValue, nil, reportError("userWebsiteVerifyRequest is required and must be specified")
	}

	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.userWebsiteVerifyRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWebsiteVerificationGetRequest struct {
	ctx context.Context
	ApiService *UserAccountAPIService
	adAccountId *string
}

// Unique identifier of an ad account.
func (r ApiWebsiteVerificationGetRequest) AdAccountId(adAccountId string) ApiWebsiteVerificationGetRequest {
	r.adAccountId = &adAccountId
	return r
}

func (r ApiWebsiteVerificationGetRequest) Execute() (*UserWebsiteVerificationCode, *http.Response, error) {
	return r.ApiService.WebsiteVerificationGetExecute(r)
}

/*
WebsiteVerificationGet Get user verification code for website claiming

Get verification code for user to install on the website to claim it.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWebsiteVerificationGetRequest
*/
func (a *UserAccountAPIService) WebsiteVerificationGet(ctx context.Context) ApiWebsiteVerificationGetRequest {
	return ApiWebsiteVerificationGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserWebsiteVerificationCode
func (a *UserAccountAPIService) WebsiteVerificationGetExecute(r ApiWebsiteVerificationGetRequest) (*UserWebsiteVerificationCode, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserWebsiteVerificationCode
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountAPIService.WebsiteVerificationGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user_account/websites/verification"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.adAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ad_account_id", r.adAccountId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
