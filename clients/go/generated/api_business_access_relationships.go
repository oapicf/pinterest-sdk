/*
Pinterest REST API

Pinterest's REST API

API version: 5.14.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// BusinessAccessRelationshipsAPIService BusinessAccessRelationshipsAPI service
type BusinessAccessRelationshipsAPIService service

type ApiDeleteBusinessMembershipRequest struct {
	ctx context.Context
	ApiService *BusinessAccessRelationshipsAPIService
	businessId string
	membersToDeleteBody *MembersToDeleteBody
}

// List of members with role to delete.
func (r ApiDeleteBusinessMembershipRequest) MembersToDeleteBody(membersToDeleteBody MembersToDeleteBody) ApiDeleteBusinessMembershipRequest {
	r.membersToDeleteBody = &membersToDeleteBody
	return r
}

func (r ApiDeleteBusinessMembershipRequest) Execute() (*DeletedMembersResponse, *http.Response, error) {
	return r.ApiService.DeleteBusinessMembershipExecute(r)
}

/*
DeleteBusinessMembership Terminate business memberships

Terminate memberships between the specified members and your business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Business id
 @return ApiDeleteBusinessMembershipRequest
*/
func (a *BusinessAccessRelationshipsAPIService) DeleteBusinessMembership(ctx context.Context, businessId string) ApiDeleteBusinessMembershipRequest {
	return ApiDeleteBusinessMembershipRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return DeletedMembersResponse
func (a *BusinessAccessRelationshipsAPIService) DeleteBusinessMembershipExecute(r ApiDeleteBusinessMembershipRequest) (*DeletedMembersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeletedMembersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessRelationshipsAPIService.DeleteBusinessMembership")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.membersToDeleteBody == nil {
		return localVarReturnValue, nil, reportError("membersToDeleteBody is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.membersToDeleteBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteBusinessPartnersRequest struct {
	ctx context.Context
	ApiService *BusinessAccessRelationshipsAPIService
	businessId string
	deletePartnersRequest *DeletePartnersRequest
}

// An object containing a \&quot;partner_ids\&quot; property composed of a list of partner IDs and a \&quot;partners_type\&quot; property specifying the type of partners to delete. 
func (r ApiDeleteBusinessPartnersRequest) DeletePartnersRequest(deletePartnersRequest DeletePartnersRequest) ApiDeleteBusinessPartnersRequest {
	r.deletePartnersRequest = &deletePartnersRequest
	return r
}

func (r ApiDeleteBusinessPartnersRequest) Execute() (*DeletePartnersResponse, *http.Response, error) {
	return r.ApiService.DeleteBusinessPartnersExecute(r)
}

/*
DeleteBusinessPartners Terminate business partnerships

Terminate partnerships between the specified partners and your business.
Note: You may only batch terminate partners of the same partner type.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiDeleteBusinessPartnersRequest
*/
func (a *BusinessAccessRelationshipsAPIService) DeleteBusinessPartners(ctx context.Context, businessId string) ApiDeleteBusinessPartnersRequest {
	return ApiDeleteBusinessPartnersRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return DeletePartnersResponse
func (a *BusinessAccessRelationshipsAPIService) DeleteBusinessPartnersExecute(r ApiDeleteBusinessPartnersRequest) (*DeletePartnersResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeletePartnersResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessRelationshipsAPIService.DeleteBusinessPartners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/partners"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.deletePartnersRequest == nil {
		return localVarReturnValue, nil, reportError("deletePartnersRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.deletePartnersRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessEmployersRequest struct {
	ctx context.Context
	ApiService *BusinessAccessRelationshipsAPIService
	pageSize *int32
	bookmark *string
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiGetBusinessEmployersRequest) PageSize(pageSize int32) ApiGetBusinessEmployersRequest {
	r.pageSize = &pageSize
	return r
}

// Cursor used to fetch the next page of items
func (r ApiGetBusinessEmployersRequest) Bookmark(bookmark string) ApiGetBusinessEmployersRequest {
	r.bookmark = &bookmark
	return r
}

func (r ApiGetBusinessEmployersRequest) Execute() (*GetBusinessEmployers200Response, *http.Response, error) {
	return r.ApiService.GetBusinessEmployersExecute(r)
}

/*
GetBusinessEmployers List business employers for user

Get all of the viewing user's business employers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBusinessEmployersRequest
*/
func (a *BusinessAccessRelationshipsAPIService) GetBusinessEmployers(ctx context.Context) ApiGetBusinessEmployersRequest {
	return ApiGetBusinessEmployersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GetBusinessEmployers200Response
func (a *BusinessAccessRelationshipsAPIService) GetBusinessEmployersExecute(r ApiGetBusinessEmployersRequest) (*GetBusinessEmployers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessEmployers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessRelationshipsAPIService.GetBusinessEmployers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/employers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessMembersRequest struct {
	ctx context.Context
	ApiService *BusinessAccessRelationshipsAPIService
	businessId string
	assetsSummary *bool
	businessRoles *[]MemberBusinessRole
	memberIds *string
	startIndex *int32
	bookmark *string
	pageSize *int32
}

// Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
func (r ApiGetBusinessMembersRequest) AssetsSummary(assetsSummary bool) ApiGetBusinessMembersRequest {
	r.assetsSummary = &assetsSummary
	return r
}

// A list of business roles to filter the members by. Only members whose roles are in the specified roles will be returned.
func (r ApiGetBusinessMembersRequest) BusinessRoles(businessRoles []MemberBusinessRole) ApiGetBusinessMembersRequest {
	r.businessRoles = &businessRoles
	return r
}

// A list of business members ids separated by comma.
func (r ApiGetBusinessMembersRequest) MemberIds(memberIds string) ApiGetBusinessMembersRequest {
	r.memberIds = &memberIds
	return r
}

// An index to start fetching the results from. Only the results starting from this index will be returned.
func (r ApiGetBusinessMembersRequest) StartIndex(startIndex int32) ApiGetBusinessMembersRequest {
	r.startIndex = &startIndex
	return r
}

// Cursor used to fetch the next page of items
func (r ApiGetBusinessMembersRequest) Bookmark(bookmark string) ApiGetBusinessMembersRequest {
	r.bookmark = &bookmark
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiGetBusinessMembersRequest) PageSize(pageSize int32) ApiGetBusinessMembersRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetBusinessMembersRequest) Execute() (*GetBusinessMembers200Response, *http.Response, error) {
	return r.ApiService.GetBusinessMembersExecute(r)
}

/*
GetBusinessMembers Get business members

Get all members of the specified business.
The return response will include the member's business_role and assets they have access to if assets_summary=TRUE

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiGetBusinessMembersRequest
*/
func (a *BusinessAccessRelationshipsAPIService) GetBusinessMembers(ctx context.Context, businessId string) ApiGetBusinessMembersRequest {
	return ApiGetBusinessMembersRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return GetBusinessMembers200Response
func (a *BusinessAccessRelationshipsAPIService) GetBusinessMembersExecute(r ApiGetBusinessMembersRequest) (*GetBusinessMembers200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessMembers200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessRelationshipsAPIService.GetBusinessMembers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}

	if r.assetsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assets_summary", r.assetsSummary, "form", "")
	} else {
		var defaultValue bool = false
		r.assetsSummary = &defaultValue
	}
	if r.businessRoles != nil {
		t := *r.businessRoles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "business_roles", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "business_roles", t, "form", "multi")
		}
	}
	if r.memberIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "member_ids", r.memberIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "form", "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBusinessPartnersRequest struct {
	ctx context.Context
	ApiService *BusinessAccessRelationshipsAPIService
	businessId string
	assetsSummary *bool
	partnerType *PartnerType
	partnerIds *string
	startIndex *int32
	pageSize *int32
	bookmark *string
}

// Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
func (r ApiGetBusinessPartnersRequest) AssetsSummary(assetsSummary bool) ApiGetBusinessPartnersRequest {
	r.assetsSummary = &assetsSummary
	return r
}

// Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner&#39;s business asset.
func (r ApiGetBusinessPartnersRequest) PartnerType(partnerType PartnerType) ApiGetBusinessPartnersRequest {
	r.partnerType = &partnerType
	return r
}

// A list of business partner ids separated by commas used to filter the results. Only partners with the specified ids will be returned.
func (r ApiGetBusinessPartnersRequest) PartnerIds(partnerIds string) ApiGetBusinessPartnersRequest {
	r.partnerIds = &partnerIds
	return r
}

// An index to start fetching the results from. Only the results starting from this index will be returned.
func (r ApiGetBusinessPartnersRequest) StartIndex(startIndex int32) ApiGetBusinessPartnersRequest {
	r.startIndex = &startIndex
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiGetBusinessPartnersRequest) PageSize(pageSize int32) ApiGetBusinessPartnersRequest {
	r.pageSize = &pageSize
	return r
}

// Cursor used to fetch the next page of items
func (r ApiGetBusinessPartnersRequest) Bookmark(bookmark string) ApiGetBusinessPartnersRequest {
	r.bookmark = &bookmark
	return r
}

func (r ApiGetBusinessPartnersRequest) Execute() (*GetBusinessPartners200Response, *http.Response, error) {
	return r.ApiService.GetBusinessPartnersExecute(r)
}

/*
GetBusinessPartners Get business partners

Get all partners of the specified business.

If the assets_summary=TRUE and:
- partner_type=INTERNAL, the business assets returned are your business assets the partner has access to.
- partner_type=EXTERNAL, the business assets returned are your partner's business assets the partner has granted you
  access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiGetBusinessPartnersRequest
*/
func (a *BusinessAccessRelationshipsAPIService) GetBusinessPartners(ctx context.Context, businessId string) ApiGetBusinessPartnersRequest {
	return ApiGetBusinessPartnersRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return GetBusinessPartners200Response
func (a *BusinessAccessRelationshipsAPIService) GetBusinessPartnersExecute(r ApiGetBusinessPartnersRequest) (*GetBusinessPartners200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GetBusinessPartners200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessRelationshipsAPIService.GetBusinessPartners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/partners"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}

	if r.assetsSummary != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "assets_summary", r.assetsSummary, "form", "")
	} else {
		var defaultValue bool = false
		r.assetsSummary = &defaultValue
	}
	if r.partnerType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partner_type", r.partnerType, "form", "")
	}
	if r.partnerIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partner_ids", r.partnerIds, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start_index", r.startIndex, "form", "")
	} else {
		var defaultValue int32 = 0
		r.startIndex = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBusinessMembershipsRequest struct {
	ctx context.Context
	ApiService *BusinessAccessRelationshipsAPIService
	businessId string
	updateMemberBusinessRoleBody *[]UpdateMemberBusinessRoleBody
}

// List of objects with the member id and the business_role.
func (r ApiUpdateBusinessMembershipsRequest) UpdateMemberBusinessRoleBody(updateMemberBusinessRoleBody []UpdateMemberBusinessRoleBody) ApiUpdateBusinessMembershipsRequest {
	r.updateMemberBusinessRoleBody = &updateMemberBusinessRoleBody
	return r
}

func (r ApiUpdateBusinessMembershipsRequest) Execute() (*UpdateMemberResultsResponseArray, *http.Response, error) {
	return r.ApiService.UpdateBusinessMembershipsExecute(r)
}

/*
UpdateBusinessMemberships Update member's business role

Update a member's business role within the business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Business id
 @return ApiUpdateBusinessMembershipsRequest
*/
func (a *BusinessAccessRelationshipsAPIService) UpdateBusinessMemberships(ctx context.Context, businessId string) ApiUpdateBusinessMembershipsRequest {
	return ApiUpdateBusinessMembershipsRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return UpdateMemberResultsResponseArray
func (a *BusinessAccessRelationshipsAPIService) UpdateBusinessMembershipsExecute(r ApiUpdateBusinessMembershipsRequest) (*UpdateMemberResultsResponseArray, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UpdateMemberResultsResponseArray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BusinessAccessRelationshipsAPIService.UpdateBusinessMemberships")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.updateMemberBusinessRoleBody == nil {
		return localVarReturnValue, nil, reportError("updateMemberBusinessRoleBody is required and must be specified")
	}
	if len(*r.updateMemberBusinessRoleBody) < 1 {
		return localVarReturnValue, nil, reportError("updateMemberBusinessRoleBody must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateMemberBusinessRoleBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
