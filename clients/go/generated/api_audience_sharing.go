/*
Pinterest REST API

Pinterest's REST API

API version: 5.14.0
Contact: blah+oapicf@cliffano.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// AudienceSharingAPIService AudienceSharingAPI service
type AudienceSharingAPIService service

type ApiAdAccountsAudiencesSharedAccountsListRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	adAccountId string
	audienceId *string
	accountType *AudienceAccountType
	pageSize *int32
	bookmark *string
}

// Unique identifier of the audience to use to filter the results.
func (r ApiAdAccountsAudiencesSharedAccountsListRequest) AudienceId(audienceId string) ApiAdAccountsAudiencesSharedAccountsListRequest {
	r.audienceId = &audienceId
	return r
}

// Filter accounts by account type.
func (r ApiAdAccountsAudiencesSharedAccountsListRequest) AccountType(accountType AudienceAccountType) ApiAdAccountsAudiencesSharedAccountsListRequest {
	r.accountType = &accountType
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiAdAccountsAudiencesSharedAccountsListRequest) PageSize(pageSize int32) ApiAdAccountsAudiencesSharedAccountsListRequest {
	r.pageSize = &pageSize
	return r
}

// Cursor used to fetch the next page of items
func (r ApiAdAccountsAudiencesSharedAccountsListRequest) Bookmark(bookmark string) ApiAdAccountsAudiencesSharedAccountsListRequest {
	r.bookmark = &bookmark
	return r
}

func (r ApiAdAccountsAudiencesSharedAccountsListRequest) Execute() (*AdAccountsAudiencesSharedAccountsList200Response, *http.Response, error) {
	return r.ApiService.AdAccountsAudiencesSharedAccountsListExecute(r)
}

/*
AdAccountsAudiencesSharedAccountsList List accounts with access to an audience owned by an ad account

List all ad accounts and/or businesses that have access to a specific audience. The audience must be owned by the requesting ad account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adAccountId Unique identifier of an ad account.
 @return ApiAdAccountsAudiencesSharedAccountsListRequest
*/
func (a *AudienceSharingAPIService) AdAccountsAudiencesSharedAccountsList(ctx context.Context, adAccountId string) ApiAdAccountsAudiencesSharedAccountsListRequest {
	return ApiAdAccountsAudiencesSharedAccountsListRequest{
		ApiService: a,
		ctx: ctx,
		adAccountId: adAccountId,
	}
}

// Execute executes the request
//  @return AdAccountsAudiencesSharedAccountsList200Response
func (a *AudienceSharingAPIService) AdAccountsAudiencesSharedAccountsListExecute(r ApiAdAccountsAudiencesSharedAccountsListRequest) (*AdAccountsAudiencesSharedAccountsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdAccountsAudiencesSharedAccountsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.AdAccountsAudiencesSharedAccountsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ad_accounts/{ad_account_id}/audiences/shared/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_id"+"}", url.PathEscape(parameterValueToString(r.adAccountId, "adAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.adAccountId) > 18 {
		return localVarReturnValue, nil, reportError("adAccountId must have less than 18 elements")
	}
	if r.audienceId == nil {
		return localVarReturnValue, nil, reportError("audienceId is required and must be specified")
	}
	if strlen(*r.audienceId) > 18 {
		return localVarReturnValue, nil, reportError("audienceId must have less than 18 elements")
	}
	if r.accountType == nil {
		return localVarReturnValue, nil, reportError("accountType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "audience_id", r.audienceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "account_type", r.accountType, "form", "")
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBusinessAccountAudiencesSharedAccountsListRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	businessId string
	audienceId *string
	accountType *AudienceAccountType
	pageSize *int32
	bookmark *string
}

// Unique identifier of the audience to use to filter the results.
func (r ApiBusinessAccountAudiencesSharedAccountsListRequest) AudienceId(audienceId string) ApiBusinessAccountAudiencesSharedAccountsListRequest {
	r.audienceId = &audienceId
	return r
}

// Filter accounts by account type.
func (r ApiBusinessAccountAudiencesSharedAccountsListRequest) AccountType(accountType AudienceAccountType) ApiBusinessAccountAudiencesSharedAccountsListRequest {
	r.accountType = &accountType
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiBusinessAccountAudiencesSharedAccountsListRequest) PageSize(pageSize int32) ApiBusinessAccountAudiencesSharedAccountsListRequest {
	r.pageSize = &pageSize
	return r
}

// Cursor used to fetch the next page of items
func (r ApiBusinessAccountAudiencesSharedAccountsListRequest) Bookmark(bookmark string) ApiBusinessAccountAudiencesSharedAccountsListRequest {
	r.bookmark = &bookmark
	return r
}

func (r ApiBusinessAccountAudiencesSharedAccountsListRequest) Execute() (*AdAccountsAudiencesSharedAccountsList200Response, *http.Response, error) {
	return r.ApiService.BusinessAccountAudiencesSharedAccountsListExecute(r)
}

/*
BusinessAccountAudiencesSharedAccountsList List accounts with access to an audience owned by a business

List all ad accounts and/or businesses that have access to a specific audience.
The audience must either be owned by an ad account in the requesting business, or it must have been shared with the requesting business.
If the requesting business is not the owner of the audience, only ad accounts owned by the requesting business will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiBusinessAccountAudiencesSharedAccountsListRequest
*/
func (a *AudienceSharingAPIService) BusinessAccountAudiencesSharedAccountsList(ctx context.Context, businessId string) ApiBusinessAccountAudiencesSharedAccountsListRequest {
	return ApiBusinessAccountAudiencesSharedAccountsListRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return AdAccountsAudiencesSharedAccountsList200Response
func (a *AudienceSharingAPIService) BusinessAccountAudiencesSharedAccountsListExecute(r ApiBusinessAccountAudiencesSharedAccountsListRequest) (*AdAccountsAudiencesSharedAccountsList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AdAccountsAudiencesSharedAccountsList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.BusinessAccountAudiencesSharedAccountsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/audiences/shared/accounts"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.audienceId == nil {
		return localVarReturnValue, nil, reportError("audienceId is required and must be specified")
	}
	if strlen(*r.audienceId) > 18 {
		return localVarReturnValue, nil, reportError("audienceId must have less than 18 elements")
	}
	if r.accountType == nil {
		return localVarReturnValue, nil, reportError("accountType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "audience_id", r.audienceId, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "account_type", r.accountType, "form", "")
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSharedAudiencesForBusinessListRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	businessId string
	bookmark *string
	order *string
	pageSize *int32
}

// Cursor used to fetch the next page of items
func (r ApiSharedAudiencesForBusinessListRequest) Bookmark(bookmark string) ApiSharedAudiencesForBusinessListRequest {
	r.bookmark = &bookmark
	return r
}

// The order in which to sort the items returned: “ASCENDING” or “DESCENDING” by ID. Note that higher-value IDs are associated with more-recently added items.
func (r ApiSharedAudiencesForBusinessListRequest) Order(order string) ApiSharedAudiencesForBusinessListRequest {
	r.order = &order
	return r
}

// Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;&#39;/docs/reference/pagination/&#39;&gt;Pagination&lt;/a&gt; for more information.
func (r ApiSharedAudiencesForBusinessListRequest) PageSize(pageSize int32) ApiSharedAudiencesForBusinessListRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiSharedAudiencesForBusinessListRequest) Execute() (*AudiencesList200Response, *http.Response, error) {
	return r.ApiService.SharedAudiencesForBusinessListExecute(r)
}

/*
SharedAudiencesForBusinessList List received audiences for a business

Get a list of received audiences for the given business.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiSharedAudiencesForBusinessListRequest
*/
func (a *AudienceSharingAPIService) SharedAudiencesForBusinessList(ctx context.Context, businessId string) ApiSharedAudiencesForBusinessListRequest {
	return ApiSharedAudiencesForBusinessListRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return AudiencesList200Response
func (a *AudienceSharingAPIService) SharedAudiencesForBusinessListExecute(r ApiSharedAudiencesForBusinessListRequest) (*AudiencesList200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AudiencesList200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.SharedAudiencesForBusinessList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/audiences"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}

	if r.bookmark != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bookmark", r.bookmark, "form", "")
	}
	if r.order != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order", r.order, "form", "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "form", "")
	} else {
		var defaultValue int32 = 25
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAdAccountToAdAccountSharedAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	adAccountId string
	sharedAudience *SharedAudience
}

func (r ApiUpdateAdAccountToAdAccountSharedAudienceRequest) SharedAudience(sharedAudience SharedAudience) ApiUpdateAdAccountToAdAccountSharedAudienceRequest {
	r.sharedAudience = &sharedAudience
	return r
}

func (r ApiUpdateAdAccountToAdAccountSharedAudienceRequest) Execute() (*SharedAudienceResponse, *http.Response, error) {
	return r.ApiService.UpdateAdAccountToAdAccountSharedAudienceExecute(r)
}

/*
UpdateAdAccountToAdAccountSharedAudience Update audience sharing between ad accounts

From an ad account, share a specific audience with another ad account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient ad account(s) must be in the same <a href='https://help.pinterest.com/en/business/article/create-and-manage-accounts'>Pinterest Business Hierarchy</a> as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href='/docs/getting-started/beta-and-advanced-access/'>Learn more</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adAccountId Unique identifier of an ad account.
 @return ApiUpdateAdAccountToAdAccountSharedAudienceRequest
*/
func (a *AudienceSharingAPIService) UpdateAdAccountToAdAccountSharedAudience(ctx context.Context, adAccountId string) ApiUpdateAdAccountToAdAccountSharedAudienceRequest {
	return ApiUpdateAdAccountToAdAccountSharedAudienceRequest{
		ApiService: a,
		ctx: ctx,
		adAccountId: adAccountId,
	}
}

// Execute executes the request
//  @return SharedAudienceResponse
func (a *AudienceSharingAPIService) UpdateAdAccountToAdAccountSharedAudienceExecute(r ApiUpdateAdAccountToAdAccountSharedAudienceRequest) (*SharedAudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharedAudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.UpdateAdAccountToAdAccountSharedAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ad_accounts/{ad_account_id}/audiences/ad_accounts/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_id"+"}", url.PathEscape(parameterValueToString(r.adAccountId, "adAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.adAccountId) > 18 {
		return localVarReturnValue, nil, reportError("adAccountId must have less than 18 elements")
	}
	if r.sharedAudience == nil {
		return localVarReturnValue, nil, reportError("sharedAudience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharedAudience
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateAdAccountToBusinessSharedAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	adAccountId string
	businessSharedAudience *BusinessSharedAudience
}

func (r ApiUpdateAdAccountToBusinessSharedAudienceRequest) BusinessSharedAudience(businessSharedAudience BusinessSharedAudience) ApiUpdateAdAccountToBusinessSharedAudienceRequest {
	r.businessSharedAudience = &businessSharedAudience
	return r
}

func (r ApiUpdateAdAccountToBusinessSharedAudienceRequest) Execute() (*BusinessSharedAudienceResponse, *http.Response, error) {
	return r.ApiService.UpdateAdAccountToBusinessSharedAudienceExecute(r)
}

/*
UpdateAdAccountToBusinessSharedAudience Update audience sharing from an ad account to businesses

From an ad account, share a specific audience with a business account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient business account must be in the same business hierarchy as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href='/docs/getting-started/beta-and-advanced-access/'>Learn more</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param adAccountId Unique identifier of an ad account.
 @return ApiUpdateAdAccountToBusinessSharedAudienceRequest
*/
func (a *AudienceSharingAPIService) UpdateAdAccountToBusinessSharedAudience(ctx context.Context, adAccountId string) ApiUpdateAdAccountToBusinessSharedAudienceRequest {
	return ApiUpdateAdAccountToBusinessSharedAudienceRequest{
		ApiService: a,
		ctx: ctx,
		adAccountId: adAccountId,
	}
}

// Execute executes the request
//  @return BusinessSharedAudienceResponse
func (a *AudienceSharingAPIService) UpdateAdAccountToBusinessSharedAudienceExecute(r ApiUpdateAdAccountToBusinessSharedAudienceRequest) (*BusinessSharedAudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BusinessSharedAudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.UpdateAdAccountToBusinessSharedAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/ad_accounts/{ad_account_id}/audiences/businesses/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"ad_account_id"+"}", url.PathEscape(parameterValueToString(r.adAccountId, "adAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.adAccountId) > 18 {
		return localVarReturnValue, nil, reportError("adAccountId must have less than 18 elements")
	}
	if r.businessSharedAudience == nil {
		return localVarReturnValue, nil, reportError("businessSharedAudience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.businessSharedAudience
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBusinessToAdAccountSharedAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	businessId string
	sharedAudience *SharedAudience
}

func (r ApiUpdateBusinessToAdAccountSharedAudienceRequest) SharedAudience(sharedAudience SharedAudience) ApiUpdateBusinessToAdAccountSharedAudienceRequest {
	r.sharedAudience = &sharedAudience
	return r
}

func (r ApiUpdateBusinessToAdAccountSharedAudienceRequest) Execute() (*SharedAudienceResponse, *http.Response, error) {
	return r.ApiService.UpdateBusinessToAdAccountSharedAudienceExecute(r)
}

/*
UpdateBusinessToAdAccountSharedAudience Update audience sharing from a business to ad accounts

From a business, share a specific audience with other ad account(s), or revoke access to a previously shared audience. <ul> <li>If the business is the owner of the audience, it can share with any ad account within the same business hierarchy.</li> <li>If the business is the recipient of the audience, it can share with any of its owned ad accounts.</li> </ul> This endpoint is not available to all apps.<a href='/docs/getting-started/beta-and-advanced-access/'>Learn more</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiUpdateBusinessToAdAccountSharedAudienceRequest
*/
func (a *AudienceSharingAPIService) UpdateBusinessToAdAccountSharedAudience(ctx context.Context, businessId string) ApiUpdateBusinessToAdAccountSharedAudienceRequest {
	return ApiUpdateBusinessToAdAccountSharedAudienceRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return SharedAudienceResponse
func (a *AudienceSharingAPIService) UpdateBusinessToAdAccountSharedAudienceExecute(r ApiUpdateBusinessToAdAccountSharedAudienceRequest) (*SharedAudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharedAudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.UpdateBusinessToAdAccountSharedAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/audiences/ad_accounts/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.sharedAudience == nil {
		return localVarReturnValue, nil, reportError("sharedAudience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharedAudience
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateBusinessToBusinessSharedAudienceRequest struct {
	ctx context.Context
	ApiService *AudienceSharingAPIService
	businessId string
	businessSharedAudience *BusinessSharedAudience
}

func (r ApiUpdateBusinessToBusinessSharedAudienceRequest) BusinessSharedAudience(businessSharedAudience BusinessSharedAudience) ApiUpdateBusinessToBusinessSharedAudienceRequest {
	r.businessSharedAudience = &businessSharedAudience
	return r
}

func (r ApiUpdateBusinessToBusinessSharedAudienceRequest) Execute() (*BusinessSharedAudienceResponse, *http.Response, error) {
	return r.ApiService.UpdateBusinessToBusinessSharedAudienceExecute(r)
}

/*
UpdateBusinessToBusinessSharedAudience Update audience sharing between businesses

From a business, share a specific audience with another business account, or revoke access to a previously shared audience. Only the audience owner can share the audience with other businesses, and the recipient business must be within the same business hierarchy.<br> This endpoint is not available to all apps.<a href='/docs/getting-started/beta-and-advanced-access/'>Learn more</a>.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param businessId Unique identifier of the requesting business.
 @return ApiUpdateBusinessToBusinessSharedAudienceRequest
*/
func (a *AudienceSharingAPIService) UpdateBusinessToBusinessSharedAudience(ctx context.Context, businessId string) ApiUpdateBusinessToBusinessSharedAudienceRequest {
	return ApiUpdateBusinessToBusinessSharedAudienceRequest{
		ApiService: a,
		ctx: ctx,
		businessId: businessId,
	}
}

// Execute executes the request
//  @return BusinessSharedAudienceResponse
func (a *AudienceSharingAPIService) UpdateBusinessToBusinessSharedAudienceExecute(r ApiUpdateBusinessToBusinessSharedAudienceRequest) (*BusinessSharedAudienceResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BusinessSharedAudienceResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AudienceSharingAPIService.UpdateBusinessToBusinessSharedAudience")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/businesses/{business_id}/audiences/businesses/shared"
	localVarPath = strings.Replace(localVarPath, "{"+"business_id"+"}", url.PathEscape(parameterValueToString(r.businessId, "businessId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(r.businessId) < 1 {
		return localVarReturnValue, nil, reportError("businessId must have at least 1 elements")
	}
	if strlen(r.businessId) > 20 {
		return localVarReturnValue, nil, reportError("businessId must have less than 20 elements")
	}
	if r.businessSharedAudience == nil {
		return localVarReturnValue, nil, reportError("businessSharedAudience is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.businessSharedAudience
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
