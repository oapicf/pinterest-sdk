#
# Pinterest REST API
# 
# Pinterest's REST API
# The version of the OpenAPI document: 5.14.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_create_asset_group_body
import ../models/model_create_asset_group_response
import ../models/model_delete_asset_group_body
import ../models/model_delete_asset_group_response
import ../models/model_delete_member_access_results_response_array
import ../models/model_delete_partner_asset_access_body
import ../models/model_delete_partner_assets_results_response_array
import ../models/model_error
import ../models/model_partner_type
import ../models/model_permissions_with_owner
import ../models/model_update_asset_group_body
import ../models/model_update_asset_group_response
import ../models/model_update_member_asset_access_body
import ../models/model_update_member_assets_results_response_array
import ../models/model_update_partner_asset_access_body
import ../models/model_update_partner_assets_results_response_array
import ../models/model_business_asset_members_get_200_response
import ../models/model_business_asset_partners_get_200_response
import ../models/model_business_assets_get_200_response
import ../models/model_business_member_assets_get_200_response
import ../models/model_business_members_asset_access_delete_request
import ../models/model_business_partner_asset_access_get_200_response

const basepath = "https://api.pinterest.com/v5"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      when name(stripGenericParams(T.typedesc).typedesc) == name(Table):
        (some(json.to(parseJson(response.body), T.typedesc)), response)
      else:
        (some(marshal.to[T](response.body)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc assetGroupCreate*(httpClient: HttpClient, businessId: string, createAssetGroupBody: CreateAssetGroupBody): (Option[CreateAssetGroupResponse], Response) =
  ## Create a new asset group.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.post(basepath & fmt"/businesses/{business_id}/asset_groups", $(%createAssetGroupBody))
  constructResult[CreateAssetGroupResponse](response)


proc assetGroupDelete*(httpClient: HttpClient, businessId: string, deleteAssetGroupBody: DeleteAssetGroupBody): (Option[DeleteAssetGroupResponse], Response) =
  ## Delete asset groups.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.delete(basepath & fmt"/businesses/{business_id}/asset_groups", $(%deleteAssetGroupBody))
  constructResult[DeleteAssetGroupResponse](response)


proc assetGroupUpdate*(httpClient: HttpClient, businessId: string, updateAssetGroupBody: UpdateAssetGroupBody): (Option[UpdateAssetGroupResponse], Response) =
  ## Update asset groups.
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.patch(basepath & fmt"/businesses/{business_id}/asset_groups", $(%updateAssetGroupBody))
  constructResult[UpdateAssetGroupResponse](response)


proc businessAssetMembersGet*(httpClient: HttpClient, businessId: string, assetId: string, bookmark: string, pageSize: int, startIndex: int): (Option[business_asset_members_get_200_response], Response) =
  ## Get members with access to asset
  let query_for_api_call = encodeQuery([
    ("bookmark", $bookmark), # Cursor used to fetch the next page of items
    ("page_size", $pageSize), # Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/reference/pagination/'>Pagination</a> for more information.
    ("start_index", $startIndex), # An index to start fetching the results from. Only the results starting from this index will be returned.
  ])

  let response = httpClient.get(basepath & fmt"/businesses/{business_id}/assets/{asset_id}/members" & "?" & query_for_api_call)
  constructResult[business_asset_members_get_200_response](response)


proc businessAssetPartnersGet*(httpClient: HttpClient, businessId: string, assetId: string, startIndex: int, bookmark: string, pageSize: int): (Option[business_asset_partners_get_200_response], Response) =
  ## Get partners with access to asset
  let query_for_api_call = encodeQuery([
    ("start_index", $startIndex), # An index to start fetching the results from. Only the results starting from this index will be returned.
    ("bookmark", $bookmark), # Cursor used to fetch the next page of items
    ("page_size", $pageSize), # Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/reference/pagination/'>Pagination</a> for more information.
  ])

  let response = httpClient.get(basepath & fmt"/businesses/{business_id}/assets/{asset_id}/partners" & "?" & query_for_api_call)
  constructResult[business_asset_partners_get_200_response](response)


proc businessAssetsGet*(httpClient: HttpClient, businessId: string, permissions: seq[PermissionsWithOwner], childAssetId: string, assetGroupId: string, assetType: string, startIndex: int, bookmark: string, pageSize: int): (Option[business_assets_get_200_response], Response) =
  ## List business assets
  let query_for_api_call = encodeQuery([
    ("permissions", $permissions.join(",")), # A list of asset permissions used to filter the assets. Only assets where the requesting business has at least one of the specified permissions will be returned.
    ("child_asset_id", $childAssetId), # A child asset unique identifier. Used to fetch asset groups that contain the asset id as a child.
    ("asset_group_id", $assetGroupId), # An asset group unique identifier. Used to fetch assets contained within the specified asset group.
    ("asset_type", $assetType), # A resource type to filter the assets by. Only assets of the specified type will be returned.
    ("start_index", $startIndex), # An index to start fetching the results from. Only the results starting from this index will be returned.
    ("bookmark", $bookmark), # Cursor used to fetch the next page of items
    ("page_size", $pageSize), # Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/reference/pagination/'>Pagination</a> for more information.
  ])

  let response = httpClient.get(basepath & fmt"/businesses/{business_id}/assets" & "?" & query_for_api_call)
  constructResult[business_assets_get_200_response](response)


proc businessMemberAssetsGet*(httpClient: HttpClient, businessId: string, memberId: string, assetType: string, startIndex: int, bookmark: string, pageSize: int): (Option[business_member_assets_get_200_response], Response) =
  ## Get assets assigned to a member
  let query_for_api_call = encodeQuery([
    ("asset_type", $assetType), # A resource type to filter the assets by. Only assets of the specified type will be returned.
    ("start_index", $startIndex), # An index to start fetching the results from. Only the results starting from this index will be returned.
    ("bookmark", $bookmark), # Cursor used to fetch the next page of items
    ("page_size", $pageSize), # Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/reference/pagination/'>Pagination</a> for more information.
  ])

  let response = httpClient.get(basepath & fmt"/businesses/{business_id}/members/{member_id}/assets" & "?" & query_for_api_call)
  constructResult[business_member_assets_get_200_response](response)


proc businessMembersAssetAccessDelete*(httpClient: HttpClient, businessId: string, businessMembersAssetAccessDeleteRequest: BusinessMembersAssetAccessDeleteRequest): (Option[DeleteMemberAccessResultsResponseArray], Response) =
  ## Delete member access to asset
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.delete(basepath & fmt"/businesses/{business_id}/members/assets/access", $(%businessMembersAssetAccessDeleteRequest))
  constructResult[DeleteMemberAccessResultsResponseArray](response)


proc businessMembersAssetAccessUpdate*(httpClient: HttpClient, businessId: string, updateMemberAssetAccessBody: UpdateMemberAssetAccessBody): (Option[UpdateMemberAssetsResultsResponseArray], Response) =
  ## Assign/Update member asset permissions
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.patch(basepath & fmt"/businesses/{business_id}/members/assets/access", $(%updateMemberAssetAccessBody))
  constructResult[UpdateMemberAssetsResultsResponseArray](response)


proc businessPartnerAssetAccessGet*(httpClient: HttpClient, businessId: string, partnerId: string, partnerType: PartnerType, assetType: string, startIndex: int, pageSize: int, bookmark: string): (Option[business_partner_asset_access_get_200_response], Response) =
  ## Get assets assigned to a partner or assets assigned by a partner
  let query_for_api_call = encodeQuery([
    ("partner_type", $partnerType), # Specifies whether to fetch internal or external (shared) partners. If partner_type=INTERNAL, the asset being queried is for accesses the partner has to your business assets.<br> If partner_type=EXTERNAL, the asset being queried is for the accesses you have to the partner's business asset.
    ("asset_type", $assetType), # A resource type to filter the assets by. Only assets of the specified type will be returned.
    ("start_index", $startIndex), # An index to start fetching the results from. Only the results starting from this index will be returned.
    ("page_size", $pageSize), # Maximum number of items to include in a single page of the response. See documentation on <a href='/docs/reference/pagination/'>Pagination</a> for more information.
    ("bookmark", $bookmark), # Cursor used to fetch the next page of items
  ])

  let response = httpClient.get(basepath & fmt"/businesses/{business_id}/partners/{partner_id}/assets" & "?" & query_for_api_call)
  constructResult[business_partner_asset_access_get_200_response](response)


proc deletePartnerAssetAccessHandlerImpl*(httpClient: HttpClient, businessId: string, deletePartnerAssetAccessBody: DeletePartnerAssetAccessBody): (Option[DeletePartnerAssetsResultsResponseArray], Response) =
  ## Delete partner access to asset
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.delete(basepath & fmt"/businesses/{business_id}/partners/assets", $(%deletePartnerAssetAccessBody))
  constructResult[DeletePartnerAssetsResultsResponseArray](response)


proc updatePartnerAssetAccessHandlerImpl*(httpClient: HttpClient, businessId: string, updatePartnerAssetAccessBody: UpdatePartnerAssetAccessBody): (Option[UpdatePartnerAssetsResultsResponseArray], Response) =
  ## Assign/Update partner asset permissions
  httpClient.headers["Content-Type"] = "application/json"

  let response = httpClient.patch(basepath & fmt"/businesses/{business_id}/partners/assets", $(%updatePartnerAssetAccessBody))
  constructResult[UpdatePartnerAssetsResultsResponseArray](response)

