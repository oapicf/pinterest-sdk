/* tslint:disable */
/* eslint-disable */
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Type of account
     * @type {string}
     * @memberof Account
     */
    'account_type'?: AccountAccountTypeEnum;
    /**
     * User account ID.
     * @type {string}
     * @memberof Account
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'profile_image'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'website_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'username'?: string;
    /**
     * Profile about description.
     * @type {string}
     * @memberof Account
     */
    'about'?: string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'business_name'?: string | null;
    /**
     * User account board count.<br/>**Note**: Board count on user account level may differ from counts found elsewhere due to attribution of collaborative Boards.
     * @type {number}
     * @memberof Account
     */
    'board_count'?: number | null;
    /**
     * User account pin count. This includes both created and saved pins.
     * @type {number}
     * @memberof Account
     */
    'pin_count'?: number | null;
    /**
     * User account follower count.
     * @type {number}
     * @memberof Account
     */
    'follower_count'?: number | null;
    /**
     * User account following count.
     * @type {number}
     * @memberof Account
     */
    'following_count'?: number | null;
    /**
     * User account monthly views.
     * @type {number}
     * @memberof Account
     */
    'monthly_views'?: number | null;
}

export const AccountAccountTypeEnum = {
    Pinner: 'PINNER',
    Business: 'BUSINESS'
} as const;

export type AccountAccountTypeEnum = typeof AccountAccountTypeEnum[keyof typeof AccountAccountTypeEnum];

/**
 * Ad group billable event type. For update, only draft ad groups may update billable event.
 * @export
 * @enum {string}
 */

export const ActionType = {
    Clickthrough: 'CLICKTHROUGH',
    Impression: 'IMPRESSION',
    VideoV50Mrc: 'VIDEO_V_50_MRC'
} as const;

export type ActionType = typeof ActionType[keyof typeof ActionType];


/**
 * 
 * @export
 * @interface AdAccount
 */
export interface AdAccount {
    /**
     * 
     * @type {string}
     * @memberof AdAccount
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdAccount
     */
    'name'?: string;
    /**
     * 
     * @type {AdAccountOwner}
     * @memberof AdAccount
     */
    'owner'?: AdAccountOwner;
    /**
     * 
     * @type {Country}
     * @memberof AdAccount
     */
    'country'?: Country;
    /**
     * 
     * @type {Currency}
     * @memberof AdAccount
     */
    'currency'?: Currency;
    /**
     * 
     * @type {Array<BusinessAccessRole>}
     * @memberof AdAccount
     */
    'permissions'?: Array<BusinessAccessRole>;
    /**
     * Creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdAccount
     */
    'created_time'?: number | null;
    /**
     * Last update time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdAccount
     */
    'updated_time'?: number | null;
}


/**
 * 
 * @export
 * @interface AdAccountAnalyticsResponseInner
 */
export interface AdAccountAnalyticsResponseInner {
    [key: string]: any;

    /**
     * The ID of the advertiser that this metrics belongs to.
     * @type {string}
     * @memberof AdAccountAnalyticsResponseInner
     */
    'AD_ACCOUNT_ID': string;
    /**
     * Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
     * @type {string}
     * @memberof AdAccountAnalyticsResponseInner
     */
    'DATE'?: string;
}
/**
 * 
 * @export
 * @interface AdAccountCreateRequest
 */
export interface AdAccountCreateRequest {
    /**
     * 
     * @type {Country}
     * @memberof AdAccountCreateRequest
     */
    'country'?: Country;
    /**
     * Ad Account name.
     * @type {string}
     * @memberof AdAccountCreateRequest
     */
    'name'?: string;
    /**
     * Advertiser\'s owning user ID.
     * @type {string}
     * @memberof AdAccountCreateRequest
     */
    'owner_user_id'?: string;
}


/**
 * 
 * @export
 * @interface AdAccountCreateSubscriptionRequest
 */
export interface AdAccountCreateSubscriptionRequest {
    /**
     * Standard HTTPS webhook URL.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionRequest
     */
    'webhook_url': string;
    /**
     * Lead form ID.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionRequest
     */
    'lead_form_id'?: string;
    /**
     * Partner access token. Only for clients that requires authentication. We recommend to avoid this param.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionRequest
     */
    'partner_access_token'?: string;
    /**
     * Partner refresh token. Only for clients that requires authentication. We recommend to avoid this param.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionRequest
     */
    'partner_refresh_token'?: string;
    /**
     * 
     * @type {AdAccountCreateSubscriptionRequestPartnerMetadata}
     * @memberof AdAccountCreateSubscriptionRequest
     */
    'partner_metadata'?: AdAccountCreateSubscriptionRequestPartnerMetadata;
}
/**
 * Partner metadata. Only for clients that requires special handling. We recommend to avoid this param.
 * @export
 * @interface AdAccountCreateSubscriptionRequestPartnerMetadata
 */
export interface AdAccountCreateSubscriptionRequestPartnerMetadata {
    /**
     * Text field value that uniquely identifies a subscriber.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionRequestPartnerMetadata
     */
    'subscriber_key'?: string;
}
/**
 * 
 * @export
 * @interface AdAccountCreateSubscriptionResponse
 */
export interface AdAccountCreateSubscriptionResponse {
    /**
     * Subscription ID.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionResponse
     */
    'id'?: string;
    /**
     * Base64 encoded key for client to decrypt lead data.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionResponse
     */
    'cryptographic_key'?: string | null;
    /**
     * Lead data encryption algorithm.
     * @type {string}
     * @memberof AdAccountCreateSubscriptionResponse
     */
    'cryptographic_algorithm'?: string | null;
    /**
     * Subscription creation time. Unix timestamp in milliseconds.
     * @type {number}
     * @memberof AdAccountCreateSubscriptionResponse
     */
    'created_time'?: number;
}
/**
 * 
 * @export
 * @interface AdAccountGetSubscriptionResponse
 */
export interface AdAccountGetSubscriptionResponse {
    /**
     * Lead form ID.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'lead_form_id'?: string | null;
    /**
     * Standard HTTPS webhook URL.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'webhook_url'?: string;
    /**
     * Subscription ID.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'id'?: string;
    /**
     * User account used to subscribe lead data.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'user_account_id'?: string;
    /**
     * The Ad Account ID that this lead form belongs to.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'ad_account_id'?: string;
    /**
     * API version.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'api_version'?: string;
    /**
     * Base64 encoded key for client to decrypt lead data.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'cryptographic_key'?: string | null;
    /**
     * Lead data encryption algorithm.
     * @type {string}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'cryptographic_algorithm'?: string | null;
    /**
     * Lead form creation time. Unix timestamp in milliseconds.
     * @type {number}
     * @memberof AdAccountGetSubscriptionResponse
     */
    'created_time'?: number;
}
/**
 * 
 * @export
 * @interface AdAccountOwner
 */
export interface AdAccountOwner {
    /**
     * Public username for the user account
     * @type {string}
     * @memberof AdAccountOwner
     */
    'username'?: string;
    /**
     * The owning account\'s user ID.
     * @type {string}
     * @memberof AdAccountOwner
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AdAccountsAudiencesSharedAccountsList200Response
 */
export interface AdAccountsAudiencesSharedAccountsList200Response {
    /**
     * 
     * @type {Array<SharedAudienceAccount>}
     * @memberof AdAccountsAudiencesSharedAccountsList200Response
     */
    'items': Array<SharedAudienceAccount>;
    /**
     * 
     * @type {string}
     * @memberof AdAccountsAudiencesSharedAccountsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface AdAccountsCountryResponse
 */
export interface AdAccountsCountryResponse {
    /**
     * 
     * @type {Array<AdAccountsCountryResponseData>}
     * @memberof AdAccountsCountryResponse
     */
    'items'?: Array<AdAccountsCountryResponseData>;
}
/**
 * 
 * @export
 * @interface AdAccountsCountryResponseData
 */
export interface AdAccountsCountryResponseData {
    /**
     * 
     * @type {AdCountry}
     * @memberof AdAccountsCountryResponseData
     */
    'code'?: AdCountry;
    /**
     * Country currency.
     * @type {string}
     * @memberof AdAccountsCountryResponseData
     */
    'currency'?: string;
    /**
     * Country index
     * @type {number}
     * @memberof AdAccountsCountryResponseData
     */
    'index'?: number;
    /**
     * Country name
     * @type {string}
     * @memberof AdAccountsCountryResponseData
     */
    'name'?: string;
}


/**
 * 
 * @export
 * @interface AdAccountsList200Response
 */
export interface AdAccountsList200Response {
    /**
     * Ad accounts
     * @type {Array<AdAccount>}
     * @memberof AdAccountsList200Response
     */
    'items': Array<AdAccount>;
    /**
     * 
     * @type {string}
     * @memberof AdAccountsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface AdAccountsSubscriptionsGetList200Response
 */
export interface AdAccountsSubscriptionsGetList200Response {
    /**
     * 
     * @type {Array<AdAccountGetSubscriptionResponse>}
     * @memberof AdAccountsSubscriptionsGetList200Response
     */
    'items': Array<AdAccountGetSubscriptionResponse>;
    /**
     * 
     * @type {string}
     * @memberof AdAccountsSubscriptionsGetList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface AdArrayResponse
 */
export interface AdArrayResponse {
    /**
     * 
     * @type {Array<AdArrayResponseElement>}
     * @memberof AdArrayResponse
     */
    'items'?: Array<AdArrayResponseElement>;
}
/**
 * 
 * @export
 * @interface AdArrayResponseElement
 */
export interface AdArrayResponseElement {
    /**
     * 
     * @type {AdResponse}
     * @memberof AdArrayResponseElement
     */
    'data'?: AdResponse;
    /**
     * 
     * @type {Exception}
     * @memberof AdArrayResponseElement
     */
    'exceptions'?: Exception;
}
/**
 * Creation fields
 * @export
 * @interface AdCommon
 */
export interface AdCommon {
    /**
     * ID of the ad group that contains the ad.
     * @type {string}
     * @memberof AdCommon
     */
    'ad_group_id'?: string;
    /**
     * Deep link URL for Android devices.
     * @type {string}
     * @memberof AdCommon
     */
    'android_deep_link'?: string | null;
    /**
     * Comma-separated deep links for the carousel pin on Android.
     * @type {Array<string>}
     * @memberof AdCommon
     */
    'carousel_android_deep_links'?: Array<string> | null;
    /**
     * Comma-separated destination URLs for the carousel pin to promote.
     * @type {Array<string>}
     * @memberof AdCommon
     */
    'carousel_destination_urls'?: Array<string> | null;
    /**
     * Comma-separated deep links for the carousel pin on iOS.
     * @type {Array<string>}
     * @memberof AdCommon
     */
    'carousel_ios_deep_links'?: Array<string> | null;
    /**
     * Tracking url for the ad clicks.
     * @type {string}
     * @memberof AdCommon
     */
    'click_tracking_url'?: string | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof AdCommon
     */
    'creative_type'?: CreativeType;
    /**
     * Destination URL.
     * @type {string}
     * @memberof AdCommon
     */
    'destination_url'?: string | null;
    /**
     * Deep link URL for iOS devices.
     * @type {string}
     * @memberof AdCommon
     */
    'ios_deep_link'?: string | null;
    /**
     * Is original pin deleted?
     * @type {boolean}
     * @memberof AdCommon
     */
    'is_pin_deleted'?: boolean;
    /**
     * Is pin repinnable?
     * @type {boolean}
     * @memberof AdCommon
     */
    'is_removable'?: boolean;
    /**
     * Name of the ad - 255 chars max.
     * @type {string}
     * @memberof AdCommon
     */
    'name'?: string | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof AdCommon
     */
    'status'?: EntityStatus;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof AdCommon
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Tracking URL for ad impressions.
     * @type {string}
     * @memberof AdCommon
     */
    'view_tracking_url'?: string | null;
    /**
     * Lead form ID for lead ad generation.
     * @type {string}
     * @memberof AdCommon
     */
    'lead_form_id'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof AdCommon
     */
    'grid_click_type'?: GridClickType | null;
    /**
     * Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_SITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
     * @type {string}
     * @memberof AdCommon
     */
    'customizable_cta_type'?: AdCommonCustomizableCtaTypeEnum | null;
    /**
     * Before creating a quiz ad, you must create an organic Pin using POST/Create Pin for each result in the quiz. Quiz ads cannot be saved by a Pinner. Quiz ad results can be saved.
     * @type {QuizPinData}
     * @memberof AdCommon
     */
    'quiz_pin_data'?: QuizPinData | null;
}

export const AdCommonCustomizableCtaTypeEnum = {
    GetOffer: 'GET_OFFER',
    LearnMore: 'LEARN_MORE',
    OrderNow: 'ORDER_NOW',
    ShopNow: 'SHOP_NOW',
    SignUp: 'SIGN_UP',
    Subscribe: 'SUBSCRIBE',
    BuyNow: 'BUY_NOW',
    ContactUs: 'CONTACT_US',
    GetQuote: 'GET_QUOTE',
    VisitSite: 'VISIT_SITE',
    ApplyNow: 'APPLY_NOW',
    BookNow: 'BOOK_NOW',
    RequestDemo: 'REQUEST_DEMO',
    RegisterNow: 'REGISTER_NOW',
    FindADealer: 'FIND_A_DEALER',
    AddToCart: 'ADD_TO_CART',
    WatchNow: 'WATCH_NOW',
    ReadMore: 'READ_MORE'
} as const;

export type AdCommonCustomizableCtaTypeEnum = typeof AdCommonCustomizableCtaTypeEnum[keyof typeof AdCommonCustomizableCtaTypeEnum];

/**
 * Country ID from ISO 3166-1 alpha-2.
 * @export
 * @enum {string}
 */

export const AdCountry = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    Ao: 'AO',
    Aq: 'AQ',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Ax: 'AX',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bl: 'BL',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Bq: 'BQ',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bv: 'BV',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cc: 'CC',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cw: 'CW',
    Cx: 'CX',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Eh: 'EH',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gs: 'GS',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hm: 'HM',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    Im: 'IM',
    In: 'IN',
    Io: 'IO',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kr: 'KR',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mf: 'MF',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Nf: 'NF',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pm: 'PM',
    Pn: 'PN',
    Pr: 'PR',
    Ps: 'PS',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sj: 'SJ',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sx: 'SX',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tf: 'TF',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tk: 'TK',
    Tl: 'TL',
    Tm: 'TM',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Um: 'UM',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Wf: 'WF',
    Ws: 'WS',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type AdCountry = typeof AdCountry[keyof typeof AdCountry];


/**
 * 
 * @export
 * @interface AdCreateRequest
 */
export interface AdCreateRequest {
    /**
     * ID of the ad group that contains the ad.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'ad_group_id': string;
    /**
     * Deep link URL for Android devices.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'android_deep_link'?: string | null;
    /**
     * Comma-separated deep links for the carousel pin on Android.
     * @type {Array<string>}
     * @memberof AdCreateRequest
     */
    'carousel_android_deep_links'?: Array<string> | null;
    /**
     * Comma-separated destination URLs for the carousel pin to promote.
     * @type {Array<string>}
     * @memberof AdCreateRequest
     */
    'carousel_destination_urls'?: Array<string> | null;
    /**
     * Comma-separated deep links for the carousel pin on iOS.
     * @type {Array<string>}
     * @memberof AdCreateRequest
     */
    'carousel_ios_deep_links'?: Array<string> | null;
    /**
     * Tracking url for the ad clicks.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'click_tracking_url'?: string | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof AdCreateRequest
     */
    'creative_type': CreativeType;
    /**
     * Destination URL.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'destination_url'?: string | null;
    /**
     * Deep link URL for iOS devices.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'ios_deep_link'?: string | null;
    /**
     * Is original pin deleted?
     * @type {boolean}
     * @memberof AdCreateRequest
     */
    'is_pin_deleted'?: boolean;
    /**
     * Is pin repinnable?
     * @type {boolean}
     * @memberof AdCreateRequest
     */
    'is_removable'?: boolean;
    /**
     * Name of the ad - 255 chars max.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof AdCreateRequest
     */
    'status'?: EntityStatus;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof AdCreateRequest
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Tracking URL for ad impressions.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'view_tracking_url'?: string | null;
    /**
     * Lead form ID for lead ad generation.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'lead_form_id'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof AdCreateRequest
     */
    'grid_click_type'?: GridClickType | null;
    /**
     * Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_SITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
     * @type {string}
     * @memberof AdCreateRequest
     */
    'customizable_cta_type'?: AdCreateRequestCustomizableCtaTypeEnum | null;
    /**
     * Before creating a quiz ad, you must create an organic Pin using POST/Create Pin for each result in the quiz. Quiz ads cannot be saved by a Pinner. Quiz ad results can be saved.
     * @type {QuizPinData}
     * @memberof AdCreateRequest
     */
    'quiz_pin_data'?: QuizPinData | null;
    /**
     * Pin ID.
     * @type {string}
     * @memberof AdCreateRequest
     */
    'pin_id': string;
}

export const AdCreateRequestCustomizableCtaTypeEnum = {
    GetOffer: 'GET_OFFER',
    LearnMore: 'LEARN_MORE',
    OrderNow: 'ORDER_NOW',
    ShopNow: 'SHOP_NOW',
    SignUp: 'SIGN_UP',
    Subscribe: 'SUBSCRIBE',
    BuyNow: 'BUY_NOW',
    ContactUs: 'CONTACT_US',
    GetQuote: 'GET_QUOTE',
    VisitSite: 'VISIT_SITE',
    ApplyNow: 'APPLY_NOW',
    BookNow: 'BOOK_NOW',
    RequestDemo: 'REQUEST_DEMO',
    RegisterNow: 'REGISTER_NOW',
    FindADealer: 'FIND_A_DEALER',
    AddToCart: 'ADD_TO_CART',
    WatchNow: 'WATCH_NOW',
    ReadMore: 'READ_MORE'
} as const;

export type AdCreateRequestCustomizableCtaTypeEnum = typeof AdCreateRequestCustomizableCtaTypeEnum[keyof typeof AdCreateRequestCustomizableCtaTypeEnum];

/**
 * 
 * @export
 * @interface AdGroupArrayResponse
 */
export interface AdGroupArrayResponse {
    /**
     * 
     * @type {Array<AdGroupArrayResponseElement>}
     * @memberof AdGroupArrayResponse
     */
    'items'?: Array<AdGroupArrayResponseElement>;
}
/**
 * 
 * @export
 * @interface AdGroupArrayResponseElement
 */
export interface AdGroupArrayResponseElement {
    /**
     * 
     * @type {AdGroupResponse}
     * @memberof AdGroupArrayResponseElement
     */
    'data'?: AdGroupResponse;
    /**
     * 
     * @type {Array<Exception>}
     * @memberof AdGroupArrayResponseElement
     */
    'exceptions'?: Array<Exception>;
}
/**
 * 
 * @export
 * @interface AdGroupAudienceSizingRequest
 */
export interface AdGroupAudienceSizingRequest {
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof AdGroupAudienceSizingRequest
     */
    'auto_targeting_enabled'?: boolean;
    /**
     * <a href=\"/docs/redoc/#section/Placement-group\">Placement group</a>.
     * @type {PlacementGroupType}
     * @memberof AdGroupAudienceSizingRequest
     */
    'placement_group'?: PlacementGroupType;
    /**
     * Pin creative types filter. </p><strong>Note:</strong> SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
     * @type {Array<string>}
     * @memberof AdGroupAudienceSizingRequest
     */
    'creative_types'?: Array<AdGroupAudienceSizingRequestCreativeTypesEnum> | null;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof AdGroupAudienceSizingRequest
     */
    'targeting_spec'?: TargetingSpec;
    /**
     * Targeted product group IDs. </p><strong>Note:</strong> This can only be combined with shopping/catalog sales campaigns. For more information, <a href=\"https://help.pinterest.com/en/business/article/shopping-ads#section-14571\" target=\"_blank\">click here</a>. SHOPPING_RETARGETING must be included in targeting_spec object or this field will be ignored.
     * @type {Array<string>}
     * @memberof AdGroupAudienceSizingRequest
     */
    'product_group_ids'?: Array<string> | null;
    /**
     * Array of keyword objects. If the keywords field is missing, all keywords will be targeted.
     * @type {Array<AdGroupAudienceSizingRequestKeywordsInner>}
     * @memberof AdGroupAudienceSizingRequest
     */
    'keywords'?: Array<AdGroupAudienceSizingRequestKeywordsInner> | null;
}

export const AdGroupAudienceSizingRequestCreativeTypesEnum = {
    Regular: 'REGULAR',
    Video: 'VIDEO',
    Shopping: 'SHOPPING',
    Carousel: 'CAROUSEL',
    MaxVideo: 'MAX_VIDEO',
    ShopThePin: 'SHOP_THE_PIN',
    Collection: 'COLLECTION',
    Idea: 'IDEA'
} as const;

export type AdGroupAudienceSizingRequestCreativeTypesEnum = typeof AdGroupAudienceSizingRequestCreativeTypesEnum[keyof typeof AdGroupAudienceSizingRequestCreativeTypesEnum];

/**
 * 
 * @export
 * @interface AdGroupAudienceSizingRequestKeywordsInner
 */
export interface AdGroupAudienceSizingRequestKeywordsInner {
    /**
     * 
     * @type {MatchTypeResponse}
     * @memberof AdGroupAudienceSizingRequestKeywordsInner
     */
    'match_type': MatchTypeResponse | null;
    /**
     * Keyword value (120 chars max).
     * @type {string}
     * @memberof AdGroupAudienceSizingRequestKeywordsInner
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface AdGroupAudienceSizingResponse
 */
export interface AdGroupAudienceSizingResponse {
    /**
     * The lower confidence bound of the estimated potential audience size. \"Potential audience size\" estimates the number of people you may be able to reach per month with your campaign. It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
     * @type {number}
     * @memberof AdGroupAudienceSizingResponse
     */
    'audience_size_lower_bound'?: number;
    /**
     * The upper confidence bound of the estimated potential audience size. \"Potential audience size\" estimates the number of people you may be able to reach per month with your campaign. It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
     * @type {number}
     * @memberof AdGroupAudienceSizingResponse
     */
    'audience_size_upper_bound'?: number;
}
/**
 * 
 * @export
 * @interface AdGroupCommon
 */
export interface AdGroupCommon {
    /**
     * Ad group name.
     * @type {string}
     * @memberof AdGroupCommon
     */
    'name'?: string;
    /**
     * Ad group/entity status.
     * @type {EntityStatus}
     * @memberof AdGroupCommon
     */
    'status'?: EntityStatus;
    /**
     * Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
     * @type {number}
     * @memberof AdGroupCommon
     */
    'budget_in_micro_currency'?: number | null;
    /**
     * Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
     * @type {number}
     * @memberof AdGroupCommon
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * Optimization goals for objective-based performance campaigns. **REQUIRED** when campaign\'s `objective_type` is set to `\"WEB_CONVERSION\"`.
     * @type {OptimizationGoalMetadata}
     * @memberof AdGroupCommon
     */
    'optimization_goal_metadata'?: OptimizationGoalMetadata | null;
    /**
     * 
     * @type {BudgetType}
     * @memberof AdGroupCommon
     */
    'budget_type'?: BudgetType;
    /**
     * Ad group start time. Unix timestamp in seconds. Defaults to current time.
     * @type {number}
     * @memberof AdGroupCommon
     */
    'start_time'?: number | null;
    /**
     * Ad group end time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdGroupCommon
     */
    'end_time'?: number | null;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof AdGroupCommon
     */
    'targeting_spec'?: TargetingSpec;
    /**
     * Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
     * @type {number}
     * @memberof AdGroupCommon
     */
    'lifetime_frequency_cap'?: number;
    /**
     * Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
     * @type {TrackingUrls}
     * @memberof AdGroupCommon
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof AdGroupCommon
     */
    'auto_targeting_enabled'?: boolean | null;
    /**
     * <a href=\"/docs/redoc/#section/Placement-group\">Placement group</a>.
     * @type {PlacementGroupType}
     * @memberof AdGroupCommon
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {PacingDeliveryType}
     * @memberof AdGroupCommon
     */
    'pacing_delivery_type'?: PacingDeliveryType;
    /**
     * Campaign ID of the ad group.
     * @type {string}
     * @memberof AdGroupCommon
     */
    'campaign_id'?: string;
    /**
     * 
     * @type {ActionType}
     * @memberof AdGroupCommon
     */
    'billable_event'?: ActionType;
    /**
     * Bid strategy type. For Campaigns with Video Completion objectives, the only supported bid strategy type is AUTOMATIC_BID.
     * @type {string}
     * @memberof AdGroupCommon
     */
    'bid_strategy_type'?: AdGroupCommonBidStrategyTypeEnum | null;
    /**
     * Targeting template IDs applied to the ad group. We currently only support 1 targeting template per ad group. To use targeting templates, do not set any other targeting fields: targeting_spec, tracking_urls, auto_targeting_enabled, placement_group. To clear all targeting template IDs, set this field to [\'0\'].
     * @type {Array<string>}
     * @memberof AdGroupCommon
     */
    'targeting_template_ids'?: Array<string> | null;
}

export const AdGroupCommonBidStrategyTypeEnum = {
    AutomaticBid: 'AUTOMATIC_BID',
    MaxBid: 'MAX_BID',
    TargetAvg: 'TARGET_AVG'
} as const;

export type AdGroupCommonBidStrategyTypeEnum = typeof AdGroupCommonBidStrategyTypeEnum[keyof typeof AdGroupCommonBidStrategyTypeEnum];

/**
 * 
 * @export
 * @interface AdGroupCreateRequest
 */
export interface AdGroupCreateRequest {
    /**
     * Ad group name.
     * @type {string}
     * @memberof AdGroupCreateRequest
     */
    'name': string;
    /**
     * Ad group/entity status.
     * @type {EntityStatus}
     * @memberof AdGroupCreateRequest
     */
    'status'?: EntityStatus;
    /**
     * Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
     * @type {number}
     * @memberof AdGroupCreateRequest
     */
    'budget_in_micro_currency'?: number | null;
    /**
     * Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
     * @type {number}
     * @memberof AdGroupCreateRequest
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * Optimization goals for objective-based performance campaigns. **REQUIRED** when campaign\'s `objective_type` is set to `\"WEB_CONVERSION\"`.
     * @type {OptimizationGoalMetadata}
     * @memberof AdGroupCreateRequest
     */
    'optimization_goal_metadata'?: OptimizationGoalMetadata | null;
    /**
     * 
     * @type {BudgetType}
     * @memberof AdGroupCreateRequest
     */
    'budget_type'?: BudgetType;
    /**
     * Ad group start time. Unix timestamp in seconds. Defaults to current time.
     * @type {number}
     * @memberof AdGroupCreateRequest
     */
    'start_time'?: number | null;
    /**
     * Ad group end time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdGroupCreateRequest
     */
    'end_time'?: number | null;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof AdGroupCreateRequest
     */
    'targeting_spec'?: TargetingSpec;
    /**
     * Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
     * @type {number}
     * @memberof AdGroupCreateRequest
     */
    'lifetime_frequency_cap'?: number;
    /**
     * Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
     * @type {TrackingUrls}
     * @memberof AdGroupCreateRequest
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Enable auto-targeting for ad group.Default value is True. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof AdGroupCreateRequest
     */
    'auto_targeting_enabled'?: boolean;
    /**
     * <a href=\"/docs/redoc/#section/Placement-group\">Placement group</a>.
     * @type {PlacementGroupType}
     * @memberof AdGroupCreateRequest
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {PacingDeliveryType}
     * @memberof AdGroupCreateRequest
     */
    'pacing_delivery_type'?: PacingDeliveryType;
    /**
     * Campaign ID of the ad group.
     * @type {string}
     * @memberof AdGroupCreateRequest
     */
    'campaign_id': string;
    /**
     * 
     * @type {ActionType}
     * @memberof AdGroupCreateRequest
     */
    'billable_event': ActionType;
    /**
     * Bid strategy type. For Campaigns with Video Completion objectives, the only supported bid strategy type is AUTOMATIC_BID.
     * @type {string}
     * @memberof AdGroupCreateRequest
     */
    'bid_strategy_type'?: AdGroupCreateRequestBidStrategyTypeEnum | null;
    /**
     * Targeting template IDs applied to the ad group. We currently only support 1 targeting template per ad group. To use targeting templates, do not set any other targeting fields: targeting_spec, tracking_urls, auto_targeting_enabled, placement_group. To clear all targeting template IDs, set this field to [\'0\'].
     * @type {Array<string>}
     * @memberof AdGroupCreateRequest
     */
    'targeting_template_ids'?: Array<string> | null;
}

export const AdGroupCreateRequestBidStrategyTypeEnum = {
    AutomaticBid: 'AUTOMATIC_BID',
    MaxBid: 'MAX_BID',
    TargetAvg: 'TARGET_AVG'
} as const;

export type AdGroupCreateRequestBidStrategyTypeEnum = typeof AdGroupCreateRequestBidStrategyTypeEnum[keyof typeof AdGroupCreateRequestBidStrategyTypeEnum];

/**
 * 
 * @export
 * @interface AdGroupResponse
 */
export interface AdGroupResponse {
    /**
     * Ad group name.
     * @type {string}
     * @memberof AdGroupResponse
     */
    'name'?: string;
    /**
     * Ad group/entity status.
     * @type {EntityStatus}
     * @memberof AdGroupResponse
     */
    'status'?: EntityStatus;
    /**
     * Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'budget_in_micro_currency'?: number | null;
    /**
     * Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * Optimization goals for objective-based performance campaigns. **REQUIRED** when campaign\'s `objective_type` is set to `\"WEB_CONVERSION\"`.
     * @type {OptimizationGoalMetadata}
     * @memberof AdGroupResponse
     */
    'optimization_goal_metadata'?: OptimizationGoalMetadata | null;
    /**
     * 
     * @type {BudgetType}
     * @memberof AdGroupResponse
     */
    'budget_type'?: BudgetType;
    /**
     * Ad group start time. Unix timestamp in seconds. Defaults to current time.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'start_time'?: number | null;
    /**
     * Ad group end time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'end_time'?: number | null;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof AdGroupResponse
     */
    'targeting_spec'?: TargetingSpec;
    /**
     * Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'lifetime_frequency_cap'?: number;
    /**
     * Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
     * @type {TrackingUrls}
     * @memberof AdGroupResponse
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof AdGroupResponse
     */
    'auto_targeting_enabled'?: boolean | null;
    /**
     * <a href=\"/docs/redoc/#section/Placement-group\">Placement group</a>.
     * @type {PlacementGroupType}
     * @memberof AdGroupResponse
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {PacingDeliveryType}
     * @memberof AdGroupResponse
     */
    'pacing_delivery_type'?: PacingDeliveryType;
    /**
     * Campaign ID of the ad group.
     * @type {string}
     * @memberof AdGroupResponse
     */
    'campaign_id'?: string;
    /**
     * 
     * @type {ActionType}
     * @memberof AdGroupResponse
     */
    'billable_event'?: ActionType;
    /**
     * Bid strategy type. For Campaigns with Video Completion objectives, the only supported bid strategy type is AUTOMATIC_BID.
     * @type {string}
     * @memberof AdGroupResponse
     */
    'bid_strategy_type'?: AdGroupResponseBidStrategyTypeEnum | null;
    /**
     * Targeting template IDs applied to the ad group. We currently only support 1 targeting template per ad group. To use targeting templates, do not set any other targeting fields: targeting_spec, tracking_urls, auto_targeting_enabled, placement_group. To clear all targeting template IDs, set this field to [\'0\'].
     * @type {Array<string>}
     * @memberof AdGroupResponse
     */
    'targeting_template_ids'?: Array<string> | null;
    /**
     * Ad group ID.
     * @type {string}
     * @memberof AdGroupResponse
     */
    'id'?: string;
    /**
     * Advertiser ID.
     * @type {string}
     * @memberof AdGroupResponse
     */
    'ad_account_id'?: string;
    /**
     * Ad group creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'created_time'?: number;
    /**
     * Ad group last update time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdGroupResponse
     */
    'updated_time'?: number;
    /**
     * Always \"adgroup\".
     * @type {string}
     * @memberof AdGroupResponse
     */
    'type'?: string;
    /**
     * oCPM learn mode
     * @type {string}
     * @memberof AdGroupResponse
     */
    'conversion_learning_mode_type'?: AdGroupResponseConversionLearningModeTypeEnum | null;
    /**
     * Ad group summary status.
     * @type {AdGroupSummaryStatus}
     * @memberof AdGroupResponse
     */
    'summary_status'?: AdGroupSummaryStatus;
    /**
     * Feed Profile ID associated to the adgroup.
     * @type {string}
     * @memberof AdGroupResponse
     */
    'feed_profile_id'?: string;
    /**
     * [DCA] The Dynamic creative assets to use for DCA. Dynamic Creative Assembly (DCA) accepts basic creative assets of an ad (image, video, title, call to action, logo etc). Then it automatically generates optimized ad combinations based on these assets.
     * @type {any}
     * @memberof AdGroupResponse
     */
    'dca_assets'?: any;
}

export const AdGroupResponseBidStrategyTypeEnum = {
    AutomaticBid: 'AUTOMATIC_BID',
    MaxBid: 'MAX_BID',
    TargetAvg: 'TARGET_AVG'
} as const;

export type AdGroupResponseBidStrategyTypeEnum = typeof AdGroupResponseBidStrategyTypeEnum[keyof typeof AdGroupResponseBidStrategyTypeEnum];
export const AdGroupResponseConversionLearningModeTypeEnum = {
    NotActive: 'NOT_ACTIVE',
    Active: 'ACTIVE'
} as const;

export type AdGroupResponseConversionLearningModeTypeEnum = typeof AdGroupResponseConversionLearningModeTypeEnum[keyof typeof AdGroupResponseConversionLearningModeTypeEnum];

/**
 * Summary status for ad group
 * @export
 * @enum {string}
 */

export const AdGroupSummaryStatus = {
    Running: 'RUNNING',
    Paused: 'PAUSED',
    NotStarted: 'NOT_STARTED',
    Completed: 'COMPLETED',
    AdvertiserDisabled: 'ADVERTISER_DISABLED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;

export type AdGroupSummaryStatus = typeof AdGroupSummaryStatus[keyof typeof AdGroupSummaryStatus];


/**
 * 
 * @export
 * @interface AdGroupUpdateRequest
 */
export interface AdGroupUpdateRequest {
    /**
     * Ad group name.
     * @type {string}
     * @memberof AdGroupUpdateRequest
     */
    'name'?: string;
    /**
     * Ad group/entity status.
     * @type {EntityStatus}
     * @memberof AdGroupUpdateRequest
     */
    'status'?: EntityStatus;
    /**
     * Budget in micro currency. This field is **REQUIRED** for non-CBO (campaign budget optimization) campaigns.  A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. A CBO campaign is limited to 70 or less ad groups.
     * @type {number}
     * @memberof AdGroupUpdateRequest
     */
    'budget_in_micro_currency'?: number | null;
    /**
     * Bid price in micro currency. This field is **REQUIRED** for the following campaign objective_type/billable_event combinations: AWARENESS/IMPRESSION, CONSIDERATION/CLICKTHROUGH, CATALOG_SALES/CLICKTHROUGH, VIDEO_VIEW/VIDEO_V_50_MRC.
     * @type {number}
     * @memberof AdGroupUpdateRequest
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * Optimization goals for objective-based performance campaigns. **REQUIRED** when campaign\'s `objective_type` is set to `\"WEB_CONVERSION\"`.
     * @type {OptimizationGoalMetadata}
     * @memberof AdGroupUpdateRequest
     */
    'optimization_goal_metadata'?: OptimizationGoalMetadata | null;
    /**
     * 
     * @type {BudgetType}
     * @memberof AdGroupUpdateRequest
     */
    'budget_type'?: BudgetType;
    /**
     * Ad group start time. Unix timestamp in seconds. Defaults to current time.
     * @type {number}
     * @memberof AdGroupUpdateRequest
     */
    'start_time'?: number | null;
    /**
     * Ad group end time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdGroupUpdateRequest
     */
    'end_time'?: number | null;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof AdGroupUpdateRequest
     */
    'targeting_spec'?: TargetingSpec;
    /**
     * Set a limit to the number of times a promoted pin from this campaign can be impressed by a pinner within the past rolling 30 days. Only available for CPM (cost per mille (1000 impressions))  ad groups. A CPM ad group has an IMPRESSION <a href=\"/docs/redoc/#section/Billable-event\">billable_event</a> value. This field **REQUIRES** the `end_time` field.
     * @type {number}
     * @memberof AdGroupUpdateRequest
     */
    'lifetime_frequency_cap'?: number;
    /**
     * Third-party tracking URLs.<br> JSON object with the format: {\"<a href=\"/docs/redoc/#section/Tracking-URL-event\">Tracking event enum</a>\":[URL string array],...}<br> For example: {\"impression\": [\"URL1\", \"URL2\"], \"click\": [\"URL1\", \"URL2\", \"URL3\"]}.<br>Up to three tracking URLs are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. May be null. Pass in an empty object - {} - to remove tracking URLs.<br><br> For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
     * @type {TrackingUrls}
     * @memberof AdGroupUpdateRequest
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof AdGroupUpdateRequest
     */
    'auto_targeting_enabled'?: boolean | null;
    /**
     * <a href=\"/docs/redoc/#section/Placement-group\">Placement group</a>.
     * @type {PlacementGroupType}
     * @memberof AdGroupUpdateRequest
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {PacingDeliveryType}
     * @memberof AdGroupUpdateRequest
     */
    'pacing_delivery_type'?: PacingDeliveryType;
    /**
     * Campaign ID of the ad group.
     * @type {string}
     * @memberof AdGroupUpdateRequest
     */
    'campaign_id'?: string;
    /**
     * 
     * @type {ActionType}
     * @memberof AdGroupUpdateRequest
     */
    'billable_event'?: ActionType;
    /**
     * Bid strategy type. For Campaigns with Video Completion objectives, the only supported bid strategy type is AUTOMATIC_BID.
     * @type {string}
     * @memberof AdGroupUpdateRequest
     */
    'bid_strategy_type'?: AdGroupUpdateRequestBidStrategyTypeEnum | null;
    /**
     * Targeting template IDs applied to the ad group. We currently only support 1 targeting template per ad group. To use targeting templates, do not set any other targeting fields: targeting_spec, tracking_urls, auto_targeting_enabled, placement_group. To clear all targeting template IDs, set this field to [\'0\'].
     * @type {Array<string>}
     * @memberof AdGroupUpdateRequest
     */
    'targeting_template_ids'?: Array<string> | null;
    /**
     * Ad group ID.
     * @type {string}
     * @memberof AdGroupUpdateRequest
     */
    'id': string;
}

export const AdGroupUpdateRequestBidStrategyTypeEnum = {
    AutomaticBid: 'AUTOMATIC_BID',
    MaxBid: 'MAX_BID',
    TargetAvg: 'TARGET_AVG'
} as const;

export type AdGroupUpdateRequestBidStrategyTypeEnum = typeof AdGroupUpdateRequestBidStrategyTypeEnum[keyof typeof AdGroupUpdateRequestBidStrategyTypeEnum];

/**
 * 
 * @export
 * @interface AdGroupsAnalyticsResponseInner
 */
export interface AdGroupsAnalyticsResponseInner {
    [key: string]: any;

    /**
     * The ID of the ad group that this metrics belongs to.
     * @type {string}
     * @memberof AdGroupsAnalyticsResponseInner
     */
    'AD_GROUP_ID': string;
    /**
     * Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
     * @type {string}
     * @memberof AdGroupsAnalyticsResponseInner
     */
    'DATE'?: string;
}
/**
 * 
 * @export
 * @interface AdGroupsList200Response
 */
export interface AdGroupsList200Response {
    /**
     * 
     * @type {Array<AdGroupResponse>}
     * @memberof AdGroupsList200Response
     */
    'items': Array<AdGroupResponse>;
    /**
     * 
     * @type {string}
     * @memberof AdGroupsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface AdPinId
 */
export interface AdPinId {
    /**
     * Pin ID.
     * @type {string}
     * @memberof AdPinId
     */
    'pin_id'?: string;
}
/**
 * 
 * @export
 * @interface AdPreviewCreateFromImage
 */
export interface AdPreviewCreateFromImage {
    /**
     * Image URL.
     * @type {string}
     * @memberof AdPreviewCreateFromImage
     */
    'image_url': string;
    /**
     * Title displayed below ad.
     * @type {string}
     * @memberof AdPreviewCreateFromImage
     */
    'title': string;
}
/**
 * 
 * @export
 * @interface AdPreviewCreateFromPin
 */
export interface AdPreviewCreateFromPin {
    /**
     * Pin ID.
     * @type {string}
     * @memberof AdPreviewCreateFromPin
     */
    'pin_id': string;
}
/**
 * @type AdPreviewRequest
 * @export
 */
export type AdPreviewRequest = AdPreviewCreateFromImage | AdPreviewCreateFromPin;

/**
 * 
 * @export
 * @interface AdPreviewURLResponse
 */
export interface AdPreviewURLResponse {
    /**
     * \'Preview URL, expires in 7 days. Can be used in an iframe. For example: https://ads.pinterest.com/ad-preview/74667c814dd2b19/ The preview object ID/key is the last param - 74667c814dd2b19\'
     * @type {string}
     * @memberof AdPreviewURLResponse
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface AdResponse
 */
export interface AdResponse {
    /**
     * ID of the ad group that contains the ad.
     * @type {string}
     * @memberof AdResponse
     */
    'ad_group_id'?: string;
    /**
     * Deep link URL for Android devices.
     * @type {string}
     * @memberof AdResponse
     */
    'android_deep_link'?: string | null;
    /**
     * Comma-separated deep links for the carousel pin on Android.
     * @type {Array<string>}
     * @memberof AdResponse
     */
    'carousel_android_deep_links'?: Array<string> | null;
    /**
     * Comma-separated destination URLs for the carousel pin to promote.
     * @type {Array<string>}
     * @memberof AdResponse
     */
    'carousel_destination_urls'?: Array<string> | null;
    /**
     * Comma-separated deep links for the carousel pin on iOS.
     * @type {Array<string>}
     * @memberof AdResponse
     */
    'carousel_ios_deep_links'?: Array<string> | null;
    /**
     * Tracking url for the ad clicks.
     * @type {string}
     * @memberof AdResponse
     */
    'click_tracking_url'?: string | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof AdResponse
     */
    'creative_type'?: CreativeType;
    /**
     * Destination URL.
     * @type {string}
     * @memberof AdResponse
     */
    'destination_url'?: string | null;
    /**
     * Deep link URL for iOS devices.
     * @type {string}
     * @memberof AdResponse
     */
    'ios_deep_link'?: string | null;
    /**
     * Is original pin deleted?
     * @type {boolean}
     * @memberof AdResponse
     */
    'is_pin_deleted'?: boolean;
    /**
     * Is pin repinnable?
     * @type {boolean}
     * @memberof AdResponse
     */
    'is_removable'?: boolean;
    /**
     * Name of the ad - 255 chars max.
     * @type {string}
     * @memberof AdResponse
     */
    'name'?: string | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof AdResponse
     */
    'status'?: EntityStatus;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof AdResponse
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Tracking URL for ad impressions.
     * @type {string}
     * @memberof AdResponse
     */
    'view_tracking_url'?: string | null;
    /**
     * Lead form ID for lead ad generation.
     * @type {string}
     * @memberof AdResponse
     */
    'lead_form_id'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof AdResponse
     */
    'grid_click_type'?: GridClickType | null;
    /**
     * Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_SITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
     * @type {string}
     * @memberof AdResponse
     */
    'customizable_cta_type'?: AdResponseCustomizableCtaTypeEnum | null;
    /**
     * Before creating a quiz ad, you must create an organic Pin using POST/Create Pin for each result in the quiz. Quiz ads cannot be saved by a Pinner. Quiz ad results can be saved.
     * @type {QuizPinData}
     * @memberof AdResponse
     */
    'quiz_pin_data'?: QuizPinData | null;
    /**
     * Pin ID.
     * @type {string}
     * @memberof AdResponse
     */
    'pin_id'?: string;
    /**
     * The ID of the advertiser that this ad belongs to.
     * @type {string}
     * @memberof AdResponse
     */
    'ad_account_id'?: string;
    /**
     * ID of the ad campaign that contains this ad.
     * @type {string}
     * @memberof AdResponse
     */
    'campaign_id'?: string;
    /**
     * Destination URL template for all items within a collections drawer.
     * @type {string}
     * @memberof AdResponse
     */
    'collection_items_destination_url_template'?: string | null;
    /**
     * Pin creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdResponse
     */
    'created_time'?: number;
    /**
     * The ID of this ad.
     * @type {string}
     * @memberof AdResponse
     */
    'id'?: string;
    /**
     * Enum reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
     * @type {Array<string>}
     * @memberof AdResponse
     */
    'rejected_reasons'?: Array<AdResponseRejectedReasonsEnum>;
    /**
     * Text reason why the pin was rejected. Returned if <code>review_status</code> is \"REJECTED\".
     * @type {Array<string>}
     * @memberof AdResponse
     */
    'rejection_labels'?: Array<string>;
    /**
     * Ad review status
     * @type {string}
     * @memberof AdResponse
     */
    'review_status'?: AdResponseReviewStatusEnum;
    /**
     * Always \"ad\".
     * @type {string}
     * @memberof AdResponse
     */
    'type'?: string;
    /**
     * Last update time. Unix timestamp in seconds.
     * @type {number}
     * @memberof AdResponse
     */
    'updated_time'?: number;
    /**
     * Ad summary status
     * @type {PinPromotionSummaryStatus}
     * @memberof AdResponse
     */
    'summary_status'?: PinPromotionSummaryStatus;
}

export const AdResponseCustomizableCtaTypeEnum = {
    GetOffer: 'GET_OFFER',
    LearnMore: 'LEARN_MORE',
    OrderNow: 'ORDER_NOW',
    ShopNow: 'SHOP_NOW',
    SignUp: 'SIGN_UP',
    Subscribe: 'SUBSCRIBE',
    BuyNow: 'BUY_NOW',
    ContactUs: 'CONTACT_US',
    GetQuote: 'GET_QUOTE',
    VisitSite: 'VISIT_SITE',
    ApplyNow: 'APPLY_NOW',
    BookNow: 'BOOK_NOW',
    RequestDemo: 'REQUEST_DEMO',
    RegisterNow: 'REGISTER_NOW',
    FindADealer: 'FIND_A_DEALER',
    AddToCart: 'ADD_TO_CART',
    WatchNow: 'WATCH_NOW',
    ReadMore: 'READ_MORE'
} as const;

export type AdResponseCustomizableCtaTypeEnum = typeof AdResponseCustomizableCtaTypeEnum[keyof typeof AdResponseCustomizableCtaTypeEnum];
export const AdResponseRejectedReasonsEnum = {
    Hashtags: 'HASHTAGS',
    PromotionsAndPrices: 'PROMOTIONS_AND_PRICES',
    Targeting: 'TARGETING',
    LandingPage: 'LANDING_PAGE',
    CapsAndSymbols: 'CAPS_AND_SYMBOLS',
    Shocking: 'SHOCKING',
    WeightLoss: 'WEIGHT_LOSS',
    ProhibitedProduct: 'PROHIBITED_PRODUCT',
    Authenticity: 'AUTHENTICITY',
    Nudity: 'NUDITY',
    ConfusingDesign: 'CONFUSING_DESIGN',
    Urgency: 'URGENCY',
    Ratings: 'RATINGS',
    App: 'APP',
    Alcohol: 'ALCOHOL',
    Contests: 'CONTESTS',
    Political: 'POLITICAL',
    Other: 'OTHER',
    Image: 'IMAGE',
    Nar: 'NAR',
    Inconsistent: 'INCONSISTENT',
    Clickbait: 'CLICKBAIT',
    NoDescription: 'NO_DESCRIPTION',
    LowQuality: 'LOW_QUALITY',
    ExaggeratedClaims: 'EXAGGERATED_CLAIMS',
    PinterestBrand: 'PINTEREST_BRAND',
    AlcoholNoSale: 'ALCOHOL_NO_SALE',
    LandingPageSpeed: 'LANDING_PAGE_SPEED',
    LandingPageHardwall: 'LANDING_PAGE_HARDWALL',
    LandingPageBroken: 'LANDING_PAGE_BROKEN',
    LandingPageQuality: 'LANDING_PAGE_QUALITY',
    OutOfStock: 'OUT_OF_STOCK',
    ImageLowQuality: 'IMAGE_LOW_QUALITY',
    ImageBusy: 'IMAGE_BUSY',
    ImagePoorlyEdited: 'IMAGE_POORLY_EDITED',
    ImageBeforeAfter: 'IMAGE_BEFORE_AFTER',
    Ugc: 'UGC',
    FakeButtons: 'FAKE_BUTTONS',
    Weapons: 'WEAPONS',
    Sensitive: 'SENSITIVE',
    UnacceptableBusiness: 'UNACCEPTABLE_BUSINESS',
    SuspiciousClaims: 'SUSPICIOUS_CLAIMS',
    Pharma: 'PHARMA',
    SuspiciousSupplements: 'SUSPICIOUS_SUPPLEMENTS',
    IllegalRecreationalDrug: 'ILLEGAL_RECREATIONAL_DRUG',
    LowQualityLandingPage: 'LOW_QUALITY_LANDING_PAGE',
    RestrictedHealthcare: 'RESTRICTED_HEALTHCARE',
    InconsistentLangFr: 'INCONSISTENT_LANG_FR'
} as const;

export type AdResponseRejectedReasonsEnum = typeof AdResponseRejectedReasonsEnum[keyof typeof AdResponseRejectedReasonsEnum];
export const AdResponseReviewStatusEnum = {
    Other: 'OTHER',
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    Approved: 'APPROVED'
} as const;

export type AdResponseReviewStatusEnum = typeof AdResponseReviewStatusEnum[keyof typeof AdResponseReviewStatusEnum];

/**
 * 
 * @export
 * @interface AdUpdateRequest
 */
export interface AdUpdateRequest {
    /**
     * ID of the ad group that contains the ad.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'ad_group_id'?: string;
    /**
     * Deep link URL for Android devices.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'android_deep_link'?: string | null;
    /**
     * Comma-separated deep links for the carousel pin on Android.
     * @type {Array<string>}
     * @memberof AdUpdateRequest
     */
    'carousel_android_deep_links'?: Array<string> | null;
    /**
     * Comma-separated destination URLs for the carousel pin to promote.
     * @type {Array<string>}
     * @memberof AdUpdateRequest
     */
    'carousel_destination_urls'?: Array<string> | null;
    /**
     * Comma-separated deep links for the carousel pin on iOS.
     * @type {Array<string>}
     * @memberof AdUpdateRequest
     */
    'carousel_ios_deep_links'?: Array<string> | null;
    /**
     * Tracking url for the ad clicks.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'click_tracking_url'?: string | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof AdUpdateRequest
     */
    'creative_type'?: CreativeType;
    /**
     * Destination URL.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'destination_url'?: string | null;
    /**
     * Deep link URL for iOS devices.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'ios_deep_link'?: string | null;
    /**
     * Is original pin deleted?
     * @type {boolean}
     * @memberof AdUpdateRequest
     */
    'is_pin_deleted'?: boolean;
    /**
     * Is pin repinnable?
     * @type {boolean}
     * @memberof AdUpdateRequest
     */
    'is_removable'?: boolean;
    /**
     * Name of the ad - 255 chars max.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'name'?: string | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof AdUpdateRequest
     */
    'status'?: EntityStatus;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof AdUpdateRequest
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Tracking URL for ad impressions.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'view_tracking_url'?: string | null;
    /**
     * Lead form ID for lead ad generation.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'lead_form_id'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof AdUpdateRequest
     */
    'grid_click_type'?: GridClickType | null;
    /**
     * Select a call to action (CTA) to display below your ad. Available only for ads with direct links enabled. CTA options for consideration and conversion campaigns are LEARN_MORE, SHOP_NOW, BOOK_NOW, SIGN_UP, VISIT_SITE, BUY_NOW, GET_OFFER, ORDER_NOW, ADD_TO_CART (for conversion campaigns with add to cart conversion events only)
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'customizable_cta_type'?: AdUpdateRequestCustomizableCtaTypeEnum | null;
    /**
     * Before creating a quiz ad, you must create an organic Pin using POST/Create Pin for each result in the quiz. Quiz ads cannot be saved by a Pinner. Quiz ad results can be saved.
     * @type {QuizPinData}
     * @memberof AdUpdateRequest
     */
    'quiz_pin_data'?: QuizPinData | null;
    /**
     * The ID of this ad.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'id': string;
    /**
     * Pin ID. This field may only be updated for draft ads.
     * @type {string}
     * @memberof AdUpdateRequest
     */
    'pin_id'?: string | null;
}

export const AdUpdateRequestCustomizableCtaTypeEnum = {
    GetOffer: 'GET_OFFER',
    LearnMore: 'LEARN_MORE',
    OrderNow: 'ORDER_NOW',
    ShopNow: 'SHOP_NOW',
    SignUp: 'SIGN_UP',
    Subscribe: 'SUBSCRIBE',
    BuyNow: 'BUY_NOW',
    ContactUs: 'CONTACT_US',
    GetQuote: 'GET_QUOTE',
    VisitSite: 'VISIT_SITE',
    ApplyNow: 'APPLY_NOW',
    BookNow: 'BOOK_NOW',
    RequestDemo: 'REQUEST_DEMO',
    RegisterNow: 'REGISTER_NOW',
    FindADealer: 'FIND_A_DEALER',
    AddToCart: 'ADD_TO_CART',
    WatchNow: 'WATCH_NOW',
    ReadMore: 'READ_MORE'
} as const;

export type AdUpdateRequestCustomizableCtaTypeEnum = typeof AdUpdateRequestCustomizableCtaTypeEnum[keyof typeof AdUpdateRequestCustomizableCtaTypeEnum];

/**
 * Reporting targeting type for ads
 * @export
 * @enum {string}
 */

export const AdsAnalyticsAdTargetingType = {
    Keyword: 'KEYWORD',
    Apptype: 'APPTYPE',
    Gender: 'GENDER',
    Location: 'LOCATION',
    Placement: 'PLACEMENT',
    Country: 'COUNTRY',
    TargetedInterest: 'TARGETED_INTEREST',
    PinnerInterest: 'PINNER_INTEREST',
    AudienceInclude: 'AUDIENCE_INCLUDE',
    Geo: 'GEO',
    AgeBucket: 'AGE_BUCKET',
    Region: 'REGION',
    QuizResult: 'QUIZ_RESULT',
    AgeBucketAndGender: 'AGE_BUCKET_AND_GENDER'
} as const;

export type AdsAnalyticsAdTargetingType = typeof AdsAnalyticsAdTargetingType[keyof typeof AdsAnalyticsAdTargetingType];


/**
 * Reporting targeting type for campaigns
 * @export
 * @enum {string}
 */

export const AdsAnalyticsCampaignTargetingType = {
    Keyword: 'KEYWORD',
    Apptype: 'APPTYPE',
    Gender: 'GENDER',
    Location: 'LOCATION',
    Placement: 'PLACEMENT',
    Country: 'COUNTRY',
    TargetedInterest: 'TARGETED_INTEREST',
    PinnerInterest: 'PINNER_INTEREST',
    AudienceInclude: 'AUDIENCE_INCLUDE',
    Geo: 'GEO',
    AgeBucket: 'AGE_BUCKET',
    Region: 'REGION',
    CreativeType: 'CREATIVE_TYPE',
    AgeBucketAndGender: 'AGE_BUCKET_AND_GENDER'
} as const;

export type AdsAnalyticsCampaignTargetingType = typeof AdsAnalyticsCampaignTargetingType[keyof typeof AdsAnalyticsCampaignTargetingType];


/**
 * 
 * @export
 * @interface AdsAnalyticsCreateAsyncRequest
 */
export interface AdsAnalyticsCreateAsyncRequest {
    /**
     * Metric report start date (UTC). Format: YYYY-MM-DD
     * @type {string}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'start_date': string;
    /**
     * Metric report end date (UTC). Format: YYYY-MM-DD
     * @type {string}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'end_date': string;
    /**
     * TOTAL - metrics are aggregated over the specified date range.<br> DAY - metrics are broken down daily.<br> HOUR - metrics are broken down hourly.<br>WEEKLY - metrics are broken down weekly.<br>MONTHLY - metrics are broken down monthly
     * @type {Granularity}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'granularity': Granularity;
    /**
     * Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
     * @type {ConversionAttributionWindowDays}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'click_window_days'?: ConversionAttributionWindowDays;
    /**
     * Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `30` days.
     * @type {ConversionAttributionWindowDays}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'engagement_window_days'?: ConversionAttributionWindowDays;
    /**
     * Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to `1` day.
     * @type {ConversionAttributionWindowDays}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'view_window_days'?: ConversionAttributionWindowDays;
    /**
     * The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @type {ConversionReportTimeType}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'conversion_report_time'?: ConversionReportTimeType;
    /**
     * List of types of attribution for the conversion report
     * @type {Array<ConversionReportAttributionType>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'attribution_types'?: Array<ConversionReportAttributionType>;
    /**
     * List of campaign ids
     * @type {Array<string>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'campaign_ids'?: Array<string>;
    /**
     * List of status values for filtering
     * @type {Array<CampaignSummaryStatus>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'campaign_statuses'?: Array<CampaignSummaryStatus>;
    /**
     * List of values for filtering. [\"WEB_SESSIONS\"] in BETA.
     * @type {Array<ObjectiveType>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'campaign_objective_types'?: Array<ObjectiveType>;
    /**
     * List of ad group ids
     * @type {Array<string>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'ad_group_ids'?: Array<string>;
    /**
     * List of values for filtering
     * @type {Array<AdGroupSummaryStatus>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'ad_group_statuses'?: Array<AdGroupSummaryStatus>;
    /**
     * List of ad ids [This parameter is no supported for Product Item Level Reports]
     * @type {Array<string>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'ad_ids'?: Array<string>;
    /**
     * List of values for filtering [This parameter is not supported for Product Item Level Reports]
     * @type {Array<PinPromotionSummaryStatus>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'ad_statuses'?: Array<PinPromotionSummaryStatus>;
    /**
     * List of product group ids
     * @type {Array<string>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'product_group_ids'?: Array<string>;
    /**
     * List of values for filtering
     * @type {Array<ProductGroupSummaryStatus>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'product_group_statuses'?: Array<ProductGroupSummaryStatus>;
    /**
     * List of product item ids
     * @type {Array<string>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'product_item_ids'?: Array<string>;
    /**
     * List of targeting types. Requires `level` to be a value ending in `_TARGETING`. [\"AGE_BUCKET_AND_GENDER\"] is in BETA and not yet available to all users.
     * @type {Array<AdsAnalyticsTargetingType>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'targeting_types'?: Array<AdsAnalyticsTargetingType>;
    /**
     * List of metrics filters
     * @type {Array<AdsAnalyticsMetricsFilter>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'metrics_filters'?: Array<AdsAnalyticsMetricsFilter>;
    /**
     * Metric and entity columns. Pin promotion and ad related columns are not supported for the Product Item level reports.
     * @type {Array<ReportingColumnAsync>}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'columns': Array<ReportingColumnAsync>;
    /**
     * Level of the report
     * @type {MetricsReportingLevel}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'level': MetricsReportingLevel;
    /**
     * Specification for formatting the report data. Reports in JSON will not zero-fill metrics, whereas reports in CSV will. Both report formats will omit rows where all the columns are equal to 0.
     * @type {DataOutputFormat}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'report_format'?: DataOutputFormat;
    /**
     * Whether to first sort the report by date or by entity ID of the reporting entity level. Date will be used as the first level key for JSON reports that use BY_DATE. BY_DATE is recommended for large requests.
     * @type {string}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'primary_sort'?: AdsAnalyticsCreateAsyncRequestPrimarySortEnum;
    /**
     * Which hour of the start date to begin the report. The entire day will be included if no start hour is provided. Only allowed for hourly reports.
     * @type {number}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'start_hour'?: number;
    /**
     * Which hour of the end date to stop the report (inclusive). For example, with an end_date of \'2020-01-01\' and end_hour of \'15\', the report will contain metrics up to \'2020-01-01 14:59:59\'. The entire day will be included if no end hour is provided. Only allowed for hourly reports.
     * @type {number}
     * @memberof AdsAnalyticsCreateAsyncRequest
     */
    'end_hour'?: number;
}

export const AdsAnalyticsCreateAsyncRequestPrimarySortEnum = {
    Id: 'BY_ID',
    Date: 'BY_DATE'
} as const;

export type AdsAnalyticsCreateAsyncRequestPrimarySortEnum = typeof AdsAnalyticsCreateAsyncRequestPrimarySortEnum[keyof typeof AdsAnalyticsCreateAsyncRequestPrimarySortEnum];

/**
 * 
 * @export
 * @interface AdsAnalyticsCreateAsyncResponse
 */
export interface AdsAnalyticsCreateAsyncResponse {
    /**
     * 
     * @type {BulkReportingJobStatus}
     * @memberof AdsAnalyticsCreateAsyncResponse
     */
    'report_status'?: BulkReportingJobStatus;
    /**
     * 
     * @type {string}
     * @memberof AdsAnalyticsCreateAsyncResponse
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AdsAnalyticsCreateAsyncResponse
     */
    'message'?: string | null;
}


/**
 * Reporting columns for sync reporting data filter
 * @export
 * @enum {string}
 */

export const AdsAnalyticsFilterColumn = {
    SpendInDollar: 'SPEND_IN_DOLLAR',
    TotalImpression: 'TOTAL_IMPRESSION'
} as const;

export type AdsAnalyticsFilterColumn = typeof AdsAnalyticsFilterColumn[keyof typeof AdsAnalyticsFilterColumn];


/**
 * Filter operator for sync reporting
 * @export
 * @enum {string}
 */

export const AdsAnalyticsFilterOperator = {
    LessThan: 'LESS_THAN',
    GreaterThan: 'GREATER_THAN'
} as const;

export type AdsAnalyticsFilterOperator = typeof AdsAnalyticsFilterOperator[keyof typeof AdsAnalyticsFilterOperator];


/**
 * 
 * @export
 * @interface AdsAnalyticsGetAsyncResponse
 */
export interface AdsAnalyticsGetAsyncResponse {
    /**
     * 
     * @type {BulkReportingJobStatus}
     * @memberof AdsAnalyticsGetAsyncResponse
     */
    'report_status'?: BulkReportingJobStatus;
    /**
     * 
     * @type {string}
     * @memberof AdsAnalyticsGetAsyncResponse
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof AdsAnalyticsGetAsyncResponse
     */
    'size'?: number | null;
}


/**
 * 
 * @export
 * @interface AdsAnalyticsMetricsFilter
 */
export interface AdsAnalyticsMetricsFilter {
    /**
     * 
     * @type {AdsAnalyticsFilterColumn}
     * @memberof AdsAnalyticsMetricsFilter
     */
    'field': AdsAnalyticsFilterColumn;
    /**
     * 
     * @type {AdsAnalyticsFilterOperator}
     * @memberof AdsAnalyticsMetricsFilter
     */
    'operator': AdsAnalyticsFilterOperator;
    /**
     * List of values for filtering
     * @type {Array<number>}
     * @memberof AdsAnalyticsMetricsFilter
     */
    'values': Array<number>;
}


/**
 * 
 * @export
 * @interface AdsAnalyticsResponseInner
 */
export interface AdsAnalyticsResponseInner {
    [key: string]: any;

    /**
     * The ID of the ad that this metrics belongs to.
     * @type {string}
     * @memberof AdsAnalyticsResponseInner
     */
    'AD_ID': string;
    /**
     * Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
     * @type {string}
     * @memberof AdsAnalyticsResponseInner
     */
    'DATE'?: string;
}
/**
 * Reporting targeting type
 * @export
 * @enum {string}
 */

export const AdsAnalyticsTargetingType = {
    Keyword: 'KEYWORD',
    Apptype: 'APPTYPE',
    Gender: 'GENDER',
    Location: 'LOCATION',
    Placement: 'PLACEMENT',
    Country: 'COUNTRY',
    TargetedInterest: 'TARGETED_INTEREST',
    PinnerInterest: 'PINNER_INTEREST',
    AudienceInclude: 'AUDIENCE_INCLUDE',
    Geo: 'GEO',
    AgeBucket: 'AGE_BUCKET',
    Region: 'REGION',
    AgeBucketAndGender: 'AGE_BUCKET_AND_GENDER'
} as const;

export type AdsAnalyticsTargetingType = typeof AdsAnalyticsTargetingType[keyof typeof AdsAnalyticsTargetingType];


/**
 * 
 * @export
 * @interface AdsCreditDiscountsResponse
 */
export interface AdsCreditDiscountsResponse {
    /**
     * True if the offer code is currently active.
     * @type {boolean}
     * @memberof AdsCreditDiscountsResponse
     */
    'active'?: boolean;
    /**
     * Advertiser ID the offer was applied to.
     * @type {string}
     * @memberof AdsCreditDiscountsResponse
     */
    'advertiser_id'?: string;
    /**
     * The type of discount of this credit
     * @type {string}
     * @memberof AdsCreditDiscountsResponse
     */
    'discountType'?: AdsCreditDiscountsResponseDiscountTypeEnum | null;
    /**
     * The discount applied in the offers currency value.
     * @type {number}
     * @memberof AdsCreditDiscountsResponse
     */
    'discountInMicroCurrency'?: number | null;
    /**
     * Currency value for the discount.
     * @type {string}
     * @memberof AdsCreditDiscountsResponse
     */
    'discountCurrency'?: string | null;
    /**
     * Human readable title of the offer code.
     * @type {string}
     * @memberof AdsCreditDiscountsResponse
     */
    'title'?: string | null;
    /**
     * The credits left to spend.
     * @type {number}
     * @memberof AdsCreditDiscountsResponse
     */
    'remainingDiscountInMicroCurrency'?: number | null;
}

export const AdsCreditDiscountsResponseDiscountTypeEnum = {
    Coupon: 'COUPON',
    Credit: 'CREDIT',
    CouponApplied: 'COUPON_APPLIED',
    CreditApplied: 'CREDIT_APPLIED',
    MarketingOfferCredit: 'MARKETING_OFFER_CREDIT',
    MarketingOfferCreditApplied: 'MARKETING_OFFER_CREDIT_APPLIED',
    GoodwillCredit: 'GOODWILL_CREDIT',
    GoodwillCreditApplied: 'GOODWILL_CREDIT_APPLIED',
    InternalCredit: 'INTERNAL_CREDIT',
    InternalCreditApplied: 'INTERNAL_CREDIT_APPLIED',
    PrepaidCredit: 'PREPAID_CREDIT',
    PrepaidCreditApplied: 'PREPAID_CREDIT_APPLIED',
    SalesIncentiveCredit: 'SALES_INCENTIVE_CREDIT',
    SalesIncentiveCreditApplied: 'SALES_INCENTIVE_CREDIT_APPLIED',
    CreditExpired: 'CREDIT_EXPIRED',
    FutureCredit: 'FUTURE_CREDIT',
    ReferralCredit: 'REFERRAL_CREDIT',
    InvoiceSalesIncentiveCredit: 'INVOICE_SALES_INCENTIVE_CREDIT',
    InvoiceSalesIncentiveCreditApplied: 'INVOICE_SALES_INCENTIVE_CREDIT_APPLIED',
    PrepaidCreditRefund: 'PREPAID_CREDIT_REFUND'
} as const;

export type AdsCreditDiscountsResponseDiscountTypeEnum = typeof AdsCreditDiscountsResponseDiscountTypeEnum[keyof typeof AdsCreditDiscountsResponseDiscountTypeEnum];

/**
 * 
 * @export
 * @interface AdsCreditRedeemRequest
 */
export interface AdsCreditRedeemRequest {
    /**
     * Takes in a SHA256 hash of the offerCode.
     * @type {string}
     * @memberof AdsCreditRedeemRequest
     */
    'offerCodeHash': string;
    /**
     * If true, only validate if we can redeem offer code. Otherwise it will actually apply the offer code to the account
     * @type {boolean}
     * @memberof AdsCreditRedeemRequest
     */
    'validateOnly': boolean;
}
/**
 * 
 * @export
 * @interface AdsCreditRedeemResponse
 */
export interface AdsCreditRedeemResponse {
    /**
     * Returns true if the offer code was successfully applied(validateOnly=false) or can be applied(validateOnly=true).
     * @type {boolean}
     * @memberof AdsCreditRedeemResponse
     */
    'success'?: boolean;
    /**
     * Error code type if error occurs
     * @type {number}
     * @memberof AdsCreditRedeemResponse
     */
    'errorCode'?: number | null;
    /**
     * Reason for failure
     * @type {string}
     * @memberof AdsCreditRedeemResponse
     */
    'errorMessage'?: string | null;
}
/**
 * 
 * @export
 * @interface AdsCreditsDiscountsGet200Response
 */
export interface AdsCreditsDiscountsGet200Response {
    /**
     * 
     * @type {Array<AdsCreditDiscountsResponse>}
     * @memberof AdsCreditsDiscountsGet200Response
     */
    'items': Array<AdsCreditDiscountsResponse>;
    /**
     * 
     * @type {string}
     * @memberof AdsCreditsDiscountsGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface AdsList200Response
 */
export interface AdsList200Response {
    /**
     * 
     * @type {Array<AdResponse>}
     * @memberof AdsList200Response
     */
    'items': Array<AdResponse>;
    /**
     * 
     * @type {string}
     * @memberof AdsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Object describing a retail catalog item\'s bid options (bid price and bid multipliers).
 * @export
 * @interface AdvancedAuctionBidOptions
 */
export interface AdvancedAuctionBidOptions {
    /**
     * Bid price in micro currency. A value of 0 will stop distribution for this item in `MAX_BID` ad groups in `CATALOG_SALES` campaigns. A value of `null` will fallback to the ad group\'s `bid_in_micro_currency`.
     * @type {number}
     * @memberof AdvancedAuctionBidOptions
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * 
     * @type {AppTypeMultipliers}
     * @memberof AdvancedAuctionBidOptions
     */
    'app_type_multipliers'?: AppTypeMultipliers | null;
    /**
     * 
     * @type {PlacementMultipliers}
     * @memberof AdvancedAuctionBidOptions
     */
    'placement_multipliers'?: PlacementMultipliers | null;
}
/**
 * 
 * @export
 * @interface AdvancedAuctionItem
 */
export interface AdvancedAuctionItem {
    /**
     * The catalog retail item id in the merchant namespace
     * @type {string}
     * @memberof AdvancedAuctionItem
     */
    'item_id': string;
    /**
     * 
     * @type {Country}
     * @memberof AdvancedAuctionItem
     */
    'country': Country;
    /**
     * 
     * @type {Language}
     * @memberof AdvancedAuctionItem
     */
    'language': Language;
    /**
     * 
     * @type {AdvancedAuctionBidOptions}
     * @memberof AdvancedAuctionItem
     */
    'bid_options': AdvancedAuctionBidOptions;
}


/**
 * Response object containing item bid options
 * @export
 * @interface AdvancedAuctionItems
 */
export interface AdvancedAuctionItems {
    /**
     * Response object of item bid options
     * @type {string}
     * @memberof AdvancedAuctionItems
     */
    'catalog_id'?: string;
    /**
     * Array with item bid options
     * @type {Array<AdvancedAuctionItem>}
     * @memberof AdvancedAuctionItems
     */
    'items'?: Array<AdvancedAuctionItem>;
}
/**
 * Object uniquely identifying a retail catalog item
 * @export
 * @interface AdvancedAuctionItemsGetRecord
 */
export interface AdvancedAuctionItemsGetRecord {
    /**
     * The catalog retail item id in the merchant namespace
     * @type {string}
     * @memberof AdvancedAuctionItemsGetRecord
     */
    'item_id': string;
    /**
     * 
     * @type {Country}
     * @memberof AdvancedAuctionItemsGetRecord
     */
    'country': Country;
    /**
     * 
     * @type {Language}
     * @memberof AdvancedAuctionItemsGetRecord
     */
    'language': Language;
}


/**
 * Request object used to get bid options values for a batch of retail catalog items
 * @export
 * @interface AdvancedAuctionItemsGetRequest
 */
export interface AdvancedAuctionItemsGetRequest {
    /**
     * Catalog id pertaining to the retail item
     * @type {string}
     * @memberof AdvancedAuctionItemsGetRequest
     */
    'catalog_id': string;
    /**
     * A list of retail catalog items to fetch bid options for
     * @type {Array<AdvancedAuctionItemsGetRecord>}
     * @memberof AdvancedAuctionItemsGetRequest
     */
    'items': Array<AdvancedAuctionItemsGetRecord>;
}
/**
 * Object describing an item bid option deletion operation
 * @export
 * @interface AdvancedAuctionItemsSubmitDeleteRecord
 */
export interface AdvancedAuctionItemsSubmitDeleteRecord {
    /**
     * The catalog retail item id in the merchant namespace
     * @type {string}
     * @memberof AdvancedAuctionItemsSubmitDeleteRecord
     */
    'item_id': string;
    /**
     * 
     * @type {Country}
     * @memberof AdvancedAuctionItemsSubmitDeleteRecord
     */
    'country': Country;
    /**
     * 
     * @type {Language}
     * @memberof AdvancedAuctionItemsSubmitDeleteRecord
     */
    'language': Language;
}


/**
 * @type AdvancedAuctionItemsSubmitRecord
 * Object describing an item bid option operation
 * @export
 */
export type AdvancedAuctionItemsSubmitRecord = { operation: 'DELETE' } & AdvancedAuctionItemsSubmitDeleteRecord | { operation: 'UPSERT' } & AdvancedAuctionItemsSubmitUpsertRecord;

/**
 * Request containing operations to perform on bid prices and bid multipliers for a batch of retail catalog items
 * @export
 * @interface AdvancedAuctionItemsSubmitRequest
 */
export interface AdvancedAuctionItemsSubmitRequest {
    /**
     * Catalog id pertaining to all items
     * @type {string}
     * @memberof AdvancedAuctionItemsSubmitRequest
     */
    'catalog_id': string;
    /**
     * Array of item bid option operations
     * @type {Array<AdvancedAuctionItemsSubmitRecord>}
     * @memberof AdvancedAuctionItemsSubmitRequest
     */
    'items': Array<AdvancedAuctionItemsSubmitRecord>;
}
/**
 * Object describing an item bid option upsert operation
 * @export
 * @interface AdvancedAuctionItemsSubmitUpsertRecord
 */
export interface AdvancedAuctionItemsSubmitUpsertRecord {
    /**
     * The catalog retail item id in the merchant namespace
     * @type {string}
     * @memberof AdvancedAuctionItemsSubmitUpsertRecord
     */
    'item_id': string;
    /**
     * 
     * @type {Country}
     * @memberof AdvancedAuctionItemsSubmitUpsertRecord
     */
    'country': Country;
    /**
     * 
     * @type {Language}
     * @memberof AdvancedAuctionItemsSubmitUpsertRecord
     */
    'language': Language;
    /**
     * 
     * @type {AdvancedAuctionBidOptions}
     * @memberof AdvancedAuctionItemsSubmitUpsertRecord
     */
    'bid_options': AdvancedAuctionBidOptions;
    /**
     * The list of item bid option fields to be set or updated. Fields specified in the updated mask without a value specified in the `bid_options` object in the body will be set to `null`. If an item bid option record is being created, fields not specified in the update mask will be initialized to `null`.
     * @type {Array<UpdateMaskBidOptionField>}
     * @memberof AdvancedAuctionItemsSubmitUpsertRecord
     */
    'update_mask': Array<UpdateMaskBidOptionField> | null;
}


/**
 * Object uniquely identifying a retail catalog item
 * @export
 * @interface AdvancedAuctionKey
 */
export interface AdvancedAuctionKey {
    /**
     * The catalog retail item id in the merchant namespace
     * @type {string}
     * @memberof AdvancedAuctionKey
     */
    'item_id': string;
    /**
     * 
     * @type {Country}
     * @memberof AdvancedAuctionKey
     */
    'country': Country;
    /**
     * 
     * @type {Language}
     * @memberof AdvancedAuctionKey
     */
    'language': Language;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const AdvancedAuctionOperation = {
    Upsert: 'UPSERT',
    Delete: 'DELETE'
} as const;

export type AdvancedAuctionOperation = typeof AdvancedAuctionOperation[keyof typeof AdvancedAuctionOperation];


/**
 * Error which occurred when applying a bid options operation to a specific item.
 * @export
 * @interface AdvancedAuctionOperationError
 */
export interface AdvancedAuctionOperationError {
    /**
     * The error code for the item bid option operation validation error
     * @type {number}
     * @memberof AdvancedAuctionOperationError
     */
    'code'?: number;
    /**
     * Message describing the item bid option operation validation error
     * @type {string}
     * @memberof AdvancedAuctionOperationError
     */
    'message'?: string;
}
/**
 * Object describing the result of an operation on an item bid option
 * @export
 * @interface AdvancedAuctionProcessedItem
 */
export interface AdvancedAuctionProcessedItem extends AdvancedAuctionItemsSubmitRecord {
    /**
     * Array with validation errors for the supplied item bid option modification operation. A non empty errors list means this single item operation was not applied.
     * @type {Array<AdvancedAuctionOperationError>}
     * @memberof AdvancedAuctionProcessedItem
     */
    'errors'?: Array<AdvancedAuctionOperationError>;
}


/**
 * Response object containing the results of an operation on an item bid option
 * @export
 * @interface AdvancedAuctionProcessedItems
 */
export interface AdvancedAuctionProcessedItems {
    /**
     * Catalog id pertaining to all items
     * @type {string}
     * @memberof AdvancedAuctionProcessedItems
     */
    'catalog_id'?: string;
    /**
     * Array of advanced auction processed items
     * @type {Array<AdvancedAuctionProcessedItem>}
     * @memberof AdvancedAuctionProcessedItems
     */
    'items'?: Array<AdvancedAuctionProcessedItem>;
}
/**
 * 
 * @export
 * @interface AnalyticsDailyMetrics
 */
export interface AnalyticsDailyMetrics {
    /**
     * 
     * @type {DataStatus}
     * @memberof AnalyticsDailyMetrics
     */
    'data_status'?: DataStatus;
    /**
     * Metrics date (UTC): YYYY-MM-DD.
     * @type {string}
     * @memberof AnalyticsDailyMetrics
     */
    'date'?: string;
    /**
     * The metric name and daily value for each requested metric
     * @type {{ [key: string]: number; }}
     * @memberof AnalyticsDailyMetrics
     */
    'metrics'?: { [key: string]: number; };
}


/**
 * 
 * @export
 * @interface AnalyticsMetricsResponse
 */
export interface AnalyticsMetricsResponse {
    /**
     * The metric name and value over the requested period for each requested metric
     * @type {{ [key: string]: number; }}
     * @memberof AnalyticsMetricsResponse
     */
    'summary_metrics'?: { [key: string]: number; };
    /**
     * Array with the requested daily metric records
     * @type {Array<AnalyticsDailyMetrics>}
     * @memberof AnalyticsMetricsResponse
     */
    'daily_metrics'?: Array<AnalyticsDailyMetrics>;
}
/**
 * This represents a mapping from app type targeting criteria to a bid price adjustment.  Multiplier values must be between 0 and 10. A value of 10 represents a 900% increase in bid price (from $1 to $10 for example). A value of 0 will stop distribution for this item on the specified app type in `MAX_BID` ad groups in `CATALOG_SALES` campaigns. All app type multipliers must be set at the same time. If a multiplier is not provided it is assumed to be 1 (no bid adjustment).
 * @export
 * @interface AppTypeMultipliers
 */
export interface AppTypeMultipliers {
    [key: string]: number | any;

    /**
     * 
     * @type {TargetingSpecAppType}
     * @memberof AppTypeMultipliers
     */
    'APP_TYPE'?: TargetingSpecAppType;
}


/**
 * 
 * @export
 * @interface AssetGroupBinding
 */
export interface AssetGroupBinding {
    /**
     * Asset Group ID.
     * @type {string}
     * @memberof AssetGroupBinding
     */
    'id'?: string;
    /**
     * Asset Group name
     * @type {string}
     * @memberof AssetGroupBinding
     */
    'asset_group_name'?: string | null;
    /**
     * Asset group description
     * @type {string}
     * @memberof AssetGroupBinding
     */
    'asset_group_description'?: string | null;
    /**
     * Asset group types
     * @type {Array<string>}
     * @memberof AssetGroupBinding
     */
    'asset_group_types'?: Array<string>;
    /**
     * A list of ad account IDs under the asset group
     * @type {Array<string>}
     * @memberof AssetGroupBinding
     */
    'ad_accounts_ids'?: Array<string> | null;
    /**
     * A list of profile IDs under asset group
     * @type {Array<string>}
     * @memberof AssetGroupBinding
     */
    'profiles_ids'?: Array<string> | null;
    /**
     * The creation time of the asset group
     * @type {number}
     * @memberof AssetGroupBinding
     */
    'created_time'?: number | null;
    /**
     * The last update time of the asset group
     * @type {number}
     * @memberof AssetGroupBinding
     */
    'updated_time'?: number | null;
    /**
     * The data of the business that owns the asset group.
     * @type {BusinessAccessUserSummary}
     * @memberof AssetGroupBinding
     */
    'owner'?: BusinessAccessUserSummary | null;
    /**
     * The data of the user that created the asset group.
     * @type {BusinessAccessUserSummary}
     * @memberof AssetGroupBinding
     */
    'created_by'?: BusinessAccessUserSummary | null;
}
/**
 * Asset group type
 * @export
 * @enum {string}
 */

export const AssetGroupType = {
    Brand: 'BRAND',
    LocationOrLanguage: 'LOCATION_OR_LANGUAGE',
    ProductLine: 'PRODUCT_LINE',
    Other: 'OTHER'
} as const;

export type AssetGroupType = typeof AssetGroupType[keyof typeof AssetGroupType];


/**
 * An object containing the permissions a business member has on the asset.
 * @export
 * @interface AssetIdPermissions
 */
export interface AssetIdPermissions {
    /**
     * Unique identifier of a business asset.
     * @type {string}
     * @memberof AssetIdPermissions
     */
    'asset_id'?: string;
    /**
     * Type of asset. Currently we only support AD_ACCOUNT and PROFILE, and ASSET_GROUP.
     * @type {string}
     * @memberof AssetIdPermissions
     */
    'asset_type'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof AssetIdPermissions
     */
    'permissions'?: Array<string>;
    /**
     * 
     * @type {AssetGroupBinding}
     * @memberof AssetIdPermissions
     */
    'asset_group_info'?: AssetGroupBinding;
}
/**
 * 
 * @export
 * @interface Audience
 */
export interface Audience {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof Audience
     */
    'ad_account_id'?: string;
    /**
     * Audience ID.
     * @type {string}
     * @memberof Audience
     */
    'id'?: string;
    /**
     * Audience name.
     * @type {string}
     * @memberof Audience
     */
    'name'?: string;
    /**
     * <a href=\"/docs/reference/glossary/#Audience Types\">Audience types</a>: ACTALIKE, ENGAGEMENT, CUSTOMER_LIST and VISITOR
     * @type {string}
     * @memberof Audience
     */
    'audience_type'?: string;
    /**
     * Audience description.
     * @type {string}
     * @memberof Audience
     */
    'description'?: string | null;
    /**
     * 
     * @type {AudienceRule}
     * @memberof Audience
     */
    'rule'?: AudienceRule;
    /**
     * Audience size.
     * @type {number}
     * @memberof Audience
     */
    'size'?: number | null;
    /**
     * Audience status. READY, INITIALIZING, TOO_SMALL - Each audience list needs to have at least 100 people with Pinterest accounts before you can start using it.
     * @type {string}
     * @memberof Audience
     */
    'status'?: string;
    /**
     * Always \"audience\".
     * @type {string}
     * @memberof Audience
     */
    'type'?: string;
    /**
     * Creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof Audience
     */
    'created_timestamp'?: number | null;
    /**
     * Last update time. Unix timestamp in seconds.
     * @type {number}
     * @memberof Audience
     */
    'updated_timestamp'?: number | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AudienceAccountType = {
    AdAccount: 'AD_ACCOUNT',
    BusinessAccount: 'BUSINESS_ACCOUNT'
} as const;

export type AudienceAccountType = typeof AudienceAccountType[keyof typeof AudienceAccountType];


/**
 * 
 * @export
 * @interface AudienceCategory
 */
export interface AudienceCategory {
    /**
     * Interest unique key (same as ID).
     * @type {string}
     * @memberof AudienceCategory
     */
    'key'?: string;
    /**
     * Interest name.
     * @type {string}
     * @memberof AudienceCategory
     */
    'name'?: string;
    /**
     * Interest\'s percent of category\'s total audience.
     * @type {number}
     * @memberof AudienceCategory
     */
    'ratio'?: number;
    /**
     * Interest affinity index.
     * @type {number}
     * @memberof AudienceCategory
     */
    'index'?: number;
    /**
     * Interest ID.
     * @type {string}
     * @memberof AudienceCategory
     */
    'id'?: string;
    /**
     * Subcategory interest distribution
     * @type {Array<AudienceSubcategory>}
     * @memberof AudienceCategory
     */
    'subcategories'?: Array<AudienceSubcategory>;
}
/**
 * 
 * @export
 * @interface AudienceCommon
 */
export interface AudienceCommon {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof AudienceCommon
     */
    'ad_account_id'?: string;
    /**
     * Audience name.
     * @type {string}
     * @memberof AudienceCommon
     */
    'name'?: string;
    /**
     * 
     * @type {AudienceRule}
     * @memberof AudienceCommon
     */
    'rule'?: AudienceRule;
}
/**
 * 
 * @export
 * @interface AudienceCreateCustomRequest
 */
export interface AudienceCreateCustomRequest {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof AudienceCreateCustomRequest
     */
    'ad_account_id'?: string;
    /**
     * Audience name.
     * @type {string}
     * @memberof AudienceCreateCustomRequest
     */
    'name': string;
    /**
     * 
     * @type {AudienceRule}
     * @memberof AudienceCreateCustomRequest
     */
    'rule': AudienceRule;
    /**
     * 
     * @type {AudienceSharingType}
     * @memberof AudienceCreateCustomRequest
     */
    'sharing_type': AudienceSharingType;
    /**
     * 
     * @type {AudienceDataParty}
     * @memberof AudienceCreateCustomRequest
     */
    'data_party': AudienceDataParty;
    /**
     * 
     * @type {string}
     * @memberof AudienceCreateCustomRequest
     */
    'category'?: string;
}


/**
 * 
 * @export
 * @interface AudienceCreateRequest
 */
export interface AudienceCreateRequest {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof AudienceCreateRequest
     */
    'ad_account_id'?: string;
    /**
     * Audience name.
     * @type {string}
     * @memberof AudienceCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {AudienceRule}
     * @memberof AudienceCreateRequest
     */
    'rule': AudienceRule;
    /**
     * Audience description.
     * @type {string}
     * @memberof AudienceCreateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {AudienceCreateRequest1AudienceType}
     * @memberof AudienceCreateRequest
     */
    'audience_type': AudienceCreateRequest1AudienceType;
}
/**
 * 
 * @export
 * @interface AudienceCreateRequest1AudienceType
 */
export interface AudienceCreateRequest1AudienceType {
}
/**
 * Whether the data is owned by the partner (1p) or by the data provider (3p)
 * @export
 * @enum {string}
 */

export const AudienceDataParty = {
    _1p: '1p',
    _3p: '3p'
} as const;

export type AudienceDataParty = typeof AudienceDataParty[keyof typeof AudienceDataParty];


/**
 * Queryable audience representation.
 * @export
 * @interface AudienceDefinition
 */
export interface AudienceDefinition {
    /**
     * Generation date
     * @type {string}
     * @memberof AudienceDefinition
     */
    'date'?: string | null;
    /**
     * Generated audience type to request.
     * @type {string}
     * @memberof AudienceDefinition
     */
    'type'?: string;
    /**
     * Generated audience scope to request.
     * @type {string}
     * @memberof AudienceDefinition
     */
    'scope'?: string;
}
/**
 * 
 * @export
 * @interface AudienceDefinitionResponse
 */
export interface AudienceDefinitionResponse {
    /**
     * 
     * @type {Array<AudienceDefinition>}
     * @memberof AudienceDefinitionResponse
     */
    'items'?: Array<AudienceDefinition>;
}
/**
 * Demographic detail for a single audience demographic
 * @export
 * @interface AudienceDemographicValue
 */
export interface AudienceDemographicValue {
    /**
     * Unique key for demographic item
     * @type {string}
     * @memberof AudienceDemographicValue
     */
    'key'?: string;
    /**
     * Display name for demographic
     * @type {string}
     * @memberof AudienceDemographicValue
     */
    'name'?: string;
    /**
     * Value of demographic item as a percent of total audience
     * @type {number}
     * @memberof AudienceDemographicValue
     */
    'ratio'?: number;
}
/**
 * Audience demographics
 * @export
 * @interface AudienceDemographics
 */
export interface AudienceDemographics {
    /**
     * Ages distribution.
     * @type {Array<AudienceDemographicValue>}
     * @memberof AudienceDemographics
     */
    'ages'?: Array<AudienceDemographicValue>;
    /**
     * Gender distribution.
     * @type {Array<AudienceDemographicValue>}
     * @memberof AudienceDemographics
     */
    'genders'?: Array<AudienceDemographicValue>;
    /**
     * Device usage distribution.
     * @type {Array<AudienceDemographicValue>}
     * @memberof AudienceDemographics
     */
    'devices'?: Array<AudienceDemographicValue>;
    /**
     * Geographic metro area distribution.
     * @type {Array<AudienceDemographicValue>}
     * @memberof AudienceDemographics
     */
    'metros'?: Array<AudienceDemographicValue>;
    /**
     * Country area distribution.
     * @type {Array<AudienceDemographicValue>}
     * @memberof AudienceDemographics
     */
    'countries'?: Array<AudienceDemographicValue>;
}
/**
 * 
 * @export
 * @interface AudienceInsightCategoryArrayResponse
 */
export interface AudienceInsightCategoryArrayResponse {
    /**
     * 
     * @type {Array<AudienceInsightCategoryCommon>}
     * @memberof AudienceInsightCategoryArrayResponse
     */
    'items'?: Array<AudienceInsightCategoryCommon>;
}
/**
 * 
 * @export
 * @interface AudienceInsightCategoryCommon
 */
export interface AudienceInsightCategoryCommon {
    /**
     * 
     * @type {string}
     * @memberof AudienceInsightCategoryCommon
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof AudienceInsightCategoryCommon
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AudienceInsightCategoryCommon
     */
    'ratio'?: number;
    /**
     * 
     * @type {number}
     * @memberof AudienceInsightCategoryCommon
     */
    'index'?: number;
    /**
     * 
     * @type {string}
     * @memberof AudienceInsightCategoryCommon
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AudienceInsightType = {
    YourTotalAudience: 'YOUR_TOTAL_AUDIENCE',
    YourEngagedAudience: 'YOUR_ENGAGED_AUDIENCE',
    PinterestTotalAudience: 'PINTEREST_TOTAL_AUDIENCE'
} as const;

export type AudienceInsightType = typeof AudienceInsightType[keyof typeof AudienceInsightType];


/**
 * Audience interests and demographics.
 * @export
 * @interface AudienceInsightsResponse
 */
export interface AudienceInsightsResponse {
    /**
     * Category interest distribution
     * @type {Array<AudienceCategory>}
     * @memberof AudienceInsightsResponse
     */
    'categories'?: Array<AudienceCategory>;
    /**
     * 
     * @type {AudienceDemographics}
     * @memberof AudienceInsightsResponse
     */
    'demographics'?: AudienceDemographics;
    /**
     * 
     * @type {AudienceInsightType}
     * @memberof AudienceInsightsResponse
     */
    'type'?: AudienceInsightType;
    /**
     * Generation date
     * @type {string}
     * @memberof AudienceInsightsResponse
     */
    'date'?: string | null;
    /**
     * Population count.
     * @type {number}
     * @memberof AudienceInsightsResponse
     */
    'size'?: number;
    /**
     * Indicates whether the audience size has been rounded up to the next highest upper boundary.
     * @type {boolean}
     * @memberof AudienceInsightsResponse
     */
    'size_is_upper_bound'?: boolean;
}


/**
 * JSON object defining targeted audience users. Example rule formats per audience type:<br>CUSTOMER_LIST: { \"customer_list_id\": \"&lt;customer list ID&gt;\"}<br>ACTALIKE: { \"seed_id\": [\"&lt;audience ID&gt;\"], \"country\": \"US\", \"percentage\": \"10\" }<br>(Valid countries include: \"US\", \"CA\", and \"GB\". Percentage should be 1-10.<br>The targeted audience should be this % size across Pinterest.)<br>VISITOR: { \"visitor_source_id\": [\"&lt;conversion tag ID&gt;\"], \"retention_days\": \"180\", \"event_source\": {\"=\": [\"web\", \"mobile\"]}, \"ingestion_source\": {\"=\": [\"tag\"]}}<br>(Retention days should be 1-540. Retention applies to specific customers.)<br>ENGAGEMENT: {\"engagement_domain\": [\"www.entomi.com\"], \"engager_type\": 1}<br>For more details on engagement audiences, see <a href=\"/docs/redoc/adtech_ads_v4/#section/November-2021\" target=\"_blank\">November 2021 changelog</a>.
 * @export
 * @interface AudienceRule
 */
export interface AudienceRule {
    /**
     * Valid countries include: \"US\", \"CA\", and \"GB\".
     * @type {string}
     * @memberof AudienceRule
     */
    'country'?: string;
    /**
     * Customer list ID. For CUSTOMER_LIST `audience_type`.
     * @type {string}
     * @memberof AudienceRule
     */
    'customer_list_id'?: string;
    /**
     * The audience account\'s verified domain. **Required** for ENGAGEMENT `audience_type`.
     * @type {Array<string>}
     * @memberof AudienceRule
     */
    'engagement_domain'?: Array<string>;
    /**
     * Engagement type enum. Optional for ENGAGEMENT `audience_type`. Supported values are `click`, `save`, `closeup`, `comment` and `like`. All engagements are included if this field is not set. 
     * @type {string}
     * @memberof AudienceRule
     */
    'engagement_type'?: string;
    /**
     * A Pinterest tag event. Optional for VISITOR `audience_type`. Possible values are `pagevisit`, `signup`, `checkout`, `viewcategory`, `search`, `addtocart`, `watchvideo`, `lead`, and `custom`. This field also accepts a partner-defined Pinterest tag event.
     * @type {string}
     * @memberof AudienceRule
     */
    'event'?: string;
    /**
     * 
     * @type {PinterestTagEventData}
     * @memberof AudienceRule
     */
    'event_data'?: PinterestTagEventData;
    /**
     * Percentage should be 1-10. The targeted audience should be this % size across Pinterest.
     * @type {number}
     * @memberof AudienceRule
     */
    'percentage'?: number;
    /**
     * IDs of engaged organic pins. Optional for ENGAGEMENT `audience_type`. For example, \"pin_id:\": [\"34567\"]
     * @type {Array<string>}
     * @memberof AudienceRule
     */
    'pin_id'?: Array<string>;
    /**
     * Optional for VISITOR `audience_type`. If `true`, the specified rule on existing engagement data is applied to pre-populate the audience. If `false`, the audience is empty at creation time. The default is `true`.
     * @type {boolean}
     * @memberof AudienceRule
     */
    'prefill'?: boolean;
    /**
     * Number of days a Pinterest user remains in the audience. Optional for ENGAGEMENT and VISITOR `audience_type`. Accepted range is 1-540. Defaults to 180 if not specified.
     * @type {number}
     * @memberof AudienceRule
     */
    'retention_days'?: number;
    /**
     * Audience ID(s). For ACTALIKE `audience_type`. 
     * @type {Array<string>}
     * @memberof AudienceRule
     */
    'seed_id'?: Array<string>;
    /**
     * Optional for ENGAGEMENT or VISITOR `audience_type`. For ENGAGEMENT, it is the engaged pin\'s URL. For VISITOR, you can use it as a string or a {operator: value} object for filtering visitors based on conversion tag event URLs. Supported operators are [ =, !=, contains, not_contains].<br>Example 1:  \"url\": \"http://www.myonlinestore123.com/view_item/shoe\"<br>Example 2: \"url\": {\"contains\": \"/view_item/shoe\"}
     * @type {Array<string>}
     * @memberof AudienceRule
     */
    'url'?: Array<string>;
    /**
     * The conversion tag ID, or the Pinterest tag ID, that you use on your website. For VISITOR `audience_type`.
     * @type {string}
     * @memberof AudienceRule
     */
    'visitor_source_id'?: string;
    /**
     * Optional for VISITOR. You can use it as a {\'=\': [value]}. Supported values are: web, mobile, offline
     * @type {object}
     * @memberof AudienceRule
     */
    'event_source'?: object;
    /**
     * Optional for VISITOR. You can use it as a {\'=\': [value]}. Supported values are: tag, mmp, file_upload, conversions_api
     * @type {object}
     * @memberof AudienceRule
     */
    'ingestion_source'?: object;
    /**
     * Optional for ENGAGEMENT. Engager type value should be 1-2.
     * @type {number}
     * @memberof AudienceRule
     */
    'engager_type'?: number;
    /**
     * Campaign ID for engagement audience filter.
     * @type {Array<string>}
     * @memberof AudienceRule
     */
    'campaign_id'?: Array<string>;
    /**
     * Ad ID for engagement audience filter.
     * @type {Array<string>}
     * @memberof AudienceRule
     */
    'ad_id'?: Array<string>;
    /**
     * Objective for engagement audience filter.
     * @type {Array<ObjectiveType>}
     * @memberof AudienceRule
     */
    'objective_type'?: Array<ObjectiveType>;
    /**
     * Ad account ID.
     * @type {string}
     * @memberof AudienceRule
     */
    'ad_account_id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AudienceShareType = {
    Shared: 'SHARED',
    Received: 'RECEIVED'
} as const;

export type AudienceShareType = typeof AudienceShareType[keyof typeof AudienceShareType];


/**
 * Audience sharing type: [\"CUSTOM\", \"SYNDICATED\"]
 * @export
 * @enum {string}
 */

export const AudienceSharingType = {
    Custom: 'CUSTOM',
    Syndicated: 'SYNDICATED'
} as const;

export type AudienceSharingType = typeof AudienceSharingType[keyof typeof AudienceSharingType];


/**
 * 
 * @export
 * @interface AudienceSubcategory
 */
export interface AudienceSubcategory {
    /**
     * Interest unique key (same as ID).
     * @type {string}
     * @memberof AudienceSubcategory
     */
    'key'?: string;
    /**
     * Subinterest name.
     * @type {string}
     * @memberof AudienceSubcategory
     */
    'name'?: string;
    /**
     * Subinterest\'s percent of category\'s total audience.
     * @type {number}
     * @memberof AudienceSubcategory
     */
    'ratio'?: number;
    /**
     * Subinterest affinity index.
     * @type {number}
     * @memberof AudienceSubcategory
     */
    'index'?: number;
    /**
     * Subinterest ID.
     * @type {string}
     * @memberof AudienceSubcategory
     */
    'id'?: string;
}
/**
 * Audience type
 * @export
 * @enum {string}
 */

export const AudienceType = {
    CustomerList: 'CUSTOMER_LIST',
    Visitor: 'VISITOR',
    Engagement: 'ENGAGEMENT',
    Actalike: 'ACTALIKE',
    Persona: 'PERSONA'
} as const;

export type AudienceType = typeof AudienceType[keyof typeof AudienceType];


/**
 * Audience operation type (update or remove).
 * @export
 * @enum {string}
 */

export const AudienceUpdateOperationType = {
    Update: 'UPDATE',
    Remove: 'REMOVE'
} as const;

export type AudienceUpdateOperationType = typeof AudienceUpdateOperationType[keyof typeof AudienceUpdateOperationType];


/**
 * 
 * @export
 * @interface AudienceUpdateRequest
 */
export interface AudienceUpdateRequest {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof AudienceUpdateRequest
     */
    'ad_account_id'?: string;
    /**
     * Audience name.
     * @type {string}
     * @memberof AudienceUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {AudienceRule}
     * @memberof AudienceUpdateRequest
     */
    'rule'?: AudienceRule;
    /**
     * Audience description.
     * @type {string}
     * @memberof AudienceUpdateRequest
     */
    'description'?: string;
    /**
     * 
     * @type {AudienceUpdateOperationType}
     * @memberof AudienceUpdateRequest
     */
    'operation_type'?: AudienceUpdateOperationType;
}


/**
 * 
 * @export
 * @interface AudiencesList200Response
 */
export interface AudiencesList200Response {
    /**
     * 
     * @type {Array<Audience>}
     * @memberof AudiencesList200Response
     */
    'items': Array<Audience>;
    /**
     * 
     * @type {string}
     * @memberof AudiencesList200Response
     */
    'bookmark'?: string | null;
}
/**
 * An object with a list of all the invites the user would like to respond to and the action to take.
 * @export
 * @interface AuthRespondInvitesBody
 */
export interface AuthRespondInvitesBody {
    /**
     * 
     * @type {Array<AuthRespondInvitesBodyInvitesInner>}
     * @memberof AuthRespondInvitesBody
     */
    'invites': Array<AuthRespondInvitesBodyInvitesInner>;
}
/**
 * 
 * @export
 * @interface AuthRespondInvitesBodyInvitesInner
 */
export interface AuthRespondInvitesBodyInvitesInner {
    /**
     * 
     * @type {AuthRespondInvitesBodyInvitesInnerAction}
     * @memberof AuthRespondInvitesBodyInvitesInner
     */
    'action': AuthRespondInvitesBodyInvitesInnerAction;
    /**
     * Unique identifier of an invite.
     * @type {string}
     * @memberof AuthRespondInvitesBodyInvitesInner
     */
    'invite_id': string;
}
/**
 * 
 * @export
 * @interface AuthRespondInvitesBodyInvitesInnerAction
 */
export interface AuthRespondInvitesBodyInvitesInnerAction {
    /**
     * Whether the invite/request is accepted.
     * @type {boolean}
     * @memberof AuthRespondInvitesBodyInvitesInnerAction
     */
    'accept_invite': boolean;
    /**
     * An object mapping asset ids to lists of business permissions. This can be used to setting/requesting permissions on various assets. If accepting an invite or request, this object would be used to grant asset permissions to the member or partner. 
     * @type {{ [key: string]: Array<Permissions>; }}
     * @memberof AuthRespondInvitesBodyInvitesInnerAction
     */
    'asset_id_to_permissions'?: { [key: string]: Array<Permissions>; };
}
/**
 * 
 * @export
 * @interface AvailabilityFilter
 */
export interface AvailabilityFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof AvailabilityFilter
     */
    'AVAILABILITY': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface BaseInviteDataResponse
 */
export interface BaseInviteDataResponse {
    /**
     * Unique identifier of the invite/request.
     * @type {string}
     * @memberof BaseInviteDataResponse
     */
    'id'?: string;
    /**
     * 
     * @type {BaseInviteDataResponseInviteData}
     * @memberof BaseInviteDataResponse
     */
    'invite_data'?: BaseInviteDataResponseInviteData;
    /**
     * Indicates whether the invite/request was received.
     * @type {boolean}
     * @memberof BaseInviteDataResponse
     */
    'is_received_invite'?: boolean;
    /**
     * Metadata for the member/partner that was sent the invite/request.
     * @type {BusinessAccessUserSummary}
     * @memberof BaseInviteDataResponse
     */
    'user'?: BusinessAccessUserSummary;
}
/**
 * Metadata for the invite/request.
 * @export
 * @interface BaseInviteDataResponseInviteData
 */
export interface BaseInviteDataResponseInviteData {
    /**
     * The date and time when the invite/request will expire. Returned in milliseconds.
     * @type {number}
     * @memberof BaseInviteDataResponseInviteData
     */
    'invite_expiration'?: number;
    /**
     * The current status of the invite. The invite can be in one of the following states PENDING, ACCEPTED, DECLINED, CANCELLED, EXPIRED.
     * @type {string}
     * @memberof BaseInviteDataResponseInviteData
     */
    'invite_status'?: string;
    /**
     * The type of invite. <br>\'MEMBER_INVITE\' is to invite a member to access your business assets. <br>\'PARTNER_INVITE\' is to invite a partner to access your business assets. <br>\'PARTNER_REQUEST\' is to request access a partner\'s business assets.
     * @type {string}
     * @memberof BaseInviteDataResponseInviteData
     */
    'invite_type'?: string;
    /**
     * The date and time the invite/request was last updated. Returned in milliseconds.
     * @type {number}
     * @memberof BaseInviteDataResponseInviteData
     */
    'last_updated_time'?: number;
    /**
     * The date and time the invite/request was sent/created. Returned in milliseconds.
     * @type {number}
     * @memberof BaseInviteDataResponseInviteData
     */
    'sent_at'?: number;
}
/**
 * The operation performed by the batch. The DELETE_DISCONTINUED operation only updates availablity to \"Out of Stock\".
 * @export
 * @enum {string}
 */

export const BatchOperation = {
    Update: 'UPDATE',
    Upsert: 'UPSERT',
    Create: 'CREATE',
    DeleteDiscontinued: 'DELETE_DISCONTINUED',
    Delete: 'DELETE'
} as const;

export type BatchOperation = typeof BatchOperation[keyof typeof BatchOperation];


/**
 * The status of the operation performed by the batch
 * @export
 * @enum {string}
 */

export const BatchOperationStatus = {
    Processing: 'PROCESSING',
    Completed: 'COMPLETED',
    Failed: 'FAILED'
} as const;

export type BatchOperationStatus = typeof BatchOperationStatus[keyof typeof BatchOperationStatus];


/**
 * 
 * @export
 * @interface BidFloor
 */
export interface BidFloor {
    /**
     * A list of bid floors in micro currency. For example, [100000, 200000]
     * @type {Array<number>}
     * @memberof BidFloor
     */
    'bid_floors'?: Array<number>;
    /**
     * Always the string \'bidfloor\'
     * @type {string}
     * @memberof BidFloor
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface BidFloorRequest
 */
export interface BidFloorRequest {
    /**
     * 
     * @type {Array<BidFloorSpec>}
     * @memberof BidFloorRequest
     */
    'bid_floor_specs': Array<BidFloorSpec>;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof BidFloorRequest
     */
    'targeting_spec'?: TargetingSpec;
}
/**
 * 
 * @export
 * @interface BidFloorSpec
 */
export interface BidFloorSpec {
    /**
     * 
     * @type {Array<Country>}
     * @memberof BidFloorSpec
     */
    'countries'?: Array<Country>;
    /**
     * 
     * @type {Currency}
     * @memberof BidFloorSpec
     */
    'currency': Currency;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof BidFloorSpec
     */
    'objective_type'?: ObjectiveType;
    /**
     * 
     * @type {ActionType}
     * @memberof BidFloorSpec
     */
    'billable_event': ActionType;
    /**
     * 
     * @type {OptimizationGoalMetadata}
     * @memberof BidFloorSpec
     */
    'optimization_goal_metadata'?: OptimizationGoalMetadata;
    /**
     * 
     * @type {CreativeType}
     * @memberof BidFloorSpec
     */
    'creative_type'?: CreativeType;
}


/**
 * 
 * @export
 * @interface BillingProfilesGet200Response
 */
export interface BillingProfilesGet200Response {
    /**
     * 
     * @type {Array<BillingProfilesResponse>}
     * @memberof BillingProfilesGet200Response
     */
    'items': Array<BillingProfilesResponse>;
    /**
     * 
     * @type {string}
     * @memberof BillingProfilesGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface BillingProfilesResponse
 */
export interface BillingProfilesResponse {
    /**
     * Billing ID.
     * @type {string}
     * @memberof BillingProfilesResponse
     */
    'id'?: string;
    /**
     * Type of the card.
     * @type {string}
     * @memberof BillingProfilesResponse
     */
    'card_type'?: BillingProfilesResponseCardTypeEnum;
    /**
     * Status of the billing.
     * @type {string}
     * @memberof BillingProfilesResponse
     */
    'status'?: BillingProfilesResponseStatusEnum;
    /**
     * Advertiser ID of the billing.
     * @type {string}
     * @memberof BillingProfilesResponse
     */
    'advertiser_id'?: string;
    /**
     * Brand of the payment method.
     * @type {string}
     * @memberof BillingProfilesResponse
     */
    'payment_method_brand'?: BillingProfilesResponsePaymentMethodBrandEnum;
}

export const BillingProfilesResponseCardTypeEnum = {
    Unknown: 'UNKNOWN',
    Visa: 'VISA',
    Mastercard: 'MASTERCARD',
    AmericanExpress: 'AMERICAN_EXPRESS',
    Discover: 'DISCOVER',
    Elo: 'ELO'
} as const;

export type BillingProfilesResponseCardTypeEnum = typeof BillingProfilesResponseCardTypeEnum[keyof typeof BillingProfilesResponseCardTypeEnum];
export const BillingProfilesResponseStatusEnum = {
    Unspecified: 'UNSPECIFIED',
    Valid: 'VALID',
    Invalid: 'INVALID',
    Pending: 'PENDING',
    Deleted: 'DELETED',
    Secondary: 'SECONDARY',
    PendingSecondary: 'PENDING_SECONDARY'
} as const;

export type BillingProfilesResponseStatusEnum = typeof BillingProfilesResponseStatusEnum[keyof typeof BillingProfilesResponseStatusEnum];
export const BillingProfilesResponsePaymentMethodBrandEnum = {
    Unknown: 'UNKNOWN',
    Visa: 'VISA',
    Mastercard: 'MASTERCARD',
    AmericanExpress: 'AMERICAN_EXPRESS',
    Discover: 'DISCOVER',
    Sofort: 'SOFORT',
    DinersClub: 'DINERS_CLUB',
    Elo: 'ELO',
    CarteBancaire: 'CARTE_BANCAIRE'
} as const;

export type BillingProfilesResponsePaymentMethodBrandEnum = typeof BillingProfilesResponsePaymentMethodBrandEnum[keyof typeof BillingProfilesResponsePaymentMethodBrandEnum];

/**
 * Board
 * @export
 * @interface Board
 */
export interface Board {
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    'id'?: string;
    /**
     * Date and time of board creation.
     * @type {string}
     * @memberof Board
     */
    'created_at'?: string;
    /**
     * Date and time of last board pins modified.
     * @type {string}
     * @memberof Board
     */
    'board_pins_modified_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Board
     */
    'description'?: string | null;
    /**
     * Count of collaborators on the board.
     * @type {number}
     * @memberof Board
     */
    'collaborator_count'?: number;
    /**
     * Count of pins on the board.
     * @type {number}
     * @memberof Board
     */
    'pin_count'?: number;
    /**
     * Board follower count.
     * @type {number}
     * @memberof Board
     */
    'follower_count'?: number;
    /**
     * 
     * @type {BoardMedia}
     * @memberof Board
     */
    'media'?: BoardMedia;
    /**
     * 
     * @type {BoardOwner}
     * @memberof Board
     */
    'owner'?: BoardOwner;
    /**
     * Privacy setting for a board. Learn more about <a href=\"https://help.pinterest.com/en/article/secret-boards\">secret boards</a> and <a href=\"https://help.pinterest.com/en/business/article/protected-boards\">protected boards</a>
     * @type {string}
     * @memberof Board
     */
    'privacy'?: BoardPrivacyEnum;
}

export const BoardPrivacyEnum = {
    Public: 'PUBLIC',
    Protected: 'PROTECTED',
    Secret: 'SECRET'
} as const;

export type BoardPrivacyEnum = typeof BoardPrivacyEnum[keyof typeof BoardPrivacyEnum];

/**
 * Board media.
 * @export
 * @interface BoardMedia
 */
export interface BoardMedia {
    /**
     * Board cover image.
     * @type {string}
     * @memberof BoardMedia
     */
    'image_cover_url'?: string | null;
    /**
     * Board pin thumbnail urls.
     * @type {Array<string>}
     * @memberof BoardMedia
     */
    'pin_thumbnail_urls'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BoardOwner
 */
export interface BoardOwner {
    /**
     * 
     * @type {string}
     * @memberof BoardOwner
     */
    'username'?: string;
}
/**
 * Sections help organize pins within a board.
 * @export
 * @interface BoardSection
 */
export interface BoardSection {
    /**
     * 
     * @type {string}
     * @memberof BoardSection
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardSection
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface BoardSectionsList200Response
 */
export interface BoardSectionsList200Response {
    /**
     * Board sections
     * @type {Array<BoardSection>}
     * @memberof BoardSectionsList200Response
     */
    'items': Array<BoardSection>;
    /**
     * 
     * @type {string}
     * @memberof BoardSectionsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Board fields for updates
 * @export
 * @interface BoardUpdate
 */
export interface BoardUpdate {
    /**
     * 
     * @type {string}
     * @memberof BoardUpdate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof BoardUpdate
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof BoardUpdate
     */
    'privacy'?: BoardUpdatePrivacyEnum;
}

export const BoardUpdatePrivacyEnum = {
    Public: 'PUBLIC',
    Secret: 'SECRET'
} as const;

export type BoardUpdatePrivacyEnum = typeof BoardUpdatePrivacyEnum[keyof typeof BoardUpdatePrivacyEnum];

/**
 * 
 * @export
 * @interface BoardsList200Response
 */
export interface BoardsList200Response {
    /**
     * Boards
     * @type {Array<Board>}
     * @memberof BoardsList200Response
     */
    'items': Array<Board>;
    /**
     * 
     * @type {string}
     * @memberof BoardsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface BoardsListPins200Response
 */
export interface BoardsListPins200Response {
    /**
     * Pins
     * @type {Array<Pin>}
     * @memberof BoardsListPins200Response
     */
    'items': Array<Pin>;
    /**
     * 
     * @type {string}
     * @memberof BoardsListPins200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface BoardsUserFollowsList200Response
 */
export interface BoardsUserFollowsList200Response {
    /**
     * 
     * @type {Array<Board>}
     * @memberof BoardsUserFollowsList200Response
     */
    'items': Array<Board>;
    /**
     * 
     * @type {string}
     * @memberof BoardsUserFollowsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Creation fields
 * @export
 * @interface BookClosedResponse
 */
export interface BookClosedResponse {
    /**
     * Are conversion metrics ready?
     * @type {boolean}
     * @memberof BookClosedResponse
     */
    'conversion_metrics_ready'?: boolean;
    /**
     * Are non-conversion metrics ready?
     * @type {boolean}
     * @memberof BookClosedResponse
     */
    'non_conversion_metrics_ready'?: boolean;
}
/**
 * 
 * @export
 * @interface BrandFilter
 */
export interface BrandFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof BrandFilter
     */
    'BRAND': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Budget type. If DAILY, an ad group\'s daily spend will not exceed the budget parameter value. If LIFETIME, the end_time parameter is **REQUIRED**, and the ad group spend is spread evenly between the ad group `start_time` and `end_time` range. A CBO campaign automatically generates ad group budgets from its campaign budget to maximize campaign outcome. For CBO campaigns, only \"CBO_ADGROUP\" is allowed. For WEB_SESSIONS campaigns, only \"LIFETIME\" is allowed. For update, only draft ad groups may update budget type.
 * @export
 * @enum {string}
 */

export const BudgetType = {
    Daily: 'DAILY',
    Lifetime: 'LIFETIME',
    CboAdgroup: 'CBO_ADGROUP'
} as const;

export type BudgetType = typeof BudgetType[keyof typeof BudgetType];


/**
 * Ad entities to get in bulk request.
 * @export
 * @interface BulkDownloadRequest
 */
export interface BulkDownloadRequest {
    /**
     * All entity types specified will be downloaded. Fewer types result in faster downloads.
     * @type {Array<BulkEntityType>}
     * @memberof BulkDownloadRequest
     */
    'entity_types'?: Array<BulkEntityType>;
    /**
     * All entities specified by these IDs as well as their children and grandchildren will be downloaded if the entity type is one of the types requested to be downloaded.
     * @type {Array<string>}
     * @memberof BulkDownloadRequest
     */
    'entity_ids'?: Array<string>;
    /**
     * Unix UTC timestamp to retrieve all entities that have changed since this time.
     * @type {string}
     * @memberof BulkDownloadRequest
     */
    'updated_since'?: string;
    /**
     * 
     * @type {BulkDownloadRequestCampaignFilter}
     * @memberof BulkDownloadRequest
     */
    'campaign_filter'?: BulkDownloadRequestCampaignFilter;
    /**
     * 
     * @type {BulkOutputFormat}
     * @memberof BulkDownloadRequest
     */
    'output_format'?: BulkOutputFormat;
}


/**
 * 
 * @export
 * @interface BulkDownloadRequestCampaignFilter
 */
export interface BulkDownloadRequestCampaignFilter {
    /**
     * Unix UTC timestamp.
     * @type {string}
     * @memberof BulkDownloadRequestCampaignFilter
     */
    'start_time'?: string;
    /**
     * Unix UTC timestamp.
     * @type {string}
     * @memberof BulkDownloadRequestCampaignFilter
     */
    'end_time'?: string;
    /**
     * Campaign name
     * @type {string}
     * @memberof BulkDownloadRequestCampaignFilter
     */
    'name'?: string;
    /**
     * 
     * @type {Array<CampaignSummaryStatus>}
     * @memberof BulkDownloadRequestCampaignFilter
     */
    'campaign_status'?: Array<CampaignSummaryStatus>;
    /**
     * 
     * @type {Array<ObjectiveType>}
     * @memberof BulkDownloadRequestCampaignFilter
     */
    'objective_type'?: Array<ObjectiveType>;
}
/**
 * 
 * @export
 * @interface BulkDownloadResponse
 */
export interface BulkDownloadResponse {
    /**
     * ID of the bulk request.
     * @type {string}
     * @memberof BulkDownloadResponse
     */
    'request_id'?: string;
}
/**
 * Refers ads entity type
 * @export
 * @enum {string}
 */

export const BulkEntityType = {
    Campaign: 'CAMPAIGN',
    AdGroup: 'AD_GROUP',
    ProductGroup: 'PRODUCT_GROUP',
    Ad: 'AD',
    Keyword: 'KEYWORD'
} as const;

export type BulkEntityType = typeof BulkEntityType[keyof typeof BulkEntityType];


/**
 * Bulk file output format
 * @export
 * @enum {string}
 */

export const BulkOutputFormat = {
    Csv: 'CSV',
    Json: 'JSON'
} as const;

export type BulkOutputFormat = typeof BulkOutputFormat[keyof typeof BulkOutputFormat];


/**
 * Possible status for a bulk reporting job
 * @export
 * @enum {string}
 */

export const BulkReportingJobStatus = {
    DoesNotExist: 'DOES_NOT_EXIST',
    Finished: 'FINISHED',
    InProgress: 'IN_PROGRESS',
    Expired: 'EXPIRED',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED'
} as const;

export type BulkReportingJobStatus = typeof BulkReportingJobStatus[keyof typeof BulkReportingJobStatus];


/**
 * Two set of objects to be managed asyncronusly by bulk. One for creations, one for modifications.
 * @export
 * @interface BulkUpsertRequest
 */
export interface BulkUpsertRequest {
    /**
     * 
     * @type {BulkUpsertRequestCreate}
     * @memberof BulkUpsertRequest
     */
    'create'?: BulkUpsertRequestCreate;
    /**
     * 
     * @type {BulkUpsertRequestUpdate}
     * @memberof BulkUpsertRequest
     */
    'update'?: BulkUpsertRequestUpdate;
}
/**
 * Request for creation of entities in bulk.
 * @export
 * @interface BulkUpsertRequestCreate
 */
export interface BulkUpsertRequestCreate {
    /**
     * 
     * @type {Array<CampaignCreateRequest>}
     * @memberof BulkUpsertRequestCreate
     */
    'campaigns'?: Array<CampaignCreateRequest>;
    /**
     * 
     * @type {Array<AdGroupCreateRequest>}
     * @memberof BulkUpsertRequestCreate
     */
    'ad_groups'?: Array<AdGroupCreateRequest>;
    /**
     * 
     * @type {Array<AdCreateRequest>}
     * @memberof BulkUpsertRequestCreate
     */
    'ads'?: Array<AdCreateRequest>;
    /**
     * 
     * @type {Array<ProductGroupPromotionCreateRequest>}
     * @memberof BulkUpsertRequestCreate
     */
    'product_groups'?: Array<ProductGroupPromotionCreateRequest>;
    /**
     * 
     * @type {Array<KeywordsRequest>}
     * @memberof BulkUpsertRequestCreate
     */
    'keywords'?: Array<KeywordsRequest>;
}
/**
 * Request for creation of entities in bulk.
 * @export
 * @interface BulkUpsertRequestUpdate
 */
export interface BulkUpsertRequestUpdate {
    /**
     * 
     * @type {Array<CampaignUpdateRequest>}
     * @memberof BulkUpsertRequestUpdate
     */
    'campaigns'?: Array<CampaignUpdateRequest>;
    /**
     * 
     * @type {Array<AdGroupUpdateRequest>}
     * @memberof BulkUpsertRequestUpdate
     */
    'ad_groups'?: Array<AdGroupUpdateRequest>;
    /**
     * 
     * @type {Array<AdUpdateRequest>}
     * @memberof BulkUpsertRequestUpdate
     */
    'ads'?: Array<AdUpdateRequest>;
    /**
     * 
     * @type {Array<ProductGroupPromotionUpdateRequest>}
     * @memberof BulkUpsertRequestUpdate
     */
    'product_groups'?: Array<ProductGroupPromotionUpdateRequest>;
    /**
     * 
     * @type {Array<KeywordUpdate>}
     * @memberof BulkUpsertRequestUpdate
     */
    'keywords'?: Array<KeywordUpdate>;
}
/**
 * ID of the bulk request.
 * @export
 * @interface BulkUpsertResponse
 */
export interface BulkUpsertResponse {
    /**
     * 
     * @type {string}
     * @memberof BulkUpsertResponse
     */
    'request_id'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const BulkUpsertStatus = {
    Running: 'RUNNING',
    Succeeded: 'SUCCEEDED',
    Failed: 'FAILED'
} as const;

export type BulkUpsertStatus = typeof BulkUpsertStatus[keyof typeof BulkUpsertStatus];


/**
 * ID of the bulk request.
 * @export
 * @interface BulkUpsertStatusResponse
 */
export interface BulkUpsertStatusResponse {
    /**
     * 
     * @type {BulkUpsertStatus}
     * @memberof BulkUpsertStatusResponse
     */
    'status'?: BulkUpsertStatus;
    /**
     * 
     * @type {string}
     * @memberof BulkUpsertStatusResponse
     */
    'result_url'?: string;
}


/**
 * 
 * @export
 * @interface BusinessAccessError
 */
export interface BusinessAccessError {
    /**
     * 
     * @type {number}
     * @memberof BusinessAccessError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof BusinessAccessError
     */
    'message': string;
}
/**
 * Permission role for business access.
 * @export
 * @enum {string}
 */

export const BusinessAccessRole = {
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Analyst: 'ANALYST',
    SosReader: 'SOS_READER',
    FinanceManager: 'FINANCE_MANAGER',
    AudienceManager: 'AUDIENCE_MANAGER',
    CampaignManager: 'CAMPAIGN_MANAGER',
    CatalogsManager: 'CATALOGS_MANAGER',
    RestrictedOwner: 'RESTRICTED_OWNER',
    ProfileManager: 'PROFILE_MANAGER',
    ProfilePublisher: 'PROFILE_PUBLISHER',
    ResourcePinnerListOwner: 'RESOURCE_PINNER_LIST_OWNER',
    ResourcePinnerListReader: 'RESOURCE_PINNER_LIST_READER',
    BizPinnerListSharer: 'BIZ_PINNER_LIST_SHARER',
    ResourceConversionTagsReader: 'RESOURCE_CONVERSION_TAGS_READER'
} as const;

export type BusinessAccessRole = typeof BusinessAccessRole[keyof typeof BusinessAccessRole];


/**
 * Metadata of the member/partner that has access to the asset.
 * @export
 * @interface BusinessAccessUserSummary
 */
export interface BusinessAccessUserSummary {
    /**
     * Email of the business member/partner.
     * @type {string}
     * @memberof BusinessAccessUserSummary
     */
    'email'?: string | null;
    /**
     * Unique identifier of the business member/partner.
     * @type {string}
     * @memberof BusinessAccessUserSummary
     */
    'id'?: string | null;
    /**
     * Username of the business member/partner.
     * @type {string}
     * @memberof BusinessAccessUserSummary
     */
    'username'?: string | null;
}
/**
 * 
 * @export
 * @interface BusinessAssetMembersGet200Response
 */
export interface BusinessAssetMembersGet200Response {
    /**
     * List of members with permissions to the asset.
     * @type {Array<UserSingleAssetBinding>}
     * @memberof BusinessAssetMembersGet200Response
     */
    'items': Array<UserSingleAssetBinding>;
    /**
     * 
     * @type {string}
     * @memberof BusinessAssetMembersGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface BusinessAssetPartnersGet200Response
 */
export interface BusinessAssetPartnersGet200Response {
    /**
     * List of partners with permissions to the asset.
     * @type {Array<UserSingleAssetBinding>}
     * @memberof BusinessAssetPartnersGet200Response
     */
    'items': Array<UserSingleAssetBinding>;
    /**
     * 
     * @type {string}
     * @memberof BusinessAssetPartnersGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface BusinessAssetsGet200Response
 */
export interface BusinessAssetsGet200Response {
    /**
     * List of assets the requesting business has access to.
     * @type {Array<GetBusinessAssetsResponse>}
     * @memberof BusinessAssetsGet200Response
     */
    'items': Array<GetBusinessAssetsResponse>;
    /**
     * 
     * @type {string}
     * @memberof BusinessAssetsGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface BusinessMemberAssetsGet200Response
 */
export interface BusinessMemberAssetsGet200Response {
    /**
     * List asset permissions the given member was granted.
     * @type {Array<AssetIdPermissions>}
     * @memberof BusinessMemberAssetsGet200Response
     */
    'items': Array<AssetIdPermissions>;
    /**
     * 
     * @type {string}
     * @memberof BusinessMemberAssetsGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * Ad accounts and profiles the business member/partner has access to.
 * @export
 * @interface BusinessMemberAssetsSummary
 */
export interface BusinessMemberAssetsSummary {
    /**
     * List of ad account IDs and respective permission levels.
     * @type {Array<BusinessMemberAssetsSummaryAdAccountsInner>}
     * @memberof BusinessMemberAssetsSummary
     */
    'ad_accounts'?: Array<BusinessMemberAssetsSummaryAdAccountsInner>;
    /**
     * List of profile IDs and respective permission levels.
     * @type {Array<BusinessMemberAssetsSummaryProfilesInner>}
     * @memberof BusinessMemberAssetsSummary
     */
    'profiles'?: Array<BusinessMemberAssetsSummaryProfilesInner>;
}
/**
 * 
 * @export
 * @interface BusinessMemberAssetsSummaryAdAccountsInner
 */
export interface BusinessMemberAssetsSummaryAdAccountsInner {
    /**
     * Unique identifier of a business ad account.
     * @type {string}
     * @memberof BusinessMemberAssetsSummaryAdAccountsInner
     */
    'id'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof BusinessMemberAssetsSummaryAdAccountsInner
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BusinessMemberAssetsSummaryProfilesInner
 */
export interface BusinessMemberAssetsSummaryProfilesInner {
    /**
     * Unique identifier of a business profile.
     * @type {string}
     * @memberof BusinessMemberAssetsSummaryProfilesInner
     */
    'id'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof BusinessMemberAssetsSummaryProfilesInner
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface BusinessMembersAssetAccessDeleteRequest
 */
export interface BusinessMembersAssetAccessDeleteRequest {
    /**
     * List of members asset access to be deleted
     * @type {Array<BusinessMembersAssetAccessDeleteRequestAccessesInner>}
     * @memberof BusinessMembersAssetAccessDeleteRequest
     */
    'accesses': Array<BusinessMembersAssetAccessDeleteRequestAccessesInner>;
}
/**
 * 
 * @export
 * @interface BusinessMembersAssetAccessDeleteRequestAccessesInner
 */
export interface BusinessMembersAssetAccessDeleteRequestAccessesInner {
    /**
     * Id of the asset on which to remove member permissions.
     * @type {string}
     * @memberof BusinessMembersAssetAccessDeleteRequestAccessesInner
     */
    'asset_id': string;
    /**
     * Unique identifier of the member on which to perform the asset permission removal
     * @type {string}
     * @memberof BusinessMembersAssetAccessDeleteRequestAccessesInner
     */
    'member_id': string;
}
/**
 * 
 * @export
 * @interface BusinessPartnerAssetAccessGet200Response
 */
export interface BusinessPartnerAssetAccessGet200Response {
    /**
     * List assets on which you granted access to your partner or assets on which your partner has granted you access.
     * @type {Array<GetPartnerAssetsResponse>}
     * @memberof BusinessPartnerAssetAccessGet200Response
     */
    'items': Array<GetPartnerAssetsResponse>;
    /**
     * 
     * @type {string}
     * @memberof BusinessPartnerAssetAccessGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * The access level a member/partner has to the business. Values are case-sensitive. <br> - EMPLOYEE: Can only view and access assets you assign to them. They cannot see details about other employees, partners, or other assets. <br> - BIZ_ADMIN: Have full control of roles and can add employees and partners as well as grant asset access. <br> - PARTNER: Can only view and access assets you assign them to/or they assign to you.
 * @export
 * @enum {string}
 */

export const BusinessRole = {
    Employee: 'EMPLOYEE',
    BizAdmin: 'BIZ_ADMIN',
    Partner: 'PARTNER'
} as const;

export type BusinessRole = typeof BusinessRole[keyof typeof BusinessRole];


/**
 * Specifies if the partner is internal or external.
 * @export
 * @enum {string}
 */

export const BusinessRoleCheckMode = {
    Internal: 'INTERNAL',
    External: 'EXTERNAL'
} as const;

export type BusinessRoleCheckMode = typeof BusinessRoleCheckMode[keyof typeof BusinessRoleCheckMode];


/**
 * The access level a member has to the business. Values are case-sensitive. <br> - EMPLOYEE: Can only view and access assets you assign to them. They cannot see details about other employees, partners, or other assets. <br> - BIZ_ADMIN: Have full control of roles and can add employees and partners as well as grant asset access.
 * @export
 * @enum {string}
 */

export const BusinessRoleForMembers = {
    Employee: 'EMPLOYEE',
    BizAdmin: 'BIZ_ADMIN'
} as const;

export type BusinessRoleForMembers = typeof BusinessRoleForMembers[keyof typeof BusinessRoleForMembers];


/**
 * 
 * @export
 * @interface BusinessSharedAudience
 */
export interface BusinessSharedAudience {
    /**
     * Unique identifier of an audience
     * @type {string}
     * @memberof BusinessSharedAudience
     */
    'audience_id': string;
    /**
     * 
     * @type {OperationType}
     * @memberof BusinessSharedAudience
     */
    'operation_type': OperationType;
    /**
     * List of business IDs to share with or revoke from.
     * @type {Array<string>}
     * @memberof BusinessSharedAudience
     */
    'recipient_business_ids': Array<string>;
}


/**
 * 
 * @export
 * @interface BusinessSharedAudienceResponse
 */
export interface BusinessSharedAudienceResponse {
    /**
     * Audience ID that was shared
     * @type {string}
     * @memberof BusinessSharedAudienceResponse
     */
    'audience_id'?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof BusinessSharedAudienceResponse
     */
    'permissions'?: Array<Role>;
    /**
     * Business IDs that received the audience
     * @type {Array<string>}
     * @memberof BusinessSharedAudienceResponse
     */
    'recipient_business_ids'?: Array<string>;
}
/**
 * Campaign Data
 * @export
 * @interface CampaignCommon
 */
export interface CampaignCommon {
    /**
     * Campaign\'s Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
     * @type {string}
     * @memberof CampaignCommon
     */
    'ad_account_id'?: string;
    /**
     * Campaign name.
     * @type {string}
     * @memberof CampaignCommon
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof CampaignCommon
     */
    'status'?: EntityStatus;
    /**
     * Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCommon
     */
    'lifetime_spend_cap'?: number | null;
    /**
     * Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCommon
     */
    'daily_spend_cap'?: number | null;
    /**
     * Order line ID that appears on the invoice.
     * @type {string}
     * @memberof CampaignCommon
     */
    'order_line_id'?: string | null;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof CampaignCommon
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCommon
     */
    'start_time'?: number | null;
    /**
     * Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCommon
     */
    'end_time'?: number | null;
    /**
     * Determine if a campaign has flexible daily budgets setup.
     * @type {boolean}
     * @memberof CampaignCommon
     */
    'is_flexible_daily_budgets'?: boolean | null;
}


/**
 * 
 * @export
 * @interface CampaignCreateCommon
 */
export interface CampaignCreateCommon {
    /**
     * Campaign\'s Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
     * @type {string}
     * @memberof CampaignCreateCommon
     */
    'ad_account_id'?: string;
    /**
     * Campaign name.
     * @type {string}
     * @memberof CampaignCreateCommon
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof CampaignCreateCommon
     */
    'status'?: EntityStatus;
    /**
     * Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCreateCommon
     */
    'lifetime_spend_cap'?: number | null;
    /**
     * Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCreateCommon
     */
    'daily_spend_cap'?: number | null;
    /**
     * Order line ID that appears on the invoice.
     * @type {string}
     * @memberof CampaignCreateCommon
     */
    'order_line_id'?: string | null;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof CampaignCreateCommon
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCreateCommon
     */
    'start_time'?: number | null;
    /**
     * Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCreateCommon
     */
    'end_time'?: number | null;
    /**
     * Determine if a campaign has flexible daily budgets setup.
     * @type {boolean}
     * @memberof CampaignCreateCommon
     */
    'is_flexible_daily_budgets'?: boolean | null;
    /**
     * When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
     * @type {number}
     * @memberof CampaignCreateCommon
     */
    'default_ad_group_budget_in_micro_currency'?: number | null;
    /**
     * Specifies whether the campaign was created in the automated campaign flow
     * @type {boolean}
     * @memberof CampaignCreateCommon
     */
    'is_automated_campaign'?: boolean | null;
}


/**
 * 
 * @export
 * @interface CampaignCreateRequest
 */
export interface CampaignCreateRequest {
    /**
     * Campaign\'s Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
     * @type {string}
     * @memberof CampaignCreateRequest
     */
    'ad_account_id': string;
    /**
     * Campaign name.
     * @type {string}
     * @memberof CampaignCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof CampaignCreateRequest
     */
    'status'?: EntityStatus;
    /**
     * Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCreateRequest
     */
    'lifetime_spend_cap'?: number | null;
    /**
     * Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCreateRequest
     */
    'daily_spend_cap'?: number | null;
    /**
     * Order line ID that appears on the invoice.
     * @type {string}
     * @memberof CampaignCreateRequest
     */
    'order_line_id'?: string | null;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof CampaignCreateRequest
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCreateRequest
     */
    'start_time'?: number | null;
    /**
     * Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCreateRequest
     */
    'end_time'?: number | null;
    /**
     * Determine if a campaign has flexible daily budgets setup.
     * @type {boolean}
     * @memberof CampaignCreateRequest
     */
    'is_flexible_daily_budgets'?: boolean | null;
    /**
     * When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
     * @type {number}
     * @memberof CampaignCreateRequest
     */
    'default_ad_group_budget_in_micro_currency'?: number | null;
    /**
     * Specifies whether the campaign was created in the automated campaign flow
     * @type {boolean}
     * @memberof CampaignCreateRequest
     */
    'is_automated_campaign'?: boolean | null;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof CampaignCreateRequest
     */
    'objective_type': ObjectiveType;
}


/**
 * 
 * @export
 * @interface CampaignCreateResponse
 */
export interface CampaignCreateResponse {
    /**
     * 
     * @type {Array<CampaignCreateResponseItem>}
     * @memberof CampaignCreateResponse
     */
    'items'?: Array<CampaignCreateResponseItem>;
}
/**
 * 
 * @export
 * @interface CampaignCreateResponseData
 */
export interface CampaignCreateResponseData {
    /**
     * Campaign\'s Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
     * @type {string}
     * @memberof CampaignCreateResponseData
     */
    'ad_account_id'?: string;
    /**
     * Campaign name.
     * @type {string}
     * @memberof CampaignCreateResponseData
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof CampaignCreateResponseData
     */
    'status'?: EntityStatus;
    /**
     * Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'lifetime_spend_cap'?: number | null;
    /**
     * Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'daily_spend_cap'?: number | null;
    /**
     * Order line ID that appears on the invoice.
     * @type {string}
     * @memberof CampaignCreateResponseData
     */
    'order_line_id'?: string | null;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof CampaignCreateResponseData
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'start_time'?: number | null;
    /**
     * Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'end_time'?: number | null;
    /**
     * Determine if a campaign has flexible daily budgets setup.
     * @type {boolean}
     * @memberof CampaignCreateResponseData
     */
    'is_flexible_daily_budgets'?: boolean | null;
    /**
     * When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'default_ad_group_budget_in_micro_currency'?: number | null;
    /**
     * Specifies whether the campaign was created in the automated campaign flow
     * @type {boolean}
     * @memberof CampaignCreateResponseData
     */
    'is_automated_campaign'?: boolean | null;
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CampaignCreateResponseData
     */
    'id'?: string;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof CampaignCreateResponseData
     */
    'objective_type'?: ObjectiveType;
    /**
     * Campaign creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'created_time'?: number;
    /**
     * UTC timestamp. Last update time.
     * @type {number}
     * @memberof CampaignCreateResponseData
     */
    'updated_time'?: number;
    /**
     * Always \"campaign\".
     * @type {string}
     * @memberof CampaignCreateResponseData
     */
    'type'?: string;
    /**
     * Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
     * @type {boolean}
     * @memberof CampaignCreateResponseData
     */
    'is_campaign_budget_optimization'?: boolean | null;
    /**
     * 
     * @type {CampaignSummaryStatus}
     * @memberof CampaignCreateResponseData
     */
    'summary_status'?: CampaignSummaryStatus;
}


/**
 * 
 * @export
 * @interface CampaignCreateResponseItem
 */
export interface CampaignCreateResponseItem {
    /**
     * 
     * @type {CampaignCreateResponseData}
     * @memberof CampaignCreateResponseItem
     */
    'data'?: CampaignCreateResponseData;
    /**
     * 
     * @type {Array<Exception>}
     * @memberof CampaignCreateResponseItem
     */
    'exceptions'?: Array<Exception>;
}
/**
 * 
 * @export
 * @interface CampaignId
 */
export interface CampaignId {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CampaignId
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface CampaignResponse
 */
export interface CampaignResponse {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CampaignResponse
     */
    'id'?: string;
    /**
     * Campaign\'s Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
     * @type {string}
     * @memberof CampaignResponse
     */
    'ad_account_id'?: string;
    /**
     * Campaign name.
     * @type {string}
     * @memberof CampaignResponse
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof CampaignResponse
     */
    'status'?: EntityStatus;
    /**
     * Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignResponse
     */
    'lifetime_spend_cap'?: number | null;
    /**
     * Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignResponse
     */
    'daily_spend_cap'?: number | null;
    /**
     * Order line ID that appears on the invoice.
     * @type {string}
     * @memberof CampaignResponse
     */
    'order_line_id'?: string | null;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof CampaignResponse
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignResponse
     */
    'start_time'?: number | null;
    /**
     * Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignResponse
     */
    'end_time'?: number | null;
    /**
     * Determine if a campaign has flexible daily budgets setup.
     * @type {boolean}
     * @memberof CampaignResponse
     */
    'is_flexible_daily_budgets'?: boolean | null;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof CampaignResponse
     */
    'objective_type'?: ObjectiveType;
    /**
     * Campaign creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof CampaignResponse
     */
    'created_time'?: number;
    /**
     * UTC timestamp. Last update time.
     * @type {number}
     * @memberof CampaignResponse
     */
    'updated_time'?: number;
    /**
     * Always \"campaign\".
     * @type {string}
     * @memberof CampaignResponse
     */
    'type'?: string;
    /**
     * Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
     * @type {boolean}
     * @memberof CampaignResponse
     */
    'is_campaign_budget_optimization'?: boolean | null;
    /**
     * 
     * @type {CampaignSummaryStatus}
     * @memberof CampaignResponse
     */
    'summary_status'?: CampaignSummaryStatus;
}


/**
 * Summary status for campaign
 * @export
 * @enum {string}
 */

export const CampaignSummaryStatus = {
    Running: 'RUNNING',
    Paused: 'PAUSED',
    NotStarted: 'NOT_STARTED',
    Completed: 'COMPLETED',
    AdvertiserDisabled: 'ADVERTISER_DISABLED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;

export type CampaignSummaryStatus = typeof CampaignSummaryStatus[keyof typeof CampaignSummaryStatus];


/**
 * 
 * @export
 * @interface CampaignUpdateRequest
 */
export interface CampaignUpdateRequest {
    /**
     * Campaign ID.
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'id': string;
    /**
     * Campaign\'s Advertiser ID. If you want to create a campaign in a Business Account shared account you need to specify the Business Access advertiser ID in both the query path param as well as the request body schema.
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'ad_account_id': string;
    /**
     * Campaign name.
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof CampaignUpdateRequest
     */
    'status'?: EntityStatus;
    /**
     * Campaign total spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"daily_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignUpdateRequest
     */
    'lifetime_spend_cap'?: number | null;
    /**
     * Campaign daily spending cap. Required for Campaign Budget Optimization (CBO) campaigns. This and \"lifetime_spend_cap\" cannot be set at the same time.
     * @type {number}
     * @memberof CampaignUpdateRequest
     */
    'daily_spend_cap'?: number | null;
    /**
     * Order line ID that appears on the invoice.
     * @type {string}
     * @memberof CampaignUpdateRequest
     */
    'order_line_id'?: string | null;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof CampaignUpdateRequest
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Campaign start time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignUpdateRequest
     */
    'start_time'?: number | null;
    /**
     * Campaign end time. Unix timestamp in seconds. Only used for Campaign Budget Optimization (CBO) campaigns.
     * @type {number}
     * @memberof CampaignUpdateRequest
     */
    'end_time'?: number | null;
    /**
     * Determine if a campaign has flexible daily budgets setup.
     * @type {boolean}
     * @memberof CampaignUpdateRequest
     */
    'is_flexible_daily_budgets'?: boolean | null;
    /**
     * When transitioning from campaign budget optimization to non-campaign budget optimization, the default_ad_group_budget_in_micro_currency will propagate to each child ad groups daily budget. Unit is micro currency of the associated advertiser account.
     * @type {number}
     * @memberof CampaignUpdateRequest
     */
    'default_ad_group_budget_in_micro_currency'?: number | null;
    /**
     * Specifies whether the campaign was created in the automated campaign flow
     * @type {boolean}
     * @memberof CampaignUpdateRequest
     */
    'is_automated_campaign'?: boolean | null;
    /**
     * Determines if a campaign automatically generate ad-group level budgets given a campaign budget to maximize campaign outcome. When transitioning from non-cbo to cbo, all previous child ad group budget will be cleared.
     * @type {boolean}
     * @memberof CampaignUpdateRequest
     */
    'is_campaign_budget_optimization'?: boolean | null;
    /**
     * 
     * @type {ObjectiveType}
     * @memberof CampaignUpdateRequest
     */
    'objective_type'?: ObjectiveType | null;
}


/**
 * 
 * @export
 * @interface CampaignUpdateResponse
 */
export interface CampaignUpdateResponse {
    /**
     * 
     * @type {Array<CampaignCreateResponseItem>}
     * @memberof CampaignUpdateResponse
     */
    'items'?: Array<CampaignCreateResponseItem>;
}
/**
 * 
 * @export
 * @interface CampaignsAnalyticsResponseInner
 */
export interface CampaignsAnalyticsResponseInner {
    [key: string]: any;

    /**
     * The ID of the campaing that this metrics belongs to.
     * @type {string}
     * @memberof CampaignsAnalyticsResponseInner
     */
    'CAMPAIGN_ID': string;
    /**
     * Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
     * @type {string}
     * @memberof CampaignsAnalyticsResponseInner
     */
    'DATE'?: string;
}
/**
 * 
 * @export
 * @interface CampaignsList200Response
 */
export interface CampaignsList200Response {
    /**
     * 
     * @type {Array<CampaignResponse>}
     * @memberof CampaignsList200Response
     */
    'items': Array<CampaignResponse>;
    /**
     * 
     * @type {string}
     * @memberof CampaignsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Request body used to cancel invites
 * @export
 * @interface CancelInvitesBody
 */
export interface CancelInvitesBody {
    /**
     * List of invite/request ids to be cancelled
     * @type {Array<string>}
     * @memberof CancelInvitesBody
     */
    'invite_ids': Array<string>;
}
/**
 * Catalog entity
 * @export
 * @interface Catalog
 */
export interface Catalog {
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    'created_at': string;
    /**
     * ID of the catalog entity.
     * @type {string}
     * @memberof Catalog
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Catalog
     */
    'updated_at': string;
    /**
     * A human-friendly name associated to a catalog entity.
     * @type {string}
     * @memberof Catalog
     */
    'name': string | null;
    /**
     * 
     * @type {CatalogsType}
     * @memberof Catalog
     */
    'catalog_type': CatalogsType;
}


/**
 * A creative assets item to be created.
 * @export
 * @interface CatalogsCreateCreativeAssetsItem
 */
export interface CatalogsCreateCreativeAssetsItem {
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CatalogsCreateCreativeAssetsItem
     */
    'creative_assets_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreateCreativeAssetsItem
     */
    'operation': CatalogsCreateCreativeAssetsItemOperationEnum;
    /**
     * 
     * @type {CatalogsCreativeAssetsAttributes}
     * @memberof CatalogsCreateCreativeAssetsItem
     */
    'attributes': CatalogsCreativeAssetsAttributes;
}

export const CatalogsCreateCreativeAssetsItemOperationEnum = {
    Create: 'CREATE'
} as const;

export type CatalogsCreateCreativeAssetsItemOperationEnum = typeof CatalogsCreateCreativeAssetsItemOperationEnum[keyof typeof CatalogsCreateCreativeAssetsItemOperationEnum];

/**
 * A hotel item to be created.
 * @export
 * @interface CatalogsCreateHotelItem
 */
export interface CatalogsCreateHotelItem {
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof CatalogsCreateHotelItem
     */
    'hotel_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreateHotelItem
     */
    'operation': CatalogsCreateHotelItemOperationEnum;
    /**
     * 
     * @type {CatalogsHotelAttributes}
     * @memberof CatalogsCreateHotelItem
     */
    'attributes': CatalogsHotelAttributes;
}

export const CatalogsCreateHotelItemOperationEnum = {
    Create: 'CREATE'
} as const;

export type CatalogsCreateHotelItemOperationEnum = typeof CatalogsCreateHotelItemOperationEnum[keyof typeof CatalogsCreateHotelItemOperationEnum];

/**
 * 
 * @export
 * @interface CatalogsCreateReportResponse
 */
export interface CatalogsCreateReportResponse {
    /**
     * Token to be used to get the report
     * @type {string}
     * @memberof CatalogsCreateReportResponse
     */
    'token'?: string;
}
/**
 * Request object for creating a catalog.
 * @export
 * @interface CatalogsCreateRequest
 */
export interface CatalogsCreateRequest {
    /**
     * Type of the catalog entity.
     * @type {string}
     * @memberof CatalogsCreateRequest
     */
    'catalog_type': CatalogsCreateRequestCatalogTypeEnum;
    /**
     * A human-friendly name associated to a given catalog.
     * @type {string}
     * @memberof CatalogsCreateRequest
     */
    'name': string;
}

export const CatalogsCreateRequestCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsCreateRequestCatalogTypeEnum = typeof CatalogsCreateRequestCatalogTypeEnum[keyof typeof CatalogsCreateRequestCatalogTypeEnum];

/**
 * An item to be created
 * @export
 * @interface CatalogsCreateRetailItem
 */
export interface CatalogsCreateRetailItem {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsCreateRetailItem
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreateRetailItem
     */
    'operation': CatalogsCreateRetailItemOperationEnum;
    /**
     * 
     * @type {ItemAttributesRequest}
     * @memberof CatalogsCreateRetailItem
     */
    'attributes': ItemAttributesRequest;
}

export const CatalogsCreateRetailItemOperationEnum = {
    Create: 'CREATE'
} as const;

export type CatalogsCreateRetailItemOperationEnum = typeof CatalogsCreateRetailItemOperationEnum[keyof typeof CatalogsCreateRetailItemOperationEnum];

/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsAttributes
 */
export interface CatalogsCreativeAssetsAttributes {
    /**
     * The name of the creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'title'?: string;
    /**
     * Brief description of the creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'description'?: string;
    /**
     * Link to the creative assets page.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'link'?: string;
    /**
     * IOS deep link to the creative assets page.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'ios_deep_link'?: string | null;
    /**
     * Link to the creative assets page.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'android_deep_link'?: string | null;
    /**
     * The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'google_product_category'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'custom_label_0'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'custom_label_1'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'custom_label_2'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'custom_label_3'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'custom_label_4'?: string | null;
    /**
     * Visibility of the creative assets. Must be one of the following values (upper or lowercase): visible, hidden.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'visibility'?: string | null;
    /**
     * The creative assets image.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'image_link'?: string;
    /**
     * The creative assets video.
     * @type {string}
     * @memberof CatalogsCreativeAssetsAttributes
     */
    'video_link'?: string;
}
/**
 * Creative assets batch item
 * @export
 * @interface CatalogsCreativeAssetsBatchItem
 */
export interface CatalogsCreativeAssetsBatchItem {
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CatalogsCreativeAssetsBatchItem
     */
    'creative_assets_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsBatchItem
     */
    'operation': CatalogsCreativeAssetsBatchItemOperationEnum;
    /**
     * 
     * @type {CatalogsUpdatableCreativeAssetsAttributes}
     * @memberof CatalogsCreativeAssetsBatchItem
     */
    'attributes': CatalogsUpdatableCreativeAssetsAttributes;
}

export const CatalogsCreativeAssetsBatchItemOperationEnum = {
    Delete: 'DELETE'
} as const;

export type CatalogsCreativeAssetsBatchItemOperationEnum = typeof CatalogsCreativeAssetsBatchItemOperationEnum[keyof typeof CatalogsCreativeAssetsBatchItemOperationEnum];

/**
 * Request object to update catalogs creative assets items
 * @export
 * @interface CatalogsCreativeAssetsBatchRequest
 */
export interface CatalogsCreativeAssetsBatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsBatchRequest
     */
    'catalog_type': CatalogsCreativeAssetsBatchRequestCatalogTypeEnum;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsCreativeAssetsBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsCreativeAssetsBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * Array with creative assets item operations
     * @type {Array<CatalogsCreativeAssetsBatchItem>}
     * @memberof CatalogsCreativeAssetsBatchRequest
     */
    'items': Array<CatalogsCreativeAssetsBatchItem>;
    /**
     * Catalog id pertaining to the creative assets item. If not provided, default to oldest creative assets catalog
     * @type {string}
     * @memberof CatalogsCreativeAssetsBatchRequest
     */
    'catalog_id'?: string;
}

export const CatalogsCreativeAssetsBatchRequestCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsBatchRequestCatalogTypeEnum = typeof CatalogsCreativeAssetsBatchRequestCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsBatchRequestCatalogTypeEnum];

/**
 * Catalogs Creative Asset Feed object
 * @export
 * @interface CatalogsCreativeAssetsFeed
 */
export interface CatalogsCreativeAssetsFeed {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'updated_at': string;
    /**
     * A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'name': string | null;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'catalog_type': CatalogsType;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'credentials': CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'preferred_processing_schedule': CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'status': CatalogsStatus;
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'default_currency': NullableCurrency | null;
    /**
     * The locale used within a feed for product descriptions.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'default_locale': string;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'default_country': Country;
    /**
     * Catalog id pertaining to the feed. If not provided, feed will use a default catalog based on type.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeed
     */
    'catalog_id': string | null;
}


/**
 * Request object for creating a feed.
 * @export
 * @interface CatalogsCreativeAssetsFeedsCreateRequest
 */
export interface CatalogsCreativeAssetsFeedsCreateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedsCreateRequestDefaultLocale}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'default_locale': CatalogsFeedsCreateRequestDefaultLocale;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'default_country': Country;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'catalog_type': CatalogsType;
    /**
     * Catalog id pertaining to the feed. If not provided, feed will use a default catalog based on type. At the moment a catalog can not have multiple creative assets feeds but this will change in the future.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'catalog_id'?: string | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsCreativeAssetsFeedsCreateRequest
     */
    'status'?: CatalogsStatus;
}


/**
 * Request object for updating a feed.
 * @export
 * @interface CatalogsCreativeAssetsFeedsUpdateRequest
 */
export interface CatalogsCreativeAssetsFeedsUpdateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'format'?: CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'location'?: string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'status'?: CatalogsStatus;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsCreativeAssetsFeedsUpdateRequest
     */
    'catalog_type': CatalogsType;
}


/**
 * Object describing a creative assets item error
 * @export
 * @interface CatalogsCreativeAssetsItemErrorResponse
 */
export interface CatalogsCreativeAssetsItemErrorResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsCreativeAssetsItemErrorResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemErrorResponse
     */
    'creative_assets_id'?: string;
    /**
     * Array with the errors for the item id requested
     * @type {Array<ItemValidationEvent>}
     * @memberof CatalogsCreativeAssetsItemErrorResponse
     */
    'errors'?: Array<ItemValidationEvent>;
}


/**
 * Object describing a hotel record
 * @export
 * @interface CatalogsCreativeAssetsItemResponse
 */
export interface CatalogsCreativeAssetsItemResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsCreativeAssetsItemResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemResponse
     */
    'creative_assets_id'?: string;
    /**
     * The pins mapped to the item
     * @type {Array<Pin>}
     * @memberof CatalogsCreativeAssetsItemResponse
     */
    'pins'?: Array<Pin> | null;
    /**
     * 
     * @type {CatalogsCreativeAssetsAttributes}
     * @memberof CatalogsCreativeAssetsItemResponse
     */
    'attributes'?: CatalogsCreativeAssetsAttributes;
}


/**
 * Object describing the catalogs creative assets items batch
 * @export
 * @interface CatalogsCreativeAssetsItemsBatch
 */
export interface CatalogsCreativeAssetsItemsBatch {
    /**
     * Id of the catalogs items batch
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsBatch
     */
    'batch_id'?: string;
    /**
     * Date and time (UTC) of the batch creation: YYYY-MM-DD\'T\'hh:mm:ss
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsBatch
     */
    'created_time'?: string;
    /**
     * Date and time (UTC) of the batch completion: YYYY-MM-DD\'T\'hh:mm:ss
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsBatch
     */
    'completed_time'?: string | null;
    /**
     * 
     * @type {BatchOperationStatus}
     * @memberof CatalogsCreativeAssetsItemsBatch
     */
    'status'?: BatchOperationStatus;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsCreativeAssetsItemsBatch
     */
    'catalog_type': CatalogsType;
    /**
     * Array with the catalogs items processing records part of the catalogs items batch
     * @type {Array<CreativeAssetsProcessingRecord>}
     * @memberof CatalogsCreativeAssetsItemsBatch
     */
    'items'?: Array<CreativeAssetsProcessingRecord>;
}


/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsItemsFilter
 */
export interface CatalogsCreativeAssetsItemsFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsFilter
     */
    'catalog_type': CatalogsCreativeAssetsItemsFilterCatalogTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsCreativeAssetsItemsFilter
     */
    'creative_assets_ids': Array<string>;
    /**
     * Catalog id pertaining to the creative assets item. If not provided, default to oldest creative assets catalog
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsFilter
     */
    'catalog_id'?: string;
}

export const CatalogsCreativeAssetsItemsFilterCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsItemsFilterCatalogTypeEnum = typeof CatalogsCreativeAssetsItemsFilterCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsItemsFilterCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsItemsPostFilter
 */
export interface CatalogsCreativeAssetsItemsPostFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsPostFilter
     */
    'catalog_type': CatalogsCreativeAssetsItemsPostFilterCatalogTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsCreativeAssetsItemsPostFilter
     */
    'creative_assets_ids': Array<string>;
    /**
     * Catalog id pertaining to the creative assets item. If not provided, default to oldest creative assets catalog
     * @type {string}
     * @memberof CatalogsCreativeAssetsItemsPostFilter
     */
    'catalog_id'?: string;
}

export const CatalogsCreativeAssetsItemsPostFilterCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsItemsPostFilterCatalogTypeEnum = typeof CatalogsCreativeAssetsItemsPostFilterCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsItemsPostFilterCatalogTypeEnum];

/**
 * Request object to list products for a given creative assets catalog_id and product group filter.
 * @export
 * @interface CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequest
 */
export interface CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequest
     */
    'catalog_type': CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequestCatalogTypeEnum;
    /**
     * Catalog id pertaining to the creative assets product group.
     * @type {string}
     * @memberof CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequest
     */
    'catalog_id': string;
    /**
     * 
     * @type {CatalogsCreativeAssetsProductGroupFilters}
     * @memberof CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequest
     */
    'filters': CatalogsCreativeAssetsProductGroupFilters;
}

export const CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequestCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequestCatalogTypeEnum = typeof CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequestCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequestCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsProduct
 */
export interface CatalogsCreativeAssetsProduct {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProduct
     */
    'catalog_type': CatalogsCreativeAssetsProductCatalogTypeEnum;
    /**
     * 
     * @type {CatalogsCreativeAssetsProductMetadata}
     * @memberof CatalogsCreativeAssetsProduct
     */
    'metadata': CatalogsCreativeAssetsProductMetadata;
    /**
     * 
     * @type {Pin}
     * @memberof CatalogsCreativeAssetsProduct
     */
    'pin': Pin | null;
}

export const CatalogsCreativeAssetsProductCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsProductCatalogTypeEnum = typeof CatalogsCreativeAssetsProductCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsProductCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsProductGroup
 */
export interface CatalogsCreativeAssetsProductGroup {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'catalog_type': CatalogsCreativeAssetsProductGroupCatalogTypeEnum;
    /**
     * ID of the creative assets product group.
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'id': string;
    /**
     * Name of creative assets product group
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsCreativeAssetsProductGroupFilters}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'filters': CatalogsCreativeAssetsProductGroupFilters;
    /**
     * Unix timestamp in seconds of when catalog product group was created.
     * @type {number}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'created_at'?: number;
    /**
     * Unix timestamp in seconds of last time catalog product group was updated.
     * @type {number}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'updated_at'?: number;
    /**
     * Catalog id pertaining to the creative assets product group.
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroup
     */
    'catalog_id': string;
}

export const CatalogsCreativeAssetsProductGroupCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsProductGroupCatalogTypeEnum = typeof CatalogsCreativeAssetsProductGroupCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsProductGroupCatalogTypeEnum];

/**
 * Request object for creating a creative assets product group.
 * @export
 * @interface CatalogsCreativeAssetsProductGroupCreateRequest
 */
export interface CatalogsCreativeAssetsProductGroupCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupCreateRequest
     */
    'catalog_type': CatalogsCreativeAssetsProductGroupCreateRequestCatalogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsCreativeAssetsProductGroupFilters}
     * @memberof CatalogsCreativeAssetsProductGroupCreateRequest
     */
    'filters': CatalogsCreativeAssetsProductGroupFilters;
    /**
     * Catalog id pertaining to the creative assets product group.
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupCreateRequest
     */
    'catalog_id': string;
}

export const CatalogsCreativeAssetsProductGroupCreateRequestCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsProductGroupCreateRequestCatalogTypeEnum = typeof CatalogsCreativeAssetsProductGroupCreateRequestCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsProductGroupCreateRequestCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsProductGroupFilterKeys
 */
export interface CatalogsCreativeAssetsProductGroupFilterKeys {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'CREATIVE_ASSETS_ID': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_0': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_1': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_2': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_3': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_4': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_6': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_5': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_4': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_3': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_2': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_1': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_0': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleMediaTypesCriteria}
     * @memberof CatalogsCreativeAssetsProductGroupFilterKeys
     */
    'MEDIA_TYPE': CatalogsProductGroupMultipleMediaTypesCriteria;
}
/**
 * Object holding a group of filters for a creative assets product group
 * @export
 * @interface CatalogsCreativeAssetsProductGroupFilters
 */
export interface CatalogsCreativeAssetsProductGroupFilters {
    /**
     * 
     * @type {Array<CatalogsCreativeAssetsProductGroupFilterKeys>}
     * @memberof CatalogsCreativeAssetsProductGroupFilters
     */
    'any_of': Array<CatalogsCreativeAssetsProductGroupFilterKeys>;
    /**
     * 
     * @type {Array<CatalogsCreativeAssetsProductGroupFilterKeys>}
     * @memberof CatalogsCreativeAssetsProductGroupFilters
     */
    'all_of': Array<CatalogsCreativeAssetsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsProductGroupFiltersAllOf
 */
export interface CatalogsCreativeAssetsProductGroupFiltersAllOf {
    /**
     * 
     * @type {Array<CatalogsCreativeAssetsProductGroupFilterKeys>}
     * @memberof CatalogsCreativeAssetsProductGroupFiltersAllOf
     */
    'all_of': Array<CatalogsCreativeAssetsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsCreativeAssetsProductGroupFiltersAnyOf
 */
export interface CatalogsCreativeAssetsProductGroupFiltersAnyOf {
    /**
     * 
     * @type {Array<CatalogsCreativeAssetsProductGroupFilterKeys>}
     * @memberof CatalogsCreativeAssetsProductGroupFiltersAnyOf
     */
    'any_of': Array<CatalogsCreativeAssetsProductGroupFilterKeys>;
}
/**
 * Product counts for a Creative Assets CatalogsProductGroup
 * @export
 * @interface CatalogsCreativeAssetsProductGroupProductCounts
 */
export interface CatalogsCreativeAssetsProductGroupProductCounts {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupProductCounts
     */
    'catalog_type': CatalogsCreativeAssetsProductGroupProductCountsCatalogTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CatalogsCreativeAssetsProductGroupProductCounts
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof CatalogsCreativeAssetsProductGroupProductCounts
     */
    'videos': number;
}

export const CatalogsCreativeAssetsProductGroupProductCountsCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsProductGroupProductCountsCatalogTypeEnum = typeof CatalogsCreativeAssetsProductGroupProductCountsCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsProductGroupProductCountsCatalogTypeEnum];

/**
 * Request object for updating a creative assets product group.
 * @export
 * @interface CatalogsCreativeAssetsProductGroupUpdateRequest
 */
export interface CatalogsCreativeAssetsProductGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupUpdateRequest
     */
    'catalog_type'?: CatalogsCreativeAssetsProductGroupUpdateRequestCatalogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductGroupUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsCreativeAssetsProductGroupFilters}
     * @memberof CatalogsCreativeAssetsProductGroupUpdateRequest
     */
    'filters'?: CatalogsCreativeAssetsProductGroupFilters;
}

export const CatalogsCreativeAssetsProductGroupUpdateRequestCatalogTypeEnum = {
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsCreativeAssetsProductGroupUpdateRequestCatalogTypeEnum = typeof CatalogsCreativeAssetsProductGroupUpdateRequestCatalogTypeEnum[keyof typeof CatalogsCreativeAssetsProductGroupUpdateRequestCatalogTypeEnum];

/**
 * Creative assets product metadata entity
 * @export
 * @interface CatalogsCreativeAssetsProductMetadata
 */
export interface CatalogsCreativeAssetsProductMetadata {
    /**
     * The user-created unique ID that represents the creative assets item.
     * @type {string}
     * @memberof CatalogsCreativeAssetsProductMetadata
     */
    'creative_assets_id': string;
    /**
     * 
     * @type {CreativeAssetsVisibilityType}
     * @memberof CatalogsCreativeAssetsProductMetadata
     */
    'visibility': CreativeAssetsVisibilityType;
}


/**
 * 
 * @export
 * @interface CatalogsDbItem
 */
export interface CatalogsDbItem {
    /**
     * 
     * @type {string}
     * @memberof CatalogsDbItem
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsDbItem
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsDbItem
     */
    'updated_at': string;
}
/**
 * A creative assets item to be deleted
 * @export
 * @interface CatalogsDeleteCreativeAssetsItem
 */
export interface CatalogsDeleteCreativeAssetsItem {
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CatalogsDeleteCreativeAssetsItem
     */
    'creative_assets_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsDeleteCreativeAssetsItem
     */
    'operation': CatalogsDeleteCreativeAssetsItemOperationEnum;
}

export const CatalogsDeleteCreativeAssetsItemOperationEnum = {
    Delete: 'DELETE'
} as const;

export type CatalogsDeleteCreativeAssetsItemOperationEnum = typeof CatalogsDeleteCreativeAssetsItemOperationEnum[keyof typeof CatalogsDeleteCreativeAssetsItemOperationEnum];

/**
 * A hotel item to be deleted
 * @export
 * @interface CatalogsDeleteHotelItem
 */
export interface CatalogsDeleteHotelItem {
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof CatalogsDeleteHotelItem
     */
    'hotel_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsDeleteHotelItem
     */
    'operation': CatalogsDeleteHotelItemOperationEnum;
}

export const CatalogsDeleteHotelItemOperationEnum = {
    Delete: 'DELETE'
} as const;

export type CatalogsDeleteHotelItemOperationEnum = typeof CatalogsDeleteHotelItemOperationEnum[keyof typeof CatalogsDeleteHotelItemOperationEnum];

/**
 * An item to be deleted
 * @export
 * @interface CatalogsDeleteRetailItem
 */
export interface CatalogsDeleteRetailItem {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsDeleteRetailItem
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsDeleteRetailItem
     */
    'operation': CatalogsDeleteRetailItemOperationEnum;
}

export const CatalogsDeleteRetailItemOperationEnum = {
    Delete: 'DELETE'
} as const;

export type CatalogsDeleteRetailItemOperationEnum = typeof CatalogsDeleteRetailItemOperationEnum[keyof typeof CatalogsDeleteRetailItemOperationEnum];

/**
 * @type CatalogsFeed
 * Catalogs Feed object
 * @export
 */
export type CatalogsFeed = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsFeed | { catalog_type: 'HOTEL' } & CatalogsHotelFeed | { catalog_type: 'RETAIL' } & CatalogsRetailFeed;

/**
 * This field is **OPTIONAL**. Use this if your feed file requires username and password.
 * @export
 * @interface CatalogsFeedCredentials
 */
export interface CatalogsFeedCredentials {
    /**
     * The required password for downloading a feed.
     * @type {string}
     * @memberof CatalogsFeedCredentials
     */
    'password': string;
    /**
     * The required username for downloading a feed.
     * @type {string}
     * @memberof CatalogsFeedCredentials
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface CatalogsFeedIngestion
 */
export interface CatalogsFeedIngestion {
    /**
     * 
     * @type {string}
     * @memberof CatalogsFeedIngestion
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsFeedIngestion
     */
    'feed_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsFeedIngestion
     */
    'created_at': string;
    /**
     * 
     * @type {CatalogsFeedProcessingStatus}
     * @memberof CatalogsFeedIngestion
     */
    'status': CatalogsFeedProcessingStatus;
}


/**
 * 
 * @export
 * @interface CatalogsFeedIngestionDetails
 */
export interface CatalogsFeedIngestionDetails {
    /**
     * 
     * @type {CatalogsFeedIngestionErrors}
     * @memberof CatalogsFeedIngestionDetails
     */
    'errors': CatalogsFeedIngestionErrors;
    /**
     * 
     * @type {CatalogsFeedIngestionInfo}
     * @memberof CatalogsFeedIngestionDetails
     */
    'info': CatalogsFeedIngestionInfo;
    /**
     * 
     * @type {CatalogsFeedIngestionWarnings}
     * @memberof CatalogsFeedIngestionDetails
     */
    'warnings': CatalogsFeedIngestionWarnings;
}
/**
 * 
 * @export
 * @interface CatalogsFeedIngestionErrors
 */
export interface CatalogsFeedIngestionErrors {
    /**
     * We experienced a technical difficulty and were unable to ingest this some items. The next ingestion will happen in 24 hours.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'LINE_LEVEL_INTERNAL_ERROR'?: number;
    /**
     * The product count has decreased by more than 99% compared to the last successful ingestion.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'LARGE_PRODUCT_COUNT_DECREASE'?: CatalogsFeedIngestionErrorsLARGEPRODUCTCOUNTDECREASEEnum;
    /**
     * We detected an issue with your account and are not currently ingesting your items. Please review our policies at policy.pinterest.com/community-guidelines#section-spam or contact us at help.pinterest.com/contact for more information.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'ACCOUNT_FLAGGED'?: number;
    /**
     * We experienced a technical difficulty and were unable to download some images. The next download attempt will happen in 24 hours.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'IMAGE_LEVEL_INTERNAL_ERROR'?: number;
    /**
     * Image files are unreadable. Please upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'IMAGE_FILE_NOT_ACCESSIBLE'?: number;
    /**
     * Image files are unreadable. Please check your link and upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'IMAGE_MALFORMED_URL'?: number;
    /**
     * Image files are unreadable. Please upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'IMAGE_FILE_NOT_FOUND'?: number;
    /**
     * Image files are unreadable. Please upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionErrors
     */
    'IMAGE_INVALID_FILE'?: number;
}

export const CatalogsFeedIngestionErrorsLARGEPRODUCTCOUNTDECREASEEnum = {
    NUMBER_1: 1
} as const;

export type CatalogsFeedIngestionErrorsLARGEPRODUCTCOUNTDECREASEEnum = typeof CatalogsFeedIngestionErrorsLARGEPRODUCTCOUNTDECREASEEnum[keyof typeof CatalogsFeedIngestionErrorsLARGEPRODUCTCOUNTDECREASEEnum];

/**
 * 
 * @export
 * @interface CatalogsFeedIngestionInfo
 */
export interface CatalogsFeedIngestionInfo {
    /**
     * The number of ingested products that are in stock.
     * @type {number}
     * @memberof CatalogsFeedIngestionInfo
     */
    'IN_STOCK'?: number;
    /**
     * The number of ingested products that are in out of stock.
     * @type {number}
     * @memberof CatalogsFeedIngestionInfo
     */
    'OUT_OF_STOCK'?: number;
    /**
     * The number of ingested products that are in preorder.
     * @type {number}
     * @memberof CatalogsFeedIngestionInfo
     */
    'PREORDER'?: number;
}
/**
 * 
 * @export
 * @interface CatalogsFeedIngestionWarnings
 */
export interface CatalogsFeedIngestionWarnings {
    /**
     * We experienced a technical difficulty and were unable to download some additional images. The next download attempt will happen in 24 hours.
     * @type {number}
     * @memberof CatalogsFeedIngestionWarnings
     */
    'ADDITIONAL_IMAGE_LEVEL_INTERNAL_ERROR'?: number;
    /**
     * Additional image files are unreadable. Please upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionWarnings
     */
    'ADDITIONAL_IMAGE_FILE_NOT_ACCESSIBLE'?: number;
    /**
     * Additional image files are unreadable. Please check your link and upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionWarnings
     */
    'ADDITIONAL_IMAGE_MALFORMED_URL'?: number;
    /**
     * Additional image files are unreadable. Please upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionWarnings
     */
    'ADDITIONAL_IMAGE_FILE_NOT_FOUND'?: number;
    /**
     * Additional image files are unreadable. Please upload new files to continue.
     * @type {number}
     * @memberof CatalogsFeedIngestionWarnings
     */
    'ADDITIONAL_IMAGE_INVALID_FILE'?: number;
    /**
     * price is not a supported column. Use base_price and sale_price instead.
     * @type {number}
     * @memberof CatalogsFeedIngestionWarnings
     */
    'HOTEL_PRICE_HEADER_IS_PRESENT'?: number;
}
/**
 * 
 * @export
 * @interface CatalogsFeedProcessingResult
 */
export interface CatalogsFeedProcessingResult {
    /**
     * 
     * @type {string}
     * @memberof CatalogsFeedProcessingResult
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsFeedProcessingResult
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsFeedProcessingResult
     */
    'updated_at': string;
    /**
     * 
     * @type {CatalogsFeedIngestionDetails}
     * @memberof CatalogsFeedProcessingResult
     */
    'ingestion_details': CatalogsFeedIngestionDetails;
    /**
     * 
     * @type {CatalogsFeedProcessingStatus}
     * @memberof CatalogsFeedProcessingResult
     */
    'status': CatalogsFeedProcessingStatus;
    /**
     * 
     * @type {CatalogsFeedProductCounts}
     * @memberof CatalogsFeedProcessingResult
     */
    'product_counts': CatalogsFeedProductCounts | null;
    /**
     * 
     * @type {CatalogsFeedValidationDetails}
     * @memberof CatalogsFeedProcessingResult
     */
    'validation_details': CatalogsFeedValidationDetails;
}


/**
 * Daily processing schedule. This field is **OPTIONAL**. Use this to configure the preferred time for processing a feed (otherwise random).
 * @export
 * @interface CatalogsFeedProcessingSchedule
 */
export interface CatalogsFeedProcessingSchedule {
    /**
     * A time in format HH:MM with leading 0 (zero)
     * @type {string}
     * @memberof CatalogsFeedProcessingSchedule
     */
    'time': string;
    /**
     * The timezone considered for the processing schedule time.
     * @type {string}
     * @memberof CatalogsFeedProcessingSchedule
     */
    'timezone': CatalogsFeedProcessingScheduleTimezoneEnum | null;
}

export const CatalogsFeedProcessingScheduleTimezoneEnum = {
    AfricaAbidjan: 'Africa/Abidjan',
    AfricaAccra: 'Africa/Accra',
    AfricaAlgiers: 'Africa/Algiers',
    AfricaBissau: 'Africa/Bissau',
    AfricaCairo: 'Africa/Cairo',
    AfricaCasablanca: 'Africa/Casablanca',
    AfricaCeuta: 'Africa/Ceuta',
    AfricaElAaiun: 'Africa/El_Aaiun',
    AfricaJohannesburg: 'Africa/Johannesburg',
    AfricaJuba: 'Africa/Juba',
    AfricaKhartoum: 'Africa/Khartoum',
    AfricaLagos: 'Africa/Lagos',
    AfricaMaputo: 'Africa/Maputo',
    AfricaMonrovia: 'Africa/Monrovia',
    AfricaNairobi: 'Africa/Nairobi',
    AfricaNdjamena: 'Africa/Ndjamena',
    AfricaSaoTome: 'Africa/Sao_Tome',
    AfricaTripoli: 'Africa/Tripoli',
    AfricaTunis: 'Africa/Tunis',
    AfricaWindhoek: 'Africa/Windhoek',
    AmericaAdak: 'America/Adak',
    AmericaAnchorage: 'America/Anchorage',
    AmericaAraguaina: 'America/Araguaina',
    AmericaArgentinaBuenosAires: 'America/Argentina/Buenos_Aires',
    AmericaArgentinaCatamarca: 'America/Argentina/Catamarca',
    AmericaArgentinaCordoba: 'America/Argentina/Cordoba',
    AmericaArgentinaJujuy: 'America/Argentina/Jujuy',
    AmericaArgentinaLaRioja: 'America/Argentina/La_Rioja',
    AmericaArgentinaMendoza: 'America/Argentina/Mendoza',
    AmericaArgentinaRioGallegos: 'America/Argentina/Rio_Gallegos',
    AmericaArgentinaSalta: 'America/Argentina/Salta',
    AmericaArgentinaSanJuan: 'America/Argentina/San_Juan',
    AmericaArgentinaSanLuis: 'America/Argentina/San_Luis',
    AmericaArgentinaTucuman: 'America/Argentina/Tucuman',
    AmericaArgentinaUshuaia: 'America/Argentina/Ushuaia',
    AmericaAsuncion: 'America/Asuncion',
    AmericaAtikokan: 'America/Atikokan',
    AmericaBahia: 'America/Bahia',
    AmericaBahiaBanderas: 'America/Bahia_Banderas',
    AmericaBarbados: 'America/Barbados',
    AmericaBelem: 'America/Belem',
    AmericaBelize: 'America/Belize',
    AmericaBlancSablon: 'America/Blanc-Sablon',
    AmericaBoaVista: 'America/Boa_Vista',
    AmericaBogota: 'America/Bogota',
    AmericaBoise: 'America/Boise',
    AmericaCambridgeBay: 'America/Cambridge_Bay',
    AmericaCampoGrande: 'America/Campo_Grande',
    AmericaCancun: 'America/Cancun',
    AmericaCaracas: 'America/Caracas',
    AmericaCayenne: 'America/Cayenne',
    AmericaChicago: 'America/Chicago',
    AmericaChihuahua: 'America/Chihuahua',
    AmericaCostaRica: 'America/Costa_Rica',
    AmericaCreston: 'America/Creston',
    AmericaCuiaba: 'America/Cuiaba',
    AmericaCuracao: 'America/Curacao',
    AmericaDanmarkshavn: 'America/Danmarkshavn',
    AmericaDawson: 'America/Dawson',
    AmericaDawsonCreek: 'America/Dawson_Creek',
    AmericaDenver: 'America/Denver',
    AmericaDetroit: 'America/Detroit',
    AmericaEdmonton: 'America/Edmonton',
    AmericaEirunepe: 'America/Eirunepe',
    AmericaElSalvador: 'America/El_Salvador',
    AmericaFortNelson: 'America/Fort_Nelson',
    AmericaFortaleza: 'America/Fortaleza',
    AmericaGlaceBay: 'America/Glace_Bay',
    AmericaGooseBay: 'America/Goose_Bay',
    AmericaGrandTurk: 'America/Grand_Turk',
    AmericaGuatemala: 'America/Guatemala',
    AmericaGuayaquil: 'America/Guayaquil',
    AmericaGuyana: 'America/Guyana',
    AmericaHalifax: 'America/Halifax',
    AmericaHavana: 'America/Havana',
    AmericaHermosillo: 'America/Hermosillo',
    AmericaIndianaIndianapolis: 'America/Indiana/Indianapolis',
    AmericaIndianaKnox: 'America/Indiana/Knox',
    AmericaIndianaMarengo: 'America/Indiana/Marengo',
    AmericaIndianaPetersburg: 'America/Indiana/Petersburg',
    AmericaIndianaTellCity: 'America/Indiana/Tell_City',
    AmericaIndianaVevay: 'America/Indiana/Vevay',
    AmericaIndianaVincennes: 'America/Indiana/Vincennes',
    AmericaIndianaWinamac: 'America/Indiana/Winamac',
    AmericaInuvik: 'America/Inuvik',
    AmericaIqaluit: 'America/Iqaluit',
    AmericaJamaica: 'America/Jamaica',
    AmericaJuneau: 'America/Juneau',
    AmericaKentuckyLouisville: 'America/Kentucky/Louisville',
    AmericaKentuckyMonticello: 'America/Kentucky/Monticello',
    AmericaLaPaz: 'America/La_Paz',
    AmericaLima: 'America/Lima',
    AmericaLosAngeles: 'America/Los_Angeles',
    AmericaMaceio: 'America/Maceio',
    AmericaManagua: 'America/Managua',
    AmericaManaus: 'America/Manaus',
    AmericaMartinique: 'America/Martinique',
    AmericaMatamoros: 'America/Matamoros',
    AmericaMazatlan: 'America/Mazatlan',
    AmericaMenominee: 'America/Menominee',
    AmericaMerida: 'America/Merida',
    AmericaMetlakatla: 'America/Metlakatla',
    AmericaMexicoCity: 'America/Mexico_City',
    AmericaMiquelon: 'America/Miquelon',
    AmericaMoncton: 'America/Moncton',
    AmericaMonterrey: 'America/Monterrey',
    AmericaMontevideo: 'America/Montevideo',
    AmericaNassau: 'America/Nassau',
    AmericaNewYork: 'America/New_York',
    AmericaNipigon: 'America/Nipigon',
    AmericaNome: 'America/Nome',
    AmericaNoronha: 'America/Noronha',
    AmericaNorthDakotaBeulah: 'America/North_Dakota/Beulah',
    AmericaNorthDakotaCenter: 'America/North_Dakota/Center',
    AmericaNorthDakotaNewSalem: 'America/North_Dakota/New_Salem',
    AmericaNuuk: 'America/Nuuk',
    AmericaOjinaga: 'America/Ojinaga',
    AmericaPanama: 'America/Panama',
    AmericaPangnirtung: 'America/Pangnirtung',
    AmericaParamaribo: 'America/Paramaribo',
    AmericaPhoenix: 'America/Phoenix',
    AmericaPortAuPrince: 'America/Port-au-Prince',
    AmericaPortOfSpain: 'America/Port_of_Spain',
    AmericaPortoVelho: 'America/Porto_Velho',
    AmericaPuertoRico: 'America/Puerto_Rico',
    AmericaPuntaArenas: 'America/Punta_Arenas',
    AmericaRainyRiver: 'America/Rainy_River',
    AmericaRankinInlet: 'America/Rankin_Inlet',
    AmericaRecife: 'America/Recife',
    AmericaRegina: 'America/Regina',
    AmericaResolute: 'America/Resolute',
    AmericaRioBranco: 'America/Rio_Branco',
    AmericaSantarem: 'America/Santarem',
    AmericaSantiago: 'America/Santiago',
    AmericaSantoDomingo: 'America/Santo_Domingo',
    AmericaSaoPaulo: 'America/Sao_Paulo',
    AmericaScoresbysund: 'America/Scoresbysund',
    AmericaSitka: 'America/Sitka',
    AmericaStJohns: 'America/St_Johns',
    AmericaSwiftCurrent: 'America/Swift_Current',
    AmericaTegucigalpa: 'America/Tegucigalpa',
    AmericaThule: 'America/Thule',
    AmericaThunderBay: 'America/Thunder_Bay',
    AmericaTijuana: 'America/Tijuana',
    AmericaToronto: 'America/Toronto',
    AmericaVancouver: 'America/Vancouver',
    AmericaWhitehorse: 'America/Whitehorse',
    AmericaWinnipeg: 'America/Winnipeg',
    AmericaYakutat: 'America/Yakutat',
    AmericaYellowknife: 'America/Yellowknife',
    AntarcticaCasey: 'Antarctica/Casey',
    AntarcticaDavis: 'Antarctica/Davis',
    AntarcticaDumontDUrville: 'Antarctica/DumontDUrville',
    AntarcticaMacquarie: 'Antarctica/Macquarie',
    AntarcticaMawson: 'Antarctica/Mawson',
    AntarcticaPalmer: 'Antarctica/Palmer',
    AntarcticaRothera: 'Antarctica/Rothera',
    AntarcticaSyowa: 'Antarctica/Syowa',
    AntarcticaTroll: 'Antarctica/Troll',
    AntarcticaVostok: 'Antarctica/Vostok',
    AsiaAlmaty: 'Asia/Almaty',
    AsiaAmman: 'Asia/Amman',
    AsiaAnadyr: 'Asia/Anadyr',
    AsiaAqtau: 'Asia/Aqtau',
    AsiaAqtobe: 'Asia/Aqtobe',
    AsiaAshgabat: 'Asia/Ashgabat',
    AsiaAtyrau: 'Asia/Atyrau',
    AsiaBaghdad: 'Asia/Baghdad',
    AsiaBaku: 'Asia/Baku',
    AsiaBangkok: 'Asia/Bangkok',
    AsiaBarnaul: 'Asia/Barnaul',
    AsiaBeirut: 'Asia/Beirut',
    AsiaBishkek: 'Asia/Bishkek',
    AsiaBrunei: 'Asia/Brunei',
    AsiaChita: 'Asia/Chita',
    AsiaChoibalsan: 'Asia/Choibalsan',
    AsiaColombo: 'Asia/Colombo',
    AsiaDamascus: 'Asia/Damascus',
    AsiaDhaka: 'Asia/Dhaka',
    AsiaDili: 'Asia/Dili',
    AsiaDubai: 'Asia/Dubai',
    AsiaDushanbe: 'Asia/Dushanbe',
    AsiaFamagusta: 'Asia/Famagusta',
    AsiaGaza: 'Asia/Gaza',
    AsiaHebron: 'Asia/Hebron',
    AsiaHoChiMinh: 'Asia/Ho_Chi_Minh',
    AsiaHongKong: 'Asia/Hong_Kong',
    AsiaHovd: 'Asia/Hovd',
    AsiaIrkutsk: 'Asia/Irkutsk',
    AsiaJakarta: 'Asia/Jakarta',
    AsiaJayapura: 'Asia/Jayapura',
    AsiaJerusalem: 'Asia/Jerusalem',
    AsiaKabul: 'Asia/Kabul',
    AsiaKamchatka: 'Asia/Kamchatka',
    AsiaKarachi: 'Asia/Karachi',
    AsiaKathmandu: 'Asia/Kathmandu',
    AsiaKhandyga: 'Asia/Khandyga',
    AsiaKolkata: 'Asia/Kolkata',
    AsiaKrasnoyarsk: 'Asia/Krasnoyarsk',
    AsiaKualaLumpur: 'Asia/Kuala_Lumpur',
    AsiaKuching: 'Asia/Kuching',
    AsiaMacau: 'Asia/Macau',
    AsiaMagadan: 'Asia/Magadan',
    AsiaMakassar: 'Asia/Makassar',
    AsiaManila: 'Asia/Manila',
    AsiaNicosia: 'Asia/Nicosia',
    AsiaNovokuznetsk: 'Asia/Novokuznetsk',
    AsiaNovosibirsk: 'Asia/Novosibirsk',
    AsiaOmsk: 'Asia/Omsk',
    AsiaOral: 'Asia/Oral',
    AsiaPontianak: 'Asia/Pontianak',
    AsiaPyongyang: 'Asia/Pyongyang',
    AsiaQatar: 'Asia/Qatar',
    AsiaQostanay: 'Asia/Qostanay',
    AsiaQyzylorda: 'Asia/Qyzylorda',
    AsiaRiyadh: 'Asia/Riyadh',
    AsiaSakhalin: 'Asia/Sakhalin',
    AsiaSamarkand: 'Asia/Samarkand',
    AsiaSeoul: 'Asia/Seoul',
    AsiaShanghai: 'Asia/Shanghai',
    AsiaSingapore: 'Asia/Singapore',
    AsiaSrednekolymsk: 'Asia/Srednekolymsk',
    AsiaTaipei: 'Asia/Taipei',
    AsiaTashkent: 'Asia/Tashkent',
    AsiaTbilisi: 'Asia/Tbilisi',
    AsiaTehran: 'Asia/Tehran',
    AsiaThimphu: 'Asia/Thimphu',
    AsiaTokyo: 'Asia/Tokyo',
    AsiaTomsk: 'Asia/Tomsk',
    AsiaUlaanbaatar: 'Asia/Ulaanbaatar',
    AsiaUrumqi: 'Asia/Urumqi',
    AsiaUstNera: 'Asia/Ust-Nera',
    AsiaVladivostok: 'Asia/Vladivostok',
    AsiaYakutsk: 'Asia/Yakutsk',
    AsiaYangon: 'Asia/Yangon',
    AsiaYekaterinburg: 'Asia/Yekaterinburg',
    AsiaYerevan: 'Asia/Yerevan',
    AtlanticAzores: 'Atlantic/Azores',
    AtlanticBermuda: 'Atlantic/Bermuda',
    AtlanticCanary: 'Atlantic/Canary',
    AtlanticCapeVerde: 'Atlantic/Cape_Verde',
    AtlanticFaroe: 'Atlantic/Faroe',
    AtlanticMadeira: 'Atlantic/Madeira',
    AtlanticReykjavik: 'Atlantic/Reykjavik',
    AtlanticSouthGeorgia: 'Atlantic/South_Georgia',
    AtlanticStanley: 'Atlantic/Stanley',
    AustraliaAdelaide: 'Australia/Adelaide',
    AustraliaBrisbane: 'Australia/Brisbane',
    AustraliaBrokenHill: 'Australia/Broken_Hill',
    AustraliaCurrie: 'Australia/Currie',
    AustraliaDarwin: 'Australia/Darwin',
    AustraliaEucla: 'Australia/Eucla',
    AustraliaHobart: 'Australia/Hobart',
    AustraliaLindeman: 'Australia/Lindeman',
    AustraliaLordHowe: 'Australia/Lord_Howe',
    AustraliaMelbourne: 'Australia/Melbourne',
    AustraliaPerth: 'Australia/Perth',
    AustraliaSydney: 'Australia/Sydney',
    Cet: 'CET',
    Cst6Cdt: 'CST6CDT',
    Eet: 'EET',
    Est: 'EST',
    Est5Edt: 'EST5EDT',
    EtcGmt: 'Etc/GMT',
    EtcGmt1: 'Etc/GMT+1',
    EtcGmt10: 'Etc/GMT+10',
    EtcGmt11: 'Etc/GMT+11',
    EtcGmt122: 'Etc/GMT+12',
    EtcGmt2: 'Etc/GMT+2',
    EtcGmt3: 'Etc/GMT+3',
    EtcGmt4: 'Etc/GMT+4',
    EtcGmt5: 'Etc/GMT+5',
    EtcGmt6: 'Etc/GMT+6',
    EtcGmt7: 'Etc/GMT+7',
    EtcGmt8: 'Etc/GMT+8',
    EtcGmt9: 'Etc/GMT+9',
    EtcGmt12: 'Etc/GMT-1',
    EtcGmt102: 'Etc/GMT-10',
    EtcGmt112: 'Etc/GMT-11',
    EtcGmt122: 'Etc/GMT-12',
    EtcGmt13: 'Etc/GMT-13',
    EtcGmt14: 'Etc/GMT-14',
    EtcGmt22: 'Etc/GMT-2',
    EtcGmt32: 'Etc/GMT-3',
    EtcGmt42: 'Etc/GMT-4',
    EtcGmt52: 'Etc/GMT-5',
    EtcGmt62: 'Etc/GMT-6',
    EtcGmt72: 'Etc/GMT-7',
    EtcGmt82: 'Etc/GMT-8',
    EtcGmt92: 'Etc/GMT-9',
    EtcUtc: 'Etc/UTC',
    EuropeAmsterdam: 'Europe/Amsterdam',
    EuropeAndorra: 'Europe/Andorra',
    EuropeAstrakhan: 'Europe/Astrakhan',
    EuropeAthens: 'Europe/Athens',
    EuropeBelgrade: 'Europe/Belgrade',
    EuropeBerlin: 'Europe/Berlin',
    EuropeBrussels: 'Europe/Brussels',
    EuropeBucharest: 'Europe/Bucharest',
    EuropeBudapest: 'Europe/Budapest',
    EuropeChisinau: 'Europe/Chisinau',
    EuropeCopenhagen: 'Europe/Copenhagen',
    EuropeDublin: 'Europe/Dublin',
    EuropeGibraltar: 'Europe/Gibraltar',
    EuropeHelsinki: 'Europe/Helsinki',
    EuropeIstanbul: 'Europe/Istanbul',
    EuropeKaliningrad: 'Europe/Kaliningrad',
    EuropeKiev: 'Europe/Kiev',
    EuropeKirov: 'Europe/Kirov',
    EuropeLisbon: 'Europe/Lisbon',
    EuropeLondon: 'Europe/London',
    EuropeLuxembourg: 'Europe/Luxembourg',
    EuropeMadrid: 'Europe/Madrid',
    EuropeMalta: 'Europe/Malta',
    EuropeMinsk: 'Europe/Minsk',
    EuropeMonaco: 'Europe/Monaco',
    EuropeMoscow: 'Europe/Moscow',
    EuropeOslo: 'Europe/Oslo',
    EuropeParis: 'Europe/Paris',
    EuropePrague: 'Europe/Prague',
    EuropeRiga: 'Europe/Riga',
    EuropeRome: 'Europe/Rome',
    EuropeSamara: 'Europe/Samara',
    EuropeSaratov: 'Europe/Saratov',
    EuropeSimferopol: 'Europe/Simferopol',
    EuropeSofia: 'Europe/Sofia',
    EuropeStockholm: 'Europe/Stockholm',
    EuropeTallinn: 'Europe/Tallinn',
    EuropeTirane: 'Europe/Tirane',
    EuropeUlyanovsk: 'Europe/Ulyanovsk',
    EuropeUzhgorod: 'Europe/Uzhgorod',
    EuropeVienna: 'Europe/Vienna',
    EuropeVilnius: 'Europe/Vilnius',
    EuropeVolgograd: 'Europe/Volgograd',
    EuropeWarsaw: 'Europe/Warsaw',
    EuropeZaporozhye: 'Europe/Zaporozhye',
    EuropeZurich: 'Europe/Zurich',
    Hst: 'HST',
    IndianChagos: 'Indian/Chagos',
    IndianChristmas: 'Indian/Christmas',
    IndianCocos: 'Indian/Cocos',
    IndianKerguelen: 'Indian/Kerguelen',
    IndianMahe: 'Indian/Mahe',
    IndianMaldives: 'Indian/Maldives',
    IndianMauritius: 'Indian/Mauritius',
    IndianReunion: 'Indian/Reunion',
    Met: 'MET',
    Mst: 'MST',
    Mst7Mdt: 'MST7MDT',
    Pst8Pdt: 'PST8PDT',
    PacificApia: 'Pacific/Apia',
    PacificAuckland: 'Pacific/Auckland',
    PacificBougainville: 'Pacific/Bougainville',
    PacificChatham: 'Pacific/Chatham',
    PacificChuuk: 'Pacific/Chuuk',
    PacificEaster: 'Pacific/Easter',
    PacificEfate: 'Pacific/Efate',
    PacificEnderbury: 'Pacific/Enderbury',
    PacificFakaofo: 'Pacific/Fakaofo',
    PacificFiji: 'Pacific/Fiji',
    PacificFunafuti: 'Pacific/Funafuti',
    PacificGalapagos: 'Pacific/Galapagos',
    PacificGambier: 'Pacific/Gambier',
    PacificGuadalcanal: 'Pacific/Guadalcanal',
    PacificGuam: 'Pacific/Guam',
    PacificHonolulu: 'Pacific/Honolulu',
    PacificKiritimati: 'Pacific/Kiritimati',
    PacificKosrae: 'Pacific/Kosrae',
    PacificKwajalein: 'Pacific/Kwajalein',
    PacificMajuro: 'Pacific/Majuro',
    PacificMarquesas: 'Pacific/Marquesas',
    PacificNauru: 'Pacific/Nauru',
    PacificNiue: 'Pacific/Niue',
    PacificNorfolk: 'Pacific/Norfolk',
    PacificNoumea: 'Pacific/Noumea',
    PacificPagoPago: 'Pacific/Pago_Pago',
    PacificPalau: 'Pacific/Palau',
    PacificPitcairn: 'Pacific/Pitcairn',
    PacificPohnpei: 'Pacific/Pohnpei',
    PacificPortMoresby: 'Pacific/Port_Moresby',
    PacificRarotonga: 'Pacific/Rarotonga',
    PacificTahiti: 'Pacific/Tahiti',
    PacificTarawa: 'Pacific/Tarawa',
    PacificTongatapu: 'Pacific/Tongatapu',
    PacificWake: 'Pacific/Wake',
    PacificWallis: 'Pacific/Wallis',
    Wet: 'WET'
} as const;

export type CatalogsFeedProcessingScheduleTimezoneEnum = typeof CatalogsFeedProcessingScheduleTimezoneEnum[keyof typeof CatalogsFeedProcessingScheduleTimezoneEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const CatalogsFeedProcessingStatus = {
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Processing: 'PROCESSING'
} as const;

export type CatalogsFeedProcessingStatus = typeof CatalogsFeedProcessingStatus[keyof typeof CatalogsFeedProcessingStatus];


/**
 * The counts can be null early in the process.
 * @export
 * @interface CatalogsFeedProductCounts
 */
export interface CatalogsFeedProductCounts {
    /**
     * The number of products in the feed file.
     * @type {number}
     * @memberof CatalogsFeedProductCounts
     */
    'original'?: number;
    /**
     * The number of products successfully ingested from the feed file.
     * @type {number}
     * @memberof CatalogsFeedProductCounts
     */
    'ingested'?: number;
}
/**
 * 
 * @export
 * @interface CatalogsFeedValidationDetails
 */
export interface CatalogsFeedValidationDetails {
    /**
     * 
     * @type {CatalogsFeedValidationErrors}
     * @memberof CatalogsFeedValidationDetails
     */
    'errors': CatalogsFeedValidationErrors;
    /**
     * 
     * @type {CatalogsFeedValidationWarnings}
     * @memberof CatalogsFeedValidationDetails
     */
    'warnings': CatalogsFeedValidationWarnings;
}
/**
 * 
 * @export
 * @interface CatalogsFeedValidationErrors
 */
export interface CatalogsFeedValidationErrors {
    /**
     * Pinterest couldn\'t download your feed.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'FETCH_ERROR'?: number;
    /**
     * Your feed wasn\'t ingested because it hasnt changed in the previous 90 days.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'FETCH_INACTIVE_FEED_ERROR'?: number;
    /**
     * Your feed includes data with an unsupported encoding format.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'ENCODING_ERROR'?: number;
    /**
     * Your feed includes data with formatting errors.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'DELIMITER_ERROR'?: number;
    /**
     * Your feed is missing some required column headers.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'REQUIRED_COLUMNS_MISSING'?: number;
    /**
     * Some products are duplicated.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'DUPLICATE_PRODUCTS'?: number;
    /**
     * Some image links are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'IMAGE_LINK_INVALID'?: number;
    /**
     * Some items are missing an item id in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'ITEMID_MISSING'?: number;
    /**
     * Some items are missing a title in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'TITLE_MISSING'?: number;
    /**
     * Some items are missing a description in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'DESCRIPTION_MISSING'?: number;
    /**
     * Some items are missing a link URL in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'PRODUCT_LINK_MISSING'?: number;
    /**
     * Some items are missing an image link URL in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'IMAGE_LINK_MISSING'?: number;
    /**
     * Some items are missing an availability value in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'AVAILABILITY_INVALID'?: number;
    /**
     * Some items have price formatting errors in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'PRODUCT_PRICE_INVALID'?: number;
    /**
     * Some link values are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'LINK_FORMAT_INVALID'?: number;
    /**
     * Your feed contains formatting errors for some items.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'PARSE_LINE_ERROR'?: number;
    /**
     * Some adwords links contain too many characters.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'ADWORDS_FORMAT_INVALID'?: number;
    /**
     * We experienced a technical difficulty and were unable to ingest your feed. The next ingestion will happen in 24 hours.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'INTERNAL_SERVICE_ERROR'?: number;
    /**
     * Your merchant domain needs to be claimed.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'NO_VERIFIED_DOMAIN'?: number;
    /**
     * Some items have invalid adult values.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'ADULT_INVALID'?: number;
    /**
     * Some items have image_link URLs that contain too many characters, so those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'IMAGE_LINK_LENGTH_TOO_LONG'?: number;
    /**
     * Some of your product link values don\'t match the verified domain associated with this account.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'INVALID_DOMAIN'?: number;
    /**
     * Your feed contains too many items, some items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'FEED_LENGTH_TOO_LONG'?: number;
    /**
     * Some product links contain too many characters, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'LINK_LENGTH_TOO_LONG'?: number;
    /**
     * Your feed couldn\'t be validated because the xml file is formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'MALFORMED_XML'?: number;
    /**
     * Some products are missing a price, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'PRICE_MISSING'?: number;
    /**
     * Your feed couldn\'t be validated because the file doesn\'t contain the minimum number of lines required.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'FEED_TOO_SMALL'?: number;
    /**
     * Some items exceed the maximum number of items per item group, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED'?: number;
    /**
     * Some items\' main images can\'t be found.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE'?: number;
    /**
     * Some items were not published because they don\'t meet Pinterest\'s Merchant Guidelines.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'PINJOIN_CONTENT_UNSAFE'?: number;
    /**
     * Some items were not published because they don\'t meet Pinterest\'s Merchant Guidelines.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'BLOCKLISTED_IMAGE_SIGNATURE'?: number;
    /**
     * Some items have list price formatting errors in their product metadata, those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'LIST_PRICE_INVALID'?: number;
    /**
     * Some items were not published because price cannot be determined. The price, list price, and sale price are all different, so those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationErrors
     */
    'PRICE_CANNOT_BE_DETERMINED'?: number;
}
/**
 * 
 * @export
 * @interface CatalogsFeedValidationWarnings
 */
export interface CatalogsFeedValidationWarnings {
    /**
     * Some items have ad links that are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'AD_LINK_FORMAT_WARNING'?: number;
    /**
     * Some items have ad link URLs that are duplicates of the link URLs for those items.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'AD_LINK_SAME_AS_LINK'?: number;
    /**
     * The title for some items were truncated because they contain too many characters.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'TITLE_LENGTH_TOO_LONG'?: number;
    /**
     * The description for some items were truncated because they contain too many characters.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'DESCRIPTION_LENGTH_TOO_LONG'?: number;
    /**
     * Some items have gender values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'GENDER_INVALID'?: number;
    /**
     * Some items have age group values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'AGE_GROUP_INVALID'?: number;
    /**
     * Some items have size type values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SIZE_TYPE_INVALID'?: number;
    /**
     * Some items have size system values which are not one of the supported size systems.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SIZE_SYSTEM_INVALID'?: number;
    /**
     * Some items have an invalid product link which contains invalid UTM tracking paramaters.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'LINK_FORMAT_WARNING'?: number;
    /**
     * Some items have sale price values that are higher than the original price of the item.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SALES_PRICE_INVALID'?: number;
    /**
     * Some items only have 1 or 2 levels of google_product_category values, which may limit visibility in recommendations, search results and shopping experiences.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'PRODUCT_CATEGORY_DEPTH_WARNING'?: number;
    /**
     * Some items have adwords_redirect links that are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'ADWORDS_FORMAT_WARNING'?: number;
    /**
     * Some items have adwords_redirect URLs that are duplicates of the link URLs for those items.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'ADWORDS_SAME_AS_LINK'?: number;
    /**
     * Your feed contains duplicate headers.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'DUPLICATE_HEADERS'?: number;
    /**
     * Ingestion completed early because there are no changes to your feed since the last successful update.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'FETCH_SAME_SIGNATURE'?: CatalogsFeedValidationWarningsFETCHSAMESIGNATUREEnum;
    /**
     * Some items have additional_image_link URLs that contain too many characters, so those items will not be published.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG'?: number;
    /**
     * Some items have additional_image_link URLs that are formatted incorrectly and will not be published with your items.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'ADDITIONAL_IMAGE_LINK_WARNING'?: number;
    /**
     * Some items have image_link URLs that are formatted incorrectly and will not be published with those items.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'IMAGE_LINK_WARNING'?: number;
    /**
     * Some items have shipping values that are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SHIPPING_INVALID'?: number;
    /**
     * Some items have tax values that are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'TAX_INVALID'?: number;
    /**
     * Some items have invalid shipping_weight values.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SHIPPING_WEIGHT_INVALID'?: number;
    /**
     * Some items have expiration_date values that are formatted incorrectly, those items will be published without an expiration date.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'EXPIRATION_DATE_INVALID'?: number;
    /**
     * Some items have availability_date values that are formatted incorrectly, those items will be published without an availability date.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'AVAILABILITY_DATE_INVALID'?: number;
    /**
     * Some items have sale_price_effective_date values that are formatted incorrectly, those items will be published without a sale date.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SALE_DATE_INVALID'?: number;
    /**
     * Some items have weight_unit values that are formatted incorrectly, those items will be published without a weight unit.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'WEIGHT_UNIT_INVALID'?: number;
    /**
     * Some items have is_bundle values that are formatted incorrectly, those items will be published without being bundled with other products.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'IS_BUNDLE_INVALID'?: number;
    /**
     * Some items have updated_time values thate are formatted incorrectly, those items will be published without an updated time.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'UPDATED_TIME_INVALID'?: number;
    /**
     * Some items have custom_label values that are too long, those items will be published without that custom label.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'CUSTOM_LABEL_LENGTH_TOO_LONG'?: number;
    /**
     * Some items have product_type values that are too long, those items will be published without that product type.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'PRODUCT_TYPE_LENGTH_TOO_LONG'?: number;
    /**
     * Some items have additional_image_link values that exceed the limit for additional images, those items will be published without some of your images.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'TOO_MANY_ADDITIONAL_IMAGE_LINKS'?: number;
    /**
     * Some items have invalid multipack values.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'MULTIPACK_INVALID'?: number;
    /**
     * The product count has increased or decreased significantly compared to the last successful ingestion.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'INDEXED_PRODUCT_COUNT_LARGE_DELTA'?: number;
    /**
     * Some items include additional_image_links that can\'t be found.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE'?: number;
    /**
     * Some items are missing a google_product_category.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'OPTIONAL_PRODUCT_CATEGORY_MISSING'?: number;
    /**
     * Some items include google_product_category values that are not formatted correctly according to the GPC taxonomy.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'OPTIONAL_PRODUCT_CATEGORY_INVALID'?: number;
    /**
     * Some items are missing a condition value, which may limit visibility in recommendations, search results and shopping experiences.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'OPTIONAL_CONDITION_MISSING'?: number;
    /**
     * Some items include condition values that are formatted incorrectly, which may limit visibility in recommendations, search results and shopping experiences.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'OPTIONAL_CONDITION_INVALID'?: number;
    /**
     * Some items include invalid ios_deep_link values.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'IOS_DEEP_LINK_INVALID'?: number;
    /**
     * Some items include invalid android_deep_link.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'ANDROID_DEEP_LINK_INVALID'?: number;
    /**
     * Some items include utm_source values that are formatted incorrectly and have been automatically corrected.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'UTM_SOURCE_AUTO_CORRECTED'?: number;
    /**
     * Some items include a currency that doesn\'t match the usual currency for the location where that product is sold or shipped.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'COUNTRY_DOES_NOT_MAP_TO_CURRENCY'?: number;
    /**
     * Some items include min_ad_price values that are formatted incorrectly.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'MIN_AD_PRICE_INVALID'?: number;
    /**
     * Some items include incorrectly formatted GTINs.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'GTIN_INVALID'?: number;
    /**
     * Some items include inconsistent currencies in price fields.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'INCONSISTENT_CURRENCY_VALUES'?: number;
    /**
     * Some items include sales price that is much lower than the list price.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SALES_PRICE_TOO_LOW'?: number;
    /**
     * Some items include incorrectly formatted shipping_width.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SHIPPING_WIDTH_INVALID'?: number;
    /**
     * Some items include incorrectly formatted shipping_height.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SHIPPING_HEIGHT_INVALID'?: number;
    /**
     * Some items include a sales price that is higher than the list price. The sales price has been defaulted to the list price.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'SALES_PRICE_TOO_HIGH'?: number;
    /**
     * Some items include incorrectly formatted MPNs.
     * @type {number}
     * @memberof CatalogsFeedValidationWarnings
     */
    'MPN_INVALID'?: number;
}

export const CatalogsFeedValidationWarningsFETCHSAMESIGNATUREEnum = {
    NUMBER_1: 1
} as const;

export type CatalogsFeedValidationWarningsFETCHSAMESIGNATUREEnum = typeof CatalogsFeedValidationWarningsFETCHSAMESIGNATUREEnum[keyof typeof CatalogsFeedValidationWarningsFETCHSAMESIGNATUREEnum];

/**
 * Request object for creating a feed. Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.
 * @export
 * @interface CatalogsFeedsCreateRequest
 */
export interface CatalogsFeedsCreateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsFeedsCreateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsFeedsCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsFeedsCreateRequest
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedsCreateRequestDefaultLocale}
     * @memberof CatalogsFeedsCreateRequest
     */
    'default_locale'?: CatalogsFeedsCreateRequestDefaultLocale;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsFeedsCreateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsFeedsCreateRequest
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsFeedsCreateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsFeedsCreateRequest
     */
    'default_country'?: Country;
    /**
     * 
     * @type {ProductAvailabilityType}
     * @memberof CatalogsFeedsCreateRequest
     */
    'default_availability'?: ProductAvailabilityType | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsFeedsCreateRequest
     */
    'status'?: CatalogsStatus;
}


/**
 * The locale used within a feed for product descriptions.
 * @export
 * @interface CatalogsFeedsCreateRequestDefaultLocale
 */
export interface CatalogsFeedsCreateRequestDefaultLocale {
}
/**
 * Request object for updating a feed.
 * @export
 * @interface CatalogsFeedsUpdateRequest
 */
export interface CatalogsFeedsUpdateRequest {
    /**
     * 
     * @type {ProductAvailabilityType}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'default_availability'?: ProductAvailabilityType | null;
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'format'?: CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'location'?: string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsFeedsUpdateRequest
     */
    'status'?: CatalogsStatus;
}


/**
 * The file format of a feed.
 * @export
 * @enum {string}
 */

export const CatalogsFormat = {
    Tsv: 'TSV',
    Csv: 'CSV',
    Xml: 'XML'
} as const;

export type CatalogsFormat = typeof CatalogsFormat[keyof typeof CatalogsFormat];


/**
 * 
 * @export
 * @interface CatalogsHotelAddress
 */
export interface CatalogsHotelAddress {
    /**
     * Primary street address of hotel.
     * @type {string}
     * @memberof CatalogsHotelAddress
     */
    'addr1'?: string;
    /**
     * City where the hotel is located.
     * @type {string}
     * @memberof CatalogsHotelAddress
     */
    'city'?: string;
    /**
     * State, county, province, where the hotel is located.
     * @type {string}
     * @memberof CatalogsHotelAddress
     */
    'region'?: string;
    /**
     * Country where the hotel is located.
     * @type {string}
     * @memberof CatalogsHotelAddress
     */
    'country'?: string;
    /**
     * Required for countries with a postal code system. Postal or zip code of the hotel.
     * @type {string}
     * @memberof CatalogsHotelAddress
     */
    'postal_code'?: string;
}
/**
 * 
 * @export
 * @interface CatalogsHotelAttributes
 */
export interface CatalogsHotelAttributes {
    /**
     * The hotel\'s name.
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'name'?: string | null;
    /**
     * Link to the product page
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'link'?: string | null;
    /**
     * Brief description of the hotel.
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'description'?: string | null;
    /**
     * The brand to which this hotel belongs to.
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'brand'?: string | null;
    /**
     * Latitude of the hotel.
     * @type {number}
     * @memberof CatalogsHotelAttributes
     */
    'latitude'?: number;
    /**
     * Longitude of the hotel.
     * @type {number}
     * @memberof CatalogsHotelAttributes
     */
    'longitude'?: number | null;
    /**
     * A list of neighborhoods where the hotel is located
     * @type {Array<string>}
     * @memberof CatalogsHotelAttributes
     */
    'neighborhood'?: Array<string> | null;
    /**
     * 
     * @type {CatalogsHotelAddress}
     * @memberof CatalogsHotelAttributes
     */
    'address'?: CatalogsHotelAddress;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'custom_label_0'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'custom_label_1'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'custom_label_2'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'custom_label_3'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'custom_label_4'?: string | null;
    /**
     * The type of property. The category can be any type of internal description desired.
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'category'?: string | null;
    /**
     * Base price of the hotel room per night followed by the ISO currency code
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'base_price'?: string | null;
    /**
     * Sale price of a hotel room per night. Used to advertise discounts off the regular price of the hotel.
     * @type {string}
     * @memberof CatalogsHotelAttributes
     */
    'sale_price'?: string | null;
    /**
     * 
     * @type {CatalogsHotelGuestRatings}
     * @memberof CatalogsHotelAttributes
     */
    'guest_ratings'?: CatalogsHotelGuestRatings;
    /**
     * 
     * @type {CatalogsHotelAttributesAllOfMainImage}
     * @memberof CatalogsHotelAttributes
     */
    'main_image'?: CatalogsHotelAttributesAllOfMainImage;
    /**
     * <p><= 2000 characters</p> <p>The links to additional images for your hotel. Up to ten additional images can be used to show a hotel from different angles. Must begin with http:// or https://.</p>
     * @type {Array<string>}
     * @memberof CatalogsHotelAttributes
     */
    'additional_image_link'?: Array<string> | null;
}
/**
 * The main hotel image
 * @export
 * @interface CatalogsHotelAttributesAllOfMainImage
 */
export interface CatalogsHotelAttributesAllOfMainImage {
    /**
     * <p><= 2000 characters</p> <p>The link to the main hotel image. Image should be at least 75x75 pixels to avoid errors. Use the additional_image_link field to add more images of your hotel. The URL of your main_image.link must be accessible by the Pinterest user-agent, and send the accurate image. Please make sure there is no template or placeholder image at the link. Must start with http:// or https://.</p>
     * @type {string}
     * @memberof CatalogsHotelAttributesAllOfMainImage
     */
    'link'?: string;
    /**
     * Tag appended to the image that identifies image category or details. There can be multiple tags associated with an image
     * @type {Array<string>}
     * @memberof CatalogsHotelAttributesAllOfMainImage
     */
    'tag'?: Array<string> | null;
}
/**
 * Hotel batch item
 * @export
 * @interface CatalogsHotelBatchItem
 */
export interface CatalogsHotelBatchItem {
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof CatalogsHotelBatchItem
     */
    'hotel_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelBatchItem
     */
    'operation': CatalogsHotelBatchItemOperationEnum;
    /**
     * 
     * @type {CatalogsUpdatableHotelAttributes}
     * @memberof CatalogsHotelBatchItem
     */
    'attributes': CatalogsUpdatableHotelAttributes;
}

export const CatalogsHotelBatchItemOperationEnum = {
    Delete: 'DELETE'
} as const;

export type CatalogsHotelBatchItemOperationEnum = typeof CatalogsHotelBatchItemOperationEnum[keyof typeof CatalogsHotelBatchItemOperationEnum];

/**
 * Request object to update catalogs hotel items
 * @export
 * @interface CatalogsHotelBatchRequest
 */
export interface CatalogsHotelBatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelBatchRequest
     */
    'catalog_type': CatalogsHotelBatchRequestCatalogTypeEnum;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsHotelBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsHotelBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * Array with catalogs item operations
     * @type {Array<CatalogsHotelBatchItem>}
     * @memberof CatalogsHotelBatchRequest
     */
    'items': Array<CatalogsHotelBatchItem>;
    /**
     * Catalog id pertaining to the hotel item. If not provided, default to oldest hotel catalog
     * @type {string}
     * @memberof CatalogsHotelBatchRequest
     */
    'catalog_id'?: string;
}

export const CatalogsHotelBatchRequestCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelBatchRequestCatalogTypeEnum = typeof CatalogsHotelBatchRequestCatalogTypeEnum[keyof typeof CatalogsHotelBatchRequestCatalogTypeEnum];

/**
 * Catalogs Hotel Feed object
 * @export
 * @interface CatalogsHotelFeed
 */
export interface CatalogsHotelFeed {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'updated_at': string;
    /**
     * A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'name': string | null;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsHotelFeed
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsHotelFeed
     */
    'catalog_type': CatalogsType;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsHotelFeed
     */
    'credentials': CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsHotelFeed
     */
    'preferred_processing_schedule': CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsHotelFeed
     */
    'status': CatalogsStatus;
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsHotelFeed
     */
    'default_currency': NullableCurrency | null;
    /**
     * The locale used within a feed for product descriptions.
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'default_locale': string;
    /**
     * Catalog id pertaining to the feed. If not provided, feed will use a default catalog based on type.
     * @type {string}
     * @memberof CatalogsHotelFeed
     */
    'catalog_id': string | null;
}


/**
 * Request object for creating a feed. Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.
 * @export
 * @interface CatalogsHotelFeedsCreateRequest
 */
export interface CatalogsHotelFeedsCreateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedsCreateRequestDefaultLocale}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'default_locale': CatalogsFeedsCreateRequestDefaultLocale;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'catalog_type': CatalogsType;
    /**
     * Catalog id pertaining to the feed. If not provided, feed will use a default catalog based on type. At the moment a catalog can not have multiple hotel feeds but this will change in the future.
     * @type {string}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'catalog_id'?: string | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsHotelFeedsCreateRequest
     */
    'status'?: CatalogsStatus;
}


/**
 * Request object for updating a feed.
 * @export
 * @interface CatalogsHotelFeedsUpdateRequest
 */
export interface CatalogsHotelFeedsUpdateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'format'?: CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'location'?: string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'status'?: CatalogsStatus;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsHotelFeedsUpdateRequest
     */
    'catalog_type': CatalogsType;
}


/**
 * If specified, you must provide all properties
 * @export
 * @interface CatalogsHotelGuestRatings
 */
export interface CatalogsHotelGuestRatings {
    /**
     * Your hotel\'s rating.
     * @type {number}
     * @memberof CatalogsHotelGuestRatings
     */
    'score'?: number;
    /**
     * Total number of people who have rated this hotel.
     * @type {number}
     * @memberof CatalogsHotelGuestRatings
     */
    'number_of_reviewers'?: number;
    /**
     * Max value for the hotel rating score.
     * @type {number}
     * @memberof CatalogsHotelGuestRatings
     */
    'max_score'?: number;
    /**
     * System you use for guest reviews.
     * @type {string}
     * @memberof CatalogsHotelGuestRatings
     */
    'rating_system'?: string;
}
/**
 * Object describing a hotel item error
 * @export
 * @interface CatalogsHotelItemErrorResponse
 */
export interface CatalogsHotelItemErrorResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsHotelItemErrorResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof CatalogsHotelItemErrorResponse
     */
    'hotel_id'?: string;
    /**
     * Array with the errors for the item id requested
     * @type {Array<ItemValidationEvent>}
     * @memberof CatalogsHotelItemErrorResponse
     */
    'errors'?: Array<ItemValidationEvent>;
}


/**
 * Object describing a hotel record
 * @export
 * @interface CatalogsHotelItemResponse
 */
export interface CatalogsHotelItemResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsHotelItemResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof CatalogsHotelItemResponse
     */
    'hotel_id'?: string;
    /**
     * The pins mapped to the item
     * @type {Array<Pin>}
     * @memberof CatalogsHotelItemResponse
     */
    'pins'?: Array<Pin> | null;
    /**
     * 
     * @type {CatalogsHotelAttributes}
     * @memberof CatalogsHotelItemResponse
     */
    'attributes'?: CatalogsHotelAttributes;
}


/**
 * Object describing the catalogs hotel items batch
 * @export
 * @interface CatalogsHotelItemsBatch
 */
export interface CatalogsHotelItemsBatch {
    /**
     * Id of the catalogs items batch
     * @type {string}
     * @memberof CatalogsHotelItemsBatch
     */
    'batch_id'?: string;
    /**
     * Date and time (UTC) of the batch creation: YYYY-MM-DD\'T\'hh:mm:ss
     * @type {string}
     * @memberof CatalogsHotelItemsBatch
     */
    'created_time'?: string;
    /**
     * Date and time (UTC) of the batch completion: YYYY-MM-DD\'T\'hh:mm:ss
     * @type {string}
     * @memberof CatalogsHotelItemsBatch
     */
    'completed_time'?: string | null;
    /**
     * 
     * @type {BatchOperationStatus}
     * @memberof CatalogsHotelItemsBatch
     */
    'status'?: BatchOperationStatus;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsHotelItemsBatch
     */
    'catalog_type': CatalogsType;
    /**
     * Array with the catalogs items processing records part of the catalogs items batch
     * @type {Array<HotelProcessingRecord>}
     * @memberof CatalogsHotelItemsBatch
     */
    'items'?: Array<HotelProcessingRecord>;
}


/**
 * 
 * @export
 * @interface CatalogsHotelItemsFilter
 */
export interface CatalogsHotelItemsFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelItemsFilter
     */
    'catalog_type': CatalogsHotelItemsFilterCatalogTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsHotelItemsFilter
     */
    'hotel_ids': Array<string>;
    /**
     * Catalog id pertaining to the hotel item. If not provided, default to oldest hotel catalog
     * @type {string}
     * @memberof CatalogsHotelItemsFilter
     */
    'catalog_id'?: string;
}

export const CatalogsHotelItemsFilterCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelItemsFilterCatalogTypeEnum = typeof CatalogsHotelItemsFilterCatalogTypeEnum[keyof typeof CatalogsHotelItemsFilterCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsHotelItemsPostFilter
 */
export interface CatalogsHotelItemsPostFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelItemsPostFilter
     */
    'catalog_type': CatalogsHotelItemsPostFilterCatalogTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsHotelItemsPostFilter
     */
    'hotel_ids': Array<string>;
    /**
     * Catalog id pertaining to the hotel item. If not provided, default to oldest hotel catalog
     * @type {string}
     * @memberof CatalogsHotelItemsPostFilter
     */
    'catalog_id'?: string;
}

export const CatalogsHotelItemsPostFilterCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelItemsPostFilterCatalogTypeEnum = typeof CatalogsHotelItemsPostFilterCatalogTypeEnum[keyof typeof CatalogsHotelItemsPostFilterCatalogTypeEnum];

/**
 * Request object to list products for a given hotel catalog_id and product group filter.
 * @export
 * @interface CatalogsHotelListProductsByCatalogBasedFilterRequest
 */
export interface CatalogsHotelListProductsByCatalogBasedFilterRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelListProductsByCatalogBasedFilterRequest
     */
    'catalog_type': CatalogsHotelListProductsByCatalogBasedFilterRequestCatalogTypeEnum;
    /**
     * Catalog id pertaining to the hotel product group.
     * @type {string}
     * @memberof CatalogsHotelListProductsByCatalogBasedFilterRequest
     */
    'catalog_id': string;
    /**
     * 
     * @type {CatalogsHotelProductGroupFilters}
     * @memberof CatalogsHotelListProductsByCatalogBasedFilterRequest
     */
    'filters': CatalogsHotelProductGroupFilters;
}

export const CatalogsHotelListProductsByCatalogBasedFilterRequestCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelListProductsByCatalogBasedFilterRequestCatalogTypeEnum = typeof CatalogsHotelListProductsByCatalogBasedFilterRequestCatalogTypeEnum[keyof typeof CatalogsHotelListProductsByCatalogBasedFilterRequestCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsHotelProduct
 */
export interface CatalogsHotelProduct {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProduct
     */
    'catalog_type': CatalogsHotelProductCatalogTypeEnum;
    /**
     * 
     * @type {CatalogsHotelProductMetadata}
     * @memberof CatalogsHotelProduct
     */
    'metadata': CatalogsHotelProductMetadata;
    /**
     * 
     * @type {Pin}
     * @memberof CatalogsHotelProduct
     */
    'pin': Pin | null;
}

export const CatalogsHotelProductCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelProductCatalogTypeEnum = typeof CatalogsHotelProductCatalogTypeEnum[keyof typeof CatalogsHotelProductCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsHotelProductGroup
 */
export interface CatalogsHotelProductGroup {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroup
     */
    'catalog_type': CatalogsHotelProductGroupCatalogTypeEnum;
    /**
     * ID of the hotel product group.
     * @type {string}
     * @memberof CatalogsHotelProductGroup
     */
    'id': string;
    /**
     * Name of hotel product group
     * @type {string}
     * @memberof CatalogsHotelProductGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsHotelProductGroupFilters}
     * @memberof CatalogsHotelProductGroup
     */
    'filters': CatalogsHotelProductGroupFilters;
    /**
     * Unix timestamp in seconds of when catalog product group was created.
     * @type {number}
     * @memberof CatalogsHotelProductGroup
     */
    'created_at'?: number;
    /**
     * Unix timestamp in seconds of last time catalog product group was updated.
     * @type {number}
     * @memberof CatalogsHotelProductGroup
     */
    'updated_at'?: number;
    /**
     * Catalog id pertaining to the hotel product group.
     * @type {string}
     * @memberof CatalogsHotelProductGroup
     */
    'catalog_id': string;
}

export const CatalogsHotelProductGroupCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelProductGroupCatalogTypeEnum = typeof CatalogsHotelProductGroupCatalogTypeEnum[keyof typeof CatalogsHotelProductGroupCatalogTypeEnum];

/**
 * Request object for creating a hotel product group.
 * @export
 * @interface CatalogsHotelProductGroupCreateRequest
 */
export interface CatalogsHotelProductGroupCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupCreateRequest
     */
    'catalog_type': CatalogsHotelProductGroupCreateRequestCatalogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsHotelProductGroupFilters}
     * @memberof CatalogsHotelProductGroupCreateRequest
     */
    'filters': CatalogsHotelProductGroupFilters;
    /**
     * Catalog id pertaining to the hotel product group.
     * @type {string}
     * @memberof CatalogsHotelProductGroupCreateRequest
     */
    'catalog_id': string;
}

export const CatalogsHotelProductGroupCreateRequestCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelProductGroupCreateRequestCatalogTypeEnum = typeof CatalogsHotelProductGroupCreateRequestCatalogTypeEnum[keyof typeof CatalogsHotelProductGroupCreateRequestCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsHotelProductGroupFilterKeys
 */
export interface CatalogsHotelProductGroupFilterKeys {
    /**
     * 
     * @type {CatalogsProductGroupPricingCurrencyCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'PRICE': CatalogsProductGroupPricingCurrencyCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'HOTEL_ID': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'BRAND': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'CUSTOM_LABEL_0': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'CUSTOM_LABEL_1': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'CUSTOM_LABEL_2': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'CUSTOM_LABEL_3': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'CUSTOM_LABEL_4': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleCountriesCriteria}
     * @memberof CatalogsHotelProductGroupFilterKeys
     */
    'COUNTRY': CatalogsProductGroupMultipleCountriesCriteria;
}
/**
 * Object holding a group of filters for a hotel product group
 * @export
 * @interface CatalogsHotelProductGroupFilters
 */
export interface CatalogsHotelProductGroupFilters {
    /**
     * 
     * @type {Array<CatalogsHotelProductGroupFilterKeys>}
     * @memberof CatalogsHotelProductGroupFilters
     */
    'any_of': Array<CatalogsHotelProductGroupFilterKeys>;
    /**
     * 
     * @type {Array<CatalogsHotelProductGroupFilterKeys>}
     * @memberof CatalogsHotelProductGroupFilters
     */
    'all_of': Array<CatalogsHotelProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsHotelProductGroupFiltersAllOf
 */
export interface CatalogsHotelProductGroupFiltersAllOf {
    /**
     * 
     * @type {Array<CatalogsHotelProductGroupFilterKeys>}
     * @memberof CatalogsHotelProductGroupFiltersAllOf
     */
    'all_of': Array<CatalogsHotelProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsHotelProductGroupFiltersAnyOf
 */
export interface CatalogsHotelProductGroupFiltersAnyOf {
    /**
     * 
     * @type {Array<CatalogsHotelProductGroupFilterKeys>}
     * @memberof CatalogsHotelProductGroupFiltersAnyOf
     */
    'any_of': Array<CatalogsHotelProductGroupFilterKeys>;
}
/**
 * Product counts for a Hotel CatalogsProductGroup
 * @export
 * @interface CatalogsHotelProductGroupProductCounts
 */
export interface CatalogsHotelProductGroupProductCounts {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupProductCounts
     */
    'catalog_type': CatalogsHotelProductGroupProductCountsCatalogTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CatalogsHotelProductGroupProductCounts
     */
    'total': number;
}

export const CatalogsHotelProductGroupProductCountsCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelProductGroupProductCountsCatalogTypeEnum = typeof CatalogsHotelProductGroupProductCountsCatalogTypeEnum[keyof typeof CatalogsHotelProductGroupProductCountsCatalogTypeEnum];

/**
 * Request object for updating a hotel product group.
 * @export
 * @interface CatalogsHotelProductGroupUpdateRequest
 */
export interface CatalogsHotelProductGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupUpdateRequest
     */
    'catalog_type'?: CatalogsHotelProductGroupUpdateRequestCatalogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelProductGroupUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsHotelProductGroupFilters}
     * @memberof CatalogsHotelProductGroupUpdateRequest
     */
    'filters'?: CatalogsHotelProductGroupFilters;
}

export const CatalogsHotelProductGroupUpdateRequestCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelProductGroupUpdateRequestCatalogTypeEnum = typeof CatalogsHotelProductGroupUpdateRequestCatalogTypeEnum[keyof typeof CatalogsHotelProductGroupUpdateRequestCatalogTypeEnum];

/**
 * Hotel product metadata entity
 * @export
 * @interface CatalogsHotelProductMetadata
 */
export interface CatalogsHotelProductMetadata {
    /**
     * The user-created unique ID that represents the hotel item.
     * @type {string}
     * @memberof CatalogsHotelProductMetadata
     */
    'hotel_id': string;
}
/**
 * Parameters for hotel report
 * @export
 * @interface CatalogsHotelReportParameters
 */
export interface CatalogsHotelReportParameters {
    /**
     * 
     * @type {string}
     * @memberof CatalogsHotelReportParameters
     */
    'catalog_type': CatalogsHotelReportParametersCatalogTypeEnum;
    /**
     * 
     * @type {CatalogsHotelReportParametersReport}
     * @memberof CatalogsHotelReportParameters
     */
    'report': CatalogsHotelReportParametersReport;
}

export const CatalogsHotelReportParametersCatalogTypeEnum = {
    Hotel: 'HOTEL'
} as const;

export type CatalogsHotelReportParametersCatalogTypeEnum = typeof CatalogsHotelReportParametersCatalogTypeEnum[keyof typeof CatalogsHotelReportParametersCatalogTypeEnum];

/**
 * @type CatalogsHotelReportParametersReport
 * @export
 */
export type CatalogsHotelReportParametersReport = { report_type: 'DISTRIBUTION_ISSUES' } & CatalogsReportDistributionIssueFilter | { report_type: 'FEED_INGESTION_ISSUES' } & CatalogsReportFeedIngestionFilter;

/**
 * 
 * @export
 * @interface CatalogsItemValidationDetails
 */
export interface CatalogsItemValidationDetails {
    /**
     * 
     * @type {NullableCatalogsItemFieldType}
     * @memberof CatalogsItemValidationDetails
     */
    'attribute_name': NullableCatalogsItemFieldType | null;
    /**
     * Provided value that caused the validation issue.
     * @type {string}
     * @memberof CatalogsItemValidationDetails
     */
    'provided_value': string | null;
}


/**
 * 
 * @export
 * @interface CatalogsItemValidationErrors
 */
export interface CatalogsItemValidationErrors {
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'ADULT_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'ADWORDS_FORMAT_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'AVAILABILITY_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'BLOCKLISTED_IMAGE_SIGNATURE'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'DESCRIPTION_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'DUPLICATE_PRODUCTS'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'IMAGE_LINK_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'IMAGE_LINK_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'IMAGE_LINK_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'INVALID_DOMAIN'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'ITEMID_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'LINK_FORMAT_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'LINK_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'LIST_PRICE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'PARSE_LINE_ERROR'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'PINJOIN_CONTENT_UNSAFE'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'PRICE_CANNOT_BE_DETERMINED'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'PRICE_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'PRODUCT_LINK_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'PRODUCT_PRICE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationErrors
     */
    'TITLE_MISSING'?: CatalogsItemValidationDetails;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CatalogsItemValidationIssue = {
    AdLinkFormatWarning: 'AD_LINK_FORMAT_WARNING',
    AdLinkSameAsLink: 'AD_LINK_SAME_AS_LINK',
    AdditionalImageLinkLengthTooLong: 'ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG',
    AdditionalImageLinkWarning: 'ADDITIONAL_IMAGE_LINK_WARNING',
    AdultInvalid: 'ADULT_INVALID',
    AdwordsFormatInvalid: 'ADWORDS_FORMAT_INVALID',
    AdwordsFormatWarning: 'ADWORDS_FORMAT_WARNING',
    AdwordsSameAsLink: 'ADWORDS_SAME_AS_LINK',
    AgeGroupInvalid: 'AGE_GROUP_INVALID',
    AndroidDeepLinkInvalid: 'ANDROID_DEEP_LINK_INVALID',
    AvailabilityDateInvalid: 'AVAILABILITY_DATE_INVALID',
    AvailabilityInvalid: 'AVAILABILITY_INVALID',
    BlocklistedImageSignature: 'BLOCKLISTED_IMAGE_SIGNATURE',
    CountryDoesNotMapToCurrency: 'COUNTRY_DOES_NOT_MAP_TO_CURRENCY',
    CustomLabelLengthTooLong: 'CUSTOM_LABEL_LENGTH_TOO_LONG',
    DescriptionLengthTooLong: 'DESCRIPTION_LENGTH_TOO_LONG',
    DescriptionMissing: 'DESCRIPTION_MISSING',
    DuplicateProducts: 'DUPLICATE_PRODUCTS',
    ExpirationDateInvalid: 'EXPIRATION_DATE_INVALID',
    GenderInvalid: 'GENDER_INVALID',
    GtinInvalid: 'GTIN_INVALID',
    ImageLinkInvalid: 'IMAGE_LINK_INVALID',
    ImageLinkLengthTooLong: 'IMAGE_LINK_LENGTH_TOO_LONG',
    ImageLinkMissing: 'IMAGE_LINK_MISSING',
    ImageLinkWarning: 'IMAGE_LINK_WARNING',
    InvalidDomain: 'INVALID_DOMAIN',
    IosDeepLinkInvalid: 'IOS_DEEP_LINK_INVALID',
    IsBundleInvalid: 'IS_BUNDLE_INVALID',
    ItemAdditionalImageDownloadFailure: 'ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE',
    ItemMainImageDownloadFailure: 'ITEM_MAIN_IMAGE_DOWNLOAD_FAILURE',
    ItemidMissing: 'ITEMID_MISSING',
    LinkFormatInvalid: 'LINK_FORMAT_INVALID',
    LinkFormatWarning: 'LINK_FORMAT_WARNING',
    LinkLengthTooLong: 'LINK_LENGTH_TOO_LONG',
    ListPriceInvalid: 'LIST_PRICE_INVALID',
    MaxItemsPerItemGroupExceeded: 'MAX_ITEMS_PER_ITEM_GROUP_EXCEEDED',
    MinAdPriceInvalid: 'MIN_AD_PRICE_INVALID',
    MpnInvalid: 'MPN_INVALID',
    MultipackInvalid: 'MULTIPACK_INVALID',
    OptionalConditionInvalid: 'OPTIONAL_CONDITION_INVALID',
    OptionalConditionMissing: 'OPTIONAL_CONDITION_MISSING',
    OptionalProductCategoryInvalid: 'OPTIONAL_PRODUCT_CATEGORY_INVALID',
    OptionalProductCategoryMissing: 'OPTIONAL_PRODUCT_CATEGORY_MISSING',
    ParseLineError: 'PARSE_LINE_ERROR',
    PinjoinContentUnsafe: 'PINJOIN_CONTENT_UNSAFE',
    PriceCannotBeDetermined: 'PRICE_CANNOT_BE_DETERMINED',
    PriceMissing: 'PRICE_MISSING',
    ProductCategoryDepthWarning: 'PRODUCT_CATEGORY_DEPTH_WARNING',
    ProductLinkMissing: 'PRODUCT_LINK_MISSING',
    ProductPriceInvalid: 'PRODUCT_PRICE_INVALID',
    ProductTypeLengthTooLong: 'PRODUCT_TYPE_LENGTH_TOO_LONG',
    SaleDateInvalid: 'SALE_DATE_INVALID',
    SalesPriceInvalid: 'SALES_PRICE_INVALID',
    SalesPriceTooHigh: 'SALES_PRICE_TOO_HIGH',
    SalesPriceTooLow: 'SALES_PRICE_TOO_LOW',
    ShippingInvalid: 'SHIPPING_INVALID',
    ShippingHeightInvalid: 'SHIPPING_HEIGHT_INVALID',
    ShippingWeightInvalid: 'SHIPPING_WEIGHT_INVALID',
    ShippingWidthInvalid: 'SHIPPING_WIDTH_INVALID',
    SizeSystemInvalid: 'SIZE_SYSTEM_INVALID',
    SizeTypeInvalid: 'SIZE_TYPE_INVALID',
    TaxInvalid: 'TAX_INVALID',
    TitleLengthTooLong: 'TITLE_LENGTH_TOO_LONG',
    TitleMissing: 'TITLE_MISSING',
    TooManyAdditionalImageLinks: 'TOO_MANY_ADDITIONAL_IMAGE_LINKS',
    UtmSourceAutoCorrected: 'UTM_SOURCE_AUTO_CORRECTED',
    WeightUnitInvalid: 'WEIGHT_UNIT_INVALID'
} as const;

export type CatalogsItemValidationIssue = typeof CatalogsItemValidationIssue[keyof typeof CatalogsItemValidationIssue];


/**
 * 
 * @export
 * @interface CatalogsItemValidationIssues
 */
export interface CatalogsItemValidationIssues {
    /**
     * Item number based on order of appearance in the Catalogs Feed. For example, \'0\' refers to first item found in a feed that was downloaded from a \'location\' specified during feed creation.
     * @type {number}
     * @memberof CatalogsItemValidationIssues
     */
    'item_number': number;
    /**
     * The merchant-created unique ID that represents the product.
     * @type {string}
     * @memberof CatalogsItemValidationIssues
     */
    'item_id': string | null;
    /**
     * 
     * @type {CatalogsItemValidationErrors}
     * @memberof CatalogsItemValidationIssues
     */
    'errors': CatalogsItemValidationErrors;
    /**
     * 
     * @type {CatalogsItemValidationWarnings}
     * @memberof CatalogsItemValidationIssues
     */
    'warnings': CatalogsItemValidationWarnings;
}
/**
 * 
 * @export
 * @interface CatalogsItemValidationWarnings
 */
export interface CatalogsItemValidationWarnings {
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'AD_LINK_FORMAT_WARNING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'AD_LINK_SAME_AS_LINK'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'ADDITIONAL_IMAGE_LINK_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'ADDITIONAL_IMAGE_LINK_WARNING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'ADWORDS_FORMAT_WARNING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'ADWORDS_SAME_AS_LINK'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'AGE_GROUP_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SIZE_SYSTEM_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'ANDROID_DEEP_LINK_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'AVAILABILITY_DATE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'COUNTRY_DOES_NOT_MAP_TO_CURRENCY'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'CUSTOM_LABEL_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'DESCRIPTION_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'EXPIRATION_DATE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'GENDER_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'GTIN_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'IMAGE_LINK_WARNING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'IOS_DEEP_LINK_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'IS_BUNDLE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'ITEM_ADDITIONAL_IMAGE_DOWNLOAD_FAILURE'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'LINK_FORMAT_WARNING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'MIN_AD_PRICE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'MPN_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'MULTIPACK_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'OPTIONAL_CONDITION_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'OPTIONAL_CONDITION_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'OPTIONAL_PRODUCT_CATEGORY_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'OPTIONAL_PRODUCT_CATEGORY_MISSING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'PRODUCT_CATEGORY_DEPTH_WARNING'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'PRODUCT_TYPE_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SALES_PRICE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SALES_PRICE_TOO_LOW'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SALES_PRICE_TOO_HIGH'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SALE_DATE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SHIPPING_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SHIPPING_HEIGHT_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SHIPPING_WEIGHT_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SHIPPING_WIDTH_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'SIZE_TYPE_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'TAX_INVALID'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'TITLE_LENGTH_TOO_LONG'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'TOO_MANY_ADDITIONAL_IMAGE_LINKS'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'UTM_SOURCE_AUTO_CORRECTED'?: CatalogsItemValidationDetails;
    /**
     * 
     * @type {CatalogsItemValidationDetails}
     * @memberof CatalogsItemValidationWarnings
     */
    'WEIGHT_UNIT_INVALID'?: CatalogsItemValidationDetails;
}
/**
 * Response object of catalogs items
 * @export
 * @interface CatalogsItems
 */
export interface CatalogsItems {
    /**
     * Array with catalogs items
     * @type {Array<ItemResponse>}
     * @memberof CatalogsItems
     */
    'items'?: Array<ItemResponse>;
}
/**
 * @type CatalogsItemsBatch
 * Object describing the catalogs items batch
 * @export
 */
export type CatalogsItemsBatch = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsItemsBatch | { catalog_type: 'HOTEL' } & CatalogsHotelItemsBatch | { catalog_type: 'RETAIL' } & CatalogsRetailItemsBatch;

/**
 * @type CatalogsItemsBatchRequest
 * Request object of catalogs items batch
 * @export
 */
export type CatalogsItemsBatchRequest = { operation: 'CREATE' } & CatalogsItemsCreateBatchRequest | { operation: 'DELETE' } & CatalogsItemsDeleteBatchRequest | { operation: 'DELETE_DISCONTINUED' } & CatalogsItemsDeleteDiscontinuedBatchRequest | { operation: 'UPDATE' } & CatalogsItemsUpdateBatchRequest | { operation: 'UPSERT' } & CatalogsItemsUpsertBatchRequest;

/**
 * Request object to create catalogs items
 * @export
 * @interface CatalogsItemsCreateBatchRequest
 */
export interface CatalogsItemsCreateBatchRequest {
    /**
     * 
     * @type {Country}
     * @memberof CatalogsItemsCreateBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsItemsCreateBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * 
     * @type {BatchOperation}
     * @memberof CatalogsItemsCreateBatchRequest
     */
    'operation': BatchOperation;
    /**
     * Array with catalogs items
     * @type {Array<ItemCreateBatchRecord>}
     * @memberof CatalogsItemsCreateBatchRequest
     */
    'items': Array<ItemCreateBatchRecord>;
}


/**
 * Request object to delete catalogs items
 * @export
 * @interface CatalogsItemsDeleteBatchRequest
 */
export interface CatalogsItemsDeleteBatchRequest {
    /**
     * 
     * @type {Country}
     * @memberof CatalogsItemsDeleteBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsItemsDeleteBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * 
     * @type {BatchOperation}
     * @memberof CatalogsItemsDeleteBatchRequest
     */
    'operation': BatchOperation;
    /**
     * Array with catalogs items
     * @type {Array<ItemDeleteBatchRecord>}
     * @memberof CatalogsItemsDeleteBatchRequest
     */
    'items': Array<ItemDeleteBatchRecord>;
}


/**
 * Request object to discontinue catalogs items
 * @export
 * @interface CatalogsItemsDeleteDiscontinuedBatchRequest
 */
export interface CatalogsItemsDeleteDiscontinuedBatchRequest {
    /**
     * 
     * @type {Country}
     * @memberof CatalogsItemsDeleteDiscontinuedBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsItemsDeleteDiscontinuedBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * 
     * @type {BatchOperation}
     * @memberof CatalogsItemsDeleteDiscontinuedBatchRequest
     */
    'operation': BatchOperation;
    /**
     * Array with catalogs items
     * @type {Array<ItemDeleteDiscontinuedBatchRecord>}
     * @memberof CatalogsItemsDeleteDiscontinuedBatchRequest
     */
    'items': Array<ItemDeleteDiscontinuedBatchRecord>;
}


/**
 * @type CatalogsItemsFilters
 * @export
 */
export type CatalogsItemsFilters = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsItemsFilter | { catalog_type: 'HOTEL' } & CatalogsHotelItemsFilter | { catalog_type: 'RETAIL' } & CatalogsRetailItemsFilter;

/**
 * @type CatalogsItemsPostFilters
 * @export
 */
export type CatalogsItemsPostFilters = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsItemsPostFilter | { catalog_type: 'HOTEL' } & CatalogsHotelItemsPostFilter | { catalog_type: 'RETAIL' } & CatalogsRetailItemsPostFilter;

/**
 * Request object of catalogs items
 * @export
 * @interface CatalogsItemsRequest
 */
export interface CatalogsItemsRequest {
    /**
     * 
     * @type {Country}
     * @memberof CatalogsItemsRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsItemsRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * 
     * @type {CatalogsItemsPostFilters}
     * @memberof CatalogsItemsRequest
     */
    'filters': CatalogsItemsPostFilters;
}


/**
 * We recommend using the CatalogsLocale values.
 * @export
 * @interface CatalogsItemsRequestLanguage
 */
export interface CatalogsItemsRequestLanguage {
}
/**
 * Request object to update catalogs items
 * @export
 * @interface CatalogsItemsUpdateBatchRequest
 */
export interface CatalogsItemsUpdateBatchRequest {
    /**
     * 
     * @type {Country}
     * @memberof CatalogsItemsUpdateBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsItemsUpdateBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * 
     * @type {BatchOperation}
     * @memberof CatalogsItemsUpdateBatchRequest
     */
    'operation': BatchOperation;
    /**
     * Array with catalogs items
     * @type {Array<ItemUpdateBatchRecord>}
     * @memberof CatalogsItemsUpdateBatchRequest
     */
    'items': Array<ItemUpdateBatchRecord>;
}


/**
 * Request object to upsert catalogs items
 * @export
 * @interface CatalogsItemsUpsertBatchRequest
 */
export interface CatalogsItemsUpsertBatchRequest {
    /**
     * 
     * @type {Country}
     * @memberof CatalogsItemsUpsertBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsItemsUpsertBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * 
     * @type {BatchOperation}
     * @memberof CatalogsItemsUpsertBatchRequest
     */
    'operation': BatchOperation;
    /**
     * Array with catalogs items
     * @type {Array<ItemUpsertBatchRecord>}
     * @memberof CatalogsItemsUpsertBatchRequest
     */
    'items': Array<ItemUpsertBatchRecord>;
}


/**
 * 
 * @export
 * @interface CatalogsList200Response
 */
export interface CatalogsList200Response {
    /**
     * 
     * @type {Array<Catalog>}
     * @memberof CatalogsList200Response
     */
    'items': Array<Catalog>;
    /**
     * 
     * @type {string}
     * @memberof CatalogsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Request object to list products for a given feed_id and product group filter.
 * @export
 * @interface CatalogsListProductsByFeedBasedFilter
 */
export interface CatalogsListProductsByFeedBasedFilter {
    /**
     * Catalog Feed id pertaining to the catalog product group filter.
     * @type {string}
     * @memberof CatalogsListProductsByFeedBasedFilter
     */
    'feed_id': string;
    /**
     * 
     * @type {CatalogsProductGroupFilters}
     * @memberof CatalogsListProductsByFeedBasedFilter
     */
    'filters': CatalogsProductGroupFilters;
}
/**
 * @type CatalogsListProductsByFilterRequest
 * Request object to list products for a given product group filter.
 * @export
 */
export type CatalogsListProductsByFilterRequest = CatalogsListProductsByFeedBasedFilter | CatalogsVerticalsListProductsByCatalogBasedFilterRequest;

/**
 * 
 * @export
 * @enum {string}
 */

export const CatalogsLocale = {
    AfZa: 'af-ZA',
    ArSa: 'ar-SA',
    BgBg: 'bg-BG',
    BnIn: 'bn-IN',
    CsCz: 'cs-CZ',
    DaDk: 'da-DK',
    De: 'de',
    ElGr: 'el-GR',
    EnAu: 'en-AU',
    EnCa: 'en-CA',
    EnGb: 'en-GB',
    EnIn: 'en-IN',
    EnUs: 'en-US',
    Es419: 'es-419',
    EsAr: 'es-AR',
    EsEs: 'es-ES',
    EsMx: 'es-MX',
    FiFi: 'fi-FI',
    Fr: 'fr',
    FrCa: 'fr-CA',
    HeIl: 'he-IL',
    HiIn: 'hi-IN',
    HrHr: 'hr-HR',
    HuHu: 'hu-HU',
    IdId: 'id-ID',
    It: 'it',
    Ja: 'ja',
    KoKr: 'ko-KR',
    MsMy: 'ms-MY',
    NbNo: 'nb-NO',
    Nl: 'nl',
    PlPl: 'pl-PL',
    PtBr: 'pt-BR',
    PtPt: 'pt-PT',
    RoRo: 'ro-RO',
    RuRu: 'ru-RU',
    SkSk: 'sk-SK',
    SvSe: 'sv-SE',
    TeIn: 'te-IN',
    ThTh: 'th-TH',
    TlPh: 'tl-PH',
    Tr: 'tr',
    UkUa: 'uk-UA',
    ViVn: 'vi-VN',
    ZhCn: 'zh-CN',
    ZhTw: 'zh-TW'
} as const;

export type CatalogsLocale = typeof CatalogsLocale[keyof typeof CatalogsLocale];


/**
 * @type CatalogsProduct
 * Catalogs product for all verticals
 * @export
 */
export type CatalogsProduct = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsProduct | { catalog_type: 'HOTEL' } & CatalogsHotelProduct | { catalog_type: 'RETAIL' } & CatalogsRetailProduct;

/**
 * Request object for creating a product group.
 * @export
 * @interface CatalogsProductGroupCreateRequest
 */
export interface CatalogsProductGroupCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupCreateRequest
     */
    'description'?: string | null;
    /**
     * boolean indicator of whether the product group is being featured or not
     * @type {boolean}
     * @memberof CatalogsProductGroupCreateRequest
     * @deprecated
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {CatalogsProductGroupFiltersRequest}
     * @memberof CatalogsProductGroupCreateRequest
     */
    'filters': CatalogsProductGroupFiltersRequest;
    /**
     * Catalog Feed id pertaining to the catalog product group.
     * @type {string}
     * @memberof CatalogsProductGroupCreateRequest
     */
    'feed_id': string;
}
/**
 * A currency filter. This filter cannot be negated
 * @export
 * @interface CatalogsProductGroupCurrencyCriteria
 */
export interface CatalogsProductGroupCurrencyCriteria {
    /**
     * 
     * @type {NonNullableCatalogsCurrency}
     * @memberof CatalogsProductGroupCurrencyCriteria
     */
    'values': NonNullableCatalogsCurrency;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupCurrencyCriteria
     */
    'negated'?: boolean;
}


/**
 * 
 * @export
 * @interface CatalogsProductGroupFilterKeys
 */
export interface CatalogsProductGroupFilterKeys {
    /**
     * 
     * @type {CatalogsProductGroupPricingCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'MIN_PRICE': CatalogsProductGroupPricingCriteria;
    /**
     * 
     * @type {CatalogsProductGroupPricingCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'MAX_PRICE': CatalogsProductGroupPricingCriteria;
    /**
     * 
     * @type {CatalogsProductGroupCurrencyCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CURRENCY': CatalogsProductGroupCurrencyCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'ITEM_ID': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'AVAILABILITY': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'BRAND': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CONDITION': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_0': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_1': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_2': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_3': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'CUSTOM_LABEL_4': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'ITEM_GROUP_ID': CatalogsProductGroupMultipleStringCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleGenderCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GENDER': CatalogsProductGroupMultipleGenderCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleMediaTypesCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'MEDIA_TYPE': CatalogsProductGroupMultipleMediaTypesCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'PRODUCT_TYPE_4': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'PRODUCT_TYPE_3': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'PRODUCT_TYPE_2': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'PRODUCT_TYPE_1': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'PRODUCT_TYPE_0': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_6': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_5': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_4': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_3': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_2': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_1': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'GOOGLE_PRODUCT_CATEGORY_0': CatalogsProductGroupMultipleStringListCriteria;
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CatalogsProductGroupFilterKeys
     */
    'PRODUCT_GROUP': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Object holding a group of filters for a catalog product group
 * @export
 * @interface CatalogsProductGroupFilters
 */
export interface CatalogsProductGroupFilters {
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFilters
     */
    'any_of': Array<CatalogsProductGroupFilterKeys>;
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFilters
     */
    'all_of': Array<CatalogsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupFiltersAllOf
 */
export interface CatalogsProductGroupFiltersAllOf {
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFiltersAllOf
     */
    'all_of': Array<CatalogsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupFiltersAnyOf
 */
export interface CatalogsProductGroupFiltersAnyOf {
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFiltersAnyOf
     */
    'any_of': Array<CatalogsProductGroupFilterKeys>;
}
/**
 * Object holding a group of filters for request on catalog product group. This is a distinct schema It is not possible to create or update a Product Group with empty filters. But some automatically generated Product Groups might have empty filters.
 * @export
 * @interface CatalogsProductGroupFiltersRequest
 */
export interface CatalogsProductGroupFiltersRequest {
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFiltersRequest
     */
    'any_of': Array<CatalogsProductGroupFilterKeys>;
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFiltersRequest
     */
    'all_of': Array<CatalogsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupFiltersRequestAnyOf
 */
export interface CatalogsProductGroupFiltersRequestAnyOf {
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFiltersRequestAnyOf
     */
    'any_of': Array<CatalogsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupFiltersRequestAnyOf1
 */
export interface CatalogsProductGroupFiltersRequestAnyOf1 {
    /**
     * 
     * @type {Array<CatalogsProductGroupFilterKeys>}
     * @memberof CatalogsProductGroupFiltersRequestAnyOf1
     */
    'all_of': Array<CatalogsProductGroupFilterKeys>;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupMultipleCountriesCriteria
 */
export interface CatalogsProductGroupMultipleCountriesCriteria {
    /**
     * 
     * @type {Array<Country>}
     * @memberof CatalogsProductGroupMultipleCountriesCriteria
     */
    'values': Array<Country>;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupMultipleCountriesCriteria
     */
    'negated'?: boolean;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupMultipleGenderCriteria
 */
export interface CatalogsProductGroupMultipleGenderCriteria {
    /**
     * 
     * @type {Array<Gender>}
     * @memberof CatalogsProductGroupMultipleGenderCriteria
     */
    'values': Array<Gender>;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupMultipleGenderCriteria
     */
    'negated'?: boolean;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupMultipleMediaTypesCriteria
 */
export interface CatalogsProductGroupMultipleMediaTypesCriteria {
    /**
     * 
     * @type {Array<MediaType>}
     * @memberof CatalogsProductGroupMultipleMediaTypesCriteria
     */
    'values': Array<MediaType>;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupMultipleMediaTypesCriteria
     */
    'negated'?: boolean;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupMultipleStringCriteria
 */
export interface CatalogsProductGroupMultipleStringCriteria {
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsProductGroupMultipleStringCriteria
     */
    'values': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupMultipleStringCriteria
     */
    'negated'?: boolean;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupMultipleStringListCriteria
 */
export interface CatalogsProductGroupMultipleStringListCriteria {
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof CatalogsProductGroupMultipleStringListCriteria
     */
    'values': Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupMultipleStringListCriteria
     */
    'negated'?: boolean;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupPinsList200Response
 */
export interface CatalogsProductGroupPinsList200Response {
    /**
     * Pins
     * @type {Array<CatalogsProduct>}
     * @memberof CatalogsProductGroupPinsList200Response
     */
    'items': Array<CatalogsProduct>;
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupPinsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupPricingCriteria
 */
export interface CatalogsProductGroupPricingCriteria {
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupPricingCriteria
     */
    'inclusion'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof CatalogsProductGroupPricingCriteria
     */
    'values': number;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupPricingCriteria
     */
    'negated'?: boolean;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupPricingCurrencyCriteria
 */
export interface CatalogsProductGroupPricingCurrencyCriteria {
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupPricingCurrencyCriteria
     */
    'operator': CatalogsProductGroupPricingCurrencyCriteriaOperatorEnum;
    /**
     * 
     * @type {number}
     * @memberof CatalogsProductGroupPricingCurrencyCriteria
     */
    'value': number;
    /**
     * 
     * @type {NonNullableCatalogsCurrency}
     * @memberof CatalogsProductGroupPricingCurrencyCriteria
     */
    'currency': NonNullableCatalogsCurrency;
    /**
     * 
     * @type {boolean}
     * @memberof CatalogsProductGroupPricingCurrencyCriteria
     */
    'negated'?: boolean;
}

export const CatalogsProductGroupPricingCurrencyCriteriaOperatorEnum = {
    GreaterThan: 'GREATER_THAN',
    GreaterThanOrEquals: 'GREATER_THAN_OR_EQUALS',
    LessThan: 'LESS_THAN',
    LessThanOrEquals: 'LESS_THAN_OR_EQUALS'
} as const;

export type CatalogsProductGroupPricingCurrencyCriteriaOperatorEnum = typeof CatalogsProductGroupPricingCurrencyCriteriaOperatorEnum[keyof typeof CatalogsProductGroupPricingCurrencyCriteriaOperatorEnum];

/**
 * @type CatalogsProductGroupProductCountsVertical
 * Product counts for a CatalogsProductGroup
 * @export
 */
export type CatalogsProductGroupProductCountsVertical = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsProductGroupProductCounts | { catalog_type: 'HOTEL' } & CatalogsHotelProductGroupProductCounts | { catalog_type: 'RETAIL' } & CatalogsRetailProductGroupProductCounts;

/**
 * 
 * @export
 * @enum {string}
 */

export const CatalogsProductGroupStatus = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type CatalogsProductGroupStatus = typeof CatalogsProductGroupStatus[keyof typeof CatalogsProductGroupStatus];


/**
 * <p>Catalog product group type</p> <p>MERCHANT_CREATED: Product groups created by merchants. <br>ALL_PRODUCTS: Consists of every product in your latest successful feed upload. <br>BEST_DEALS: Consists of products with the deepest drop in price. <br>PINNER_FAVORITES: Consists of products that are resonating most with people on Pinterest, based on engagement. <br>TOP_SELLERS: Consists of products with the highest conversion rate, if you have the conversion tag installed. <br>BACK_IN_STOCK: Consists of products that were previously out of stock and are now in stock. <br>NEW_ARRIVALS: Consists of products that are new to your Catalog. <br>SHOPIFY_COLLECTION: Product groups created based on Shopify Product Collections. <br>I2PC: Product groups created based on predicted product category.</p>
 * @export
 * @enum {string}
 */

export const CatalogsProductGroupType = {
    MerchantCreated: 'MERCHANT_CREATED',
    AllProducts: 'ALL_PRODUCTS',
    BestDeals: 'BEST_DEALS',
    PinnerFavorites: 'PINNER_FAVORITES',
    TopSellers: 'TOP_SELLERS',
    BackInStock: 'BACK_IN_STOCK',
    NewArrivals: 'NEW_ARRIVALS',
    ShopifyCollections: 'SHOPIFY_COLLECTIONS',
    I2Pc: 'I2PC'
} as const;

export type CatalogsProductGroupType = typeof CatalogsProductGroupType[keyof typeof CatalogsProductGroupType];


/**
 * Request object for updating a product group.
 * @export
 * @interface CatalogsProductGroupUpdateRequest
 */
export interface CatalogsProductGroupUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupUpdateRequest
     */
    'description'?: string | null;
    /**
     * boolean indicator of whether the product group is being featured or not
     * @type {boolean}
     * @memberof CatalogsProductGroupUpdateRequest
     * @deprecated
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {CatalogsProductGroupFiltersRequest}
     * @memberof CatalogsProductGroupUpdateRequest
     */
    'filters'?: CatalogsProductGroupFiltersRequest;
}
/**
 * 
 * @export
 * @interface CatalogsProductGroupsList200Response
 */
export interface CatalogsProductGroupsList200Response {
    /**
     * 
     * @type {Array<CatalogsVerticalProductGroup>}
     * @memberof CatalogsProductGroupsList200Response
     */
    'items': Array<CatalogsVerticalProductGroup>;
    /**
     * 
     * @type {string}
     * @memberof CatalogsProductGroupsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * @type CatalogsProductGroupsUpdateRequest
 * @export
 */
export type CatalogsProductGroupsUpdateRequest = CatalogsProductGroupUpdateRequest | CatalogsVerticalProductGroupUpdateRequest;

/**
 * 
 * @export
 * @interface CatalogsReport
 */
export interface CatalogsReport {
    /**
     * 
     * @type {string}
     * @memberof CatalogsReport
     */
    'report_status'?: CatalogsReportReportStatusEnum;
    /**
     * URL to download the report
     * @type {string}
     * @memberof CatalogsReport
     */
    'url'?: string | null;
    /**
     * Size of the report in bytes
     * @type {number}
     * @memberof CatalogsReport
     */
    'size'?: number | null;
}

export const CatalogsReportReportStatusEnum = {
    Finished: 'FINISHED',
    InProgress: 'IN_PROGRESS'
} as const;

export type CatalogsReportReportStatusEnum = typeof CatalogsReportReportStatusEnum[keyof typeof CatalogsReportReportStatusEnum];

/**
 * 
 * @export
 * @interface CatalogsReportDistributionIssueFilter
 */
export interface CatalogsReportDistributionIssueFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsReportDistributionIssueFilter
     */
    'report_type': CatalogsReportDistributionIssueFilterReportTypeEnum;
    /**
     * Unique identifier of a catalog. If not given, oldest catalog will be used
     * @type {string}
     * @memberof CatalogsReportDistributionIssueFilter
     */
    'catalog_id'?: string;
}

export const CatalogsReportDistributionIssueFilterReportTypeEnum = {
    DistributionIssues: 'DISTRIBUTION_ISSUES'
} as const;

export type CatalogsReportDistributionIssueFilterReportTypeEnum = typeof CatalogsReportDistributionIssueFilterReportTypeEnum[keyof typeof CatalogsReportDistributionIssueFilterReportTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsReportDistributionStats
 */
export interface CatalogsReportDistributionStats {
    /**
     * 
     * @type {string}
     * @memberof CatalogsReportDistributionStats
     */
    'report_type'?: CatalogsReportDistributionStatsReportTypeEnum;
    /**
     * ID of the catalog entity.
     * @type {string}
     * @memberof CatalogsReportDistributionStats
     */
    'catalog_id'?: string;
    /**
     * The event code that a diagnostics aggregated number references
     * @type {number}
     * @memberof CatalogsReportDistributionStats
     */
    'code'?: number;
    /**
     * A human-friendly label for the event code (e.g, \'SPAM\')
     * @type {string}
     * @memberof CatalogsReportDistributionStats
     */
    'code_label'?: string;
    /**
     * Title message describing the diagnostic issue
     * @type {string}
     * @memberof CatalogsReportDistributionStats
     */
    'message'?: string;
    /**
     * Number of occurrences of the issue
     * @type {number}
     * @memberof CatalogsReportDistributionStats
     */
    'occurrences'?: number;
    /**
     * Indicates if issue makes items ineligible for ads distribution
     * @type {boolean}
     * @memberof CatalogsReportDistributionStats
     */
    'ineligible_for_ads'?: boolean;
    /**
     * Indicates if issue makes items ineligible for organic distribution
     * @type {boolean}
     * @memberof CatalogsReportDistributionStats
     */
    'ineligible_for_organic'?: boolean;
}

export const CatalogsReportDistributionStatsReportTypeEnum = {
    DistributionIssues: 'DISTRIBUTION_ISSUES'
} as const;

export type CatalogsReportDistributionStatsReportTypeEnum = typeof CatalogsReportDistributionStatsReportTypeEnum[keyof typeof CatalogsReportDistributionStatsReportTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsReportFeedIngestionFilter
 */
export interface CatalogsReportFeedIngestionFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsReportFeedIngestionFilter
     */
    'report_type': CatalogsReportFeedIngestionFilterReportTypeEnum;
    /**
     * ID of the feed entity.
     * @type {string}
     * @memberof CatalogsReportFeedIngestionFilter
     */
    'feed_id': string;
    /**
     * Unique identifier of a feed processing result. It can be acquired from the \"id\" field of the \"items\" array within the response of the [List processing results for a given feed](/docs/api/v5/#operation/feed_processing_results/list). If not provided, default to most recent completed processing result.
     * @type {string}
     * @memberof CatalogsReportFeedIngestionFilter
     */
    'processing_result_id'?: string;
}

export const CatalogsReportFeedIngestionFilterReportTypeEnum = {
    FeedIngestionIssues: 'FEED_INGESTION_ISSUES'
} as const;

export type CatalogsReportFeedIngestionFilterReportTypeEnum = typeof CatalogsReportFeedIngestionFilterReportTypeEnum[keyof typeof CatalogsReportFeedIngestionFilterReportTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsReportFeedIngestionStats
 */
export interface CatalogsReportFeedIngestionStats {
    /**
     * 
     * @type {string}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'report_type'?: CatalogsReportFeedIngestionStatsReportTypeEnum;
    /**
     * ID of the catalog entity.
     * @type {string}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'catalog_id'?: string;
    /**
     * The event code that a diagnostics aggregated number references
     * @type {number}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'code'?: number;
    /**
     * A human-friendly label for the event code (e.g, \'AVAILABILITY_INVALID\')
     * @type {string}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'code_label'?: string;
    /**
     * Title message describing the diagnostic issue
     * @type {string}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'message'?: string;
    /**
     * Number of occurrences of the issue
     * @type {number}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'occurrences'?: number;
    /**
     * An ERROR means that items have been dropped, while a WARN denotes that items have been ingested despite an issue
     * @type {string}
     * @memberof CatalogsReportFeedIngestionStats
     */
    'severity'?: CatalogsReportFeedIngestionStatsSeverityEnum;
}

export const CatalogsReportFeedIngestionStatsReportTypeEnum = {
    FeedIngestionIssues: 'FEED_INGESTION_ISSUES'
} as const;

export type CatalogsReportFeedIngestionStatsReportTypeEnum = typeof CatalogsReportFeedIngestionStatsReportTypeEnum[keyof typeof CatalogsReportFeedIngestionStatsReportTypeEnum];
export const CatalogsReportFeedIngestionStatsSeverityEnum = {
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type CatalogsReportFeedIngestionStatsSeverityEnum = typeof CatalogsReportFeedIngestionStatsSeverityEnum[keyof typeof CatalogsReportFeedIngestionStatsSeverityEnum];

/**
 * @type CatalogsReportParameters
 * Report parameters
 * @export
 */
export type CatalogsReportParameters = { catalog_type: 'HOTEL' } & CatalogsHotelReportParameters | { catalog_type: 'RETAIL' } & CatalogsRetailReportParameters;

/**
 * @type CatalogsReportStats
 * Diagnostics aggregated numbers
 * @export
 */
export type CatalogsReportStats = { report_type: 'DISTRIBUTION_ISSUES' } & CatalogsReportDistributionStats | { report_type: 'FEED_INGESTION_ISSUES' } & CatalogsReportFeedIngestionStats;

/**
 * A request object that can have multiple operations on a single retail batch
 * @export
 * @interface CatalogsRetailBatchRequest
 */
export interface CatalogsRetailBatchRequest {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailBatchRequest
     */
    'catalog_type': CatalogsRetailBatchRequestCatalogTypeEnum;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsRetailBatchRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsItemsRequestLanguage}
     * @memberof CatalogsRetailBatchRequest
     */
    'language': CatalogsItemsRequestLanguage;
    /**
     * Array with catalogs item operations
     * @type {Array<CatalogsRetailBatchRequestItemsInner>}
     * @memberof CatalogsRetailBatchRequest
     */
    'items': Array<CatalogsRetailBatchRequestItemsInner>;
}

export const CatalogsRetailBatchRequestCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailBatchRequestCatalogTypeEnum = typeof CatalogsRetailBatchRequestCatalogTypeEnum[keyof typeof CatalogsRetailBatchRequestCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsRetailBatchRequestItemsInner
 */
export interface CatalogsRetailBatchRequestItemsInner {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsRetailBatchRequestItemsInner
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailBatchRequestItemsInner
     */
    'operation': CatalogsRetailBatchRequestItemsInnerOperationEnum;
    /**
     * 
     * @type {ItemAttributesRequest}
     * @memberof CatalogsRetailBatchRequestItemsInner
     */
    'attributes': ItemAttributesRequest;
    /**
     * The list of product attributes to be updated. Attributes specified in the update mask without a value specified in the body will be deleted from the product item.
     * @type {Array<UpdateMaskFieldType>}
     * @memberof CatalogsRetailBatchRequestItemsInner
     */
    'update_mask'?: Array<UpdateMaskFieldType> | null;
}

export const CatalogsRetailBatchRequestItemsInnerOperationEnum = {
    Delete: 'DELETE'
} as const;

export type CatalogsRetailBatchRequestItemsInnerOperationEnum = typeof CatalogsRetailBatchRequestItemsInnerOperationEnum[keyof typeof CatalogsRetailBatchRequestItemsInnerOperationEnum];

/**
 * Catalogs Retail Feed object
 * @export
 * @interface CatalogsRetailFeed
 */
export interface CatalogsRetailFeed {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailFeed
     */
    'created_at': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailFeed
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailFeed
     */
    'updated_at': string;
    /**
     * A human-friendly name associated to a given feed. This value is currently nullable due to historical reasons. It is expected to become non-nullable in the future.
     * @type {string}
     * @memberof CatalogsRetailFeed
     */
    'name': string | null;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsRetailFeed
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsRetailFeed
     */
    'catalog_type': CatalogsType;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsRetailFeed
     */
    'credentials': CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsRetailFeed
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsRetailFeed
     */
    'preferred_processing_schedule': CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsRetailFeed
     */
    'status': CatalogsStatus;
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsRetailFeed
     */
    'default_currency': NullableCurrency | null;
    /**
     * The locale used within a feed for product descriptions.
     * @type {string}
     * @memberof CatalogsRetailFeed
     */
    'default_locale': string;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsRetailFeed
     */
    'default_country': Country;
    /**
     * 
     * @type {ProductAvailabilityType}
     * @memberof CatalogsRetailFeed
     */
    'default_availability': ProductAvailabilityType | null;
}


/**
 * Request object for creating a retail feed.
 * @export
 * @interface CatalogsRetailFeedsCreateRequest
 */
export interface CatalogsRetailFeedsCreateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'format': CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedsCreateRequestDefaultLocale}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'default_locale': CatalogsFeedsCreateRequestDefaultLocale;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'location': string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'catalog_type': CatalogsType;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'default_country': Country;
    /**
     * 
     * @type {ProductAvailabilityType}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'default_availability'?: ProductAvailabilityType | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsRetailFeedsCreateRequest
     */
    'status'?: CatalogsStatus;
}


/**
 * Request object for updating a feed.
 * @export
 * @interface CatalogsRetailFeedsUpdateRequest
 */
export interface CatalogsRetailFeedsUpdateRequest {
    /**
     * 
     * @type {NullableCurrency}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'default_currency'?: NullableCurrency | null;
    /**
     * A human-friendly name associated to a given feed.
     * @type {string}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {CatalogsFormat}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'format'?: CatalogsFormat;
    /**
     * 
     * @type {CatalogsFeedCredentials}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'credentials'?: CatalogsFeedCredentials | null;
    /**
     * The URL where a feed is available for download. This URL is what Pinterest will use to download a feed for processing.
     * @type {string}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'location'?: string;
    /**
     * 
     * @type {CatalogsFeedProcessingSchedule}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'preferred_processing_schedule'?: CatalogsFeedProcessingSchedule | null;
    /**
     * 
     * @type {CatalogsStatus}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'status'?: CatalogsStatus;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'catalog_type': CatalogsType;
    /**
     * 
     * @type {ProductAvailabilityType}
     * @memberof CatalogsRetailFeedsUpdateRequest
     */
    'default_availability'?: ProductAvailabilityType | null;
}


/**
 * Object describing a retail item error
 * @export
 * @interface CatalogsRetailItemErrorResponse
 */
export interface CatalogsRetailItemErrorResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsRetailItemErrorResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsRetailItemErrorResponse
     */
    'item_id'?: string;
    /**
     * Array with the errors for the item id requested
     * @type {Array<ItemValidationEvent>}
     * @memberof CatalogsRetailItemErrorResponse
     */
    'errors'?: Array<ItemValidationEvent>;
}


/**
 * Object describing a retail item record
 * @export
 * @interface CatalogsRetailItemResponse
 */
export interface CatalogsRetailItemResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsRetailItemResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog retail item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsRetailItemResponse
     */
    'item_id'?: string;
    /**
     * The pins mapped to the item
     * @type {Array<Pin>}
     * @memberof CatalogsRetailItemResponse
     */
    'pins'?: Array<Pin> | null;
    /**
     * 
     * @type {ItemAttributes}
     * @memberof CatalogsRetailItemResponse
     */
    'attributes'?: ItemAttributes;
}


/**
 * Object describing the catalogs retail items batch
 * @export
 * @interface CatalogsRetailItemsBatch
 */
export interface CatalogsRetailItemsBatch {
    /**
     * Id of the catalogs items batch
     * @type {string}
     * @memberof CatalogsRetailItemsBatch
     */
    'batch_id'?: string;
    /**
     * Date and time (UTC) of the batch creation: YYYY-MM-DD\'T\'hh:mm:ss
     * @type {string}
     * @memberof CatalogsRetailItemsBatch
     */
    'created_time'?: string;
    /**
     * Date and time (UTC) of the batch completion: YYYY-MM-DD\'T\'hh:mm:ss
     * @type {string}
     * @memberof CatalogsRetailItemsBatch
     */
    'completed_time'?: string | null;
    /**
     * 
     * @type {BatchOperationStatus}
     * @memberof CatalogsRetailItemsBatch
     */
    'status'?: BatchOperationStatus;
    /**
     * 
     * @type {CatalogsType}
     * @memberof CatalogsRetailItemsBatch
     */
    'catalog_type': CatalogsType;
    /**
     * Array with the catalogs items processing records part of the catalogs items batch
     * @type {Array<ItemProcessingRecord>}
     * @memberof CatalogsRetailItemsBatch
     */
    'items'?: Array<ItemProcessingRecord>;
}


/**
 * 
 * @export
 * @interface CatalogsRetailItemsFilter
 */
export interface CatalogsRetailItemsFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailItemsFilter
     */
    'catalog_type': CatalogsRetailItemsFilterCatalogTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsRetailItemsFilter
     */
    'item_ids': Array<string>;
    /**
     * Catalog id pertaining to the retail item. If not provided, default to oldest retail catalog
     * @type {string}
     * @memberof CatalogsRetailItemsFilter
     */
    'catalog_id'?: string;
}

export const CatalogsRetailItemsFilterCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailItemsFilterCatalogTypeEnum = typeof CatalogsRetailItemsFilterCatalogTypeEnum[keyof typeof CatalogsRetailItemsFilterCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsRetailItemsPostFilter
 */
export interface CatalogsRetailItemsPostFilter {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailItemsPostFilter
     */
    'catalog_type': CatalogsRetailItemsPostFilterCatalogTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof CatalogsRetailItemsPostFilter
     */
    'item_ids': Array<string>;
    /**
     * Catalog id pertaining to the retail item. If not provided, default to oldest retail catalog
     * @type {string}
     * @memberof CatalogsRetailItemsPostFilter
     */
    'catalog_id'?: string;
}

export const CatalogsRetailItemsPostFilterCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailItemsPostFilterCatalogTypeEnum = typeof CatalogsRetailItemsPostFilterCatalogTypeEnum[keyof typeof CatalogsRetailItemsPostFilterCatalogTypeEnum];

/**
 * Request object to list products for a given retail catalog_id and product group filter.
 * @export
 * @interface CatalogsRetailListProductsByCatalogBasedFilterRequest
 */
export interface CatalogsRetailListProductsByCatalogBasedFilterRequest {
    /**
     * Retail catalog based product group is available only for selected partners at the moment. If you are not eligible, please use feed based one.
     * @type {string}
     * @memberof CatalogsRetailListProductsByCatalogBasedFilterRequest
     */
    'catalog_type': CatalogsRetailListProductsByCatalogBasedFilterRequestCatalogTypeEnum;
    /**
     * Catalog id pertaining to the retail product group.
     * @type {string}
     * @memberof CatalogsRetailListProductsByCatalogBasedFilterRequest
     */
    'catalog_id': string;
    /**
     * 
     * @type {CatalogsProductGroupFilters}
     * @memberof CatalogsRetailListProductsByCatalogBasedFilterRequest
     */
    'filters': CatalogsProductGroupFilters;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsRetailListProductsByCatalogBasedFilterRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsLocale}
     * @memberof CatalogsRetailListProductsByCatalogBasedFilterRequest
     */
    'locale': CatalogsLocale;
}

export const CatalogsRetailListProductsByCatalogBasedFilterRequestCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailListProductsByCatalogBasedFilterRequestCatalogTypeEnum = typeof CatalogsRetailListProductsByCatalogBasedFilterRequestCatalogTypeEnum[keyof typeof CatalogsRetailListProductsByCatalogBasedFilterRequestCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsRetailProduct
 */
export interface CatalogsRetailProduct {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProduct
     */
    'catalog_type': CatalogsRetailProductCatalogTypeEnum;
    /**
     * 
     * @type {CatalogsRetailProductMetadata}
     * @memberof CatalogsRetailProduct
     */
    'metadata': CatalogsRetailProductMetadata;
    /**
     * 
     * @type {Pin}
     * @memberof CatalogsRetailProduct
     */
    'pin': Pin | null;
}

export const CatalogsRetailProductCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailProductCatalogTypeEnum = typeof CatalogsRetailProductCatalogTypeEnum[keyof typeof CatalogsRetailProductCatalogTypeEnum];

/**
 * 
 * @export
 * @interface CatalogsRetailProductGroup
 */
export interface CatalogsRetailProductGroup {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'catalog_type': CatalogsRetailProductGroupCatalogTypeEnum;
    /**
     * ID of the catalog product group.
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'id': string;
    /**
     * Name of catalog product group
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsProductGroupFilters}
     * @memberof CatalogsRetailProductGroup
     */
    'filters': CatalogsProductGroupFilters;
    /**
     * boolean indicator of whether the product group is being featured or not
     * @type {boolean}
     * @memberof CatalogsRetailProductGroup
     * @deprecated
     */
    'is_featured'?: boolean;
    /**
     * 
     * @type {CatalogsProductGroupType}
     * @memberof CatalogsRetailProductGroup
     */
    'type'?: CatalogsProductGroupType;
    /**
     * 
     * @type {CatalogsProductGroupStatus}
     * @memberof CatalogsRetailProductGroup
     */
    'status'?: CatalogsProductGroupStatus;
    /**
     * Unix timestamp in seconds of when catalog product group was created.
     * @type {number}
     * @memberof CatalogsRetailProductGroup
     */
    'created_at'?: number;
    /**
     * Unix timestamp in seconds of last time catalog product group was updated.
     * @type {number}
     * @memberof CatalogsRetailProductGroup
     */
    'updated_at'?: number;
    /**
     * Catalog id pertaining to the retail product group.
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'catalog_id': string;
    /**
     * id of the catalogs feed belonging to this catalog product group
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'feed_id': string | null;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'country'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroup
     */
    'locale'?: string | null;
}

export const CatalogsRetailProductGroupCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailProductGroupCatalogTypeEnum = typeof CatalogsRetailProductGroupCatalogTypeEnum[keyof typeof CatalogsRetailProductGroupCatalogTypeEnum];

/**
 * Request object for creating a product group.
 * @export
 * @interface CatalogsRetailProductGroupCreateRequest
 */
export interface CatalogsRetailProductGroupCreateRequest {
    /**
     * Retail catalog based product group is available only for selected partners at the moment. If you are not eligible, please use feed based one.
     * @type {string}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'catalog_type': CatalogsRetailProductGroupCreateRequestCatalogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsProductGroupFiltersRequest}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'filters': CatalogsProductGroupFiltersRequest;
    /**
     * Catalog id pertaining to the retail product group.
     * @type {string}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'catalog_id': string;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'country': Country;
    /**
     * 
     * @type {CatalogsLocale}
     * @memberof CatalogsRetailProductGroupCreateRequest
     */
    'locale': CatalogsLocale;
}

export const CatalogsRetailProductGroupCreateRequestCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailProductGroupCreateRequestCatalogTypeEnum = typeof CatalogsRetailProductGroupCreateRequestCatalogTypeEnum[keyof typeof CatalogsRetailProductGroupCreateRequestCatalogTypeEnum];

/**
 * Product counts for a Retail CatalogsProductGroup
 * @export
 * @interface CatalogsRetailProductGroupProductCounts
 */
export interface CatalogsRetailProductGroupProductCounts {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroupProductCounts
     */
    'catalog_type': CatalogsRetailProductGroupProductCountsCatalogTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof CatalogsRetailProductGroupProductCounts
     */
    'in_stock': number;
    /**
     * 
     * @type {number}
     * @memberof CatalogsRetailProductGroupProductCounts
     */
    'out_of_stock': number;
    /**
     * 
     * @type {number}
     * @memberof CatalogsRetailProductGroupProductCounts
     */
    'preorder': number;
    /**
     * 
     * @type {number}
     * @memberof CatalogsRetailProductGroupProductCounts
     */
    'total': number;
    /**
     * 
     * @type {number}
     * @memberof CatalogsRetailProductGroupProductCounts
     */
    'videos'?: number;
}

export const CatalogsRetailProductGroupProductCountsCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailProductGroupProductCountsCatalogTypeEnum = typeof CatalogsRetailProductGroupProductCountsCatalogTypeEnum[keyof typeof CatalogsRetailProductGroupProductCountsCatalogTypeEnum];

/**
 * Request object for updating a retail product group.
 * @export
 * @interface CatalogsRetailProductGroupUpdateRequest
 */
export interface CatalogsRetailProductGroupUpdateRequest {
    /**
     * Retail catalog based product group is available only for selected partners at the moment. If you are not eligible, please use feed based one.
     * @type {string}
     * @memberof CatalogsRetailProductGroupUpdateRequest
     */
    'catalog_type'?: CatalogsRetailProductGroupUpdateRequestCatalogTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroupUpdateRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailProductGroupUpdateRequest
     */
    'description'?: string | null;
    /**
     * 
     * @type {CatalogsProductGroupFiltersRequest}
     * @memberof CatalogsRetailProductGroupUpdateRequest
     */
    'filters'?: CatalogsProductGroupFiltersRequest;
    /**
     * 
     * @type {Country}
     * @memberof CatalogsRetailProductGroupUpdateRequest
     */
    'country'?: Country;
    /**
     * 
     * @type {CatalogsLocale}
     * @memberof CatalogsRetailProductGroupUpdateRequest
     */
    'locale'?: CatalogsLocale;
}

export const CatalogsRetailProductGroupUpdateRequestCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailProductGroupUpdateRequestCatalogTypeEnum = typeof CatalogsRetailProductGroupUpdateRequestCatalogTypeEnum[keyof typeof CatalogsRetailProductGroupUpdateRequestCatalogTypeEnum];

/**
 * Retail product metadata entity
 * @export
 * @interface CatalogsRetailProductMetadata
 */
export interface CatalogsRetailProductMetadata {
    /**
     * The user-created unique ID that represents the product.
     * @type {string}
     * @memberof CatalogsRetailProductMetadata
     */
    'item_id': string;
    /**
     * The parent ID of the product.
     * @type {string}
     * @memberof CatalogsRetailProductMetadata
     */
    'item_group_id': string | null;
    /**
     * 
     * @type {NonNullableProductAvailabilityType}
     * @memberof CatalogsRetailProductMetadata
     */
    'availability': NonNullableProductAvailabilityType;
    /**
     * The price of the product.
     * @type {number}
     * @memberof CatalogsRetailProductMetadata
     */
    'price': number;
    /**
     * The discounted price of the product.
     * @type {number}
     * @memberof CatalogsRetailProductMetadata
     */
    'sale_price': number | null;
    /**
     * 
     * @type {NonNullableCatalogsCurrency}
     * @memberof CatalogsRetailProductMetadata
     */
    'currency': NonNullableCatalogsCurrency;
}


/**
 * Parameters for retail report
 * @export
 * @interface CatalogsRetailReportParameters
 */
export interface CatalogsRetailReportParameters {
    /**
     * 
     * @type {string}
     * @memberof CatalogsRetailReportParameters
     */
    'catalog_type': CatalogsRetailReportParametersCatalogTypeEnum;
    /**
     * 
     * @type {CatalogsHotelReportParametersReport}
     * @memberof CatalogsRetailReportParameters
     */
    'report': CatalogsHotelReportParametersReport;
}

export const CatalogsRetailReportParametersCatalogTypeEnum = {
    Retail: 'RETAIL'
} as const;

export type CatalogsRetailReportParametersCatalogTypeEnum = typeof CatalogsRetailReportParametersCatalogTypeEnum[keyof typeof CatalogsRetailReportParametersCatalogTypeEnum];

/**
 * Status for catalogs entities. Present in catalogs_feed values. When a feed is deleted, the response will inform DELETED as status.
 * @export
 * @enum {string}
 */

export const CatalogsStatus = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type CatalogsStatus = typeof CatalogsStatus[keyof typeof CatalogsStatus];


/**
 * Type of the catalog entity.
 * @export
 * @enum {string}
 */

export const CatalogsType = {
    Retail: 'RETAIL',
    Hotel: 'HOTEL',
    CreativeAssets: 'CREATIVE_ASSETS'
} as const;

export type CatalogsType = typeof CatalogsType[keyof typeof CatalogsType];


/**
 * 
 * @export
 * @interface CatalogsUpdatableCreativeAssetsAttributes
 */
export interface CatalogsUpdatableCreativeAssetsAttributes {
    /**
     * The name of the creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'title'?: string;
    /**
     * Brief description of the creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'description'?: string;
    /**
     * Link to the creative assets page.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'link'?: string;
    /**
     * IOS deep link to the creative assets page.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'ios_deep_link'?: string | null;
    /**
     * Link to the creative assets page.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'android_deep_link'?: string | null;
    /**
     * The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'google_product_category'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'custom_label_0'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'custom_label_1'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'custom_label_2'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'custom_label_3'?: string | null;
    /**
     * Custom grouping of creative assets.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'custom_label_4'?: string | null;
    /**
     * Visibility of the creative assets. Must be one of the following values (upper or lowercase): visible, hidden.
     * @type {string}
     * @memberof CatalogsUpdatableCreativeAssetsAttributes
     */
    'visibility'?: string | null;
}
/**
 * 
 * @export
 * @interface CatalogsUpdatableHotelAttributes
 */
export interface CatalogsUpdatableHotelAttributes {
    /**
     * The hotel\'s name.
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'name'?: string | null;
    /**
     * Link to the product page
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'link'?: string | null;
    /**
     * Brief description of the hotel.
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'description'?: string | null;
    /**
     * The brand to which this hotel belongs to.
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'brand'?: string | null;
    /**
     * Latitude of the hotel.
     * @type {number}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'latitude'?: number;
    /**
     * Longitude of the hotel.
     * @type {number}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'longitude'?: number | null;
    /**
     * A list of neighborhoods where the hotel is located
     * @type {Array<string>}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'neighborhood'?: Array<string> | null;
    /**
     * 
     * @type {CatalogsHotelAddress}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'address'?: CatalogsHotelAddress;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'custom_label_0'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'custom_label_1'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'custom_label_2'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'custom_label_3'?: string | null;
    /**
     * Custom grouping of hotels
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'custom_label_4'?: string | null;
    /**
     * The type of property. The category can be any type of internal description desired.
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'category'?: string | null;
    /**
     * Base price of the hotel room per night followed by the ISO currency code
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'base_price'?: string | null;
    /**
     * Sale price of a hotel room per night. Used to advertise discounts off the regular price of the hotel.
     * @type {string}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'sale_price'?: string | null;
    /**
     * 
     * @type {CatalogsHotelGuestRatings}
     * @memberof CatalogsUpdatableHotelAttributes
     */
    'guest_ratings'?: CatalogsHotelGuestRatings;
}
/**
 * A creative assets item to be updated.
 * @export
 * @interface CatalogsUpdateCreativeAssetsItem
 */
export interface CatalogsUpdateCreativeAssetsItem {
    /**
     * The catalog creative assets item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsUpdateCreativeAssetsItem
     */
    'creative_assets_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsUpdateCreativeAssetsItem
     */
    'operation': CatalogsUpdateCreativeAssetsItemOperationEnum;
    /**
     * 
     * @type {CatalogsUpdatableCreativeAssetsAttributes}
     * @memberof CatalogsUpdateCreativeAssetsItem
     */
    'attributes': CatalogsUpdatableCreativeAssetsAttributes;
}

export const CatalogsUpdateCreativeAssetsItemOperationEnum = {
    Update: 'UPDATE'
} as const;

export type CatalogsUpdateCreativeAssetsItemOperationEnum = typeof CatalogsUpdateCreativeAssetsItemOperationEnum[keyof typeof CatalogsUpdateCreativeAssetsItemOperationEnum];

/**
 * Object describing an hotel item batch record
 * @export
 * @interface CatalogsUpdateHotelItem
 */
export interface CatalogsUpdateHotelItem {
    /**
     * The catalog hotel item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsUpdateHotelItem
     */
    'hotel_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsUpdateHotelItem
     */
    'operation': CatalogsUpdateHotelItemOperationEnum;
    /**
     * 
     * @type {CatalogsUpdatableHotelAttributes}
     * @memberof CatalogsUpdateHotelItem
     */
    'attributes': CatalogsUpdatableHotelAttributes;
}

export const CatalogsUpdateHotelItemOperationEnum = {
    Update: 'UPDATE'
} as const;

export type CatalogsUpdateHotelItemOperationEnum = typeof CatalogsUpdateHotelItemOperationEnum[keyof typeof CatalogsUpdateHotelItemOperationEnum];

/**
 * An item to be updated
 * @export
 * @interface CatalogsUpdateRetailItem
 */
export interface CatalogsUpdateRetailItem {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsUpdateRetailItem
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsUpdateRetailItem
     */
    'operation': CatalogsUpdateRetailItemOperationEnum;
    /**
     * 
     * @type {UpdatableItemAttributes}
     * @memberof CatalogsUpdateRetailItem
     */
    'attributes': UpdatableItemAttributes;
    /**
     * The list of product attributes to be updated. Attributes specified in the update mask without a value specified in the body will be deleted from the product item.
     * @type {Array<UpdateMaskFieldType>}
     * @memberof CatalogsUpdateRetailItem
     */
    'update_mask'?: Array<UpdateMaskFieldType> | null;
}

export const CatalogsUpdateRetailItemOperationEnum = {
    Update: 'UPDATE'
} as const;

export type CatalogsUpdateRetailItemOperationEnum = typeof CatalogsUpdateRetailItemOperationEnum[keyof typeof CatalogsUpdateRetailItemOperationEnum];

/**
 * A creative assets item to be upserted.
 * @export
 * @interface CatalogsUpsertCreativeAssetsItem
 */
export interface CatalogsUpsertCreativeAssetsItem {
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CatalogsUpsertCreativeAssetsItem
     */
    'creative_assets_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsUpsertCreativeAssetsItem
     */
    'operation': CatalogsUpsertCreativeAssetsItemOperationEnum;
    /**
     * 
     * @type {CatalogsCreativeAssetsAttributes}
     * @memberof CatalogsUpsertCreativeAssetsItem
     */
    'attributes': CatalogsCreativeAssetsAttributes;
}

export const CatalogsUpsertCreativeAssetsItemOperationEnum = {
    Upsert: 'UPSERT'
} as const;

export type CatalogsUpsertCreativeAssetsItemOperationEnum = typeof CatalogsUpsertCreativeAssetsItemOperationEnum[keyof typeof CatalogsUpsertCreativeAssetsItemOperationEnum];

/**
 * A hotel item to be upserted.
 * @export
 * @interface CatalogsUpsertHotelItem
 */
export interface CatalogsUpsertHotelItem {
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof CatalogsUpsertHotelItem
     */
    'hotel_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsUpsertHotelItem
     */
    'operation': CatalogsUpsertHotelItemOperationEnum;
    /**
     * 
     * @type {CatalogsHotelAttributes}
     * @memberof CatalogsUpsertHotelItem
     */
    'attributes': CatalogsHotelAttributes;
}

export const CatalogsUpsertHotelItemOperationEnum = {
    Upsert: 'UPSERT'
} as const;

export type CatalogsUpsertHotelItemOperationEnum = typeof CatalogsUpsertHotelItemOperationEnum[keyof typeof CatalogsUpsertHotelItemOperationEnum];

/**
 * An item to be upserted
 * @export
 * @interface CatalogsUpsertRetailItem
 */
export interface CatalogsUpsertRetailItem {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof CatalogsUpsertRetailItem
     */
    'item_id': string;
    /**
     * 
     * @type {string}
     * @memberof CatalogsUpsertRetailItem
     */
    'operation': CatalogsUpsertRetailItemOperationEnum;
    /**
     * 
     * @type {ItemAttributesRequest}
     * @memberof CatalogsUpsertRetailItem
     */
    'attributes': ItemAttributesRequest;
}

export const CatalogsUpsertRetailItemOperationEnum = {
    Upsert: 'UPSERT'
} as const;

export type CatalogsUpsertRetailItemOperationEnum = typeof CatalogsUpsertRetailItemOperationEnum[keyof typeof CatalogsUpsertRetailItemOperationEnum];

/**
 * @type CatalogsVerticalBatchRequest
 * A request object that can have multiple operations on a single batch
 * @export
 */
export type CatalogsVerticalBatchRequest = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsBatchRequest | { catalog_type: 'HOTEL' } & CatalogsHotelBatchRequest | { catalog_type: 'RETAIL' } & CatalogsRetailBatchRequest;

/**
 * @type CatalogsVerticalFeedsCreateRequest
 * Request object for creating a feed.
 * @export
 */
export type CatalogsVerticalFeedsCreateRequest = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsFeedsCreateRequest | { catalog_type: 'HOTEL' } & CatalogsHotelFeedsCreateRequest | { catalog_type: 'RETAIL' } & CatalogsRetailFeedsCreateRequest;

/**
 * @type CatalogsVerticalFeedsUpdateRequest
 * Request object for updating a feed.
 * @export
 */
export type CatalogsVerticalFeedsUpdateRequest = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsFeedsUpdateRequest | { catalog_type: 'HOTEL' } & CatalogsHotelFeedsUpdateRequest | { catalog_type: 'RETAIL' } & CatalogsRetailFeedsUpdateRequest;

/**
 * @type CatalogsVerticalProductGroup
 * @export
 */
export type CatalogsVerticalProductGroup = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsProductGroup | { catalog_type: 'HOTEL' } & CatalogsHotelProductGroup | { catalog_type: 'RETAIL' } & CatalogsRetailProductGroup;

/**
 * @type CatalogsVerticalProductGroupCreateRequest
 * Request object for creating a catalog based product group.
 * @export
 */
export type CatalogsVerticalProductGroupCreateRequest = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsProductGroupCreateRequest | { catalog_type: 'HOTEL' } & CatalogsHotelProductGroupCreateRequest | { catalog_type: 'RETAIL' } & CatalogsRetailProductGroupCreateRequest;

/**
 * @type CatalogsVerticalProductGroupUpdateRequest
 * Request object for updating a catalog based product group.
 * @export
 */
export type CatalogsVerticalProductGroupUpdateRequest = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsProductGroupUpdateRequest | { catalog_type: 'HOTEL' } & CatalogsHotelProductGroupUpdateRequest | { catalog_type: 'RETAIL' } & CatalogsRetailProductGroupUpdateRequest;

/**
 * @type CatalogsVerticalsListProductsByCatalogBasedFilterRequest
 * Request object to list products for a given catalog_id and product group filter.
 * @export
 */
export type CatalogsVerticalsListProductsByCatalogBasedFilterRequest = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsListProductsByCatalogBasedFilterRequest | { catalog_type: 'HOTEL' } & CatalogsHotelListProductsByCatalogBasedFilterRequest | { catalog_type: 'RETAIL' } & CatalogsRetailListProductsByCatalogBasedFilterRequest;

/**
 * 
 * @export
 * @interface ConditionFilter
 */
export interface ConditionFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof ConditionFilter
     */
    'CONDITION': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Schema describing the object in the response, which contains information about the events that were received and processed.
 * @export
 * @interface ConversionApiResponse
 */
export interface ConversionApiResponse {
    /**
     * Total number of events received in the request.
     * @type {number}
     * @memberof ConversionApiResponse
     */
    'num_events_received': number;
    /**
     * Number of events that were successfully processed from the events.
     * @type {number}
     * @memberof ConversionApiResponse
     */
    'num_events_processed': number;
    /**
     * Specific messages for each event received. The order will match the order in which the events were received in the request.
     * @type {Array<ConversionApiResponseEventsInner>}
     * @memberof ConversionApiResponse
     */
    'events': Array<ConversionApiResponseEventsInner>;
}
/**
 * 
 * @export
 * @interface ConversionApiResponseEventsInner
 */
export interface ConversionApiResponseEventsInner {
    /**
     * Whether the event was processed successfully.
     * @type {string}
     * @memberof ConversionApiResponseEventsInner
     */
    'status': ConversionApiResponseEventsInnerStatusEnum;
    /**
     * Error message containing more information about why the event failed to be processed.
     * @type {string}
     * @memberof ConversionApiResponseEventsInner
     */
    'error_message'?: string | null;
    /**
     * Warning messages about any fields in the event which are not standard. These are not critical to event processing.
     * @type {string}
     * @memberof ConversionApiResponseEventsInner
     */
    'warning_message'?: string | null;
}

export const ConversionApiResponseEventsInnerStatusEnum = {
    Failed: 'failed',
    Processed: 'processed'
} as const;

export type ConversionApiResponseEventsInnerStatusEnum = typeof ConversionApiResponseEventsInnerStatusEnum[keyof typeof ConversionApiResponseEventsInnerStatusEnum];

/**
 * 
 * @export
 * @enum {number}
 */

export const ConversionAttributionWindowDays = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;

export type ConversionAttributionWindowDays = typeof ConversionAttributionWindowDays[keyof typeof ConversionAttributionWindowDays];


/**
 * 
 * @export
 * @interface ConversionEventResponse
 */
export interface ConversionEventResponse {
    /**
     * 
     * @type {ConversionTagType}
     * @memberof ConversionEventResponse
     */
    'conversion_event'?: ConversionTagType;
    /**
     * Id of the tag.
     * @type {string}
     * @memberof ConversionEventResponse
     */
    'conversion_tag_id'?: string;
    /**
     * Id of the ad account.
     * @type {string}
     * @memberof ConversionEventResponse
     */
    'ad_account_id'?: string;
    /**
     * Creation date in epoch format.
     * @type {number}
     * @memberof ConversionEventResponse
     */
    'created_time'?: number;
}


/**
 * A list of events (one or more) encapsulated by a data object.
 * @export
 * @interface ConversionEvents
 */
export interface ConversionEvents {
    /**
     * 
     * @type {Array<ConversionEventsDataInner>}
     * @memberof ConversionEvents
     */
    'data': Array<ConversionEventsDataInner>;
}
/**
 * 
 * @export
 * @interface ConversionEventsDataInner
 */
export interface ConversionEventsDataInner {
    /**
     * <p>The type of the user event. Please use the right event_name otherwise the event won\'t be accepted and show up correctly in reports.   <ul>   <li><code>add_to_cart</code></li>   <li><code>checkout</code></li>   <li><code>custom</code></li>   <li><code>lead</code></li>   <li><code>page_visit</code></li>   <li><code>search</code></li>   <li><code>signup</code></li>   <li><code>view_category</code></li>   <li><code>watch_video</code></li>   </ul> </p> 
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'event_name': string;
    /**
     * <p>   The source indicating where the conversion event occurred.   <ul>     <li><code>app_android</code></li>     <li><code>app_ios</code></li>     <li><code>web</code></li>     <li><code>offline</code></li>   </ul> </p> 
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'action_source': string;
    /**
     * The time when the event happened. Unix timestamp in seconds.
     * @type {number}
     * @memberof ConversionEventsDataInner
     */
    'event_time': number;
    /**
     * A unique id string that identifies this event and can be used for deduping between events ingested via both the conversion API and Pinterest tracking. Without this, event\'s data is likely to be double counted and will cause report metric inflation. Third-party vendors make sure this field is updated on both Pinterest tag and Conversions API side before rolling out template for Conversions API.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'event_id': string;
    /**
     * URL of the web conversion event.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'event_source_url'?: string | null;
    /**
     * When action_source is web or offline, it defines whether the user has opted out of tracking for web conversion events. While when action_source is app_android or app_ios, it defines whether the user has enabled Limit Ad Tracking on their iOS device, or opted out of Ads Personalization on their Android device.
     * @type {boolean}
     * @memberof ConversionEventsDataInner
     */
    'opt_out'?: boolean;
    /**
     * The third party partner name responsible to send the event to Conversions API on behalf of the advertiser. The naming convention is \"ss-partnername\" lowercase. E.g ss-shopify
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'partner_name'?: string | null;
    /**
     * 
     * @type {ConversionEventsUserData}
     * @memberof ConversionEventsDataInner
     */
    'user_data': ConversionEventsUserData;
    /**
     * 
     * @type {ConversionEventsDataInnerCustomData}
     * @memberof ConversionEventsDataInner
     */
    'custom_data'?: ConversionEventsDataInnerCustomData;
    /**
     * The app store app ID.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'app_id'?: string | null;
    /**
     * Name of the app.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'app_name'?: string | null;
    /**
     * Version of the app.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'app_version'?: string | null;
    /**
     * Brand of the user device.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'device_brand'?: string | null;
    /**
     * User device\'s mobile carrier.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'device_carrier'?: string | null;
    /**
     * Model of the user device.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'device_model'?: string | null;
    /**
     * Type of the user device.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'device_type'?: string | null;
    /**
     * Version of the device operating system.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'os_version'?: string | null;
    /**
     * Whether the event occurred when the user device was connected to wifi.
     * @type {boolean}
     * @memberof ConversionEventsDataInner
     */
    'wifi'?: boolean;
    /**
     * Two-character ISO-639-1 language code indicating the user\'s language.
     * @type {string}
     * @memberof ConversionEventsDataInner
     */
    'language'?: string | null;
}
/**
 * Object containing other custom data.
 * @export
 * @interface ConversionEventsDataInnerCustomData
 */
export interface ConversionEventsDataInnerCustomData {
    /**
     * The ISO-4217 currency code. If not provided, we will default to the advertiser\'s currency set during account creation. Your campaign performance needs this field to report right ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'currency'?: string | null;
    /**
     * Total value of the event. Accepted as a string in the request; it will be parsed into a double. For example, if there are two items in a checkout event, the value should be the total price. We recommend to use pre-tax, pre-shipping final value.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'value'?: string | null;
    /**
     * List of products IDs. We recommend using this if you are a merchant for PageVisit, AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
     * @type {Array<string>}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'content_ids'?: Array<string>;
    /**
     * The name of the page or product associated with the event.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'content_name'?: string | null;
    /**
     * The category of the content associated with the event.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'content_category'?: string | null;
    /**
     * The brand of the content associated with the event.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'content_brand'?: string | null;
    /**
     * A list of objects containing information about products, such as price and quantity. We recommend using this if you are a merchant for PageVisit, AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
     * @type {Array<ConversionEventsDataInnerCustomDataContentsInner>}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'contents'?: Array<ConversionEventsDataInnerCustomDataContentsInner>;
    /**
     * Total number of products of the event. For example, the total number of items purchased in a checkout event. We recommend using this if you are a merchant for AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
     * @type {number}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'num_items'?: number;
    /**
     * The order ID. We recommend sending order_id to help us deduplicate events when necessary. This also helps to run other measurement products at Pinterest.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'order_id'?: string | null;
    /**
     * The search string related to the user conversion event.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'search_string'?: string | null;
    /**
     * Flags for different privacy rights laws to opt out users of sharing personal information. Values should be comma separated. Please follow the <a href=\"https://help.pinterest.com/en/business/article/limited-data-processing\" target=\"_blank\">Help Center</a> and <a href=\"/docs/api-features/conversion-overview/\" target=\"_blank\">dev site</a> for specific opt_out_type set up.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'opt_out_type'?: string | null;
    /**
     * Named partner. Not required, this is for Pinterest internal use only. Please do not use this unless specifically guided.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomData
     */
    'np'?: string | null;
}
/**
 * 
 * @export
 * @interface ConversionEventsDataInnerCustomDataContentsInner
 */
export interface ConversionEventsDataInnerCustomDataContentsInner {
    /**
     * The id of a product. We recommend using this if you are a merchant for AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomDataContentsInner
     */
    'id'?: string;
    /**
     * The price of a product. Accepted as a string in the request; it will be parsed into a double. This is the original item value before any discount. We recommend using this if you are a merchant for PageVisit, AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomDataContentsInner
     */
    'item_price'?: string;
    /**
     * The amount of a product. We recommend using this if you are a merchant for AddToCart and Checkouts. For detail, please check <a href=\"https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\" target=\"_blank\">here</a> (Install the Pinterest tag section).
     * @type {number}
     * @memberof ConversionEventsDataInnerCustomDataContentsInner
     */
    'quantity'?: number;
    /**
     * The name of a product.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomDataContentsInner
     */
    'item_name'?: string;
    /**
     * The category of a product.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomDataContentsInner
     */
    'item_category'?: string;
    /**
     * The brand of a product.
     * @type {string}
     * @memberof ConversionEventsDataInnerCustomDataContentsInner
     */
    'item_brand'?: string;
}
/**
 * Object containing customer information data. Note, It is required at least one of 1) em, 2) hashed_maids or 3) pair client_ip_address + client_user_agent.
 * @export
 * @interface ConversionEventsUserData
 */
export interface ConversionEventsUserData {
    /**
     * Sha256 hashes of user\'s phone numbers, only digits with country code, area code, and number. Remove any symbols, letters, spaces and leading zeros. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'ph'?: Array<string>;
    /**
     * Sha256 hashes of user\'s gender, in lowercase. Either \"f\" or \"m\" or \"n\" for non-binary gender. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'ge'?: Array<string>;
    /**
     * Sha256 hashes of user\'s date of birthday, given as year, month, and day. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'db'?: Array<string>;
    /**
     * Sha256 hashes of user\'s last name, in lowercase. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'ln'?: Array<string>;
    /**
     * Sha256 hashes of user\'s first name, in lowercase. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'fn'?: Array<string>;
    /**
     * Sha256 hashes of user\'s city, in lowercase, and without spaces or punctuation. User residency city (mostly billing). The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'ct'?: Array<string>;
    /**
     * Sha256 hashes of user\'s state, given as a two-letter code in lowercase. User residency state (mostly billing). The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'st'?: Array<string>;
    /**
     * Sha256 hashes of user\'s zipcode, only digits. User residency zipcode (mostly billing). The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'zp'?: Array<string>;
    /**
     * Sha256 hashes of two-character ISO-3166 country code indicating the user\'s country, in lowercase. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'country'?: Array<string>;
    /**
     * Sha256 hashes of the unique id from the advertiser that identifies a user in their space, e.g. user id, loyalty id, etc. We highly recommend this on all events. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'external_id'?: Array<string>;
    /**
     * The unique identifier stored in _epik cookie on your domain or &epik= query parameter in the URL. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserData
     */
    'click_id'?: string | null;
    /**
     * A unique identifier of visitors\' information defined by third party partners. e.g RampID
     * @type {string}
     * @memberof ConversionEventsUserData
     */
    'partner_id'?: string | null;
    /**
     * Sha256 hashes of lowercase version of user\'s email addresses. Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'em': Array<string>;
    /**
     * Sha256 hashes of user\'s \"Google Advertising IDs\" (GAIDs) or \"Apple\'s Identifier for Advertisers\" (IDFAs). Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserData
     */
    'hashed_maids': Array<string>;
    /**
     * The user\'s IP address, which can be either in IPv4 or IPv6 format. Used for matching. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserData
     */
    'client_ip_address': string;
    /**
     * The user agent string of the user\'s web browser. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserData
     */
    'client_user_agent': string;
}
/**
 * 
 * @export
 * @interface ConversionEventsUserDataAnyOf
 */
export interface ConversionEventsUserDataAnyOf {
    /**
     * Sha256 hashes of lowercase version of user\'s email addresses. Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserDataAnyOf
     */
    'em': Array<string>;
    /**
     * Sha256 hashes of user\'s \"Google Advertising IDs\" (GAIDs) or \"Apple\'s Identifier for Advertisers\" (IDFAs). Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserDataAnyOf
     */
    'hashed_maids'?: Array<string>;
    /**
     * The user\'s IP address, which can be either in IPv4 or IPv6 format. Used for matching. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserDataAnyOf
     */
    'client_ip_address'?: string;
    /**
     * The user agent string of the user\'s web browser. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserDataAnyOf
     */
    'client_user_agent'?: string;
}
/**
 * 
 * @export
 * @interface ConversionEventsUserDataAnyOf1
 */
export interface ConversionEventsUserDataAnyOf1 {
    /**
     * Sha256 hashes of lowercase version of user\'s email addresses. Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserDataAnyOf1
     */
    'em'?: Array<string>;
    /**
     * Sha256 hashes of user\'s \"Google Advertising IDs\" (GAIDs) or \"Apple\'s Identifier for Advertisers\" (IDFAs). Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserDataAnyOf1
     */
    'hashed_maids': Array<string>;
    /**
     * The user\'s IP address, which can be either in IPv4 or IPv6 format. Used for matching. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserDataAnyOf1
     */
    'client_ip_address'?: string;
    /**
     * The user agent string of the user\'s web browser. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserDataAnyOf1
     */
    'client_user_agent'?: string;
}
/**
 * 
 * @export
 * @interface ConversionEventsUserDataAnyOf2
 */
export interface ConversionEventsUserDataAnyOf2 {
    /**
     * Sha256 hashes of lowercase version of user\'s email addresses. Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserDataAnyOf2
     */
    'em'?: Array<string>;
    /**
     * Sha256 hashes of user\'s \"Google Advertising IDs\" (GAIDs) or \"Apple\'s Identifier for Advertisers\" (IDFAs). Used for matching. We highly recommend this on checkout events at least. It may improve reporting performance such as ROAS/CPA. The string should be in the UTF-8 format.
     * @type {Array<string>}
     * @memberof ConversionEventsUserDataAnyOf2
     */
    'hashed_maids'?: Array<string>;
    /**
     * The user\'s IP address, which can be either in IPv4 or IPv6 format. Used for matching. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserDataAnyOf2
     */
    'client_ip_address': string;
    /**
     * The user agent string of the user\'s web browser. We highly recommend this for all events. It may improve reporting performance such as ROAS/CPA.
     * @type {string}
     * @memberof ConversionEventsUserDataAnyOf2
     */
    'client_user_agent': string;
}
/**
 * Attribution type. Refers to the Pinterest Tag endpoints
 * @export
 * @enum {string}
 */

export const ConversionReportAttributionType = {
    Individual: 'INDIVIDUAL',
    Household: 'HOUSEHOLD'
} as const;

export type ConversionReportAttributionType = typeof ConversionReportAttributionType[keyof typeof ConversionReportAttributionType];


/**
 * Conversion report time type
 * @export
 * @enum {string}
 */

export const ConversionReportTimeType = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;

export type ConversionReportTimeType = typeof ConversionReportTimeType[keyof typeof ConversionReportTimeType];


/**
 * 
 * @export
 * @interface ConversionTagCommon
 */
export interface ConversionTagCommon {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof ConversionTagCommon
     */
    'ad_account_id'?: string;
    /**
     * Tag code snippet.
     * @type {string}
     * @memberof ConversionTagCommon
     */
    'code_snippet'?: string;
    /**
     * 
     * @type {EnhancedMatchStatusType}
     * @memberof ConversionTagCommon
     */
    'enhanced_match_status'?: EnhancedMatchStatusType | null;
    /**
     * Tag ID.
     * @type {string}
     * @memberof ConversionTagCommon
     */
    'id'?: string;
    /**
     * Time for the last event fired.
     * @type {number}
     * @memberof ConversionTagCommon
     */
    'last_fired_time_ms'?: number | null;
    /**
     * Conversion tag name.
     * @type {string}
     * @memberof ConversionTagCommon
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof ConversionTagCommon
     */
    'status'?: EntityStatus;
    /**
     * Version number.
     * @type {string}
     * @memberof ConversionTagCommon
     */
    'version'?: string;
    /**
     * 
     * @type {ConversionTagConfigs}
     * @memberof ConversionTagCommon
     */
    'configs'?: ConversionTagConfigs;
}


/**
 * 
 * @export
 * @interface ConversionTagConfigs
 */
export interface ConversionTagConfigs {
    /**
     * Whether Automatic Enhanced Match email is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagConfigs
     */
    'aem_enabled'?: boolean | null;
    /**
     * Metadata ingestion frequency.
     * @type {number}
     * @memberof ConversionTagConfigs
     */
    'md_frequency'?: number | null;
    /**
     * Whether Automatic Enhanced Match name is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagConfigs
     */
    'aem_fnln_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match phone is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagConfigs
     */
    'aem_ph_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match gender is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagConfigs
     */
    'aem_ge_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match birthdate is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagConfigs
     */
    'aem_db_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match location is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagConfigs
     */
    'aem_loc_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ConversionTagCreate
 */
export interface ConversionTagCreate {
    /**
     * Conversion tag name.
     * @type {string}
     * @memberof ConversionTagCreate
     */
    'name': string;
    /**
     * Whether Automatic Enhanced Match email is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagCreate
     */
    'aem_enabled'?: boolean | null;
    /**
     * Metadata ingestion frequency.
     * @type {number}
     * @memberof ConversionTagCreate
     */
    'md_frequency'?: number | null;
    /**
     * Whether Automatic Enhanced Match name is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagCreate
     */
    'aem_fnln_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match phone is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagCreate
     */
    'aem_ph_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match gender is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagCreate
     */
    'aem_ge_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match birthdate is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagCreate
     */
    'aem_db_enabled'?: boolean | null;
    /**
     * Whether Automatic Enhanced Match location is enabled. See <a href=\"https://help.pinterest.com/en/business/article/enhanced-match\" target=\"_blank\">Enhanced match</a> for more information.
     * @type {boolean}
     * @memberof ConversionTagCreate
     */
    'aem_loc_enabled'?: boolean | null;
}
/**
 * 
 * @export
 * @interface ConversionTagListResponse
 */
export interface ConversionTagListResponse {
    /**
     * 
     * @type {Array<ConversionTagResponse>}
     * @memberof ConversionTagListResponse
     */
    'items'?: Array<ConversionTagResponse>;
}
/**
 * 
 * @export
 * @interface ConversionTagResponse
 */
export interface ConversionTagResponse {
    /**
     * Ad account ID.
     * @type {string}
     * @memberof ConversionTagResponse
     */
    'ad_account_id'?: string;
    /**
     * Tag code snippet.
     * @type {string}
     * @memberof ConversionTagResponse
     */
    'code_snippet'?: string;
    /**
     * 
     * @type {EnhancedMatchStatusType}
     * @memberof ConversionTagResponse
     */
    'enhanced_match_status'?: EnhancedMatchStatusType | null;
    /**
     * Tag ID.
     * @type {string}
     * @memberof ConversionTagResponse
     */
    'id'?: string;
    /**
     * Time for the last event fired.
     * @type {number}
     * @memberof ConversionTagResponse
     */
    'last_fired_time_ms'?: number | null;
    /**
     * Conversion tag name.
     * @type {string}
     * @memberof ConversionTagResponse
     */
    'name'?: string;
    /**
     * 
     * @type {EntityStatus}
     * @memberof ConversionTagResponse
     */
    'status'?: EntityStatus;
    /**
     * Version number.
     * @type {string}
     * @memberof ConversionTagResponse
     */
    'version'?: string;
    /**
     * 
     * @type {ConversionTagConfigs}
     * @memberof ConversionTagResponse
     */
    'configs'?: ConversionTagConfigs;
}


/**
 * conversion tag type
 * @export
 * @enum {string}
 */

export const ConversionTagType = {
    PageLoad: 'PAGE_LOAD',
    Unknown: 'UNKNOWN',
    Initialized: 'INITIALIZED',
    PageVisit: 'PAGE_VISIT',
    Signup: 'SIGNUP',
    Checkout: 'CHECKOUT',
    Custom: 'CUSTOM',
    ViewCategory: 'VIEW_CATEGORY',
    Search: 'SEARCH',
    AddToCart: 'ADD_TO_CART',
    WatchVideo: 'WATCH_VIDEO',
    Lead: 'LEAD',
    AppInstall: 'APP_INSTALL',
    WebSession: 'WEB_SESSION',
    ExternalMeasurement: 'EXTERNAL_MEASUREMENT'
} as const;

export type ConversionTagType = typeof ConversionTagType[keyof typeof ConversionTagType];


/**
 * Country ID from ISO 3166-1 alpha-2.
 * @export
 * @enum {string}
 */

export const Country = {
    Ad: 'AD',
    Ae: 'AE',
    Af: 'AF',
    Ag: 'AG',
    Ai: 'AI',
    Al: 'AL',
    Am: 'AM',
    Ao: 'AO',
    Aq: 'AQ',
    Ar: 'AR',
    As: 'AS',
    At: 'AT',
    Au: 'AU',
    Aw: 'AW',
    Ax: 'AX',
    Az: 'AZ',
    Ba: 'BA',
    Bb: 'BB',
    Bd: 'BD',
    Be: 'BE',
    Bf: 'BF',
    Bg: 'BG',
    Bh: 'BH',
    Bi: 'BI',
    Bj: 'BJ',
    Bl: 'BL',
    Bm: 'BM',
    Bn: 'BN',
    Bo: 'BO',
    Bq: 'BQ',
    Br: 'BR',
    Bs: 'BS',
    Bt: 'BT',
    Bv: 'BV',
    Bw: 'BW',
    By: 'BY',
    Bz: 'BZ',
    Ca: 'CA',
    Cc: 'CC',
    Cd: 'CD',
    Cf: 'CF',
    Cg: 'CG',
    Ch: 'CH',
    Ci: 'CI',
    Ck: 'CK',
    Cl: 'CL',
    Cm: 'CM',
    Cn: 'CN',
    Co: 'CO',
    Cr: 'CR',
    Cu: 'CU',
    Cv: 'CV',
    Cw: 'CW',
    Cx: 'CX',
    Cy: 'CY',
    Cz: 'CZ',
    De: 'DE',
    Dj: 'DJ',
    Dk: 'DK',
    Dm: 'DM',
    Do: 'DO',
    Dz: 'DZ',
    Ec: 'EC',
    Ee: 'EE',
    Eg: 'EG',
    Eh: 'EH',
    Er: 'ER',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fj: 'FJ',
    Fk: 'FK',
    Fm: 'FM',
    Fo: 'FO',
    Fr: 'FR',
    Ga: 'GA',
    Gb: 'GB',
    Gd: 'GD',
    Ge: 'GE',
    Gf: 'GF',
    Gg: 'GG',
    Gh: 'GH',
    Gi: 'GI',
    Gl: 'GL',
    Gm: 'GM',
    Gn: 'GN',
    Gp: 'GP',
    Gq: 'GQ',
    Gr: 'GR',
    Gs: 'GS',
    Gt: 'GT',
    Gu: 'GU',
    Gw: 'GW',
    Gy: 'GY',
    Hk: 'HK',
    Hm: 'HM',
    Hn: 'HN',
    Hr: 'HR',
    Ht: 'HT',
    Hu: 'HU',
    Id: 'ID',
    Ie: 'IE',
    Il: 'IL',
    Im: 'IM',
    In: 'IN',
    Io: 'IO',
    Iq: 'IQ',
    Ir: 'IR',
    Is: 'IS',
    It: 'IT',
    Je: 'JE',
    Jm: 'JM',
    Jo: 'JO',
    Jp: 'JP',
    Ke: 'KE',
    Kg: 'KG',
    Kh: 'KH',
    Ki: 'KI',
    Km: 'KM',
    Kn: 'KN',
    Kr: 'KR',
    Kw: 'KW',
    Ky: 'KY',
    Kz: 'KZ',
    La: 'LA',
    Lb: 'LB',
    Lc: 'LC',
    Li: 'LI',
    Lk: 'LK',
    Lr: 'LR',
    Ls: 'LS',
    Lt: 'LT',
    Lu: 'LU',
    Lv: 'LV',
    Ly: 'LY',
    Ma: 'MA',
    Mc: 'MC',
    Md: 'MD',
    Me: 'ME',
    Mf: 'MF',
    Mg: 'MG',
    Mh: 'MH',
    Mk: 'MK',
    Ml: 'ML',
    Mm: 'MM',
    Mn: 'MN',
    Mo: 'MO',
    Mp: 'MP',
    Mq: 'MQ',
    Mr: 'MR',
    Ms: 'MS',
    Mt: 'MT',
    Mu: 'MU',
    Mv: 'MV',
    Mw: 'MW',
    Mx: 'MX',
    My: 'MY',
    Mz: 'MZ',
    Na: 'NA',
    Nc: 'NC',
    Ne: 'NE',
    Nf: 'NF',
    Ng: 'NG',
    Ni: 'NI',
    Nl: 'NL',
    No: 'NO',
    Np: 'NP',
    Nr: 'NR',
    Nu: 'NU',
    Nz: 'NZ',
    Om: 'OM',
    Pa: 'PA',
    Pe: 'PE',
    Pf: 'PF',
    Pg: 'PG',
    Ph: 'PH',
    Pk: 'PK',
    Pl: 'PL',
    Pm: 'PM',
    Pn: 'PN',
    Pr: 'PR',
    Ps: 'PS',
    Pt: 'PT',
    Pw: 'PW',
    Py: 'PY',
    Qa: 'QA',
    Re: 'RE',
    Ro: 'RO',
    Rs: 'RS',
    Ru: 'RU',
    Rw: 'RW',
    Sa: 'SA',
    Sb: 'SB',
    Sc: 'SC',
    Sd: 'SD',
    Se: 'SE',
    Sg: 'SG',
    Sh: 'SH',
    Si: 'SI',
    Sj: 'SJ',
    Sk: 'SK',
    Sl: 'SL',
    Sm: 'SM',
    Sn: 'SN',
    So: 'SO',
    Sr: 'SR',
    Ss: 'SS',
    St: 'ST',
    Sv: 'SV',
    Sx: 'SX',
    Sy: 'SY',
    Sz: 'SZ',
    Tc: 'TC',
    Td: 'TD',
    Tf: 'TF',
    Tg: 'TG',
    Th: 'TH',
    Tj: 'TJ',
    Tk: 'TK',
    Tl: 'TL',
    Tm: 'TM',
    Tn: 'TN',
    To: 'TO',
    Tr: 'TR',
    Tt: 'TT',
    Tv: 'TV',
    Tw: 'TW',
    Tz: 'TZ',
    Ua: 'UA',
    Ug: 'UG',
    Um: 'UM',
    Us: 'US',
    Uy: 'UY',
    Uz: 'UZ',
    Va: 'VA',
    Vc: 'VC',
    Ve: 'VE',
    Vg: 'VG',
    Vi: 'VI',
    Vn: 'VN',
    Vu: 'VU',
    Wf: 'WF',
    Ws: 'WS',
    Ye: 'YE',
    Yt: 'YT',
    Za: 'ZA',
    Zm: 'ZM',
    Zw: 'ZW'
} as const;

export type Country = typeof Country[keyof typeof Country];


/**
 * 
 * @export
 * @interface CountryFilter
 */
export interface CountryFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleCountriesCriteria}
     * @memberof CountryFilter
     */
    'COUNTRY': CatalogsProductGroupMultipleCountriesCriteria;
}
/**
 * An object containing a list of all the asset access requests
 * @export
 * @interface CreateAssetAccessRequestBody
 */
export interface CreateAssetAccessRequestBody {
    /**
     * 
     * @type {Array<CreateAssetAccessRequestBodyAssetRequestsInner>}
     * @memberof CreateAssetAccessRequestBody
     */
    'asset_requests': Array<CreateAssetAccessRequestBodyAssetRequestsInner>;
}
/**
 * 
 * @export
 * @interface CreateAssetAccessRequestBodyAssetRequestsInner
 */
export interface CreateAssetAccessRequestBodyAssetRequestsInner {
    /**
     * Unique identifier of a business partner to request asset access to.
     * @type {string}
     * @memberof CreateAssetAccessRequestBodyAssetRequestsInner
     */
    'partner_id': string;
    /**
     * An object mapping asset ids to lists of business permissions. This can be used to setting/requesting permissions on various assets. If accepting an invite or request, this object would be used to grant asset permissions to the member or partner. 
     * @type {{ [key: string]: Array<Permissions>; }}
     * @memberof CreateAssetAccessRequestBodyAssetRequestsInner
     */
    'asset_id_to_permissions': { [key: string]: Array<Permissions>; };
}
/**
 * 
 * @export
 * @interface CreateAssetAccessRequestErrorMessageInner
 */
export interface CreateAssetAccessRequestErrorMessageInner {
    /**
     * Error code associated with the error in requesting asset access.
     * @type {number}
     * @memberof CreateAssetAccessRequestErrorMessageInner
     */
    'code'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateAssetAccessRequestErrorMessageInner
     */
    'messages'?: Array<string>;
}
/**
 * 
 * @export
 * @interface CreateAssetAccessRequestResponse
 */
export interface CreateAssetAccessRequestResponse {
    /**
     * A list of errors associated with the asset access requests. Will be returned if there is an error.
     * @type {Array<CreateAssetAccessRequestErrorMessageInner>}
     * @memberof CreateAssetAccessRequestResponse
     */
    'exceptions'?: Array<CreateAssetAccessRequestErrorMessageInner> | null;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof CreateAssetAccessRequestResponse
     */
    'invites'?: { [key: string]: string; } | null;
}
/**
 * 
 * @export
 * @interface CreateAssetGroupBody
 */
export interface CreateAssetGroupBody {
    /**
     * Asset Group name
     * @type {string}
     * @memberof CreateAssetGroupBody
     */
    'asset_group_name': string;
    /**
     * Asset group description
     * @type {string}
     * @memberof CreateAssetGroupBody
     */
    'asset_group_description': string;
    /**
     * Asset Group Types. Note: The asset group types are used for user reference and categorization purposes only and do not impact the functionality of the asset group.
     * @type {Array<AssetGroupType>}
     * @memberof CreateAssetGroupBody
     */
    'asset_group_types': Array<AssetGroupType>;
}
/**
 * 
 * @export
 * @interface CreateAssetGroupResponse
 */
export interface CreateAssetGroupResponse {
    /**
     * 
     * @type {AssetGroupBinding}
     * @memberof CreateAssetGroupResponse
     */
    'asset_group'?: AssetGroupBinding;
}
/**
 * Request body for updating asset roles for existing invites.
 * @export
 * @interface CreateAssetInvitesRequest
 */
export interface CreateAssetInvitesRequest {
    /**
     * 
     * @type {Array<CreateAssetInvitesRequestItem>}
     * @memberof CreateAssetInvitesRequest
     */
    'invites': Array<CreateAssetInvitesRequestItem>;
}
/**
 * Object declaring an asset role update to an invite.
 * @export
 * @interface CreateAssetInvitesRequestItem
 */
export interface CreateAssetInvitesRequestItem {
    /**
     * Unique identifier of an invite.
     * @type {string}
     * @memberof CreateAssetInvitesRequestItem
     */
    'invite_id': string;
    /**
     * 
     * @type {InviteType}
     * @memberof CreateAssetInvitesRequestItem
     */
    'invite_type': InviteType;
    /**
     * An object mapping asset ids to lists of business permissions. This can be used to setting/requesting permissions on various assets. If accepting an invite or request, this object would be used to grant asset permissions to the member or partner. 
     * @type {{ [key: string]: Array<Permissions>; }}
     * @memberof CreateAssetInvitesRequestItem
     */
    'asset_id_to_permissions': { [key: string]: Array<Permissions>; };
}


/**
 * 
 * @export
 * @interface CreateInvitesResultsResponseArray
 */
export interface CreateInvitesResultsResponseArray {
    /**
     * List of invite/request creation status. If there is an error, an exception object will be returned. If the action was successfully completed, an invite object will be returned.
     * @type {Array<CreateInvitesResultsResponseArrayItemsInner>}
     * @memberof CreateInvitesResultsResponseArray
     */
    'items'?: Array<CreateInvitesResultsResponseArrayItemsInner>;
}
/**
 * 
 * @export
 * @interface CreateInvitesResultsResponseArrayItemsInner
 */
export interface CreateInvitesResultsResponseArrayItemsInner {
    /**
     * 
     * @type {InviteExceptionResponse}
     * @memberof CreateInvitesResultsResponseArrayItemsInner
     */
    'exception'?: InviteExceptionResponse | null;
    /**
     * 
     * @type {CreateInvitesResultsResponseArrayItemsInnerInvite}
     * @memberof CreateInvitesResultsResponseArrayItemsInner
     */
    'invite'?: CreateInvitesResultsResponseArrayItemsInnerInvite | null;
}
/**
 * An invite object if the invite/request was successfully created. Will only be provided if the an invite/request is successfully created.
 * @export
 * @interface CreateInvitesResultsResponseArrayItemsInnerInvite
 */
export interface CreateInvitesResultsResponseArrayItemsInnerInvite {
    /**
     * Unique identifier of the invite/request.
     * @type {string}
     * @memberof CreateInvitesResultsResponseArrayItemsInnerInvite
     */
    'id'?: string;
    /**
     * Metadata for the member/partner that was sent the invite/request.
     * @type {BusinessAccessUserSummary}
     * @memberof CreateInvitesResultsResponseArrayItemsInnerInvite
     */
    'user'?: BusinessAccessUserSummary;
}
/**
 * 
 * @export
 * @interface CreateMMMReportRequest
 */
export interface CreateMMMReportRequest {
    /**
     * Name of the Marketing Mix Modeling (MMM) report
     * @type {string}
     * @memberof CreateMMMReportRequest
     */
    'report_name': string;
    /**
     * Metric report start date (UTC). Format: YYYY-MM-DD
     * @type {string}
     * @memberof CreateMMMReportRequest
     */
    'start_date': string;
    /**
     * Metric report end date (UTC). Format: YYYY-MM-DD
     * @type {string}
     * @memberof CreateMMMReportRequest
     */
    'end_date': string;
    /**
     * DAY - metrics are broken down daily.<br> WEEK - metrics are broken down weekly.
     * @type {string}
     * @memberof CreateMMMReportRequest
     */
    'granularity': CreateMMMReportRequestGranularityEnum;
    /**
     * Level of the report
     * @type {string}
     * @memberof CreateMMMReportRequest
     */
    'level': CreateMMMReportRequestLevelEnum;
    /**
     * List of targeting types
     * @type {Array<MMMReportingTargetingType>}
     * @memberof CreateMMMReportRequest
     */
    'targeting_types': Array<MMMReportingTargetingType>;
    /**
     * Metric and entity columns
     * @type {Array<MMMReportingColumn>}
     * @memberof CreateMMMReportRequest
     */
    'columns': Array<MMMReportingColumn>;
    /**
     * A List of countries for filtering
     * @type {Array<TargetingAdvertiserCountry>}
     * @memberof CreateMMMReportRequest
     */
    'countries'?: Array<TargetingAdvertiserCountry>;
}

export const CreateMMMReportRequestGranularityEnum = {
    Day: 'DAY',
    Week: 'WEEK'
} as const;

export type CreateMMMReportRequestGranularityEnum = typeof CreateMMMReportRequestGranularityEnum[keyof typeof CreateMMMReportRequestGranularityEnum];
export const CreateMMMReportRequestLevelEnum = {
    CampaignTargeting: 'CAMPAIGN_TARGETING',
    AdGroupTargeting: 'AD_GROUP_TARGETING'
} as const;

export type CreateMMMReportRequestLevelEnum = typeof CreateMMMReportRequestLevelEnum[keyof typeof CreateMMMReportRequestLevelEnum];

/**
 * 
 * @export
 * @interface CreateMMMReportResponse
 */
export interface CreateMMMReportResponse {
    /**
     * 
     * @type {number}
     * @memberof CreateMMMReportResponse
     */
    'code'?: number;
    /**
     * 
     * @type {CreateMMMReportResponseData}
     * @memberof CreateMMMReportResponse
     */
    'data'?: CreateMMMReportResponseData;
}
/**
 * 
 * @export
 * @interface CreateMMMReportResponseData
 */
export interface CreateMMMReportResponseData {
    /**
     * 
     * @type {BulkReportingJobStatus}
     * @memberof CreateMMMReportResponseData
     */
    'report_status'?: BulkReportingJobStatus;
    /**
     * 
     * @type {string}
     * @memberof CreateMMMReportResponseData
     */
    'token'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateMMMReportResponseData
     */
    'message'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof CreateMMMReportResponseData
     */
    'status'?: string;
}


/**
 * Body to be used on path to send Members or Partners Invite or Request
 * @export
 * @interface CreateMembershipOrPartnershipInvitesBody
 */
export interface CreateMembershipOrPartnershipInvitesBody {
    /**
     * The business access level to grant member/partner. Note, values are case-sensitive. - EMPLOYEE: Can only view and access assets you assign them to. They cannot see details about other employees, partners, or other assets. - BIZ_ADMIN: Have full control of roles and can add employees and partners as well as grant asset access. - PARTNER: Can only view and access assets you assign them to/or they assign to you.
     * @type {string}
     * @memberof CreateMembershipOrPartnershipInvitesBody
     */
    'business_role': CreateMembershipOrPartnershipInvitesBodyBusinessRoleEnum;
    /**
     * 
     * @type {InviteType}
     * @memberof CreateMembershipOrPartnershipInvitesBody
     */
    'invite_type': InviteType;
    /**
     * A list of usernames, emails, or a mix of them. Should be used if invite_type is MEMBER_INVITE
     * @type {Array<string>}
     * @memberof CreateMembershipOrPartnershipInvitesBody
     */
    'members'?: Array<string>;
    /**
     * A list of partner_id. Should be used if invite_type is PARTNER_INVITE or PARTNER_REQUEST
     * @type {Array<string>}
     * @memberof CreateMembershipOrPartnershipInvitesBody
     */
    'partners'?: Array<string>;
}

export const CreateMembershipOrPartnershipInvitesBodyBusinessRoleEnum = {
    Employee: 'EMPLOYEE',
    BizAdmin: 'BIZ_ADMIN',
    Partner: 'PARTNER'
} as const;

export type CreateMembershipOrPartnershipInvitesBodyBusinessRoleEnum = typeof CreateMembershipOrPartnershipInvitesBodyBusinessRoleEnum[keyof typeof CreateMembershipOrPartnershipInvitesBodyBusinessRoleEnum];

/**
 * 
 * @export
 * @interface CreativeAssetsIdFilter
 */
export interface CreativeAssetsIdFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CreativeAssetsIdFilter
     */
    'CREATIVE_ASSETS_ID': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Object describing an item processing record
 * @export
 * @interface CreativeAssetsProcessingRecord
 */
export interface CreativeAssetsProcessingRecord {
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof CreativeAssetsProcessingRecord
     */
    'creative_assets_id'?: string;
    /**
     * Array with the validation errors for the item processing record. A non empty errors list causes the item processing to fail.
     * @type {Array<ItemValidationEvent>}
     * @memberof CreativeAssetsProcessingRecord
     */
    'errors'?: Array<ItemValidationEvent>;
    /**
     * Array with the validation warnings for the item processing record
     * @type {Array<ItemValidationEvent>}
     * @memberof CreativeAssetsProcessingRecord
     */
    'warnings'?: Array<ItemValidationEvent>;
    /**
     * 
     * @type {ItemProcessingStatus}
     * @memberof CreativeAssetsProcessingRecord
     */
    'status'?: ItemProcessingStatus;
}


/**
 * Creative assets visibility.
 * @export
 * @enum {string}
 */

export const CreativeAssetsVisibilityType = {
    Visible: 'VISIBLE',
    Hidden: 'HIDDEN'
} as const;

export type CreativeAssetsVisibilityType = typeof CreativeAssetsVisibilityType[keyof typeof CreativeAssetsVisibilityType];


/**
 * Ad creative type enum. For update, only draft ads may update creative type. </p><strong>Note:</strong> SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
 * @export
 * @enum {string}
 */

export const CreativeType = {
    Regular: 'REGULAR',
    Video: 'VIDEO',
    Shopping: 'SHOPPING',
    Carousel: 'CAROUSEL',
    MaxVideo: 'MAX_VIDEO',
    ShopThePin: 'SHOP_THE_PIN',
    Collection: 'COLLECTION',
    Idea: 'IDEA',
    Showcase: 'SHOWCASE',
    Quiz: 'QUIZ'
} as const;

export type CreativeType = typeof CreativeType[keyof typeof CreativeType];


/**
 * Currency Codes from ISO 4217
 * @export
 * @enum {string}
 */

export const Currency = {
    Unk: 'UNK',
    Usd: 'USD',
    Gbp: 'GBP',
    Cad: 'CAD',
    Eur: 'EUR',
    Aud: 'AUD',
    Nzd: 'NZD',
    Sek: 'SEK',
    Ils: 'ILS',
    Chf: 'CHF',
    Hkd: 'HKD',
    Jpy: 'JPY',
    Sgd: 'SGD',
    Krw: 'KRW',
    Nok: 'NOK',
    Dkk: 'DKK',
    Pln: 'PLN',
    Ron: 'RON',
    Huf: 'HUF',
    Czk: 'CZK',
    Brl: 'BRL',
    Mxn: 'MXN',
    Ars: 'ARS',
    Clp: 'CLP',
    Cop: 'COP',
    Inr: 'INR',
    Try: 'TRY'
} as const;

export type Currency = typeof Currency[keyof typeof Currency];


/**
 * 
 * @export
 * @interface CurrencyFilter
 */
export interface CurrencyFilter {
    /**
     * 
     * @type {CatalogsProductGroupCurrencyCriteria}
     * @memberof CurrencyFilter
     */
    'CURRENCY': CatalogsProductGroupCurrencyCriteria;
}
/**
 * 
 * @export
 * @interface CustomLabel0Filter
 */
export interface CustomLabel0Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CustomLabel0Filter
     */
    'CUSTOM_LABEL_0': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface CustomLabel1Filter
 */
export interface CustomLabel1Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CustomLabel1Filter
     */
    'CUSTOM_LABEL_1': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface CustomLabel2Filter
 */
export interface CustomLabel2Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CustomLabel2Filter
     */
    'CUSTOM_LABEL_2': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface CustomLabel3Filter
 */
export interface CustomLabel3Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CustomLabel3Filter
     */
    'CUSTOM_LABEL_3': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface CustomLabel4Filter
 */
export interface CustomLabel4Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof CustomLabel4Filter
     */
    'CUSTOM_LABEL_4': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface CustomerList
 */
export interface CustomerList {
    /**
     * Associated ad account ID.
     * @type {string}
     * @memberof CustomerList
     */
    'ad_account_id'?: string;
    /**
     * Creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof CustomerList
     */
    'created_time'?: number;
    /**
     * Customer list ID.
     * @type {string}
     * @memberof CustomerList
     */
    'id'?: string;
    /**
     * Customer list name.
     * @type {string}
     * @memberof CustomerList
     */
    'name'?: string;
    /**
     * Total number of list updates.  List creation counts as one batch. Each <a href=\"/docs/redoc/#operation/ads_v3_customer_list_add_handler_PUT\">Append</a> or <a href=\"/docs/redoc/#operation/ads_v3_customer_list_remove_handler_PUT\">Remove API</a> call counts as another. List creation via the Ads Manager UI could result in more than one batch since the UI breaks up large lists.
     * @type {number}
     * @memberof CustomerList
     */
    'num_batches'?: number;
    /**
     * Number of removed user records. In a <a href=\"/docs/redoc/#operation/ads_v3_customer_list_remove_handler_PUT\">Remove API</a> call, this counter increases even if the user is not found in the list.
     * @type {number}
     * @memberof CustomerList
     */
    'num_removed_user_records'?: number;
    /**
     * Number of uploaded user records. In an <a href=\"/docs/redoc/#operation/ads_v3_customer_list_add_handler_PUT\">Append API</a> call, this counter increases even if the uploaded user is already in the list.
     * @type {number}
     * @memberof CustomerList
     */
    'num_uploaded_user_records'?: number;
    /**
     * Customer list status. TOO_SMALL - the list has less than 100 Pinterest users.
     * @type {string}
     * @memberof CustomerList
     */
    'status'?: CustomerListStatusEnum;
    /**
     * Always \"customerlist\".
     * @type {string}
     * @memberof CustomerList
     */
    'type'?: string;
    /**
     * Last update time. Unix timestamp in seconds.
     * @type {number}
     * @memberof CustomerList
     */
    'updated_time'?: number;
    /**
     * Customer list errors
     * @type {object}
     * @memberof CustomerList
     */
    'exceptions'?: object;
}

export const CustomerListStatusEnum = {
    Processing: 'PROCESSING',
    Ready: 'READY',
    TooSmall: 'TOO_SMALL',
    Uploading: 'UPLOADING'
} as const;

export type CustomerListStatusEnum = typeof CustomerListStatusEnum[keyof typeof CustomerListStatusEnum];

/**
 * 
 * @export
 * @interface CustomerListRequest
 */
export interface CustomerListRequest {
    /**
     * Customer list name.
     * @type {string}
     * @memberof CustomerListRequest
     */
    'name': string;
    /**
     * Records list. Can be any combination of emails, MAIDs, or IDFAs. Emails must be lowercase and can be plain text or hashed using SHA1, SHA256, or MD5. MAIDs and IDFAs must be hashed with SHA1, SHA256, or MD5.
     * @type {string}
     * @memberof CustomerListRequest
     */
    'records': string;
    /**
     * 
     * @type {UserListType}
     * @memberof CustomerListRequest
     */
    'list_type'?: UserListType;
    /**
     * Customer list errors.
     * @type {object}
     * @memberof CustomerListRequest
     */
    'exceptions'?: object;
}


/**
 * 
 * @export
 * @interface CustomerListUpdateRequest
 */
export interface CustomerListUpdateRequest {
    /**
     * Records list. Can be any combination of emails, MAIDs, or IDFAs. Emails must be lowercase and can be plain text or hashed using SHA1, SHA256, or MD5. MAIDs and IDFAs must be hashed with SHA1, SHA256, or MD5.
     * @type {string}
     * @memberof CustomerListUpdateRequest
     */
    'records': string;
    /**
     * 
     * @type {UserListOperationType}
     * @memberof CustomerListUpdateRequest
     */
    'operation_type': UserListOperationType;
    /**
     * 
     * @type {Exception}
     * @memberof CustomerListUpdateRequest
     */
    'exceptions'?: Exception;
}


/**
 * 
 * @export
 * @interface CustomerListsList200Response
 */
export interface CustomerListsList200Response {
    /**
     * 
     * @type {Array<CustomerList>}
     * @memberof CustomerListsList200Response
     */
    'items': Array<CustomerList>;
    /**
     * 
     * @type {string}
     * @memberof CustomerListsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Format of generated report
 * @export
 * @enum {string}
 */

export const DataOutputFormat = {
    Json: 'JSON',
    Csv: 'CSV'
} as const;

export type DataOutputFormat = typeof DataOutputFormat[keyof typeof DataOutputFormat];


/**
 * Metrics availablity, e.g., \"READY\".
 * @export
 * @enum {string}
 */

export const DataStatus = {
    Processing: 'PROCESSING',
    Ready: 'READY',
    Estimate: 'ESTIMATE',
    BeforeBusinessCreated: 'BEFORE_BUSINESS_CREATED',
    BeforeDataRetentionPeriod: 'BEFORE_DATA_RETENTION_PERIOD',
    BeforePinDataRetentionPeriod: 'BEFORE_PIN_DATA_RETENTION_PERIOD',
    BeforeMetricStartDate: 'BEFORE_METRIC_START_DATE',
    BeforeCoreMetricStartDate: 'BEFORE_CORE_METRIC_START_DATE',
    BeforePinFormatMetricStartDate: 'BEFORE_PIN_FORMAT_METRIC_START_DATE',
    BeforeAudienceMetricStartDate: 'BEFORE_AUDIENCE_METRIC_START_DATE',
    BeforeAudienceMonthlyMetricStartDate: 'BEFORE_AUDIENCE_MONTHLY_METRIC_START_DATE',
    BeforeVideoMetricStartDate: 'BEFORE_VIDEO_METRIC_START_DATE',
    BeforeConversionMetricStartDate: 'BEFORE_CONVERSION_METRIC_START_DATE',
    PurchasersMetricSmallerThanThreshold: 'PURCHASERS_METRIC_SMALLER_THAN_THRESHOLD',
    InBadTagDate: 'IN_BAD_TAG_DATE',
    BeforePublishedMetricStartDate: 'BEFORE_PUBLISHED_METRIC_START_DATE',
    BeforeAssistMetricStartDate: 'BEFORE_ASSIST_METRIC_START_DATE',
    BeforePinCreated: 'BEFORE_PIN_CREATED',
    BeforeAccountClaimed: 'BEFORE_ACCOUNT_CLAIMED',
    BeforeDemographicFiltersStartDate: 'BEFORE_DEMOGRAPHIC_FILTERS_START_DATE',
    AudienceSegmentSmallerThanThreshold: 'AUDIENCE_SEGMENT_SMALLER_THAN_THRESHOLD',
    AudienceTotalSmallerThanThreshold: 'AUDIENCE_TOTAL_SMALLER_THAN_THRESHOLD',
    BeforeProductGroupFilterStartDate: 'BEFORE_PRODUCT_GROUP_FILTER_START_DATE'
} as const;

export type DataStatus = typeof DataStatus[keyof typeof DataStatus];


/**
 * Request body used to delete asset groups
 * @export
 * @interface DeleteAssetGroupBody
 */
export interface DeleteAssetGroupBody {
    /**
     * List of ids of asset groups to be deleted
     * @type {Array<string>}
     * @memberof DeleteAssetGroupBody
     */
    'asset_groups_to_delete': Array<string>;
}
/**
 * 
 * @export
 * @interface DeleteAssetGroupResponse
 */
export interface DeleteAssetGroupResponse {
    /**
     * A list of ids of successfully deleted asset groups.
     * @type {Array<string>}
     * @memberof DeleteAssetGroupResponse
     */
    'deleted_asset_groups'?: Array<string>;
    /**
     * A list of errors associated with the asset groups. Will be returned if there is an error.
     * @type {Array<DeleteAssetGroupResponseExceptionsInner>}
     * @memberof DeleteAssetGroupResponse
     */
    'exceptions'?: Array<DeleteAssetGroupResponseExceptionsInner> | null;
}
/**
 * 
 * @export
 * @interface DeleteAssetGroupResponseExceptionsInner
 */
export interface DeleteAssetGroupResponseExceptionsInner {
    /**
     * Error code associated with the error deleting asset group.
     * @type {number}
     * @memberof DeleteAssetGroupResponseExceptionsInner
     */
    'code'?: number;
    /**
     * Error message associated with the error deleting asset group.
     * @type {string}
     * @memberof DeleteAssetGroupResponseExceptionsInner
     */
    'message'?: string;
    /**
     * Asset group id of the exception.
     * @type {string}
     * @memberof DeleteAssetGroupResponseExceptionsInner
     */
    'asset_group_id'?: string;
}
/**
 * Response to delete invites sent to Members or Partners, if there is an exception, return the exception mapped with the invite id
 * @export
 * @interface DeleteInvitesResultsResponseArray
 */
export interface DeleteInvitesResultsResponseArray {
    /**
     * List of invite/Request deletion status. If there is an error, an exception object will be returned. If the invite/request was successfully cancelled, an invite object will be returned for the invite that was cancelled.
     * @type {Array<DeleteInvitesResultsResponseArrayItemsInner>}
     * @memberof DeleteInvitesResultsResponseArray
     */
    'items'?: Array<DeleteInvitesResultsResponseArrayItemsInner>;
}
/**
 * 
 * @export
 * @interface DeleteInvitesResultsResponseArrayItemsInner
 */
export interface DeleteInvitesResultsResponseArrayItemsInner {
    /**
     * 
     * @type {DeleteInvitesResultsResponseArrayItemsInnerException}
     * @memberof DeleteInvitesResultsResponseArrayItemsInner
     */
    'exception'?: DeleteInvitesResultsResponseArrayItemsInnerException | null;
    /**
     * 
     * @type {BaseInviteDataResponse}
     * @memberof DeleteInvitesResultsResponseArrayItemsInner
     */
    'invite'?: BaseInviteDataResponse | null;
}
/**
 * An exception object if there is an error performing the cancellation. It will only be provided if there is an error.
 * @export
 * @interface DeleteInvitesResultsResponseArrayItemsInnerException
 */
export interface DeleteInvitesResultsResponseArrayItemsInnerException {
    /**
     * Unique identifier of an invite.
     * @type {string}
     * @memberof DeleteInvitesResultsResponseArrayItemsInnerException
     */
    'invite_id'?: string;
    /**
     * Error message associated with the error in performing the action on the invite/request.
     * @type {string}
     * @memberof DeleteInvitesResultsResponseArrayItemsInnerException
     */
    'message'?: string;
}
/**
 * The terminated asset access.
 * @export
 * @interface DeleteMemberAccessResult
 */
export interface DeleteMemberAccessResult {
    /**
     * Unique identifier of the business asset.
     * @type {string}
     * @memberof DeleteMemberAccessResult
     */
    'asset_id'?: string;
    /**
     * Unique identifier of the business member.
     * @type {string}
     * @memberof DeleteMemberAccessResult
     */
    'member_id'?: string;
}
/**
 * 
 * @export
 * @interface DeleteMemberAccessResultsResponseArray
 */
export interface DeleteMemberAccessResultsResponseArray {
    /**
     * List of member asset permissions that were deleted.
     * @type {Array<DeleteMemberAccessResult>}
     * @memberof DeleteMemberAccessResultsResponseArray
     */
    'items'?: Array<DeleteMemberAccessResult>;
}
/**
 * 
 * @export
 * @interface DeletePartnerAssetAccessBody
 */
export interface DeletePartnerAssetAccessBody {
    /**
     * 
     * @type {Array<DeletePartnerAssetAccessBodyAccessesInner>}
     * @memberof DeletePartnerAssetAccessBody
     */
    'accesses': Array<DeletePartnerAssetAccessBodyAccessesInner>;
}
/**
 * 
 * @export
 * @interface DeletePartnerAssetAccessBodyAccessesInner
 */
export interface DeletePartnerAssetAccessBodyAccessesInner {
    /**
     * Unique identifier of a business partner to update asset access to.
     * @type {string}
     * @memberof DeletePartnerAssetAccessBodyAccessesInner
     */
    'partner_id': string;
    /**
     * Unique identifier of the business asset.
     * @type {string}
     * @memberof DeletePartnerAssetAccessBodyAccessesInner
     */
    'asset_id': string;
    /**
     * If partner_type=INTERNAL, the deleted asset access is for the access the partner has to your business asset.<br> If partner_type=EXTERNAL, the deleted asset access is for the access you have to the partner\'s business asset.
     * @type {string}
     * @memberof DeletePartnerAssetAccessBodyAccessesInner
     */
    'partner_type'?: DeletePartnerAssetAccessBodyAccessesInnerPartnerTypeEnum;
}

export const DeletePartnerAssetAccessBodyAccessesInnerPartnerTypeEnum = {
    Internal: 'INTERNAL',
    External: 'EXTERNAL'
} as const;

export type DeletePartnerAssetAccessBodyAccessesInnerPartnerTypeEnum = typeof DeletePartnerAssetAccessBodyAccessesInnerPartnerTypeEnum[keyof typeof DeletePartnerAssetAccessBodyAccessesInnerPartnerTypeEnum];

/**
 * The terminated asset access.
 * @export
 * @interface DeletePartnerAssetsResult
 */
export interface DeletePartnerAssetsResult {
    /**
     * Unique identifier of a business asset.
     * @type {string}
     * @memberof DeletePartnerAssetsResult
     */
    'asset_id'?: string;
    /**
     * Type of asset. Currently we only support AD_ACCOUNT and PROFILE, and ASSET_GROUP.
     * @type {string}
     * @memberof DeletePartnerAssetsResult
     */
    'asset_type'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof DeletePartnerAssetsResult
     */
    'permissions'?: Array<string>;
    /**
     * If is_shared_partner=FALSE, you terminated a partner\'s asset access to your business asset.<br> If is_shared_partner=TRUE, you terminated your asset access to your partner\'s business asset.
     * @type {boolean}
     * @memberof DeletePartnerAssetsResult
     */
    'is_shared_partner'?: boolean;
    /**
     * Unique identifier of a business partner.
     * @type {string}
     * @memberof DeletePartnerAssetsResult
     */
    'partner_id'?: string;
}
/**
 * 
 * @export
 * @interface DeletePartnerAssetsResultsResponseArray
 */
export interface DeletePartnerAssetsResultsResponseArray {
    /**
     * List of terminated asset access.
     * @type {Array<DeletePartnerAssetsResult>}
     * @memberof DeletePartnerAssetsResultsResponseArray
     */
    'items'?: Array<DeletePartnerAssetsResult>;
}
/**
 * 
 * @export
 * @interface DeletePartnersRequest
 */
export interface DeletePartnersRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeletePartnersRequest
     */
    'partner_ids': Array<string>;
    /**
     * 
     * @type {string & BusinessRoleCheckMode}
     * @memberof DeletePartnersRequest
     */
    'partner_type'?: string & BusinessRoleCheckMode | null;
}
/**
 * An object with a list of partners that were deleted.
 * @export
 * @interface DeletePartnersResponse
 */
export interface DeletePartnersResponse {
    /**
     * List of partners whose business partnership have been terminated.
     * @type {Array<string>}
     * @memberof DeletePartnersResponse
     */
    'deleted_partners'?: Array<string>;
}
/**
 * An object with a list of members that were deleted.
 * @export
 * @interface DeletedMembersResponse
 */
export interface DeletedMembersResponse {
    /**
     * List of members whose business membership have been terminated.
     * @type {Array<string>}
     * @memberof DeletedMembersResponse
     */
    'deleted_members'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DeliveryMetricsResponse
 */
export interface DeliveryMetricsResponse {
    /**
     * 
     * @type {Array<DeliveryMetricsResponseItemsInner>}
     * @memberof DeliveryMetricsResponse
     */
    'items'?: Array<DeliveryMetricsResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface DeliveryMetricsResponseItemsInner
 */
export interface DeliveryMetricsResponseItemsInner {
    /**
     * Metric\'s name.
     * @type {string}
     * @memberof DeliveryMetricsResponseItemsInner
     */
    'name'?: string;
    /**
     * Category name
     * @type {string}
     * @memberof DeliveryMetricsResponseItemsInner
     */
    'category'?: DeliveryMetricsResponseItemsInnerCategoryEnum;
    /**
     * How the metric is defined.
     * @type {string}
     * @memberof DeliveryMetricsResponseItemsInner
     */
    'definition'?: string;
    /**
     * Display name, when available. If unavaible it will not be returned. Matches how the metric is named in our native tools like Pinterest Ads Manager.
     * @type {string}
     * @memberof DeliveryMetricsResponseItemsInner
     */
    'display_name'?: string;
}

export const DeliveryMetricsResponseItemsInnerCategoryEnum = {
    Ads: 'ADS',
    Organic: 'ORGANIC'
} as const;

export type DeliveryMetricsResponseItemsInnerCategoryEnum = typeof DeliveryMetricsResponseItemsInnerCategoryEnum[keyof typeof DeliveryMetricsResponseItemsInnerCategoryEnum];

/**
 * Used for including extra details to a base error
 * @export
 * @interface DetailedError
 */
export interface DetailedError {
    /**
     * 
     * @type {number}
     * @memberof DetailedError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof DetailedError
     */
    'message': string;
    /**
     * 
     * @type {object}
     * @memberof DetailedError
     */
    'details': object;
}
/**
 * The enhanced match status of the tag
 * @export
 * @enum {string}
 */

export const EnhancedMatchStatusType = {
    Unknown: 'UNKNOWN',
    NotValidated: 'NOT_VALIDATED',
    ValidatingInProgress: 'VALIDATING_IN_PROGRESS',
    ValidationComplete: 'VALIDATION_COMPLETE'
} as const;

export type EnhancedMatchStatusType = typeof EnhancedMatchStatusType[keyof typeof EnhancedMatchStatusType];


/**
 * Entity status
 * @export
 * @enum {string}
 */

export const EntityStatus = {
    Active: 'ACTIVE',
    Paused: 'PAUSED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;

export type EntityStatus = typeof EntityStatus[keyof typeof EntityStatus];


/**
 * 
 * @export
 * @interface Exception
 */
export interface Exception {
    /**
     * Exception error code.
     * @type {number}
     * @memberof Exception
     */
    'code'?: number;
    /**
     * Exception message.
     * @type {string}
     * @memberof Exception
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface FeedProcessingResultsList200Response
 */
export interface FeedProcessingResultsList200Response {
    /**
     * 
     * @type {Array<CatalogsFeedProcessingResult>}
     * @memberof FeedProcessingResultsList200Response
     */
    'items': Array<CatalogsFeedProcessingResult>;
    /**
     * 
     * @type {string}
     * @memberof FeedProcessingResultsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * @type FeedsCreateRequest
 * @export
 */
export type FeedsCreateRequest = CatalogsFeedsCreateRequest | CatalogsVerticalFeedsCreateRequest;

/**
 * 
 * @export
 * @interface FeedsList200Response
 */
export interface FeedsList200Response {
    /**
     * 
     * @type {Array<CatalogsFeed>}
     * @memberof FeedsList200Response
     */
    'items': Array<CatalogsFeed>;
    /**
     * 
     * @type {string}
     * @memberof FeedsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * @type FeedsUpdateRequest
 * @export
 */
export type FeedsUpdateRequest = CatalogsFeedsUpdateRequest | CatalogsVerticalFeedsUpdateRequest;

/**
 * 
 * @export
 * @interface FollowUserRequest
 */
export interface FollowUserRequest {
    /**
     * Whether this request comes as result of auto-follow after clicking on a link. Follow links can be used by partners on their site or in emails. Only selected partners can be followed this way. We verify that partner can be auto-followed.
     * @type {boolean}
     * @memberof FollowUserRequest
     */
    'auto_follow'?: boolean;
}
/**
 * 
 * @export
 * @interface FollowersList200Response
 */
export interface FollowersList200Response {
    /**
     * 
     * @type {Array<UserSummary>}
     * @memberof FollowersList200Response
     */
    'items': Array<UserSummary>;
    /**
     * 
     * @type {string}
     * @memberof FollowersList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const Gender = {
    Female: 'FEMALE',
    Male: 'MALE',
    Unisex: 'UNISEX'
} as const;

export type Gender = typeof Gender[keyof typeof Gender];


/**
 * 
 * @export
 * @interface GenderFilter
 */
export interface GenderFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleGenderCriteria}
     * @memberof GenderFilter
     */
    'GENDER': CatalogsProductGroupMultipleGenderCriteria;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const GetAudiencesOrderBy = {
    None: 'NONE',
    Id: 'ID',
    Size: 'SIZE',
    CreationDate: 'CREATION_DATE',
    UpdatedTime: 'UPDATED_TIME',
    Name: 'NAME',
    Status: 'STATUS',
    Type: 'TYPE'
} as const;

export type GetAudiencesOrderBy = typeof GetAudiencesOrderBy[keyof typeof GetAudiencesOrderBy];


/**
 * Type of asset.
 * @export
 * @enum {string}
 */

export const GetBusinessAssetTypeResponse = {
    AdAccount: 'AD_ACCOUNT',
    Profile: 'PROFILE',
    AssetGroup: 'ASSET_GROUP',
    ConversionTag: 'CONVERSION_TAG'
} as const;

export type GetBusinessAssetTypeResponse = typeof GetBusinessAssetTypeResponse[keyof typeof GetBusinessAssetTypeResponse];


/**
 * An object containing the permissions a business has on the asset.
 * @export
 * @interface GetBusinessAssetsResponse
 */
export interface GetBusinessAssetsResponse {
    /**
     * Unique identifier of a business asset.
     * @type {string}
     * @memberof GetBusinessAssetsResponse
     */
    'asset_id'?: string;
    /**
     * Type of asset. Currently we only support AD_ACCOUNT and PROFILE, and ASSET_GROUP.
     * @type {string}
     * @memberof GetBusinessAssetsResponse
     */
    'asset_type'?: string;
    /**
     * 
     * @type {AssetGroupBinding}
     * @memberof GetBusinessAssetsResponse
     */
    'asset_group_info'?: AssetGroupBinding;
}
/**
 * 
 * @export
 * @interface GetBusinessEmployers200Response
 */
export interface GetBusinessEmployers200Response {
    /**
     * List of employers.
     * @type {Array<UserBusinessRoleBinding>}
     * @memberof GetBusinessEmployers200Response
     */
    'items': Array<UserBusinessRoleBinding>;
    /**
     * 
     * @type {string}
     * @memberof GetBusinessEmployers200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface GetBusinessMembers200Response
 */
export interface GetBusinessMembers200Response {
    /**
     * List of business members.
     * @type {Array<UserBusinessRoleBinding>}
     * @memberof GetBusinessMembers200Response
     */
    'items': Array<UserBusinessRoleBinding>;
    /**
     * 
     * @type {string}
     * @memberof GetBusinessMembers200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface GetBusinessPartners200Response
 */
export interface GetBusinessPartners200Response {
    /**
     * List of business partners.
     * @type {Array<UserBusinessRoleBinding>}
     * @memberof GetBusinessPartners200Response
     */
    'items': Array<UserBusinessRoleBinding>;
    /**
     * 
     * @type {string}
     * @memberof GetBusinessPartners200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface GetInvites200Response
 */
export interface GetInvites200Response {
    /**
     * List of invite and request data.
     * @type {Array<InviteResponse>}
     * @memberof GetInvites200Response
     */
    'items': Array<InviteResponse>;
    /**
     * 
     * @type {string}
     * @memberof GetInvites200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface GetMMMReportResponse
 */
export interface GetMMMReportResponse {
    /**
     * 
     * @type {number}
     * @memberof GetMMMReportResponse
     */
    'code'?: number;
    /**
     * 
     * @type {GetMMMReportResponseData}
     * @memberof GetMMMReportResponse
     */
    'data'?: GetMMMReportResponseData;
    /**
     * 
     * @type {string}
     * @memberof GetMMMReportResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetMMMReportResponse
     */
    'status'?: string;
}
/**
 * 
 * @export
 * @interface GetMMMReportResponseData
 */
export interface GetMMMReportResponseData {
    /**
     * 
     * @type {string}
     * @memberof GetMMMReportResponseData
     */
    'report_status'?: GetMMMReportResponseDataReportStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof GetMMMReportResponseData
     */
    'url'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof GetMMMReportResponseData
     */
    'size'?: number | null;
}

export const GetMMMReportResponseDataReportStatusEnum = {
    DoesNotExist: 'DOES_NOT_EXIST',
    Finished: 'FINISHED',
    InProgress: 'IN_PROGRESS',
    Expired: 'EXPIRED',
    Failed: 'FAILED',
    Cancelled: 'CANCELLED'
} as const;

export type GetMMMReportResponseDataReportStatusEnum = typeof GetMMMReportResponseDataReportStatusEnum[keyof typeof GetMMMReportResponseDataReportStatusEnum];

/**
 * An object containing the permissions a you/your business partner has on the asset.
 * @export
 * @interface GetPartnerAssetsResponse
 */
export interface GetPartnerAssetsResponse {
    /**
     * Unique identifier of a business asset.
     * @type {string}
     * @memberof GetPartnerAssetsResponse
     */
    'asset_id'?: string;
    /**
     * Type of asset. Currently we only support AD_ACCOUNT and PROFILE, and ASSET_GROUP.
     * @type {string}
     * @memberof GetPartnerAssetsResponse
     */
    'asset_type'?: string;
    /**
     * The permissions you or your partner has on the asset. If partner_type=INTERNAL, the permission levels are for the access the partner has to your business asset.<br> If partner_type=EXTERNAL, the permission levels are for the access you have to the partner\'s business asset.
     * @type {Array<string>}
     * @memberof GetPartnerAssetsResponse
     */
    'permissions'?: Array<string>;
    /**
     * 
     * @type {AssetGroupBinding}
     * @memberof GetPartnerAssetsResponse
     */
    'asset_group_info'?: AssetGroupBinding;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory0Filter
 */
export interface GoogleProductCategory0Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory0Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_0': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory1Filter
 */
export interface GoogleProductCategory1Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory1Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_1': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory2Filter
 */
export interface GoogleProductCategory2Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory2Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_2': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory3Filter
 */
export interface GoogleProductCategory3Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory3Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_3': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory4Filter
 */
export interface GoogleProductCategory4Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory4Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_4': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory5Filter
 */
export interface GoogleProductCategory5Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory5Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_5': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface GoogleProductCategory6Filter
 */
export interface GoogleProductCategory6Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof GoogleProductCategory6Filter
     */
    'GOOGLE_PRODUCT_CATEGORY_6': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * Granularity
 * @export
 * @enum {string}
 */

export const Granularity = {
    Total: 'TOTAL',
    Day: 'DAY',
    Hour: 'HOUR',
    Week: 'WEEK',
    Month: 'MONTH'
} as const;

export type Granularity = typeof Granularity[keyof typeof Granularity];


/**
 * Where a user is taken after clicking on an ad in grid. </p><strong>Note:</strong>  This parameter is read-only and is set to DIRECT_TO_DESTINATION by default for direct links supported ads.  grid_click_type values provided will be ignored.
 * @export
 * @enum {string}
 */

export const GridClickType = {
    Closeup: 'CLOSEUP',
    DirectToDestination: 'DIRECT_TO_DESTINATION'
} as const;

export type GridClickType = typeof GridClickType[keyof typeof GridClickType];


/**
 * 
 * @export
 * @interface HotelIdFilter
 */
export interface HotelIdFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof HotelIdFilter
     */
    'HOTEL_ID': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Object describing an item processing record
 * @export
 * @interface HotelProcessingRecord
 */
export interface HotelProcessingRecord {
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof HotelProcessingRecord
     */
    'hotel_id'?: string;
    /**
     * Array with the validation errors for the item processing record. A non empty errors list causes the item processing to fail.
     * @type {Array<ItemValidationEvent>}
     * @memberof HotelProcessingRecord
     */
    'errors'?: Array<ItemValidationEvent>;
    /**
     * Array with the validation warnings for the item processing record
     * @type {Array<ItemValidationEvent>}
     * @memberof HotelProcessingRecord
     */
    'warnings'?: Array<ItemValidationEvent>;
    /**
     * 
     * @type {ItemProcessingStatus}
     * @memberof HotelProcessingRecord
     */
    'status'?: ItemProcessingStatus;
}


/**
 * 
 * @export
 * @interface ImageDetails
 */
export interface ImageDetails {
    /**
     * 
     * @type {number}
     * @memberof ImageDetails
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof ImageDetails
     */
    'height': number | null;
    /**
     * 
     * @type {string}
     * @memberof ImageDetails
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImageMetadata
 */
export interface ImageMetadata {
    /**
     * 
     * @type {string}
     * @memberof ImageMetadata
     */
    'item_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ImageMetadata
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageMetadata
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ImageMetadata
     */
    'link'?: string | null;
    /**
     * 
     * @type {ImageMetadataImages}
     * @memberof ImageMetadata
     */
    'images'?: ImageMetadataImages;
}
/**
 * 
 * @export
 * @interface ImageMetadataImages
 */
export interface ImageMetadataImages {
    /**
     * 
     * @type {ImageDetails}
     * @memberof ImageMetadataImages
     */
    '150x150'?: ImageDetails;
    /**
     * 
     * @type {ImageDetails}
     * @memberof ImageMetadataImages
     */
    '400x300'?: ImageDetails;
    /**
     * 
     * @type {ImageDetails}
     * @memberof ImageMetadataImages
     */
    '600x'?: ImageDetails;
    /**
     * 
     * @type {ImageDetails}
     * @memberof ImageMetadataImages
     */
    '1200x'?: ImageDetails;
}
/**
 * Schema for log sent from an integration application.
 * @export
 * @interface IntegrationLog
 */
export interface IntegrationLog {
    /**
     * Timestamp in milliseconds of when the log was executed at the client.
     * @type {number}
     * @memberof IntegrationLog
     */
    'client_timestamp': number;
    /**
     * Log event type
     * @type {string}
     * @memberof IntegrationLog
     */
    'event_type': IntegrationLogEventTypeEnum;
    /**
     * Log level type
     * @type {string}
     * @memberof IntegrationLog
     */
    'log_level': IntegrationLogLogLevelEnum;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    'external_business_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    'advertiser_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    'merchant_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    'tag_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationLog
     */
    'feed_profile_id'?: string | null;
    /**
     * Explanation of the event that occured.
     * @type {string}
     * @memberof IntegrationLog
     */
    'message'?: string;
    /**
     * Version number of the integration application.
     * @type {string}
     * @memberof IntegrationLog
     */
    'app_version_number'?: string;
    /**
     * Version number of the platform the integration application is running on.
     * @type {string}
     * @memberof IntegrationLog
     */
    'platform_version_number'?: string;
    /**
     * 
     * @type {IntegrationLogClientError}
     * @memberof IntegrationLog
     */
    'error'?: IntegrationLogClientError;
    /**
     * 
     * @type {IntegrationLogClientRequest}
     * @memberof IntegrationLog
     */
    'request'?: IntegrationLogClientRequest;
}

export const IntegrationLogEventTypeEnum = {
    App: 'APP',
    Api: 'API'
} as const;

export type IntegrationLogEventTypeEnum = typeof IntegrationLogEventTypeEnum[keyof typeof IntegrationLogEventTypeEnum];
export const IntegrationLogLogLevelEnum = {
    Info: 'INFO',
    Warn: 'WARN',
    Error: 'ERROR'
} as const;

export type IntegrationLogLogLevelEnum = typeof IntegrationLogLogLevelEnum[keyof typeof IntegrationLogLogLevelEnum];

/**
 * System error details included in the log sent by the client.
 * @export
 * @interface IntegrationLogClientError
 */
export interface IntegrationLogClientError {
    /**
     * Original cause of the error.
     * @type {string}
     * @memberof IntegrationLogClientError
     */
    'cause'?: string;
    /**
     * Column number in the line of the file that raised the error.
     * @type {number}
     * @memberof IntegrationLogClientError
     */
    'column_number'?: number;
    /**
     * Filename where the error happened.
     * @type {string}
     * @memberof IntegrationLogClientError
     */
    'file_name'?: string;
    /**
     * Line number where the error happened.
     * @type {number}
     * @memberof IntegrationLogClientError
     */
    'line_number'?: number;
    /**
     * Human-readable description of the error.
     * @type {string}
     * @memberof IntegrationLogClientError
     */
    'message'?: string;
    /**
     * More detail about the message.
     * @type {string}
     * @memberof IntegrationLogClientError
     */
    'message_detail'?: string;
    /**
     * Filename where the error happened.
     * @type {string}
     * @memberof IntegrationLogClientError
     */
    'name'?: string;
    /**
     * Integer that specifies the error code.
     * @type {number}
     * @memberof IntegrationLogClientError
     */
    'number'?: number;
    /**
     * Stack trace of where the error happened.
     * @type {string}
     * @memberof IntegrationLogClientError
     */
    'stack_trace'?: string;
}
/**
 * HTTP request details included in the log sent by the client.
 * @export
 * @interface IntegrationLogClientRequest
 */
export interface IntegrationLogClientRequest {
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogClientRequest
     */
    'method': IntegrationLogClientRequestMethodEnum;
    /**
     * HTTP request host from host header.
     * @type {string}
     * @memberof IntegrationLogClientRequest
     */
    'host': string;
    /**
     * HTTP request path.
     * @type {string}
     * @memberof IntegrationLogClientRequest
     */
    'path': string;
    /**
     * HTTP request headers as key-value pairs.
     * @type {{ [key: string]: string; }}
     * @memberof IntegrationLogClientRequest
     */
    'request_headers'?: { [key: string]: string; };
    /**
     * HTTP response headers as key-value pairs.
     * @type {{ [key: string]: string; }}
     * @memberof IntegrationLogClientRequest
     */
    'response_headers'?: { [key: string]: string; };
    /**
     * 
     * @type {number}
     * @memberof IntegrationLogClientRequest
     */
    'response_status_code'?: number;
}

export const IntegrationLogClientRequestMethodEnum = {
    Get: 'GET',
    Head: 'HEAD',
    Post: 'POST',
    Put: 'PUT',
    Delete: 'DELETE',
    Connect: 'CONNECT',
    Options: 'OPTIONS',
    Trace: 'TRACE',
    Patch: 'PATCH'
} as const;

export type IntegrationLogClientRequestMethodEnum = typeof IntegrationLogClientRequestMethodEnum[keyof typeof IntegrationLogClientRequestMethodEnum];

/**
 * Schema describing the response when a log has invalid fields.
 * @export
 * @interface IntegrationLogsInvalidLogResponse
 */
export interface IntegrationLogsInvalidLogResponse {
    /**
     * 
     * @type {Array<IntegrationLogsInvalidLogResponseRejectedLogsInner>}
     * @memberof IntegrationLogsInvalidLogResponse
     */
    'rejected_logs'?: Array<IntegrationLogsInvalidLogResponseRejectedLogsInner>;
}
/**
 * 
 * @export
 * @interface IntegrationLogsInvalidLogResponseRejectedLogsInner
 */
export interface IntegrationLogsInvalidLogResponseRejectedLogsInner {
    /**
     * Index of the log in the batch.
     * @type {number}
     * @memberof IntegrationLogsInvalidLogResponseRejectedLogsInner
     */
    'log_index'?: number;
    /**
     * The field name containing an invalid value.
     * @type {string}
     * @memberof IntegrationLogsInvalidLogResponseRejectedLogsInner
     */
    'field': string;
    /**
     * The value that is invalid.
     * @type {string}
     * @memberof IntegrationLogsInvalidLogResponseRejectedLogsInner
     */
    'value': string;
    /**
     * The reason the value is invalid.
     * @type {string}
     * @memberof IntegrationLogsInvalidLogResponseRejectedLogsInner
     */
    'reason': string;
}
/**
 * Batch of logs sent from an integration application.
 * @export
 * @interface IntegrationLogsRequest
 */
export interface IntegrationLogsRequest {
    /**
     * 
     * @type {Array<IntegrationLog>}
     * @memberof IntegrationLogsRequest
     */
    'logs': Array<IntegrationLog>;
}
/**
 * Response when logs are successfully processed.
 * @export
 * @interface IntegrationLogsSuccessResponse
 */
export interface IntegrationLogsSuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof IntegrationLogsSuccessResponse
     */
    'message'?: string;
}
/**
 * Integration metadata
 * @export
 * @interface IntegrationMetadata
 */
export interface IntegrationMetadata {
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'external_business_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'connected_merchant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'connected_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'connected_advertiser_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'connected_lba_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'connected_tag_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationMetadata
     */
    'partner_access_token_expiry'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationMetadata
     */
    'partner_refresh_token_expiry'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'scopes'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationMetadata
     */
    'created_timestamp'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationMetadata
     */
    'updated_timestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'additional_id_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationMetadata
     */
    'partner_metadata'?: string;
}
/**
 * Integration record
 * @export
 * @interface IntegrationRecord
 */
export interface IntegrationRecord {
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'external_business_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'connected_merchant_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'connected_user_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'connected_advertiser_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'connected_lba_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'connected_tag_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'partner_access_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'partner_refresh_token'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'partner_primary_email'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRecord
     */
    'partner_access_token_expiry'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRecord
     */
    'partner_refresh_token_expiry'?: number | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'scopes'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'partner_metadata'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRecord
     */
    'additional_id_1'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRecord
     */
    'created_time'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRecord
     */
    'updated_time'?: number;
}
/**
 * Schema used for creating the integration metadata.
 * @export
 * @interface IntegrationRequest
 */
export interface IntegrationRequest {
    /**
     * External business ID for the integration.
     * @type {string}
     * @memberof IntegrationRequest
     */
    'external_business_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'connected_merchant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'connected_advertiser_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'connected_lba_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'connected_tag_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'partner_access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'partner_refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'partner_primary_email'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRequest
     */
    'partner_access_token_expiry'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRequest
     */
    'partner_refresh_token_expiry'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'scopes'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'additional_id_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequest
     */
    'partner_metadata'?: string;
}
/**
 * Schema used for updating the integration metadata.
 * @export
 * @interface IntegrationRequestPatch
 */
export interface IntegrationRequestPatch {
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'connected_merchant_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'connected_advertiser_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'connected_lba_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'connected_tag_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'partner_access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'partner_refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'partner_primary_email'?: string;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRequestPatch
     */
    'partner_access_token_expiry'?: number;
    /**
     * 
     * @type {number}
     * @memberof IntegrationRequestPatch
     */
    'partner_refresh_token_expiry'?: number;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'scopes'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'additional_id_1'?: string;
    /**
     * 
     * @type {string}
     * @memberof IntegrationRequestPatch
     */
    'partner_metadata'?: string;
}
/**
 * 
 * @export
 * @interface IntegrationsGetList200Response
 */
export interface IntegrationsGetList200Response {
    /**
     * 
     * @type {Array<IntegrationRecord>}
     * @memberof IntegrationsGetList200Response
     */
    'items': Array<IntegrationRecord>;
    /**
     * 
     * @type {string}
     * @memberof IntegrationsGetList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface Interest
 */
export interface Interest {
    /**
     * 
     * @type {string}
     * @memberof Interest
     */
    'canonical_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof Interest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Interest
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof Interest
     */
    'name'?: string;
}
/**
 * Ad accounts and profiles the member/partner will be granted access to with this invite/request.
 * @export
 * @interface InviteAssetsSummary
 */
export interface InviteAssetsSummary {
    /**
     * List of ad account IDs and respective permission levels that will be assigned.
     * @type {Array<InviteAssetsSummaryAdAccountsInner>}
     * @memberof InviteAssetsSummary
     */
    'ad_accounts'?: Array<InviteAssetsSummaryAdAccountsInner>;
    /**
     * List of profile IDs and respective permission levels that will be assigned.
     * @type {Array<InviteAssetsSummaryProfilesInner>}
     * @memberof InviteAssetsSummary
     */
    'profiles'?: Array<InviteAssetsSummaryProfilesInner>;
}
/**
 * 
 * @export
 * @interface InviteAssetsSummaryAdAccountsInner
 */
export interface InviteAssetsSummaryAdAccountsInner {
    /**
     * Unique identifier of a business ad account.
     * @type {string}
     * @memberof InviteAssetsSummaryAdAccountsInner
     */
    'id'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof InviteAssetsSummaryAdAccountsInner
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InviteAssetsSummaryProfilesInner
 */
export interface InviteAssetsSummaryProfilesInner {
    /**
     * Unique identifier of a business profile.
     * @type {string}
     * @memberof InviteAssetsSummaryProfilesInner
     */
    'id'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof InviteAssetsSummaryProfilesInner
     */
    'permissions'?: Array<string>;
}
/**
 * An invite object if the invite/request was successfully updated. Will only be provided if the an invite/request is successfully updated.
 * @export
 * @interface InviteBusinessRoleBinding
 */
export interface InviteBusinessRoleBinding {
    /**
     * Unique identifier for the business that created the invite/request.
     * @type {string}
     * @memberof InviteBusinessRoleBinding
     */
    'created_by_business_id'?: string;
    /**
     * Unique identifier for the user that created the invite/request.
     * @type {string}
     * @memberof InviteBusinessRoleBinding
     */
    'created_by_user_id'?: string;
    /**
     * Metadata for the user that updated the invite/request.
     * @type {BusinessAccessUserSummary}
     * @memberof InviteBusinessRoleBinding
     */
    'user'?: BusinessAccessUserSummary;
    /**
     * Unique identifier of the invite/request.
     * @type {string}
     * @memberof InviteBusinessRoleBinding
     */
    'id'?: string;
    /**
     * 
     * @type {BaseInviteDataResponseInviteData}
     * @memberof InviteBusinessRoleBinding
     */
    'invite_data'?: BaseInviteDataResponseInviteData;
    /**
     * Indicates whether the invite/request was received.
     * @type {boolean}
     * @memberof InviteBusinessRoleBinding
     */
    'is_received_invite'?: boolean;
}
/**
 * An exception object if there is an error performing the action. Will only be provided if there is an error.
 * @export
 * @interface InviteExceptionResponse
 */
export interface InviteExceptionResponse {
    /**
     * Unique identifier of the invite/request.
     * @type {string}
     * @memberof InviteExceptionResponse
     */
    'invite_or_request_id'?: string | null;
    /**
     * Error code associated with the error in performing the action on the invite/request.
     * @type {number}
     * @memberof InviteExceptionResponse
     */
    'code'?: number;
    /**
     * Error message associated with the error in performing the action on the invite/request.
     * @type {string}
     * @memberof InviteExceptionResponse
     */
    'message'?: string;
    /**
     * A list of users\' usernames or emails OR a list of partner ids that caused the error.
     * @type {Array<string>}
     * @memberof InviteExceptionResponse
     */
    'users_or_partner_ids'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface InviteResponse
 */
export interface InviteResponse {
    /**
     * 
     * @type {InviteAssetsSummary}
     * @memberof InviteResponse
     */
    'assets_summary'?: InviteAssetsSummary | null;
    /**
     * The access level a user would be granted on the business if the invite/request is accepted. This can be EMPLOYEE, BIZ_ADMIN, or PARTNER.
     * @type {Array<string>}
     * @memberof InviteResponse
     */
    'business_roles'?: Array<string>;
    /**
     * Metadata for the business that created the invite/request.
     * @type {BusinessAccessUserSummary}
     * @memberof InviteResponse
     */
    'created_by_business'?: BusinessAccessUserSummary | null;
    /**
     * Metadata for the user that created the invite/request.
     * @type {BusinessAccessUserSummary}
     * @memberof InviteResponse
     */
    'created_by_user'?: BusinessAccessUserSummary | null;
    /**
     * The time the invite/request was created. Returned in milliseconds.
     * @type {number}
     * @memberof InviteResponse
     */
    'created_time'?: number;
    /**
     * Unique identifier of the invite/request.
     * @type {string}
     * @memberof InviteResponse
     */
    'id'?: string;
    /**
     * 
     * @type {BaseInviteDataResponseInviteData}
     * @memberof InviteResponse
     */
    'invite_data'?: BaseInviteDataResponseInviteData;
    /**
     * Indicates whether the invite/request was received.
     * @type {boolean}
     * @memberof InviteResponse
     */
    'is_received_invite'?: boolean;
    /**
     * Metadata for the member/partner that was sent the invite/request.
     * @type {BusinessAccessUserSummary}
     * @memberof InviteResponse
     */
    'user'?: BusinessAccessUserSummary;
}
/**
 * The current status of the invite.
 * @export
 * @enum {string}
 */

export const InviteStatus = {
    Pending: 'PENDING',
    Accepted: 'ACCEPTED',
    Declined: 'DECLINED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED'
} as const;

export type InviteStatus = typeof InviteStatus[keyof typeof InviteStatus];


/**
 * The type of invite. <br>\'MEMBER_INVITE\' is to invite a member to access your business assets. <br>\'PARTNER INVITE\' is to invite a partner to access your business assets. <br>\'PARTNER_REQUEST\' is to request access a partner\'s business assets.
 * @export
 * @enum {string}
 */

export const InviteType = {
    MemberInvite: 'MEMBER_INVITE',
    PartnerInvite: 'PARTNER_INVITE',
    PartnerRequest: 'PARTNER_REQUEST'
} as const;

export type InviteType = typeof InviteType[keyof typeof InviteType];


/**
 * 
 * @export
 * @interface ItemAttributes
 */
export interface ItemAttributes {
    /**
     * Allows advertisers to specify a separate URL that can be used to track traffic coming from Pinterest shopping ads. Must send full URL including trackingdo not send tracking parameters only. At this time we do not support impression tracking. Must begin with http:// or https://.
     * @type {string}
     * @memberof ItemAttributes
     */
    'ad_link'?: string | null;
    /**
     * Set this attribute to TRUE if you\'re submitting items that are considered adult. These will not be shown on Pinterest.
     * @type {boolean}
     * @memberof ItemAttributes
     */
    'adult'?: boolean | null;
    /**
     * The age group to apply a demographic range to the product. Must be one of the following values (upper or lowercased): newborn , infant, toddler, kids, or adult.
     * @type {string}
     * @memberof ItemAttributes
     */
    'age_group'?: string | null;
    /**
     * The availability of the product. Must be one of the following values (upper or lowercased): in stock, out of stock , preorder.
     * @type {string}
     * @memberof ItemAttributes
     */
    'availability'?: string;
    /**
     * Average reviews for the item. Can be a number from 1-5.
     * @type {number}
     * @memberof ItemAttributes
     */
    'average_review_rating'?: number | null;
    /**
     * The brand of the product.
     * @type {string}
     * @memberof ItemAttributes
     */
    'brand'?: string | null;
    /**
     * This attribute is not supported anymore.
     * @type {boolean}
     * @memberof ItemAttributes
     * @deprecated
     */
    'checkout_enabled'?: boolean | null;
    /**
     * The primary color of the product.
     * @type {string}
     * @memberof ItemAttributes
     */
    'color'?: string | null;
    /**
     * The condition of the product. Must be one of the following values (upper or lowercased): new, used, or refurbished.
     * @type {string}
     * @memberof ItemAttributes
     */
    'condition'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'custom_label_0'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'custom_label_1'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'custom_label_2'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'custom_label_3'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'custom_label_4'?: string | null;
    /**
     * <p><= 10000 characters</p> <p>The description of the product.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'description'?: string;
    /**
     * The item is free to ship.
     * @type {boolean}
     * @memberof ItemAttributes
     */
    'free_shipping_label'?: boolean | null;
    /**
     * The minimum order purchase necessary for the customer to get free shipping. Only relevant if free shipping is offered.
     * @type {string}
     * @memberof ItemAttributes
     */
    'free_shipping_limit'?: string | null;
    /**
     * The gender associated with the product. Must be one of the following values (upper or lowercased): male, female , or unisex.
     * @type {string}
     * @memberof ItemAttributes
     */
    'gender'?: string | null;
    /**
     * The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
     * @type {string}
     * @memberof ItemAttributes
     */
    'google_product_category'?: string | null;
    /**
     * The unique universal product identifier.
     * @type {number}
     * @memberof ItemAttributes
     */
    'gtin'?: number | null;
    /**
     * <p><= 127 characters</p> <p>The user-created unique ID that represents the product. Only Unicode characters are accepted.</p>
     * @type {string}
     * @memberof ItemAttributes
     * @deprecated
     */
    'id'?: string;
    /**
     * <p><= 127 characters</p> <p>The parent ID of the product.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'item_group_id'?: string | null;
    /**
     * The millisecond timestamp when the item was lastly modified by the merchant.
     * @type {number}
     * @memberof ItemAttributes
     */
    'last_updated_time'?: number | null;
    /**
     * <p><= 511 characters</p> <p>The landing page for the product.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'link'?: string;
    /**
     * The material used to make the product.
     * @type {string}
     * @memberof ItemAttributes
     */
    'material'?: string | null;
    /**
     * The minimum advertised price of the product. It supports the following formats, \"19.99 USD\", \"19.99USD\" and \"19.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof ItemAttributes
     */
    'min_ad_price'?: string | null;
    /**
     * The mobile-optimized version of your landing page. Must begin with http:// or https://.
     * @type {string}
     * @memberof ItemAttributes
     */
    'mobile_link'?: string | null;
    /**
     * Manufacturer Part Number are alpha-numeric codes created by the manufacturer of a product to uniquely identify it among all products from the same manufacturer.
     * @type {string}
     * @memberof ItemAttributes
     */
    'mpn'?: string | null;
    /**
     * The number of ratings for the item.
     * @type {number}
     * @memberof ItemAttributes
     */
    'number_of_ratings'?: number | null;
    /**
     * The number of reviews available for the item.
     * @type {number}
     * @memberof ItemAttributes
     */
    'number_of_reviews'?: number | null;
    /**
     * The description of the pattern used for the product.
     * @type {string}
     * @memberof ItemAttributes
     */
    'pattern'?: string | null;
    /**
     * The price of the product. It supports the following formats, \"24.99 USD\", \"24.99USD\" and \"24.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof ItemAttributes
     */
    'price'?: string;
    /**
     * <p><= 1000 characters</p> <p>The categorization of your product based on your custom product taxonomy. Subcategories must be sent separated by  > . The > must be wrapped by spaces. We do not recognize any other delimiters such as comma or pipe.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'product_type'?: string | null;
    /**
     * The discounted price of the product. The sale_price must be lower than the price. It supports the following formats, \"14.99 USD\", \"14.99USD\" and \"14.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof ItemAttributes
     */
    'sale_price'?: string | null;
    /**
     * Shipping consists of one group of up to four elements, country, region, service (all optional) and price (required). All colons, even for blank values, are required.
     * @type {string}
     * @memberof ItemAttributes
     */
    'shipping'?: string | null;
    /**
     * The height of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof ItemAttributes
     */
    'shipping_height'?: string | null;
    /**
     * The weight of the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof ItemAttributes
     */
    'shipping_weight'?: string | null;
    /**
     * The width of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof ItemAttributes
     */
    'shipping_width'?: string | null;
    /**
     * The size of the product.
     * @type {string}
     * @memberof ItemAttributes
     */
    'size'?: string | null;
    /**
     * Indicates the countrys sizing system in which you are submitting your product. Must be one of the following values (upper or lowercased): US, UK, EU, DE , FR, JP, CN, IT,  BR, MEX, or AU.
     * @type {string}
     * @memberof ItemAttributes
     */
    'size_system'?: string | null;
    /**
     * Additional description for the size. Must be one of the following values (upper or lowercased): regular, petite , plus, big_and_tall, or maternity.
     * @type {string}
     * @memberof ItemAttributes
     */
    'size_type'?: string | null;
    /**
     * Tax consists of one group of up to four elements, country, region, rate (all required) and tax_ship (optional). All colons, even for blank values, are required.
     * @type {string}
     * @memberof ItemAttributes
     */
    'tax'?: string | null;
    /**
     * <p><= 500 characters</p> <p>The name of the product.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'title'?: string;
    /**
     * Options for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed.
     * @type {Array<string>}
     * @memberof ItemAttributes
     */
    'variant_names'?: Array<string> | null;
    /**
     * Option values for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed. The order of the variant values must be consistent with the order of the variant names.
     * @type {Array<string>}
     * @memberof ItemAttributes
     */
    'variant_values'?: Array<string> | null;
    /**
     * <p><= 2000 characters</p> <p>The links to additional images for your product. Up to ten additional images can be used to show a product from different angles or to show different stages. Must begin with http:// or https://.</p>
     * @type {Array<string>}
     * @memberof ItemAttributes
     */
    'additional_image_link'?: Array<string> | null;
    /**
     * <p><= 2000 characters</p> <p>The link to the main product images. Images should be at least 75x75 pixels to avoid errors. Use the additional_image_link field to add more images of your product. The URL of your image_link must be accessible by the Pinterest user-agent, and send the accurate images. Please make sure there are no template or placeholder images at the link. Must start with http:// or https://.</p>
     * @type {Array<string>}
     * @memberof ItemAttributes
     */
    'image_link'?: Array<string>;
    /**
     * <p><= 2,000 characters</p> <p>Hosted link to the product video.</p> <p>File types for linked videos must be .mp4, .mov or .m4v.</p> <p>File size cannot exceed 2GB.</p>
     * @type {string}
     * @memberof ItemAttributes
     */
    'video_link'?: string | null;
}
/**
 * 
 * @export
 * @interface ItemAttributesRequest
 */
export interface ItemAttributesRequest {
    /**
     * Allows advertisers to specify a separate URL that can be used to track traffic coming from Pinterest shopping ads. Must send full URL including trackingdo not send tracking parameters only. At this time we do not support impression tracking. Must begin with http:// or https://.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'ad_link'?: string | null;
    /**
     * Set this attribute to TRUE if you\'re submitting items that are considered adult. These will not be shown on Pinterest.
     * @type {boolean}
     * @memberof ItemAttributesRequest
     */
    'adult'?: boolean | null;
    /**
     * The age group to apply a demographic range to the product. Must be one of the following values (upper or lowercased): newborn , infant, toddler, kids, or adult.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'age_group'?: string | null;
    /**
     * The availability of the product. Must be one of the following values (upper or lowercased): in stock, out of stock , preorder.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'availability'?: string;
    /**
     * Average reviews for the item. Can be a number from 1-5.
     * @type {number}
     * @memberof ItemAttributesRequest
     */
    'average_review_rating'?: number | null;
    /**
     * The brand of the product.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'brand'?: string | null;
    /**
     * This attribute is not supported anymore.
     * @type {boolean}
     * @memberof ItemAttributesRequest
     * @deprecated
     */
    'checkout_enabled'?: boolean | null;
    /**
     * The primary color of the product.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'color'?: string | null;
    /**
     * The condition of the product. Must be one of the following values (upper or lowercased): new, used, or refurbished.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'condition'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'custom_label_0'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'custom_label_1'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'custom_label_2'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'custom_label_3'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'custom_label_4'?: string | null;
    /**
     * <p><= 10000 characters</p> <p>The description of the product.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'description'?: string;
    /**
     * The item is free to ship.
     * @type {boolean}
     * @memberof ItemAttributesRequest
     */
    'free_shipping_label'?: boolean | null;
    /**
     * The minimum order purchase necessary for the customer to get free shipping. Only relevant if free shipping is offered.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'free_shipping_limit'?: string | null;
    /**
     * The gender associated with the product. Must be one of the following values (upper or lowercased): male, female , or unisex.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'gender'?: string | null;
    /**
     * The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'google_product_category'?: string | null;
    /**
     * The unique universal product identifier.
     * @type {number}
     * @memberof ItemAttributesRequest
     */
    'gtin'?: number | null;
    /**
     * <p><= 127 characters</p> <p>The user-created unique ID that represents the product. Only Unicode characters are accepted.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     * @deprecated
     */
    'id'?: string;
    /**
     * <p><= 127 characters</p> <p>The parent ID of the product.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'item_group_id'?: string | null;
    /**
     * The millisecond timestamp when the item was lastly modified by the merchant.
     * @type {number}
     * @memberof ItemAttributesRequest
     */
    'last_updated_time'?: number | null;
    /**
     * <p><= 511 characters</p> <p>The landing page for the product.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'link'?: string;
    /**
     * The material used to make the product.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'material'?: string | null;
    /**
     * The minimum advertised price of the product. It supports the following formats, \"19.99 USD\", \"19.99USD\" and \"19.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'min_ad_price'?: string | null;
    /**
     * The mobile-optimized version of your landing page. Must begin with http:// or https://.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'mobile_link'?: string | null;
    /**
     * Manufacturer Part Number are alpha-numeric codes created by the manufacturer of a product to uniquely identify it among all products from the same manufacturer.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'mpn'?: string | null;
    /**
     * The number of ratings for the item.
     * @type {number}
     * @memberof ItemAttributesRequest
     */
    'number_of_ratings'?: number | null;
    /**
     * The number of reviews available for the item.
     * @type {number}
     * @memberof ItemAttributesRequest
     */
    'number_of_reviews'?: number | null;
    /**
     * The description of the pattern used for the product.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'pattern'?: string | null;
    /**
     * The price of the product. It supports the following formats, \"24.99 USD\", \"24.99USD\" and \"24.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'price'?: string;
    /**
     * <p><= 1000 characters</p> <p>The categorization of your product based on your custom product taxonomy. Subcategories must be sent separated by  > . The > must be wrapped by spaces. We do not recognize any other delimiters such as comma or pipe.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'product_type'?: string | null;
    /**
     * The discounted price of the product. The sale_price must be lower than the price. It supports the following formats, \"14.99 USD\", \"14.99USD\" and \"14.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'sale_price'?: string | null;
    /**
     * Shipping consists of one group of up to four elements, country, region, service (all optional) and price (required). All colons, even for blank values, are required.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'shipping'?: string | null;
    /**
     * The height of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'shipping_height'?: string | null;
    /**
     * The weight of the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'shipping_weight'?: string | null;
    /**
     * The width of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'shipping_width'?: string | null;
    /**
     * The size of the product.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'size'?: string | null;
    /**
     * Indicates the countrys sizing system in which you are submitting your product. Must be one of the following values (upper or lowercased): US, UK, EU, DE , FR, JP, CN, IT,  BR, MEX, or AU.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'size_system'?: string | null;
    /**
     * Additional description for the size. Must be one of the following values (upper or lowercased): regular, petite , plus, big_and_tall, or maternity.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'size_type'?: string | null;
    /**
     * Tax consists of one group of up to four elements, country, region, rate (all required) and tax_ship (optional). All colons, even for blank values, are required.
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'tax'?: string | null;
    /**
     * <p><= 500 characters</p> <p>The name of the product.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'title'?: string;
    /**
     * Options for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed.
     * @type {Array<string>}
     * @memberof ItemAttributesRequest
     */
    'variant_names'?: Array<string> | null;
    /**
     * Option values for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed. The order of the variant values must be consistent with the order of the variant names.
     * @type {Array<string>}
     * @memberof ItemAttributesRequest
     */
    'variant_values'?: Array<string> | null;
    /**
     * <p><= 2000 characters</p> <p>The links to additional images for your product. Up to ten additional images can be used to show a product from different angles or to show different stages. Must begin with http:// or https://.</p>
     * @type {Array<string>}
     * @memberof ItemAttributesRequest
     */
    'additional_image_link'?: Array<string> | null;
    /**
     * 
     * @type {ItemAttributesRequestAllOfImageLink}
     * @memberof ItemAttributesRequest
     */
    'image_link'?: ItemAttributesRequestAllOfImageLink;
    /**
     * <p><= 2,000 characters</p> <p>Hosted link to the product video.</p> <p>File types for linked videos must be .mp4, .mov or .m4v.</p> <p>File size cannot exceed 2GB.</p>
     * @type {string}
     * @memberof ItemAttributesRequest
     */
    'video_link'?: string | null;
}
/**
 * @type ItemAttributesRequestAllOfImageLink
 * <p><= 2000 characters</p> <p>The links to the main product images. Images should be at least 75x75 pixels to avoid errors. Use the additional_image_link field to add more images of your product. The URL of your image_link must be accessible by the Pinterest user-agent, and send the accurate images. Please make sure there are no template or placeholder images at the link. Must start with http:// or https://.</p>
 * @export
 */
export type ItemAttributesRequestAllOfImageLink = Array<string> | string;

/**
 * @type ItemBatchRecord
 * Object describing an item batch record
 * @export
 */
export type ItemBatchRecord = ItemCreateBatchRecord | ItemDeleteBatchRecord | ItemDeleteDiscontinuedBatchRecord | ItemUpdateBatchRecord | ItemUpsertBatchRecord;

/**
 * Object describing an item batch record to create items
 * @export
 * @interface ItemCreateBatchRecord
 */
export interface ItemCreateBatchRecord {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemCreateBatchRecord
     */
    'item_id'?: string;
    /**
     * 
     * @type {ItemAttributesRequest}
     * @memberof ItemCreateBatchRecord
     */
    'attributes'?: ItemAttributesRequest;
}
/**
 * Object describing an item batch record to delete items
 * @export
 * @interface ItemDeleteBatchRecord
 */
export interface ItemDeleteBatchRecord {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemDeleteBatchRecord
     */
    'item_id'?: string;
}
/**
 * Object describing an item batch record to discontinue items
 * @export
 * @interface ItemDeleteDiscontinuedBatchRecord
 */
export interface ItemDeleteDiscontinuedBatchRecord {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemDeleteDiscontinuedBatchRecord
     */
    'item_id'?: string;
}
/**
 * 
 * @export
 * @interface ItemGroupIdFilter
 */
export interface ItemGroupIdFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof ItemGroupIdFilter
     */
    'ITEM_GROUP_ID': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * 
 * @export
 * @interface ItemIdFilter
 */
export interface ItemIdFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof ItemIdFilter
     */
    'ITEM_ID': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Object describing an item processing record
 * @export
 * @interface ItemProcessingRecord
 */
export interface ItemProcessingRecord {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemProcessingRecord
     */
    'item_id'?: string;
    /**
     * Array with the validation errors for the item processing record. A non empty errors list causes the item processing to fail.
     * @type {Array<ItemValidationEvent>}
     * @memberof ItemProcessingRecord
     */
    'errors'?: Array<ItemValidationEvent>;
    /**
     * Array with the validation warnings for the item processing record
     * @type {Array<ItemValidationEvent>}
     * @memberof ItemProcessingRecord
     */
    'warnings'?: Array<ItemValidationEvent>;
    /**
     * 
     * @type {ItemProcessingStatus}
     * @memberof ItemProcessingRecord
     */
    'status'?: ItemProcessingStatus;
}


/**
 * The status of the item processing record
 * @export
 * @enum {string}
 */

export const ItemProcessingStatus = {
    Success: 'SUCCESS',
    Failure: 'FAILURE',
    Processing: 'PROCESSING'
} as const;

export type ItemProcessingStatus = typeof ItemProcessingStatus[keyof typeof ItemProcessingStatus];


/**
 * Object describing an item record
 * @export
 * @interface ItemResponse
 */
export interface ItemResponse {
    /**
     * 
     * @type {CatalogsType}
     * @memberof ItemResponse
     */
    'catalog_type': CatalogsType;
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemResponse
     */
    'item_id'?: string;
    /**
     * Array with the errors for the item id requested
     * @type {Array<ItemValidationEvent>}
     * @memberof ItemResponse
     */
    'errors'?: Array<ItemValidationEvent>;
    /**
     * The catalog hotel id in the merchant namespace
     * @type {string}
     * @memberof ItemResponse
     */
    'hotel_id'?: string;
    /**
     * The catalog creative assets id in the merchant namespace
     * @type {string}
     * @memberof ItemResponse
     */
    'creative_assets_id'?: string;
}


/**
 * @type ItemResponseAnyOf
 * @export
 */
export type ItemResponseAnyOf = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsItemResponse | { catalog_type: 'HOTEL' } & CatalogsHotelItemResponse | { catalog_type: 'RETAIL' } & CatalogsRetailItemResponse;

/**
 * @type ItemResponseAnyOf1
 * @export
 */
export type ItemResponseAnyOf1 = { catalog_type: 'CREATIVE_ASSETS' } & CatalogsCreativeAssetsItemErrorResponse | { catalog_type: 'HOTEL' } & CatalogsHotelItemErrorResponse | { catalog_type: 'RETAIL' } & CatalogsRetailItemErrorResponse;

/**
 * Object describing an item batch record to update items
 * @export
 * @interface ItemUpdateBatchRecord
 */
export interface ItemUpdateBatchRecord {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemUpdateBatchRecord
     */
    'item_id'?: string;
    /**
     * 
     * @type {UpdatableItemAttributes}
     * @memberof ItemUpdateBatchRecord
     */
    'attributes'?: UpdatableItemAttributes;
    /**
     * The list of product attributes to be updated. Attributes specified in the update mask without a value specified in the body will be deleted from the product item.
     * @type {Array<UpdateMaskFieldType>}
     * @memberof ItemUpdateBatchRecord
     */
    'update_mask'?: Array<UpdateMaskFieldType> | null;
}
/**
 * Object describing an item batch record to upsert items
 * @export
 * @interface ItemUpsertBatchRecord
 */
export interface ItemUpsertBatchRecord {
    /**
     * The catalog item id in the merchant namespace
     * @type {string}
     * @memberof ItemUpsertBatchRecord
     */
    'item_id'?: string;
    /**
     * 
     * @type {ItemAttributesRequest}
     * @memberof ItemUpsertBatchRecord
     */
    'attributes'?: ItemAttributesRequest;
}
/**
 * Object describing an item validation event
 * @export
 * @interface ItemValidationEvent
 */
export interface ItemValidationEvent {
    /**
     * The attribute that the item validation event references
     * @type {string}
     * @memberof ItemValidationEvent
     */
    'attribute'?: string;
    /**
     * The event code that the item validation event references
     * @type {number}
     * @memberof ItemValidationEvent
     */
    'code'?: number;
    /**
     * Title message describing the item validation event
     * @type {string}
     * @memberof ItemValidationEvent
     */
    'message'?: string;
}
/**
 * @type ItemsBatchPostRequest
 * @export
 */
export type ItemsBatchPostRequest = CatalogsItemsBatchRequest | CatalogsVerticalBatchRequest;

/**
 * 
 * @export
 * @interface ItemsIssuesList200Response
 */
export interface ItemsIssuesList200Response {
    /**
     * 
     * @type {Array<CatalogsItemValidationIssues>}
     * @memberof ItemsIssuesList200Response
     */
    'items': Array<CatalogsItemValidationIssues>;
    /**
     * 
     * @type {string}
     * @memberof ItemsIssuesList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface Keyword
 */
export interface Keyword {
    /**
     * </p><strong>Note:</strong> bid field has been deprecated. Input will not be set and field will return null. Keyword custom bid in microcurrency - null if inherited from parent ad group.
     * @type {number}
     * @memberof Keyword
     */
    'bid'?: number | null;
    /**
     * 
     * @type {MatchTypeResponse}
     * @memberof Keyword
     */
    'match_type': MatchTypeResponse | null;
    /**
     * Keyword value (120 chars max).
     * @type {string}
     * @memberof Keyword
     */
    'value': string;
    /**
     * 
     * @type {boolean}
     * @memberof Keyword
     */
    'archived'?: boolean;
    /**
     * Keyword ID .
     * @type {string}
     * @memberof Keyword
     */
    'id'?: string;
    /**
     * Keyword parent entity ID (advertiser, campaign, ad group).
     * @type {string}
     * @memberof Keyword
     */
    'parent_id'?: string;
    /**
     * Parent entity type
     * @type {string}
     * @memberof Keyword
     */
    'parent_type'?: string;
    /**
     * Always keyword
     * @type {string}
     * @memberof Keyword
     */
    'type'?: string;
}


/**
 * 
 * @export
 * @interface KeywordError
 */
export interface KeywordError {
    /**
     * 
     * @type {Keyword}
     * @memberof KeywordError
     */
    'data'?: Keyword;
    /**
     * 
     * @type {Array<string>}
     * @memberof KeywordError
     */
    'error_messages'?: Array<string>;
}
/**
 * Keyword metrics JSON
 * @export
 * @interface KeywordMetrics
 */
export interface KeywordMetrics {
    /**
     * Average cost per click
     * @type {number}
     * @memberof KeywordMetrics
     */
    'avg_cpc_in_micro_currency'?: number;
    /**
     * Keyword\'s search frequency. This value is based on keyword frequency in pepsi client response
     * @type {string}
     * @memberof KeywordMetrics
     */
    'keyword_query_volume'?: string;
}
/**
 * 
 * @export
 * @interface KeywordMetricsResponse
 */
export interface KeywordMetricsResponse {
    /**
     * Keyword name, e.g., \"keyword\":\"fashion outfits\"
     * @type {string}
     * @memberof KeywordMetricsResponse
     */
    'keyword'?: string;
    /**
     * 
     * @type {KeywordMetrics}
     * @memberof KeywordMetricsResponse
     */
    'metrics'?: KeywordMetrics;
}
/**
 * 
 * @export
 * @interface KeywordUpdate
 */
export interface KeywordUpdate {
    /**
     * Keyword ID.
     * @type {string}
     * @memberof KeywordUpdate
     */
    'id': string;
    /**
     * Is keyword archived?
     * @type {boolean}
     * @memberof KeywordUpdate
     */
    'archived'?: boolean;
    /**
     * </p><strong>Note:</strong> bid field has been deprecated. Input will not be set and field will return null. Keyword custom bid in microcurrency - null if inherited from parent ad group.
     * @type {number}
     * @memberof KeywordUpdate
     */
    'bid'?: number | null;
}
/**
 * 
 * @export
 * @interface KeywordUpdateBody
 */
export interface KeywordUpdateBody {
    /**
     * Keywords to update. Object array. Each object has 2 possible fields:<br>1. \"id\": (required) keyword ID<br>2. \"archived\": boolean. Should keyword be archived?<br>For example: [{\"id\":\"2886610576653\", \"archived\": false}, {\"id\":\"2886610576654\",  \"archived\": true}, ...]
     * @type {Array<KeywordUpdate>}
     * @memberof KeywordUpdateBody
     */
    'keywords': Array<KeywordUpdate>;
}
/**
 * 
 * @export
 * @interface KeywordsCommon
 */
export interface KeywordsCommon {
    /**
     * </p><strong>Note:</strong> bid field has been deprecated. Input will not be set and field will return null. Keyword custom bid in microcurrency - null if inherited from parent ad group.
     * @type {number}
     * @memberof KeywordsCommon
     */
    'bid'?: number | null;
    /**
     * 
     * @type {MatchTypeResponse}
     * @memberof KeywordsCommon
     */
    'match_type': MatchTypeResponse | null;
    /**
     * Keyword value (120 chars max).
     * @type {string}
     * @memberof KeywordsCommon
     */
    'value': string;
}


/**
 * 
 * @export
 * @interface KeywordsGet200Response
 */
export interface KeywordsGet200Response {
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof KeywordsGet200Response
     */
    'items': Array<Keyword>;
    /**
     * 
     * @type {string}
     * @memberof KeywordsGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface KeywordsMetricsArrayResponse
 */
export interface KeywordsMetricsArrayResponse {
    /**
     * 
     * @type {Array<KeywordMetricsResponse>}
     * @memberof KeywordsMetricsArrayResponse
     */
    'data'?: Array<KeywordMetricsResponse>;
}
/**
 * 
 * @export
 * @interface KeywordsRequest
 */
export interface KeywordsRequest {
    /**
     * Keyword JSON array. Each array element has 3 fields
     * @type {Array<KeywordsCommon>}
     * @memberof KeywordsRequest
     */
    'keywords': Array<KeywordsCommon>;
    /**
     * Keyword parent entity ID (advertiser, campaign, ad group).
     * @type {string}
     * @memberof KeywordsRequest
     */
    'parent_id': string;
}
/**
 * 
 * @export
 * @interface KeywordsResponse
 */
export interface KeywordsResponse {
    /**
     * 
     * @type {Array<KeywordError>}
     * @memberof KeywordsResponse
     */
    'errors'?: Array<KeywordError>;
    /**
     * 
     * @type {Array<Keyword>}
     * @memberof KeywordsResponse
     */
    'keywords'?: Array<Keyword>;
}
/**
 * Language code, which is among the offical ISO 639-1 language list.
 * @export
 * @enum {string}
 */

export const Language = {
    Am: 'AM',
    Ar: 'AR',
    Az: 'AZ',
    Bg: 'BG',
    Bn: 'BN',
    Bs: 'BS',
    Ca: 'CA',
    Cs: 'CS',
    Da: 'DA',
    Dv: 'DV',
    Dz: 'DZ',
    De: 'DE',
    El: 'EL',
    En: 'EN',
    Es: 'ES',
    Et: 'ET',
    Fa: 'FA',
    Fi: 'FI',
    Fr: 'FR',
    He: 'HE',
    Hi: 'HI',
    Hr: 'HR',
    Hu: 'HU',
    Hy: 'HY',
    Id: 'ID',
    In: 'IN',
    Is: 'IS',
    It: 'IT',
    Iw: 'IW',
    Ja: 'JA',
    Ka: 'KA',
    Km: 'KM',
    Ko: 'KO',
    Lo: 'LO',
    Lt: 'LT',
    Lv: 'LV',
    Mk: 'MK',
    Mn: 'MN',
    Ms: 'MS',
    My: 'MY',
    Nb: 'NB',
    Ne: 'NE',
    Nl: 'NL',
    No: 'NO',
    Pl: 'PL',
    Pt: 'PT',
    Ro: 'RO',
    Ru: 'RU',
    Sk: 'SK',
    Sl: 'SL',
    Sq: 'SQ',
    Sr: 'SR',
    Sv: 'SV',
    Tl: 'TL',
    Uk: 'UK',
    Vi: 'VI',
    Te: 'TE',
    Th: 'TH',
    Tr: 'TR',
    Xx: 'XX',
    Zh: 'ZH'
} as const;

export type Language = typeof Language[keyof typeof Language];


/**
 * 
 * @export
 * @interface LeadFormArrayResponse
 */
export interface LeadFormArrayResponse {
    /**
     * 
     * @type {Array<LeadFormArrayResponseItemsInner>}
     * @memberof LeadFormArrayResponse
     */
    'items'?: Array<LeadFormArrayResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface LeadFormArrayResponseItemsInner
 */
export interface LeadFormArrayResponseItemsInner {
    /**
     * 
     * @type {LeadFormResponse}
     * @memberof LeadFormArrayResponseItemsInner
     */
    'data'?: LeadFormResponse;
    /**
     * 
     * @type {Array<Exception>}
     * @memberof LeadFormArrayResponseItemsInner
     */
    'exceptions'?: Array<Exception>;
}
/**
 * Creation fields
 * @export
 * @interface LeadFormCommon
 */
export interface LeadFormCommon {
    /**
     * Internal name of the lead form.
     * @type {string}
     * @memberof LeadFormCommon
     */
    'name'?: string | null;
    /**
     * A link to the advertiser\'s privacy policy. This will be included in the lead form\'s disclosure language.
     * @type {string}
     * @memberof LeadFormCommon
     */
    'privacy_policy_link'?: string | null;
    /**
     * Whether the advertiser has accepted Pinterest\'s terms of service for creating a lead ad.  By sending us TRUE for this parameter, you agree that (i) you will use any personal information received in compliance with the privacy policy you share with Pinterest, and (ii) you will comply with Pinterest\'s <a href=\"https://policy.pinterest.com/en/lead-ad-terms\">Lead Ad Terms</a>. As a reminder, all advertising on Pinterest is subject to the <a href=\"https://business.pinterest.com/en/pinterest-advertising-services-agreement/\">Pinterest Advertising Services Agreement</a> or an equivalent agreement as set forth on an IO
     * @type {boolean}
     * @memberof LeadFormCommon
     */
    'has_accepted_terms'?: boolean;
    /**
     * A message for people who complete the form to let them know what happens next.
     * @type {string}
     * @memberof LeadFormCommon
     */
    'completion_message'?: string | null;
    /**
     * 
     * @type {LeadFormStatus}
     * @memberof LeadFormCommon
     */
    'status'?: LeadFormStatus;
    /**
     * Additional disclosure language to be included in the lead form.
     * @type {string}
     * @memberof LeadFormCommon
     */
    'disclosure_language'?: string | null;
    /**
     * List of questions to be displayed on the lead form.
     * @type {Array<LeadFormQuestion>}
     * @memberof LeadFormCommon
     */
    'questions'?: Array<LeadFormQuestion>;
    /**
     * List of additional policy links to be displayed on the lead form.
     * @type {Array<LeadFormCommonPolicyLinksInner>}
     * @memberof LeadFormCommon
     */
    'policy_links'?: Array<LeadFormCommonPolicyLinksInner>;
}


/**
 * 
 * @export
 * @interface LeadFormCommonPolicyLinksInner
 */
export interface LeadFormCommonPolicyLinksInner {
    /**
     * Policy label for an additional policy link.
     * @type {string}
     * @memberof LeadFormCommonPolicyLinksInner
     */
    'label'?: string;
    /**
     * Policy link for an additional policy link.
     * @type {string}
     * @memberof LeadFormCommonPolicyLinksInner
     */
    'link'?: string;
}
/**
 * 
 * @export
 * @interface LeadFormCreateRequest
 */
export interface LeadFormCreateRequest {
    /**
     * Internal name of the lead form.
     * @type {string}
     * @memberof LeadFormCreateRequest
     */
    'name': string | null;
    /**
     * A link to the advertiser\'s privacy policy. This will be included in the lead form\'s disclosure language.
     * @type {string}
     * @memberof LeadFormCreateRequest
     */
    'privacy_policy_link': string | null;
    /**
     * Whether the advertiser has accepted Pinterest\'s terms of service for creating a lead ad.  By sending us TRUE for this parameter, you agree that (i) you will use any personal information received in compliance with the privacy policy you share with Pinterest, and (ii) you will comply with Pinterest\'s <a href=\"https://policy.pinterest.com/en/lead-ad-terms\">Lead Ad Terms</a>. As a reminder, all advertising on Pinterest is subject to the <a href=\"https://business.pinterest.com/en/pinterest-advertising-services-agreement/\">Pinterest Advertising Services Agreement</a> or an equivalent agreement as set forth on an IO
     * @type {boolean}
     * @memberof LeadFormCreateRequest
     */
    'has_accepted_terms': boolean;
    /**
     * A message for people who complete the form to let them know what happens next.
     * @type {string}
     * @memberof LeadFormCreateRequest
     */
    'completion_message': string | null;
    /**
     * 
     * @type {LeadFormStatus}
     * @memberof LeadFormCreateRequest
     */
    'status'?: LeadFormStatus;
    /**
     * Additional disclosure language to be included in the lead form.
     * @type {string}
     * @memberof LeadFormCreateRequest
     */
    'disclosure_language'?: string | null;
    /**
     * List of questions to be displayed on the lead form.
     * @type {Array<LeadFormQuestion>}
     * @memberof LeadFormCreateRequest
     */
    'questions': Array<LeadFormQuestion>;
    /**
     * List of additional policy links to be displayed on the lead form.
     * @type {Array<LeadFormCommonPolicyLinksInner>}
     * @memberof LeadFormCreateRequest
     */
    'policy_links'?: Array<LeadFormCommonPolicyLinksInner>;
}


/**
 * 
 * @export
 * @interface LeadFormQuestion
 */
export interface LeadFormQuestion {
    /**
     * 
     * @type {LeadFormQuestionType}
     * @memberof LeadFormQuestion
     */
    'question_type'?: LeadFormQuestionType;
    /**
     * 
     * @type {LeadFormQuestionFieldType}
     * @memberof LeadFormQuestion
     */
    'custom_question_field_type'?: LeadFormQuestionFieldType | null;
    /**
     * Question label for a custom question.
     * @type {string}
     * @memberof LeadFormQuestion
     */
    'custom_question_label'?: string | null;
    /**
     * Question options for a custom question.
     * @type {Array<string>}
     * @memberof LeadFormQuestion
     */
    'custom_question_options'?: Array<string> | null;
}


/**
 * Lead form question field type
 * @export
 * @enum {string}
 */

export const LeadFormQuestionFieldType = {
    TextField: 'TEXT_FIELD',
    TextArea: 'TEXT_AREA',
    RadioList: 'RADIO_LIST',
    Checkbox: 'CHECKBOX'
} as const;

export type LeadFormQuestionFieldType = typeof LeadFormQuestionFieldType[keyof typeof LeadFormQuestionFieldType];


/**
 * Lead form question type
 * @export
 * @enum {string}
 */

export const LeadFormQuestionType = {
    Custom: 'CUSTOM',
    FullName: 'FULL_NAME',
    FirstName: 'FIRST_NAME',
    LastName: 'LAST_NAME',
    Email: 'EMAIL',
    PhoneNumber: 'PHONE_NUMBER',
    ZipCode: 'ZIP_CODE',
    Gender: 'GENDER',
    City: 'CITY',
    Country: 'COUNTRY',
    StateProvince: 'STATE_PROVINCE',
    Address: 'ADDRESS',
    DateOfBirth: 'DATE_OF_BIRTH',
    Age: 'AGE'
} as const;

export type LeadFormQuestionType = typeof LeadFormQuestionType[keyof typeof LeadFormQuestionType];


/**
 * 
 * @export
 * @interface LeadFormResponse
 */
export interface LeadFormResponse {
    /**
     * Internal name of the lead form.
     * @type {string}
     * @memberof LeadFormResponse
     */
    'name'?: string | null;
    /**
     * A link to the advertiser\'s privacy policy. This will be included in the lead form\'s disclosure language.
     * @type {string}
     * @memberof LeadFormResponse
     */
    'privacy_policy_link'?: string | null;
    /**
     * Whether the advertiser has accepted Pinterest\'s terms of service for creating a lead ad.  By sending us TRUE for this parameter, you agree that (i) you will use any personal information received in compliance with the privacy policy you share with Pinterest, and (ii) you will comply with Pinterest\'s <a href=\"https://policy.pinterest.com/en/lead-ad-terms\">Lead Ad Terms</a>. As a reminder, all advertising on Pinterest is subject to the <a href=\"https://business.pinterest.com/en/pinterest-advertising-services-agreement/\">Pinterest Advertising Services Agreement</a> or an equivalent agreement as set forth on an IO
     * @type {boolean}
     * @memberof LeadFormResponse
     */
    'has_accepted_terms'?: boolean;
    /**
     * A message for people who complete the form to let them know what happens next.
     * @type {string}
     * @memberof LeadFormResponse
     */
    'completion_message'?: string | null;
    /**
     * 
     * @type {LeadFormStatus}
     * @memberof LeadFormResponse
     */
    'status'?: LeadFormStatus;
    /**
     * Additional disclosure language to be included in the lead form.
     * @type {string}
     * @memberof LeadFormResponse
     */
    'disclosure_language'?: string | null;
    /**
     * List of questions to be displayed on the lead form.
     * @type {Array<LeadFormQuestion>}
     * @memberof LeadFormResponse
     */
    'questions'?: Array<LeadFormQuestion>;
    /**
     * List of additional policy links to be displayed on the lead form.
     * @type {Array<LeadFormCommonPolicyLinksInner>}
     * @memberof LeadFormResponse
     */
    'policy_links'?: Array<LeadFormCommonPolicyLinksInner>;
    /**
     * The ID of this lead form
     * @type {string}
     * @memberof LeadFormResponse
     */
    'id'?: string;
    /**
     * The Ad Account ID that this lead form belongs to.
     * @type {string}
     * @memberof LeadFormResponse
     */
    'ad_account_id'?: string;
    /**
     * Lead form creation time. Unix timestamp in seconds.
     * @type {number}
     * @memberof LeadFormResponse
     */
    'created_time'?: number;
    /**
     * Last update time. Unix timestamp in seconds.
     * @type {number}
     * @memberof LeadFormResponse
     */
    'updated_time'?: number;
}


/**
 * Status of the lead form
 * @export
 * @enum {string}
 */

export const LeadFormStatus = {
    Draft: 'DRAFT',
    Active: 'ACTIVE'
} as const;

export type LeadFormStatus = typeof LeadFormStatus[keyof typeof LeadFormStatus];


/**
 * Request to create test data for lead data test API.
 * @export
 * @interface LeadFormTestRequest
 */
export interface LeadFormTestRequest {
    /**
     * Test lead answers. Should follow the creation order.
     * @type {Array<string>}
     * @memberof LeadFormTestRequest
     */
    'answers': Array<string>;
}
/**
 * Response for lead data test API.
 * @export
 * @interface LeadFormTestResponse
 */
export interface LeadFormTestResponse {
    /**
     * Subscription ID.
     * @type {string}
     * @memberof LeadFormTestResponse
     */
    'subscription_id'?: string;
}
/**
 * 
 * @export
 * @interface LeadFormUpdateRequest
 */
export interface LeadFormUpdateRequest {
    /**
     * Internal name of the lead form.
     * @type {string}
     * @memberof LeadFormUpdateRequest
     */
    'name'?: string | null;
    /**
     * A link to the advertiser\'s privacy policy. This will be included in the lead form\'s disclosure language.
     * @type {string}
     * @memberof LeadFormUpdateRequest
     */
    'privacy_policy_link'?: string | null;
    /**
     * Whether the advertiser has accepted Pinterest\'s terms of service for creating a lead ad.  By sending us TRUE for this parameter, you agree that (i) you will use any personal information received in compliance with the privacy policy you share with Pinterest, and (ii) you will comply with Pinterest\'s <a href=\"https://policy.pinterest.com/en/lead-ad-terms\">Lead Ad Terms</a>. As a reminder, all advertising on Pinterest is subject to the <a href=\"https://business.pinterest.com/en/pinterest-advertising-services-agreement/\">Pinterest Advertising Services Agreement</a> or an equivalent agreement as set forth on an IO
     * @type {boolean}
     * @memberof LeadFormUpdateRequest
     */
    'has_accepted_terms'?: boolean;
    /**
     * A message for people who complete the form to let them know what happens next.
     * @type {string}
     * @memberof LeadFormUpdateRequest
     */
    'completion_message'?: string | null;
    /**
     * 
     * @type {LeadFormStatus}
     * @memberof LeadFormUpdateRequest
     */
    'status'?: LeadFormStatus;
    /**
     * Additional disclosure language to be included in the lead form.
     * @type {string}
     * @memberof LeadFormUpdateRequest
     */
    'disclosure_language'?: string | null;
    /**
     * List of questions to be displayed on the lead form.
     * @type {Array<LeadFormQuestion>}
     * @memberof LeadFormUpdateRequest
     */
    'questions'?: Array<LeadFormQuestion>;
    /**
     * List of additional policy links to be displayed on the lead form.
     * @type {Array<LeadFormCommonPolicyLinksInner>}
     * @memberof LeadFormUpdateRequest
     */
    'policy_links'?: Array<LeadFormCommonPolicyLinksInner>;
    /**
     * The ID of this lead form to be updated
     * @type {string}
     * @memberof LeadFormUpdateRequest
     */
    'id': string;
}


/**
 * 
 * @export
 * @interface LeadFormsList200Response
 */
export interface LeadFormsList200Response {
    /**
     * 
     * @type {Array<LeadFormResponse>}
     * @memberof LeadFormsList200Response
     */
    'items': Array<LeadFormResponse>;
    /**
     * 
     * @type {string}
     * @memberof LeadFormsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface LeadsExportCreateRequest
 */
export interface LeadsExportCreateRequest {
    /**
     * Export leads collected on and after start date (UTC). Format: YYYY-MM-DD
     * @type {string}
     * @memberof LeadsExportCreateRequest
     */
    'start_date': string;
    /**
     * Export leads collected on and before end date (UTC). Format: YYYY-MM-DD
     * @type {string}
     * @memberof LeadsExportCreateRequest
     */
    'end_date': string;
    /**
     * ID for the ad collecting leads
     * @type {string}
     * @memberof LeadsExportCreateRequest
     */
    'ad_id': string;
}
/**
 * 
 * @export
 * @interface LeadsExportCreateResponse
 */
export interface LeadsExportCreateResponse {
    /**
     * ID for the leads export job
     * @type {string}
     * @memberof LeadsExportCreateResponse
     */
    'leads_export_id'?: string;
}
/**
 * 
 * @export
 * @interface LeadsExportResponseData
 */
export interface LeadsExportResponseData {
    /**
     * 
     * @type {LeadsExportStatus}
     * @memberof LeadsExportResponseData
     */
    'export_status'?: LeadsExportStatus;
    /**
     * 
     * @type {string}
     * @memberof LeadsExportResponseData
     */
    'download_url'?: string | null;
}


/**
 * Status of a leads export job
 * @export
 * @enum {string}
 */

export const LeadsExportStatus = {
    InProgress: 'IN_PROGRESS',
    Finished: 'FINISHED',
    Failed: 'FAILED'
} as const;

export type LeadsExportStatus = typeof LeadsExportStatus[keyof typeof LeadsExportStatus];


/**
 * 
 * @export
 * @interface LineItem
 */
export interface LineItem {
    /**
     * Product brand. For example, \"Parker\".
     * @type {string}
     * @memberof LineItem
     */
    'product_brand'?: string;
    /**
     * Product category. For example, \"Shoes\".
     * @type {string}
     * @memberof LineItem
     */
    'product_category'?: string;
    /**
     * Product ID. For example, 1414.
     * @type {number}
     * @memberof LineItem
     */
    'product_id'?: number;
    /**
     * Product name. For example, \"Parker Boots\".
     * @type {string}
     * @memberof LineItem
     */
    'product_name'?: string;
    /**
     * Product price. For example, \"99.99\".
     * @type {string}
     * @memberof LineItem
     */
    'product_price'?: string;
    /**
     * Product quantity. For example, 2.
     * @type {number}
     * @memberof LineItem
     */
    'product_quantity'?: number;
    /**
     * Product variant. For example, \"Red\".
     * @type {string}
     * @memberof LineItem
     */
    'product_variant'?: string;
    /**
     * Product variant ID. For example, \"1414-34832\".
     * @type {string}
     * @memberof LineItem
     */
    'product_variant_id'?: string;
}
/**
 * 
 * @export
 * @interface LinkedBusiness
 */
export interface LinkedBusiness {
    /**
     * Username
     * @type {string}
     * @memberof LinkedBusiness
     */
    'username'?: string;
    /**
     * image_small_url
     * @type {string}
     * @memberof LinkedBusiness
     */
    'image_small_url'?: string;
    /**
     * image_medium_url
     * @type {string}
     * @memberof LinkedBusiness
     */
    'image_medium_url'?: string;
    /**
     * image_large_url
     * @type {string}
     * @memberof LinkedBusiness
     */
    'image_large_url'?: string;
    /**
     * image_xlarge_url
     * @type {string}
     * @memberof LinkedBusiness
     */
    'image_xlarge_url'?: string;
}
/**
 * Marketing Mix Modeling (MMM) Reporting Columns
 * @export
 * @enum {string}
 */

export const MMMReportingColumn = {
    SpendInDollar: 'SPEND_IN_DOLLAR',
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInDollar: 'ECPM_IN_DOLLAR',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdGroupId: 'AD_GROUP_ID',
    AdGroupName: 'AD_GROUP_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Impression1: 'IMPRESSION_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Impression2: 'IMPRESSION_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    AdvertiserName: 'ADVERTISER_NAME',
    SpendOrderLinePaidType: 'SPEND_ORDER_LINE_PAID_TYPE'
} as const;

export type MMMReportingColumn = typeof MMMReportingColumn[keyof typeof MMMReportingColumn];


/**
 * Ad targeting types for MMM report
 * @export
 * @enum {string}
 */

export const MMMReportingTargetingType = {
    Apptype: 'APPTYPE',
    Country: 'COUNTRY',
    CreativeType: 'CREATIVE_TYPE',
    Gender: 'GENDER',
    Location: 'LOCATION'
} as const;

export type MMMReportingTargetingType = typeof MMMReportingTargetingType[keyof typeof MMMReportingTargetingType];


/**
 * Keyword match type
 * @export
 * @enum {string}
 */

export const MatchType = {
    Broad: 'BROAD',
    Phrase: 'PHRASE',
    Exact: 'EXACT',
    ExactNegative: 'EXACT_NEGATIVE',
    PhraseNegative: 'PHRASE_NEGATIVE'
} as const;

export type MatchType = typeof MatchType[keyof typeof MatchType];


/**
 * Keyword match type
 * @export
 * @enum {string}
 */

export const MatchTypeResponse = {
    Broad: 'BROAD',
    Phrase: 'PHRASE',
    Exact: 'EXACT',
    ExactNegative: 'EXACT_NEGATIVE',
    PhraseNegative: 'PHRASE_NEGATIVE'
} as const;

export type MatchTypeResponse = typeof MatchTypeResponse[keyof typeof MatchTypeResponse];


/**
 * 
 * @export
 * @interface MaxPriceFilter
 */
export interface MaxPriceFilter {
    /**
     * 
     * @type {CatalogsProductGroupPricingCriteria}
     * @memberof MaxPriceFilter
     */
    'MAX_PRICE': CatalogsProductGroupPricingCriteria;
}
/**
 * 
 * @export
 * @interface MediaList200Response
 */
export interface MediaList200Response {
    /**
     * Media
     * @type {Array<MediaUploadDetails>}
     * @memberof MediaList200Response
     */
    'items': Array<MediaUploadDetails>;
    /**
     * 
     * @type {string}
     * @memberof MediaList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const MediaType = {
    Image: 'IMAGE',
    Video: 'VIDEO'
} as const;

export type MediaType = typeof MediaType[keyof typeof MediaType];


/**
 * 
 * @export
 * @interface MediaTypeFilter
 */
export interface MediaTypeFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleMediaTypesCriteria}
     * @memberof MediaTypeFilter
     */
    'MEDIA_TYPE': CatalogsProductGroupMultipleMediaTypesCriteria;
}
/**
 * Media upload that has been registered but not uploaded/processed yet.
 * @export
 * @interface MediaUpload
 */
export interface MediaUpload {
    /**
     * Unique identifier for this media upload. Used to track status and for attaching during Pin creation.
     * @type {string}
     * @memberof MediaUpload
     */
    'media_id'?: string;
    /**
     * 
     * @type {MediaUploadType}
     * @memberof MediaUpload
     */
    'media_type'?: MediaUploadType;
    /**
     * The URL where you will POST your media file.
     * @type {string}
     * @memberof MediaUpload
     */
    'upload_url'?: string;
    /**
     * 
     * @type {MediaUploadAllOfUploadParameters}
     * @memberof MediaUpload
     */
    'upload_parameters'?: MediaUploadAllOfUploadParameters;
}


/**
 * The list of parameter key/value pairs you will need to send with your POST request to upload your media file.
 * @export
 * @interface MediaUploadAllOfUploadParameters
 */
export interface MediaUploadAllOfUploadParameters {
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'x-amz-date'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'x-amz-signature'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'x-amz-security-token'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'x-amz-algorithm'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'policy'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'x-amz-credential'?: string;
    /**
     * 
     * @type {string}
     * @memberof MediaUploadAllOfUploadParameters
     */
    'Content-Type'?: string;
}
/**
 * Media upload details
 * @export
 * @interface MediaUploadDetails
 */
export interface MediaUploadDetails {
    /**
     * 
     * @type {string}
     * @memberof MediaUploadDetails
     */
    'media_id'?: string;
    /**
     * 
     * @type {MediaUploadType}
     * @memberof MediaUploadDetails
     */
    'media_type'?: MediaUploadType;
    /**
     * 
     * @type {MediaUploadStatus}
     * @memberof MediaUploadDetails
     */
    'status'?: MediaUploadStatus;
}


/**
 * Media upload request
 * @export
 * @interface MediaUploadRequest
 */
export interface MediaUploadRequest {
    /**
     * 
     * @type {MediaUploadType}
     * @memberof MediaUploadRequest
     */
    'media_type': MediaUploadType;
}


/**
 * Media upload status
 * @export
 * @enum {string}
 */

export const MediaUploadStatus = {
    Registered: 'registered',
    Processing: 'processing',
    Succeeded: 'succeeded',
    Failed: 'failed'
} as const;

export type MediaUploadStatus = typeof MediaUploadStatus[keyof typeof MediaUploadStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const MediaUploadType = {
    Video: 'video'
} as const;

export type MediaUploadType = typeof MediaUploadType[keyof typeof MediaUploadType];


/**
 * The access level a member/partner has to the business. Values are case-sensitive. <br> - EMPLOYEE: Can only view and access ad accounts you assign to them. They cannot see details about other employees, external partners or other ad accounts. <br> - BIZ_ADMIN: Have full control of roles and can add employees, external partners as well as grant ad account access.
 * @export
 * @enum {string}
 */

export const MemberBusinessRole = {
    Employee: 'EMPLOYEE',
    BizAdmin: 'BIZ_ADMIN'
} as const;

export type MemberBusinessRole = typeof MemberBusinessRole[keyof typeof MemberBusinessRole];


/**
 * 
 * @export
 * @interface MembersToDeleteBody
 */
export interface MembersToDeleteBody {
    /**
     * 
     * @type {Array<MembersToDeleteBodyMembersInner>}
     * @memberof MembersToDeleteBody
     */
    'members': Array<MembersToDeleteBodyMembersInner>;
}
/**
 * 
 * @export
 * @interface MembersToDeleteBodyMembersInner
 */
export interface MembersToDeleteBodyMembersInner {
    /**
     * Unique identifier of the member
     * @type {string}
     * @memberof MembersToDeleteBodyMembersInner
     */
    'member_id': string;
    /**
     * 
     * @type {BusinessRoleForMembers}
     * @memberof MembersToDeleteBodyMembersInner
     */
    'business_role': BusinessRoleForMembers;
}


/**
 * Level of the reporting request
 * @export
 * @enum {string}
 */

export const MetricsReportingLevel = {
    Advertiser: 'ADVERTISER',
    AdvertiserTargeting: 'ADVERTISER_TARGETING',
    Campaign: 'CAMPAIGN',
    CampaignTargeting: 'CAMPAIGN_TARGETING',
    AdGroup: 'AD_GROUP',
    AdGroupTargeting: 'AD_GROUP_TARGETING',
    PinPromotion: 'PIN_PROMOTION',
    PinPromotionTargeting: 'PIN_PROMOTION_TARGETING',
    Keyword: 'KEYWORD',
    ProductGroup: 'PRODUCT_GROUP',
    ProductGroupTargeting: 'PRODUCT_GROUP_TARGETING',
    ProductItem: 'PRODUCT_ITEM',
    ProductItemTargeting: 'PRODUCT_ITEM_TARGETING'
} as const;

export type MetricsReportingLevel = typeof MetricsReportingLevel[keyof typeof MetricsReportingLevel];


/**
 * 
 * @export
 * @interface MetricsResponse
 */
export interface MetricsResponse {
    /**
     * 
     * @type {Array<object>}
     * @memberof MetricsResponse
     */
    'data'?: Array<object>;
}
/**
 * 
 * @export
 * @interface MinPriceFilter
 */
export interface MinPriceFilter {
    /**
     * 
     * @type {CatalogsProductGroupPricingCriteria}
     * @memberof MinPriceFilter
     */
    'MIN_PRICE': CatalogsProductGroupPricingCriteria;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code': number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * @type MultipleProductGroupsInner
 * @export
 */
export type MultipleProductGroupsInner = CatalogsProductGroupCreateRequest | CatalogsVerticalProductGroupCreateRequest;

/**
 * Currency Codes from ISO 4217.
 * @export
 * @enum {string}
 */

export const NonNullableCatalogsCurrency = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD'
} as const;

export type NonNullableCatalogsCurrency = typeof NonNullableCatalogsCurrency[keyof typeof NonNullableCatalogsCurrency];


/**
 * Product availability.
 * @export
 * @enum {string}
 */

export const NonNullableProductAvailabilityType = {
    InStock: 'IN_STOCK',
    OutOfStock: 'OUT_OF_STOCK',
    Preorder: 'PREORDER'
} as const;

export type NonNullableProductAvailabilityType = typeof NonNullableProductAvailabilityType[keyof typeof NonNullableProductAvailabilityType];


/**
 * Product item fields
 * @export
 * @enum {string}
 */

export const NullableCatalogsItemFieldType = {
    ItemId: 'ITEM_ID',
    ItemGroupId: 'ITEM_GROUP_ID',
    Title: 'TITLE',
    Description: 'DESCRIPTION',
    ItemLink: 'ITEM_LINK',
    OrganicLink: 'ORGANIC_LINK',
    ImageLink: 'IMAGE_LINK',
    AdwordsRedirectLink: 'ADWORDS_REDIRECT_LINK',
    AdLink: 'AD_LINK',
    Size: 'SIZE',
    GoogleProductCategory: 'GOOGLE_PRODUCT_CATEGORY',
    ProductCategory: 'PRODUCT_CATEGORY',
    Condition: 'CONDITION',
    Availability: 'AVAILABILITY',
    Gender: 'GENDER',
    AgeGroup: 'AGE_GROUP',
    SizeType: 'SIZE_TYPE',
    SizeSystem: 'SIZE_SYSTEM',
    Adult: 'ADULT',
    Shipping: 'SHIPPING',
    ShippingWeight: 'SHIPPING_WEIGHT',
    Tax: 'TAX',
    Multipack: 'MULTIPACK',
    AdditionalImageLink: 'ADDITIONAL_IMAGE_LINK',
    Price: 'PRICE',
    SalePrice: 'SALE_PRICE',
    IsBundle: 'IS_BUNDLE',
    ExpirationDate: 'EXPIRATION_DATE',
    SalePriceEffectiveDate: 'SALE_PRICE_EFFECTIVE_DATE',
    AvailabilityDate: 'AVAILABILITY_DATE',
    WeightUnit: 'WEIGHT_UNIT',
    ProductType: 'PRODUCT_TYPE',
    CustomLabel0: 'CUSTOM_LABEL_0',
    CustomLabel1: 'CUSTOM_LABEL_1',
    CustomLabel2: 'CUSTOM_LABEL_2',
    CustomLabel3: 'CUSTOM_LABEL_3',
    CustomLabel4: 'CUSTOM_LABEL_4',
    Material: 'MATERIAL',
    Pattern: 'PATTERN',
    Color: 'COLOR',
    Brand: 'BRAND',
    Gtin: 'GTIN',
    Mpn: 'MPN',
    IosDeepLink: 'IOS_DEEP_LINK',
    AndroidDeepLink: 'ANDROID_DEEP_LINK',
    FreeShippingLabel: 'FREE_SHIPPING_LABEL',
    FreeShippingLimit: 'FREE_SHIPPING_LIMIT',
    AvgReviewRating: 'AVG_REVIEW_RATING',
    NumRatings: 'NUM_RATINGS',
    NumReviews: 'NUM_REVIEWS',
    AltText: 'ALT_TEXT',
    VariantNames: 'VARIANT_NAMES',
    VariantValues: 'VARIANT_VALUES',
    MinAdPrice: 'MIN_AD_PRICE',
    ShippingWidth: 'SHIPPING_WIDTH',
    ShippingHeight: 'SHIPPING_HEIGHT'
} as const;

export type NullableCatalogsItemFieldType = typeof NullableCatalogsItemFieldType[keyof typeof NullableCatalogsItemFieldType];


/**
 * Currency Codes from ISO 4217.
 * @export
 * @enum {string}
 */

export const NullableCurrency = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byn: 'BYN',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD'
} as const;

export type NullableCurrency = typeof NullableCurrency[keyof typeof NullableCurrency];


/**
 * A request to receive a client token.
 * @export
 * @interface OauthAccessTokenRequestClientCredentials
 */
export interface OauthAccessTokenRequestClientCredentials {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestClientCredentials
     */
    'grant_type': OauthAccessTokenRequestClientCredentialsGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestClientCredentials
     */
    'scope': string;
}

export const OauthAccessTokenRequestClientCredentialsGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenRequestClientCredentialsGrantTypeEnum = typeof OauthAccessTokenRequestClientCredentialsGrantTypeEnum[keyof typeof OauthAccessTokenRequestClientCredentialsGrantTypeEnum];

/**
 * A request to exchange an authorization code for an access token.
 * @export
 * @interface OauthAccessTokenRequestCode
 */
export interface OauthAccessTokenRequestCode {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestCode
     */
    'grant_type': OauthAccessTokenRequestCodeGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestCode
     */
    'code': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestCode
     */
    'redirect_uri': string;
}

export const OauthAccessTokenRequestCodeGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenRequestCodeGrantTypeEnum = typeof OauthAccessTokenRequestCodeGrantTypeEnum[keyof typeof OauthAccessTokenRequestCodeGrantTypeEnum];

/**
 * A request to exchange a refresh token for a new access token.
 * @export
 * @interface OauthAccessTokenRequestRefresh
 */
export interface OauthAccessTokenRequestRefresh {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestRefresh
     */
    'grant_type': OauthAccessTokenRequestRefreshGrantTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestRefresh
     */
    'refresh_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenRequestRefresh
     */
    'scope'?: string;
    /**
     * Setting this field to <code>true</code> will add a new refresh token to your 200 response, as well as the refresh_token_expires_in and refresh_token_expires_at fields. To see the structure of this payload, set the 200 response_type to \"everlasting_refresh\".
     * @type {boolean}
     * @memberof OauthAccessTokenRequestRefresh
     */
    'refresh_on'?: boolean;
}

export const OauthAccessTokenRequestRefreshGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenRequestRefreshGrantTypeEnum = typeof OauthAccessTokenRequestRefreshGrantTypeEnum[keyof typeof OauthAccessTokenRequestRefreshGrantTypeEnum];

/**
 * A successful OAuth access token response.
 * @export
 * @interface OauthAccessTokenResponse
 */
export interface OauthAccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponse
     */
    'response_type'?: OauthAccessTokenResponseResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponse
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponse
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponse
     */
    'scope': string;
}

export const OauthAccessTokenResponseResponseTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenResponseResponseTypeEnum = typeof OauthAccessTokenResponseResponseTypeEnum[keyof typeof OauthAccessTokenResponseResponseTypeEnum];

/**
 * A successful OAuth client token response for the client token flow.
 * @export
 * @interface OauthAccessTokenResponseClientCredentials
 */
export interface OauthAccessTokenResponseClientCredentials {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseClientCredentials
     */
    'response_type'?: OauthAccessTokenResponseClientCredentialsResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseClientCredentials
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseClientCredentials
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseClientCredentials
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseClientCredentials
     */
    'scope': string;
}

export const OauthAccessTokenResponseClientCredentialsResponseTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenResponseClientCredentialsResponseTypeEnum = typeof OauthAccessTokenResponseClientCredentialsResponseTypeEnum[keyof typeof OauthAccessTokenResponseClientCredentialsResponseTypeEnum];

/**
 * A successful OAuth access token response for the authorization code flow.
 * @export
 * @interface OauthAccessTokenResponseCode
 */
export interface OauthAccessTokenResponseCode {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseCode
     */
    'response_type'?: OauthAccessTokenResponseCodeResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseCode
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseCode
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseCode
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseCode
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseCode
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseCode
     */
    'refresh_token_expires_in': number;
}

export const OauthAccessTokenResponseCodeResponseTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenResponseCodeResponseTypeEnum = typeof OauthAccessTokenResponseCodeResponseTypeEnum[keyof typeof OauthAccessTokenResponseCodeResponseTypeEnum];

/**
 * A successful OAuth access token response for the refresh token flow, with an added everlasting refresh token.
 * @export
 * @interface OauthAccessTokenResponseEverlastingRefresh
 */
export interface OauthAccessTokenResponseEverlastingRefresh {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'response_type'?: OauthAccessTokenResponseEverlastingRefreshResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'refresh_token_expires_in': number;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseEverlastingRefresh
     */
    'refresh_token_expires_at': number;
}

export const OauthAccessTokenResponseEverlastingRefreshResponseTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenResponseEverlastingRefreshResponseTypeEnum = typeof OauthAccessTokenResponseEverlastingRefreshResponseTypeEnum[keyof typeof OauthAccessTokenResponseEverlastingRefreshResponseTypeEnum];

/**
 * A successful OAuth access token response for the refresh token flow, with an added refresh token.
 * @export
 * @interface OauthAccessTokenResponseIntegrationRefresh
 */
export interface OauthAccessTokenResponseIntegrationRefresh {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'response_type'?: OauthAccessTokenResponseIntegrationRefreshResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'scope': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'refresh_token': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseIntegrationRefresh
     */
    'refresh_token_expires_in': number;
}

export const OauthAccessTokenResponseIntegrationRefreshResponseTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenResponseIntegrationRefreshResponseTypeEnum = typeof OauthAccessTokenResponseIntegrationRefreshResponseTypeEnum[keyof typeof OauthAccessTokenResponseIntegrationRefreshResponseTypeEnum];

/**
 * A successful OAuth access token response for the refresh token flow.
 * @export
 * @interface OauthAccessTokenResponseRefresh
 */
export interface OauthAccessTokenResponseRefresh {
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseRefresh
     */
    'response_type'?: OauthAccessTokenResponseRefreshResponseTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseRefresh
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseRefresh
     */
    'token_type': string;
    /**
     * 
     * @type {number}
     * @memberof OauthAccessTokenResponseRefresh
     */
    'expires_in': number;
    /**
     * 
     * @type {string}
     * @memberof OauthAccessTokenResponseRefresh
     */
    'scope': string;
}

export const OauthAccessTokenResponseRefreshResponseTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;

export type OauthAccessTokenResponseRefreshResponseTypeEnum = typeof OauthAccessTokenResponseRefreshResponseTypeEnum[keyof typeof OauthAccessTokenResponseRefreshResponseTypeEnum];

/**
 * Campaign objective type. If set as one of [\"AWARENESS\", \"CONSIDERATION\", \"WEB_CONVERSION\", \"CATALOG_SALES\", \"VIDEO_COMPLETION\"] the campaign is considered as a Campaign Budget Optimization (CBO) campaign, meaning budget needs to be set at the campaign level rather than at the ad group level. [\"WEB_SESSIONS\"] is DEPRECATED. For update, only draft campaigns may update objective type.
 * @export
 * @enum {string}
 */

export const ObjectiveType = {
    Awareness: 'AWARENESS',
    Consideration: 'CONSIDERATION',
    VideoView: 'VIDEO_VIEW',
    WebConversion: 'WEB_CONVERSION',
    CatalogSales: 'CATALOG_SALES',
    WebSessions: 'WEB_SESSIONS',
    VideoCompletion: 'VIDEO_COMPLETION'
} as const;

export type ObjectiveType = typeof ObjectiveType[keyof typeof ObjectiveType];


/**
 * Operation type to share a specific audience or revoke access to a previously shared audience
 * @export
 * @enum {string}
 */

export const OperationType = {
    Share: 'SHARE',
    Revoke: 'REVOKE'
} as const;

export type OperationType = typeof OperationType[keyof typeof OperationType];


/**
 * 
 * @export
 * @interface OptimizationGoalMetadata
 */
export interface OptimizationGoalMetadata {
    /**
     * 
     * @type {OptimizationGoalMetadataConversionTagV3GoalMetadata}
     * @memberof OptimizationGoalMetadata
     */
    'conversion_tag_v3_goal_metadata'?: OptimizationGoalMetadataConversionTagV3GoalMetadata;
    /**
     * 
     * @type {OptimizationGoalMetadataFrequencyGoalMetadata}
     * @memberof OptimizationGoalMetadata
     */
    'frequency_goal_metadata'?: OptimizationGoalMetadataFrequencyGoalMetadata;
    /**
     * 
     * @type {OptimizationGoalMetadataScrollupGoalMetadata}
     * @memberof OptimizationGoalMetadata
     */
    'scrollup_goal_metadata'?: OptimizationGoalMetadataScrollupGoalMetadata;
}
/**
 * 
 * @export
 * @interface OptimizationGoalMetadataConversionTagV3GoalMetadata
 */
export interface OptimizationGoalMetadataConversionTagV3GoalMetadata {
    /**
     * 
     * @type {OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadata
     */
    'attribution_windows'?: OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows;
    /**
     * 
     * @type {string}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadata
     */
    'conversion_event'?: OptimizationGoalMetadataConversionTagV3GoalMetadataConversionEventEnum;
    /**
     * 
     * @type {string}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadata
     */
    'conversion_tag_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadata
     */
    'cpa_goal_value_in_micro_currency'?: string;
    /**
     * ROAS optimization is not supported
     * @type {boolean}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadata
     */
    'is_roas_optimized'?: boolean | null;
    /**
     * Conversion learning model type
     * @type {string}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadata
     */
    'learning_mode_type'?: OptimizationGoalMetadataConversionTagV3GoalMetadataLearningModeTypeEnum | null;
}

export const OptimizationGoalMetadataConversionTagV3GoalMetadataConversionEventEnum = {
    PageVisit: 'PAGE_VISIT',
    Signup: 'SIGNUP',
    Checkout: 'CHECKOUT',
    Custom: 'CUSTOM',
    ViewCategory: 'VIEW_CATEGORY',
    Search: 'SEARCH',
    AddToCart: 'ADD_TO_CART',
    WatchVideo: 'WATCH_VIDEO',
    Lead: 'LEAD',
    AppInstall: 'APP_INSTALL'
} as const;

export type OptimizationGoalMetadataConversionTagV3GoalMetadataConversionEventEnum = typeof OptimizationGoalMetadataConversionTagV3GoalMetadataConversionEventEnum[keyof typeof OptimizationGoalMetadataConversionTagV3GoalMetadataConversionEventEnum];
export const OptimizationGoalMetadataConversionTagV3GoalMetadataLearningModeTypeEnum = {
    NotActive: 'NOT_ACTIVE',
    Active: 'ACTIVE'
} as const;

export type OptimizationGoalMetadataConversionTagV3GoalMetadataLearningModeTypeEnum = typeof OptimizationGoalMetadataConversionTagV3GoalMetadataLearningModeTypeEnum[keyof typeof OptimizationGoalMetadataConversionTagV3GoalMetadataLearningModeTypeEnum];

/**
 * 
 * @export
 * @interface OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows
 */
export interface OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows {
    /**
     * 
     * @type {number}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows
     */
    'click_window_days'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows
     */
    'engagement_window_days'?: number;
    /**
     * 
     * @type {number}
     * @memberof OptimizationGoalMetadataConversionTagV3GoalMetadataAttributionWindows
     */
    'view_window_days'?: number;
}
/**
 * 
 * @export
 * @interface OptimizationGoalMetadataFrequencyGoalMetadata
 */
export interface OptimizationGoalMetadataFrequencyGoalMetadata {
    /**
     * 
     * @type {number}
     * @memberof OptimizationGoalMetadataFrequencyGoalMetadata
     */
    'frequency'?: number;
    /**
     * User entity counts time range
     * @type {string}
     * @memberof OptimizationGoalMetadataFrequencyGoalMetadata
     */
    'timerange'?: OptimizationGoalMetadataFrequencyGoalMetadataTimerangeEnum;
}

export const OptimizationGoalMetadataFrequencyGoalMetadataTimerangeEnum = {
    ThirtyDay: 'THIRTY_DAY',
    Day: 'DAY',
    SevenDay: 'SEVEN_DAY',
    TwentyMinute: 'TWENTY_MINUTE',
    TenMinute: 'TEN_MINUTE',
    TwentyFourHour: 'TWENTY_FOUR_HOUR'
} as const;

export type OptimizationGoalMetadataFrequencyGoalMetadataTimerangeEnum = typeof OptimizationGoalMetadataFrequencyGoalMetadataTimerangeEnum[keyof typeof OptimizationGoalMetadataFrequencyGoalMetadataTimerangeEnum];

/**
 * 
 * @export
 * @interface OptimizationGoalMetadataScrollupGoalMetadata
 */
export interface OptimizationGoalMetadataScrollupGoalMetadata {
    /**
     * 
     * @type {string}
     * @memberof OptimizationGoalMetadataScrollupGoalMetadata
     */
    'scrollup_goal_value_in_micro_currency'?: string | null;
}
/**
 * 
 * @export
 * @interface OrderLine
 */
export interface OrderLine {
    /**
     * Order line ID.
     * @type {string}
     * @memberof OrderLine
     */
    'id'?: string;
    /**
     * Always \"orderline\".
     * @type {string}
     * @memberof OrderLine
     */
    'type'?: string;
    /**
     * Ad account ID.
     * @type {string}
     * @memberof OrderLine
     */
    'ad_account_id'?: string;
    /**
     * Purchase order ID.
     * @type {string}
     * @memberof OrderLine
     */
    'purchase_order_id'?: string | null;
    /**
     * Start time. Unix timestamp.
     * @type {number}
     * @memberof OrderLine
     */
    'start_time'?: number;
    /**
     * End time. Unix timestamp.
     * @type {number}
     * @memberof OrderLine
     */
    'end_time'?: number | null;
    /**
     * Order line budget in micro currency.
     * @type {number}
     * @memberof OrderLine
     */
    'budget'?: number | null;
    /**
     * Order line paid budget in micro currency.
     * @type {number}
     * @memberof OrderLine
     */
    'paid_budget'?: number | null;
    /**
     * Order line status.
     * @type {OrderLineStatus}
     * @memberof OrderLine
     */
    'status'?: OrderLineStatus;
    /**
     * Order line name.
     * @type {string}
     * @memberof OrderLine
     */
    'name'?: string | null;
    /**
     * Order line paid type.
     * @type {OrderLinePaidType}
     * @memberof OrderLine
     */
    'paid_type'?: OrderLinePaidType | null;
    /**
     * Associated List of campaign IDs.
     * @type {Array<string>}
     * @memberof OrderLine
     */
    'campaign_ids': Array<string>;
}


/**
 * 
 * @export
 * @interface OrderLineError
 */
export interface OrderLineError {
    /**
     * 
     * @type {OrderLine}
     * @memberof OrderLineError
     */
    'data'?: OrderLine;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderLineError
     */
    'error_messages'?: Array<string>;
}
/**
 * Order Line Paid Type
 * @export
 * @enum {string}
 */

export const OrderLinePaidType = {
    Paid: 'PAID',
    Bonus: 'BONUS',
    MakeGood: 'MAKE_GOOD',
    Test: 'TEST'
} as const;

export type OrderLinePaidType = typeof OrderLinePaidType[keyof typeof OrderLinePaidType];


/**
 * 
 * @export
 * @interface OrderLineResponse
 */
export interface OrderLineResponse {
    /**
     * Error list if update(s) fail.
     * @type {Array<OrderLineError>}
     * @memberof OrderLineResponse
     */
    'errors'?: Array<OrderLineError>;
    /**
     * Order Line object array.
     * @type {Array<OrderLine>}
     * @memberof OrderLineResponse
     */
    'order_line'?: Array<OrderLine>;
}
/**
 * 
 * @export
 * @interface OrderLineSingleResponse
 */
export interface OrderLineSingleResponse {
    /**
     * 
     * @type {OrderLineResponse}
     * @memberof OrderLineSingleResponse
     */
    'data'?: OrderLineResponse;
}
/**
 * Order Line Status
 * @export
 * @enum {string}
 */

export const OrderLineStatus = {
    Active: 'ACTIVE',
    Paused: 'PAUSED',
    Deleted: 'DELETED'
} as const;

export type OrderLineStatus = typeof OrderLineStatus[keyof typeof OrderLineStatus];


/**
 * Order Line
 * @export
 * @interface OrderLines
 */
export interface OrderLines {
    /**
     * Order line ID.
     * @type {string}
     * @memberof OrderLines
     */
    'id'?: string;
    /**
     * Always \"orderline\".
     * @type {string}
     * @memberof OrderLines
     */
    'type'?: string;
    /**
     * Ad account ID.
     * @type {string}
     * @memberof OrderLines
     */
    'ad_account_id'?: string;
    /**
     * Purchase order ID.
     * @type {string}
     * @memberof OrderLines
     */
    'purchase_order_id'?: string | null;
    /**
     * Start time. Unix timestamp.
     * @type {number}
     * @memberof OrderLines
     */
    'start_time'?: number;
    /**
     * End time. Unix timestamp.
     * @type {number}
     * @memberof OrderLines
     */
    'end_time'?: number | null;
    /**
     * Order line budget in micro currency.
     * @type {number}
     * @memberof OrderLines
     */
    'budget'?: number | null;
    /**
     * Order line paid budget in micro currency.
     * @type {number}
     * @memberof OrderLines
     */
    'paid_budget'?: number | null;
    /**
     * Order line status.
     * @type {OrderLineStatus}
     * @memberof OrderLines
     */
    'status'?: OrderLineStatus;
    /**
     * Order line name.
     * @type {string}
     * @memberof OrderLines
     */
    'name'?: string | null;
    /**
     * Order line paid type.
     * @type {OrderLinePaidType}
     * @memberof OrderLines
     */
    'paid_type'?: OrderLinePaidType | null;
}


/**
 * 
 * @export
 * @interface OrderLinesArrayResponse
 */
export interface OrderLinesArrayResponse {
    /**
     * 
     * @type {Array<OrderLines>}
     * @memberof OrderLinesArrayResponse
     */
    'items'?: Array<OrderLines>;
}
/**
 * 
 * @export
 * @interface OrderLinesList200Response
 */
export interface OrderLinesList200Response {
    /**
     * 
     * @type {Array<OrderLine>}
     * @memberof OrderLinesList200Response
     */
    'items': Array<OrderLine>;
    /**
     * 
     * @type {string}
     * @memberof OrderLinesList200Response
     */
    'bookmark'?: string | null;
}
/**
 * Ad group pacing delivery type. With ACCELERATED, an ad group budget is spent as fast as possible. With STANDARD, an ad group budget is spent smoothly over a day. When using CBO, only the STANDARD pacing delivery type is allowed.
 * @export
 * @enum {string}
 */

export const PacingDeliveryType = {
    Standard: 'STANDARD',
    Accelerated: 'ACCELERATED'
} as const;

export type PacingDeliveryType = typeof PacingDeliveryType[keyof typeof PacingDeliveryType];


/**
 * 
 * @export
 * @interface PageVisitConversionTagsGet200Response
 */
export interface PageVisitConversionTagsGet200Response {
    /**
     * 
     * @type {Array<ConversionEventResponse>}
     * @memberof PageVisitConversionTagsGet200Response
     */
    'items': Array<ConversionEventResponse>;
    /**
     * 
     * @type {string}
     * @memberof PageVisitConversionTagsGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface Paginated
 */
export interface Paginated {
    /**
     * 
     * @type {Array<object>}
     * @memberof Paginated
     */
    'items': Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Paginated
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PartnerType = {
    Internal: 'INTERNAL',
    External: 'EXTERNAL'
} as const;

export type PartnerType = typeof PartnerType[keyof typeof PartnerType];


/**
 * 
 * @export
 * @enum {string}
 */

export const Permissions = {
    Admin: 'ADMIN',
    Analyst: 'ANALYST',
    FinanceManager: 'FINANCE_MANAGER',
    AudienceManager: 'AUDIENCE_MANAGER',
    CampaignManager: 'CAMPAIGN_MANAGER',
    CatalogsManager: 'CATALOGS_MANAGER',
    ProfilePublisher: 'PROFILE_PUBLISHER'
} as const;

export type Permissions = typeof Permissions[keyof typeof Permissions];


/**
 * 
 * @export
 * @enum {string}
 */

export const PermissionsWithOwner = {
    Admin: 'ADMIN',
    Analyst: 'ANALYST',
    FinanceManager: 'FINANCE_MANAGER',
    AudienceManager: 'AUDIENCE_MANAGER',
    CampaignManager: 'CAMPAIGN_MANAGER',
    CatalogsManager: 'CATALOGS_MANAGER',
    CatalogsViewer: 'CATALOGS_VIEWER',
    ProfilePublisher: 'PROFILE_PUBLISHER',
    Owner: 'OWNER'
} as const;

export type PermissionsWithOwner = typeof PermissionsWithOwner[keyof typeof PermissionsWithOwner];


/**
 * Pin
 * @export
 * @interface Pin
 */
export interface Pin {
    /**
     * 
     * @type {string}
     * @memberof Pin
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pin
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof Pin
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pin
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pin
     */
    'description'?: string | null;
    /**
     * Dominant pin color. Hex number, e.g. \\\"#6E7874\\\".
     * @type {string}
     * @memberof Pin
     */
    'dominant_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof Pin
     */
    'alt_text'?: string | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof Pin
     */
    'creative_type'?: CreativeType | null;
    /**
     * The board to which this Pin belongs.
     * @type {string}
     * @memberof Pin
     */
    'board_id'?: string;
    /**
     * The board section to which this Pin belongs.
     * @type {string}
     * @memberof Pin
     */
    'board_section_id'?: string | null;
    /**
     * 
     * @type {BoardOwner}
     * @memberof Pin
     */
    'board_owner'?: BoardOwner;
    /**
     * Whether the \"operation user_account\" is the Pin owner.
     * @type {boolean}
     * @memberof Pin
     */
    'is_owner'?: boolean;
    /**
     * 
     * @type {PinMedia}
     * @memberof Pin
     */
    'media'?: PinMedia;
    /**
     * 
     * @type {PinMediaSource}
     * @memberof Pin
     */
    'media_source'?: PinMediaSource;
    /**
     * The source pin id if this pin was saved from another pin. <a href=\"https://help.pinterest.com/article/save-pins-on-pinterest\">Learn more</a>.
     * @type {string}
     * @memberof Pin
     */
    'parent_pin_id'?: string | null;
    /**
     * Whether the Pin is standard or not. See documentation on <a href=\"/docs/api-features/content-overview/\">Changes to Pin creation</a> for more information.
     * @type {boolean}
     * @memberof Pin
     */
    'is_standard'?: boolean;
    /**
     * Whether the Pin has been promoted or not.
     * @type {boolean}
     * @memberof Pin
     */
    'has_been_promoted'?: boolean;
    /**
     * Private note for this Pin. <a href=\"https://help.pinterest.com/en/article/add-notes-to-your-pins\">Learn more</a>.
     * @type {string}
     * @memberof Pin
     */
    'note'?: string | null;
    /**
     * Pin metrics with associated time intervals if any.
     * @type {object}
     * @memberof Pin
     */
    'pin_metrics'?: object | null;
}


/**
 * 
 * @export
 * @interface PinAnalyticsMetricsResponse
 */
export interface PinAnalyticsMetricsResponse {
    /**
     * The lifetime metric name and value.
     * @type {{ [key: string]: number; }}
     * @memberof PinAnalyticsMetricsResponse
     */
    'lifetime_metrics'?: { [key: string]: number; };
    /**
     * Array with the requested daily metric records
     * @type {Array<PinAnalyticsMetricsResponseDailyMetricsInner>}
     * @memberof PinAnalyticsMetricsResponse
     */
    'daily_metrics'?: Array<PinAnalyticsMetricsResponseDailyMetricsInner>;
    /**
     * The metric name and value over the requested period for each requested metric
     * @type {{ [key: string]: number; }}
     * @memberof PinAnalyticsMetricsResponse
     */
    'summary_metrics'?: { [key: string]: number; };
}
/**
 * 
 * @export
 * @interface PinAnalyticsMetricsResponseDailyMetricsInner
 */
export interface PinAnalyticsMetricsResponseDailyMetricsInner {
    /**
     * 
     * @type {DataStatus}
     * @memberof PinAnalyticsMetricsResponseDailyMetricsInner
     */
    'data_status'?: DataStatus;
    /**
     * Metrics date (UTC): YYYY-MM-DD.
     * @type {string}
     * @memberof PinAnalyticsMetricsResponseDailyMetricsInner
     */
    'date'?: string;
    /**
     * The metric name and daily value for each requested metric
     * @type {{ [key: string]: number; }}
     * @memberof PinAnalyticsMetricsResponseDailyMetricsInner
     */
    'metrics'?: { [key: string]: number; };
}


/**
 * Pin
 * @export
 * @interface PinCreate
 */
export interface PinCreate {
    /**
     * 
     * @type {string}
     * @memberof PinCreate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinCreate
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinCreate
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PinCreate
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PinCreate
     */
    'description'?: string | null;
    /**
     * Dominant pin color. Hex number, e.g. \\\"#6E7874\\\".
     * @type {string}
     * @memberof PinCreate
     */
    'dominant_color'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PinCreate
     */
    'alt_text'?: string | null;
    /**
     * The board to which this Pin belongs.
     * @type {string}
     * @memberof PinCreate
     */
    'board_id'?: string;
    /**
     * The board section to which this Pin belongs.
     * @type {string}
     * @memberof PinCreate
     */
    'board_section_id'?: string | null;
    /**
     * 
     * @type {BoardOwner}
     * @memberof PinCreate
     */
    'board_owner'?: BoardOwner;
    /**
     * 
     * @type {PinMedia}
     * @memberof PinCreate
     */
    'media'?: PinMedia;
    /**
     * 
     * @type {PinMediaSource}
     * @memberof PinCreate
     */
    'media_source'?: PinMediaSource;
    /**
     * The source pin id if this pin was saved from another pin. <a href=\"https://help.pinterest.com/article/save-pins-on-pinterest\">Learn more</a>.
     * @type {string}
     * @memberof PinCreate
     */
    'parent_pin_id'?: string | null;
    /**
     * Private note for this Pin. <a href=\"https://help.pinterest.com/en/article/add-notes-to-your-pins\">Learn more</a>.
     * @type {string}
     * @memberof PinCreate
     */
    'note'?: string | null;
}
/**
 * Pin media objects.
 * @export
 * @interface PinMedia
 */
export interface PinMedia {
    /**
     * 
     * @type {string}
     * @memberof PinMedia
     */
    'media_type'?: string;
}
/**
 * 
 * @export
 * @interface PinMediaMetadata
 */
export interface PinMediaMetadata {
    /**
     * 
     * @type {string}
     * @memberof PinMediaMetadata
     */
    'item_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinMediaMetadata
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PinMediaMetadata
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof PinMediaMetadata
     */
    'link'?: string | null;
    /**
     * 
     * @type {ImageMetadataImages}
     * @memberof PinMediaMetadata
     */
    'images'?: ImageMetadataImages;
    /**
     * 
     * @type {string}
     * @memberof PinMediaMetadata
     */
    'cover_image_url'?: string;
    /**
     * Video url (720p). </p><strong>Note:</strong> This field is limited and not available to all apps.
     * @type {string}
     * @memberof PinMediaMetadata
     */
    'video_url'?: string | null;
    /**
     * Duration (in milliseconds)
     * @type {number}
     * @memberof PinMediaMetadata
     */
    'duration'?: number;
    /**
     * Height (in pixels)
     * @type {number}
     * @memberof PinMediaMetadata
     */
    'height'?: number;
    /**
     * Width (in pixels)
     * @type {number}
     * @memberof PinMediaMetadata
     */
    'width'?: number;
}
/**
 * @type PinMediaSource
 * Pin media source.
 * @export
 */
export type PinMediaSource = { source_type: 'image_base64' } & PinMediaSourceImageBase64 | { source_type: 'image_url' } & PinMediaSourceImageURL | { source_type: 'multiple_image_base64' } & PinMediaSourceImagesBase64 | { source_type: 'multiple_image_urls' } & PinMediaSourceImagesURL | { source_type: 'pin_url' } & PinMediaSourcePinURL | { source_type: 'video_id' } & PinMediaSourceVideoID;

/**
 * Base64-encoded image media source
 * @export
 * @interface PinMediaSourceImageBase64
 */
export interface PinMediaSourceImageBase64 {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImageBase64
     */
    'source_type': PinMediaSourceImageBase64SourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImageBase64
     */
    'content_type': PinMediaSourceImageBase64ContentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImageBase64
     */
    'data': string;
    /**
     * Set the parameter to false to create the new simplified Pin instead of the standard pin. Currently the field is only available to a list of beta users.
     * @type {boolean}
     * @memberof PinMediaSourceImageBase64
     */
    'is_standard'?: boolean;
}

export const PinMediaSourceImageBase64SourceTypeEnum = {
    ImageBase64: 'image_base64'
} as const;

export type PinMediaSourceImageBase64SourceTypeEnum = typeof PinMediaSourceImageBase64SourceTypeEnum[keyof typeof PinMediaSourceImageBase64SourceTypeEnum];
export const PinMediaSourceImageBase64ContentTypeEnum = {
    Jpeg: 'image/jpeg',
    Png: 'image/png'
} as const;

export type PinMediaSourceImageBase64ContentTypeEnum = typeof PinMediaSourceImageBase64ContentTypeEnum[keyof typeof PinMediaSourceImageBase64ContentTypeEnum];

/**
 * Image URL-based media source
 * @export
 * @interface PinMediaSourceImageURL
 */
export interface PinMediaSourceImageURL {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImageURL
     */
    'source_type': PinMediaSourceImageURLSourceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImageURL
     */
    'url': string;
    /**
     * Set the parameter to false to create the new simplified Pin instead of the standard pin. Currently the field is only available to a list of beta users.
     * @type {boolean}
     * @memberof PinMediaSourceImageURL
     */
    'is_standard'?: boolean;
}

export const PinMediaSourceImageURLSourceTypeEnum = {
    ImageUrl: 'image_url'
} as const;

export type PinMediaSourceImageURLSourceTypeEnum = typeof PinMediaSourceImageURLSourceTypeEnum[keyof typeof PinMediaSourceImageURLSourceTypeEnum];

/**
 * Multiple Base64-encoded images media source
 * @export
 * @interface PinMediaSourceImagesBase64
 */
export interface PinMediaSourceImagesBase64 {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesBase64
     */
    'source_type'?: PinMediaSourceImagesBase64SourceTypeEnum;
    /**
     * Array with image objects.
     * @type {Array<PinMediaSourceImagesBase64ItemsInner>}
     * @memberof PinMediaSourceImagesBase64
     */
    'items': Array<PinMediaSourceImagesBase64ItemsInner>;
    /**
     * 
     * @type {number}
     * @memberof PinMediaSourceImagesBase64
     */
    'index'?: number;
}

export const PinMediaSourceImagesBase64SourceTypeEnum = {
    MultipleImageBase64: 'multiple_image_base64'
} as const;

export type PinMediaSourceImagesBase64SourceTypeEnum = typeof PinMediaSourceImagesBase64SourceTypeEnum[keyof typeof PinMediaSourceImagesBase64SourceTypeEnum];

/**
 * 
 * @export
 * @interface PinMediaSourceImagesBase64ItemsInner
 */
export interface PinMediaSourceImagesBase64ItemsInner {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesBase64ItemsInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesBase64ItemsInner
     */
    'description'?: string;
    /**
     * Destination link for the image.
     * @type {string}
     * @memberof PinMediaSourceImagesBase64ItemsInner
     */
    'link'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesBase64ItemsInner
     */
    'content_type': PinMediaSourceImagesBase64ItemsInnerContentTypeEnum;
    /**
     * Image to upload as base64 string.
     * @type {string}
     * @memberof PinMediaSourceImagesBase64ItemsInner
     */
    'data': string;
}

export const PinMediaSourceImagesBase64ItemsInnerContentTypeEnum = {
    Jpeg: 'image/jpeg',
    Png: 'image/png'
} as const;

export type PinMediaSourceImagesBase64ItemsInnerContentTypeEnum = typeof PinMediaSourceImagesBase64ItemsInnerContentTypeEnum[keyof typeof PinMediaSourceImagesBase64ItemsInnerContentTypeEnum];

/**
 * Multiple images urls-based media source
 * @export
 * @interface PinMediaSourceImagesURL
 */
export interface PinMediaSourceImagesURL {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesURL
     */
    'source_type'?: PinMediaSourceImagesURLSourceTypeEnum;
    /**
     * Array with image objects.
     * @type {Array<PinMediaSourceImagesURLItemsInner>}
     * @memberof PinMediaSourceImagesURL
     */
    'items': Array<PinMediaSourceImagesURLItemsInner>;
    /**
     * 
     * @type {number}
     * @memberof PinMediaSourceImagesURL
     */
    'index'?: number;
}

export const PinMediaSourceImagesURLSourceTypeEnum = {
    MultipleImageUrls: 'multiple_image_urls'
} as const;

export type PinMediaSourceImagesURLSourceTypeEnum = typeof PinMediaSourceImagesURLSourceTypeEnum[keyof typeof PinMediaSourceImagesURLSourceTypeEnum];

/**
 * 
 * @export
 * @interface PinMediaSourceImagesURLItemsInner
 */
export interface PinMediaSourceImagesURLItemsInner {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesURLItemsInner
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceImagesURLItemsInner
     */
    'description'?: string;
    /**
     * Destination link for the image.
     * @type {string}
     * @memberof PinMediaSourceImagesURLItemsInner
     */
    'link'?: string;
    /**
     * URL of image to upload.
     * @type {string}
     * @memberof PinMediaSourceImagesURLItemsInner
     */
    'url': string;
}
/**
 * Pin URL-based media source for product pin creation. Currently the field is only available to a list of beta users.
 * @export
 * @interface PinMediaSourcePinURL
 */
export interface PinMediaSourcePinURL {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourcePinURL
     */
    'source_type': PinMediaSourcePinURLSourceTypeEnum;
    /**
     * This is an affiliate link or sponsored product. The FTC requires disclosure for paid partnerships and affiliate products.
     * @type {boolean}
     * @memberof PinMediaSourcePinURL
     */
    'is_affiliate_link'?: boolean;
}

export const PinMediaSourcePinURLSourceTypeEnum = {
    PinUrl: 'pin_url'
} as const;

export type PinMediaSourcePinURLSourceTypeEnum = typeof PinMediaSourcePinURLSourceTypeEnum[keyof typeof PinMediaSourcePinURLSourceTypeEnum];

/**
 * Video ID-based media source
 * @export
 * @interface PinMediaSourceVideoID
 */
export interface PinMediaSourceVideoID {
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceVideoID
     */
    'source_type': PinMediaSourceVideoIDSourceTypeEnum;
    /**
     * Cover image url.
     * @type {string}
     * @memberof PinMediaSourceVideoID
     */
    'cover_image_url'?: string;
    /**
     * Content type for cover image Base64.
     * @type {string}
     * @memberof PinMediaSourceVideoID
     */
    'cover_image_content_type'?: PinMediaSourceVideoIDCoverImageContentTypeEnum;
    /**
     * Cover image Base64.
     * @type {string}
     * @memberof PinMediaSourceVideoID
     */
    'cover_image_data'?: string;
    /**
     * 
     * @type {string}
     * @memberof PinMediaSourceVideoID
     */
    'media_id': string;
    /**
     * Set the parameter to false to create the new simplified Pin instead of the standard pin. Currently the field is only available to a list of beta users.
     * @type {boolean}
     * @memberof PinMediaSourceVideoID
     */
    'is_standard'?: boolean;
}

export const PinMediaSourceVideoIDSourceTypeEnum = {
    VideoId: 'video_id'
} as const;

export type PinMediaSourceVideoIDSourceTypeEnum = typeof PinMediaSourceVideoIDSourceTypeEnum[keyof typeof PinMediaSourceVideoIDSourceTypeEnum];
export const PinMediaSourceVideoIDCoverImageContentTypeEnum = {
    Jpeg: 'image/jpeg',
    Png: 'image/png'
} as const;

export type PinMediaSourceVideoIDCoverImageContentTypeEnum = typeof PinMediaSourceVideoIDCoverImageContentTypeEnum[keyof typeof PinMediaSourceVideoIDCoverImageContentTypeEnum];

/**
 * Pin with image.
 * @export
 * @interface PinMediaWithImage
 */
export interface PinMediaWithImage extends PinMedia {
    /**
     * 
     * @type {PinMediaWithImageAllOfImages}
     * @memberof PinMediaWithImage
     */
    'images'?: PinMediaWithImageAllOfImages;
}
/**
 * 
 * @export
 * @interface PinMediaWithImageAllOfImages
 */
export interface PinMediaWithImageAllOfImages {
    /**
     * 
     * @type {object}
     * @memberof PinMediaWithImageAllOfImages
     */
    '150x150'?: object;
    /**
     * 
     * @type {object}
     * @memberof PinMediaWithImageAllOfImages
     */
    '400x300'?: object;
    /**
     * 
     * @type {object}
     * @memberof PinMediaWithImageAllOfImages
     */
    '600x'?: object;
    /**
     * 
     * @type {object}
     * @memberof PinMediaWithImageAllOfImages
     */
    '1200x'?: object;
}
/**
 * Pin with a mix of images and videos.
 * @export
 * @interface PinMediaWithImageAndVideo
 */
export interface PinMediaWithImageAndVideo extends PinMedia {
    /**
     * 
     * @type {Array<PinMediaMetadata>}
     * @memberof PinMediaWithImageAndVideo
     */
    'items'?: Array<PinMediaMetadata>;
}
/**
 * Pin with multiple images.
 * @export
 * @interface PinMediaWithImages
 */
export interface PinMediaWithImages extends PinMedia {
    /**
     * 
     * @type {Array<ImageMetadata>}
     * @memberof PinMediaWithImages
     */
    'items'?: Array<ImageMetadata>;
}
/**
 * Pin with video.
 * @export
 * @interface PinMediaWithVideo
 */
export interface PinMediaWithVideo extends PinMedia {
    /**
     * 
     * @type {PinMediaWithImageAllOfImages}
     * @memberof PinMediaWithVideo
     */
    'images'?: PinMediaWithImageAllOfImages;
    /**
     * 
     * @type {string}
     * @memberof PinMediaWithVideo
     */
    'cover_image_url'?: string;
    /**
     * Video url (720p). </p><strong>Note:</strong> This field is limited and not available to all apps.
     * @type {string}
     * @memberof PinMediaWithVideo
     */
    'video_url'?: string | null;
    /**
     * Duration (in milliseconds)
     * @type {number}
     * @memberof PinMediaWithVideo
     */
    'duration'?: number;
    /**
     * Height (in pixels)
     * @type {number}
     * @memberof PinMediaWithVideo
     */
    'height'?: number;
    /**
     * Width (in pixels)
     * @type {number}
     * @memberof PinMediaWithVideo
     */
    'width'?: number;
}
/**
 * Pin with multiple videos.
 * @export
 * @interface PinMediaWithVideos
 */
export interface PinMediaWithVideos extends PinMedia {
    /**
     * 
     * @type {Array<VideoMetadata>}
     * @memberof PinMediaWithVideos
     */
    'items'?: Array<VideoMetadata>;
}
/**
 * Summary status for pin promotions
 * @export
 * @enum {string}
 */

export const PinPromotionSummaryStatus = {
    Approved: 'APPROVED',
    Paused: 'PAUSED',
    Pending: 'PENDING',
    Rejected: 'REJECTED',
    AdvertiserDisabled: 'ADVERTISER_DISABLED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;

export type PinPromotionSummaryStatus = typeof PinPromotionSummaryStatus[keyof typeof PinPromotionSummaryStatus];


/**
 * Pin fields for updates
 * @export
 * @interface PinUpdate
 */
export interface PinUpdate {
    /**
     * Pin\'s alternative text.
     * @type {string}
     * @memberof PinUpdate
     */
    'alt_text'?: string | null;
    /**
     * The id of the board to move the Pin onto.
     * @type {string}
     * @memberof PinUpdate
     */
    'board_id'?: string | null;
    /**
     * <a href=\"https://help.pinterest.com/en/article/create-a-board-section\">Board section</a> ID.
     * @type {string}
     * @memberof PinUpdate
     */
    'board_section_id'?: string | null;
    /**
     * Pin description - 800 characters maximum.
     * @type {string}
     * @memberof PinUpdate
     */
    'description'?: string | null;
    /**
     * URL viewer is taken to when they click pin.
     * @type {string}
     * @memberof PinUpdate
     */
    'link'?: string | null;
    /**
     * The native pin title that creators explicitly prefer to display.
     * @type {string}
     * @memberof PinUpdate
     */
    'title'?: string | null;
    /**
     * Carousel Pin slots data.
     * @type {Array<PinUpdateCarouselSlotsInner>}
     * @memberof PinUpdate
     */
    'carousel_slots'?: Array<PinUpdateCarouselSlotsInner>;
    /**
     * Private note for this Pin. <a href=\"https://help.pinterest.com/en/article/add-notes-to-your-pins\">Learn more</a>.
     * @type {string}
     * @memberof PinUpdate
     */
    'note'?: string | null;
}
/**
 * 
 * @export
 * @interface PinUpdateCarouselSlotsInner
 */
export interface PinUpdateCarouselSlotsInner {
    /**
     * Carousel Pin slot title.
     * @type {string}
     * @memberof PinUpdateCarouselSlotsInner
     */
    'title'?: string;
    /**
     * Carousel Pin slot description.
     * @type {string}
     * @memberof PinUpdateCarouselSlotsInner
     */
    'description'?: string;
    /**
     * Carousel Pin slot link.
     * @type {string}
     * @memberof PinUpdateCarouselSlotsInner
     */
    'link'?: string;
}
/**
 * @type PinsAnalyticsMetricTypesParameterInner
 * @export
 */
export type PinsAnalyticsMetricTypesParameterInner = string;

/**
 * 
 * @export
 * @interface PinsList200Response
 */
export interface PinsList200Response {
    /**
     * 
     * @type {Array<Pin>}
     * @memberof PinsList200Response
     */
    'items': Array<Pin>;
    /**
     * 
     * @type {string}
     * @memberof PinsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface PinsSaveRequest
 */
export interface PinsSaveRequest {
    /**
     * Unique identifier of the board to which the pin will be saved.
     * @type {string}
     * @memberof PinsSaveRequest
     */
    'board_id'?: string | null;
    /**
     * Unique identifier of the board section to which the pin will be saved.
     * @type {string}
     * @memberof PinsSaveRequest
     */
    'board_section_id'?: string | null;
}
/**
 * Optional for VISITOR `audience_type`. With the Pinterest tag, you can use event data to capture event details from your website. This object lists all the available predefined event data fields in the Pinterest tag. You can include these event data fields as part of a VISITOR audience s `rule`; however, you **must** specify an `event` for the `event_data` fields to be evaluated. Besides whats listed, you can also create your own set of `event_data` fields and define their usages or purposes according to your website needs. However, the benefit of using the predefined event data fields is that we can provide various metrics based on those fields\' data.<br>Examples per `event` type:<br>`pagevisit`<br>\"event_data\": { \"page_name\": \"My online store 123 | view items | shoe\" }<br>`signup`<br>\"event_data\": { \"lead_type\": \"New release promotion\" }<br>`checkout`<br>\"event_data\": { \"value\": 116, \"order_quantity\": 2, \"currency\": \"USD\", \"line_items\": [ { \"product_name\": \"Pillows (Set of 2)\", \"product_id\": \"11\", \"product_price\": 48, \"product_quantity\": 1 }, { \"product_name\": \"Pillows, Large (Set of 2)\", \"product_id\": \"15\", \"product_price\": 68, \"product_quantity\": 1 } ] }<br>`addtocart`<br>\"event_data\": { \"value\": 499, \"order_quantity\": 1, \"currency\": \"USD\", \"line_items\": [ { \"product_name\": \"Red leather boots\", \"product_id\": \"3486\", \"product_category\": \"shoe\", \"product_variant_id\": \"JB11103000\", \"product_price\": 499, \"product_quantity\": \"1\" , \"product_brand\": \"My brand\" }]}<br>`watchvideo`<br>\"event_data\": { \"video_title\": \"My Product Video 01\" }<br>`lead`<br>\"event_data\": { \"lead_type\": \"Newsletter\" }
 * @export
 * @interface PinterestTagEventData
 */
export interface PinterestTagEventData {
    /**
     * 
     * @type {Currency}
     * @memberof PinterestTagEventData
     */
    'currency'?: Currency;
    /**
     * Promotion code. For example, \"Newsletter\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'lead_type'?: string;
    /**
     * 
     * @type {LineItem}
     * @memberof PinterestTagEventData
     */
    'line_items'?: LineItem;
    /**
     * Order ID. For example, \"X-151481\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'order_id'?: string;
    /**
     * Order quantity. For example, 1.
     * @type {number}
     * @memberof PinterestTagEventData
     */
    'order_quantity'?: number;
    /**
     * Page name. For example, \"Our Favorite Pins on Pinterest\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'page_name'?: string;
    /**
     * Promotion code. For example, \"WINTER10\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'promo_code'?: string;
    /**
     * Property. For example, \"Athleta\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'property'?: string;
    /**
     * Search query string. For example, \"boots\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'search_query'?: string;
    /**
     * Product value. For example, \"199.98\"
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'value'?: string;
    /**
     * Video title. For example, \"How to style your Parker Boots\".
     * @type {string}
     * @memberof PinterestTagEventData
     */
    'video_title'?: string;
}


/**
 * Campaign placement group type
 * @export
 * @enum {string}
 */

export const PlacementGroupType = {
    All: 'ALL',
    Search: 'SEARCH',
    Browse: 'BROWSE',
    Other: 'OTHER'
} as const;

export type PlacementGroupType = typeof PlacementGroupType[keyof typeof PlacementGroupType];


/**
 * This represents a mapping from placement to a bid price adjustment.  Multiplier values must be between 0 and 10. A value of 10 represents a 900% increase in bid price (from $1 to $10 for example). A value of 0 will stop distribution for this item on the specified placement in `MAX_BID` ad groups in `CATALOG_SALES` campaigns. All placement multipliers must be set at the same time. If a multiplier is not provided it is assumed to be 1 (no bid adjustment).
 * @export
 * @interface PlacementMultipliers
 */
export interface PlacementMultipliers {
    [key: string]: number | any;

    /**
     * 
     * @type {string}
     * @memberof PlacementMultipliers
     */
    'PLACEMENT'?: PlacementMultipliersPLACEMENTEnum;
}

export const PlacementMultipliersPLACEMENTEnum = {
    Search: 'SEARCH',
    Browse: 'BROWSE'
} as const;

export type PlacementMultipliersPLACEMENTEnum = typeof PlacementMultipliersPLACEMENTEnum[keyof typeof PlacementMultipliersPLACEMENTEnum];

/**
 * 
 * @export
 * @interface PriceFilter
 */
export interface PriceFilter {
    /**
     * 
     * @type {CatalogsProductGroupPricingCurrencyCriteria}
     * @memberof PriceFilter
     */
    'PRICE': CatalogsProductGroupPricingCurrencyCriteria;
}
/**
 * Default availability for products in a feed.
 * @export
 * @enum {string}
 */

export const ProductAvailabilityType = {
    InStock: 'IN_STOCK',
    OutOfStock: 'OUT_OF_STOCK',
    Preorder: 'PREORDER'
} as const;

export type ProductAvailabilityType = typeof ProductAvailabilityType[keyof typeof ProductAvailabilityType];


/**
 * 
 * @export
 * @interface ProductGroupAnalyticsResponseInner
 */
export interface ProductGroupAnalyticsResponseInner {
    [key: string]: any;

    /**
     * The ID of the product group that this metrics belongs to.
     * @type {string}
     * @memberof ProductGroupAnalyticsResponseInner
     */
    'PRODUCT_GROUP_ID': string;
    /**
     * Current metrics date. Only returned when granularity is a time-based value (`DAY`, `HOUR`, `WEEK`, `MONTH`)
     * @type {string}
     * @memberof ProductGroupAnalyticsResponseInner
     */
    'DATE'?: string;
}
/**
 * 
 * @export
 * @interface ProductGroupPromotion
 */
export interface ProductGroupPromotion {
    /**
     * ID of the product group promotion.
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'id'?: string;
    /**
     * ID of the ad group the product group belongs to.
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'ad_group_id'?: string;
    /**
     * The bid in micro currency.
     * @type {number}
     * @memberof ProductGroupPromotion
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * True if the group is BIDDABLE, false if it should be EXCLUDED from serving ads.
     * @type {boolean}
     * @memberof ProductGroupPromotion
     */
    'included'?: boolean | null;
    /**
     * The full product group definition path
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'definition'?: string | null;
    /**
     * The definition of the product group, relative to its parent - an attribute name/value pair
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'relative_definition'?: string | null;
    /**
     * The parent Product Group ID of this Product Group
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'parent_id'?: string | null;
    /**
     * Slideshow Collections Title
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'slideshow_collections_title'?: string | null;
    /**
     * Slideshow Collections Description
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'slideshow_collections_description'?: string | null;
    /**
     * If set to true products promoted in this product group will use the Mobile Deep Link specified in your catalog
     * @type {boolean}
     * @memberof ProductGroupPromotion
     */
    'is_mdl'?: boolean | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof ProductGroupPromotion
     */
    'status'?: EntityStatus;
    /**
     * Tracking template for proudct group promotions. 4000 limit
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'tracking_url'?: string | null;
    /**
     * ID of the catalogs product group that this product group promotion references
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'catalog_product_group_id'?: string | null;
    /**
     * Catalogs product group name
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'catalog_product_group_name'?: string | null;
    /**
     * Hero Pin ID if this PG is promoted as a Collection
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'collections_hero_pin_id'?: string | null;
    /**
     * Collections Hero Destination Url
     * @type {string}
     * @memberof ProductGroupPromotion
     */
    'collections_hero_destination_url'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof ProductGroupPromotion
     */
    'grid_click_type'?: GridClickType | null;
}


/**
 * 
 * @export
 * @interface ProductGroupPromotionCreateRequest
 */
export interface ProductGroupPromotionCreateRequest {
    /**
     * ID of the Ad Group the Product Group Promotion belongs to.
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequest
     */
    'ad_group_id': string;
    /**
     * 
     * @type {Array<ProductGroupPromotionCreateRequestElement>}
     * @memberof ProductGroupPromotionCreateRequest
     */
    'product_group_promotion': Array<ProductGroupPromotionCreateRequestElement>;
}
/**
 * 
 * @export
 * @interface ProductGroupPromotionCreateRequestElement
 */
export interface ProductGroupPromotionCreateRequestElement {
    /**
     * ID of the product group promotion.
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'id'?: string;
    /**
     * ID of the ad group the product group belongs to.
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'ad_group_id'?: string;
    /**
     * The bid in micro currency.
     * @type {number}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * True if the group is BIDDABLE, false if it should be EXCLUDED from serving ads.
     * @type {boolean}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'included'?: boolean | null;
    /**
     * The full product group definition path
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'definition'?: string | null;
    /**
     * The definition of the product group, relative to its parent - an attribute name/value pair
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'relative_definition'?: string | null;
    /**
     * The parent Product Group ID of this Product Group
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'parent_id'?: string | null;
    /**
     * Slideshow Collections Title
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'slideshow_collections_title'?: string | null;
    /**
     * Slideshow Collections Description
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'slideshow_collections_description'?: string | null;
    /**
     * If set to true products promoted in this product group will use the Mobile Deep Link specified in your catalog
     * @type {boolean}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'is_mdl'?: boolean | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'status'?: EntityStatus;
    /**
     * Tracking template for proudct group promotions. 4000 limit
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'tracking_url'?: string | null;
    /**
     * ID of the catalogs product group that this product group promotion references
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'catalog_product_group_id'?: string | null;
    /**
     * Catalogs product group name
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'catalog_product_group_name'?: string | null;
    /**
     * Hero Pin ID if this PG is promoted as a Collection
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'collections_hero_pin_id'?: string | null;
    /**
     * Collections Hero Destination Url
     * @type {string}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'collections_hero_destination_url'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'grid_click_type'?: GridClickType | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof ProductGroupPromotionCreateRequestElement
     */
    'creative_type'?: CreativeType;
}


/**
 * 
 * @export
 * @interface ProductGroupPromotionResponse
 */
export interface ProductGroupPromotionResponse {
    /**
     * 
     * @type {Array<ProductGroupPromotionResponseItem>}
     * @memberof ProductGroupPromotionResponse
     */
    'items'?: Array<ProductGroupPromotionResponseItem>;
}
/**
 * 
 * @export
 * @interface ProductGroupPromotionResponseElement
 */
export interface ProductGroupPromotionResponseElement {
    /**
     * ID of the product group promotion.
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'id'?: string;
    /**
     * ID of the ad group the product group belongs to.
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'ad_group_id'?: string;
    /**
     * The bid in micro currency.
     * @type {number}
     * @memberof ProductGroupPromotionResponseElement
     */
    'bid_in_micro_currency'?: number | null;
    /**
     * True if the group is BIDDABLE, false if it should be EXCLUDED from serving ads.
     * @type {boolean}
     * @memberof ProductGroupPromotionResponseElement
     */
    'included'?: boolean | null;
    /**
     * The full product group definition path
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'definition'?: string | null;
    /**
     * The definition of the product group, relative to its parent - an attribute name/value pair
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'relative_definition'?: string | null;
    /**
     * The parent Product Group ID of this Product Group
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'parent_id'?: string | null;
    /**
     * Slideshow Collections Title
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'slideshow_collections_title'?: string | null;
    /**
     * Slideshow Collections Description
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'slideshow_collections_description'?: string | null;
    /**
     * If set to true products promoted in this product group will use the Mobile Deep Link specified in your catalog
     * @type {boolean}
     * @memberof ProductGroupPromotionResponseElement
     */
    'is_mdl'?: boolean | null;
    /**
     * 
     * @type {EntityStatus}
     * @memberof ProductGroupPromotionResponseElement
     */
    'status'?: EntityStatus;
    /**
     * Tracking template for proudct group promotions. 4000 limit
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'tracking_url'?: string | null;
    /**
     * ID of the catalogs product group that this product group promotion references
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'catalog_product_group_id'?: string | null;
    /**
     * Catalogs product group name
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'catalog_product_group_name'?: string | null;
    /**
     * Hero Pin ID if this PG is promoted as a Collection
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'collections_hero_pin_id'?: string | null;
    /**
     * Collections Hero Destination Url
     * @type {string}
     * @memberof ProductGroupPromotionResponseElement
     */
    'collections_hero_destination_url'?: string | null;
    /**
     * 
     * @type {GridClickType}
     * @memberof ProductGroupPromotionResponseElement
     */
    'grid_click_type'?: GridClickType | null;
    /**
     * 
     * @type {CreativeType}
     * @memberof ProductGroupPromotionResponseElement
     */
    'creative_type'?: CreativeType;
}


/**
 * 
 * @export
 * @interface ProductGroupPromotionResponseItem
 */
export interface ProductGroupPromotionResponseItem {
    /**
     * 
     * @type {ProductGroupPromotionResponseElement}
     * @memberof ProductGroupPromotionResponseItem
     */
    'data'?: ProductGroupPromotionResponseElement;
    /**
     * 
     * @type {Array<Exception>}
     * @memberof ProductGroupPromotionResponseItem
     */
    'exceptions'?: Array<Exception> | null;
}
/**
 * 
 * @export
 * @interface ProductGroupPromotionUpdateRequest
 */
export interface ProductGroupPromotionUpdateRequest {
    /**
     * ID of the ad group the product group belongs to.
     * @type {string}
     * @memberof ProductGroupPromotionUpdateRequest
     */
    'ad_group_id': string;
    /**
     * 
     * @type {Array<ProductGroupPromotion>}
     * @memberof ProductGroupPromotionUpdateRequest
     */
    'product_group_promotion': Array<ProductGroupPromotion>;
}
/**
 * 
 * @export
 * @interface ProductGroupPromotionsList200Response
 */
export interface ProductGroupPromotionsList200Response {
    /**
     * 
     * @type {Array<ProductGroupPromotionResponseItem>}
     * @memberof ProductGroupPromotionsList200Response
     */
    'items': Array<ProductGroupPromotionResponseItem>;
    /**
     * 
     * @type {string}
     * @memberof ProductGroupPromotionsList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface ProductGroupReferenceFilter
 */
export interface ProductGroupReferenceFilter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringCriteria}
     * @memberof ProductGroupReferenceFilter
     */
    'PRODUCT_GROUP': CatalogsProductGroupMultipleStringCriteria;
}
/**
 * Summary status for product group
 * @export
 * @enum {string}
 */

export const ProductGroupSummaryStatus = {
    Running: 'RUNNING',
    Paused: 'PAUSED',
    Excluded: 'EXCLUDED',
    Archived: 'ARCHIVED'
} as const;

export type ProductGroupSummaryStatus = typeof ProductGroupSummaryStatus[keyof typeof ProductGroupSummaryStatus];


/**
 * 
 * @export
 * @interface ProductType0Filter
 */
export interface ProductType0Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof ProductType0Filter
     */
    'PRODUCT_TYPE_0': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface ProductType1Filter
 */
export interface ProductType1Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof ProductType1Filter
     */
    'PRODUCT_TYPE_1': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface ProductType2Filter
 */
export interface ProductType2Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof ProductType2Filter
     */
    'PRODUCT_TYPE_2': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface ProductType3Filter
 */
export interface ProductType3Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof ProductType3Filter
     */
    'PRODUCT_TYPE_3': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * 
 * @export
 * @interface ProductType4Filter
 */
export interface ProductType4Filter {
    /**
     * 
     * @type {CatalogsProductGroupMultipleStringListCriteria}
     * @memberof ProductType4Filter
     */
    'PRODUCT_TYPE_4': CatalogsProductGroupMultipleStringListCriteria;
}
/**
 * This field includes all quiz data including questions, options, and results.
 * @export
 * @interface QuizPinData
 */
export interface QuizPinData {
    /**
     * 
     * @type {Array<QuizPinQuestion>}
     * @memberof QuizPinData
     */
    'questions'?: Array<QuizPinQuestion>;
    /**
     * 
     * @type {Array<QuizPinResult>}
     * @memberof QuizPinData
     */
    'results'?: Array<QuizPinResult>;
    /**
     * Quiz ad tie breaker type, default is RANDOM
     * @type {string}
     * @memberof QuizPinData
     */
    'tie_breaker_type'?: QuizPinDataTieBreakerTypeEnum;
    /**
     * 
     * @type {QuizPinResult}
     * @memberof QuizPinData
     */
    'tie_breaker_custom_result'?: QuizPinResult | null;
}

export const QuizPinDataTieBreakerTypeEnum = {
    Random: 'RANDOM',
    Custom: 'CUSTOM'
} as const;

export type QuizPinDataTieBreakerTypeEnum = typeof QuizPinDataTieBreakerTypeEnum[keyof typeof QuizPinDataTieBreakerTypeEnum];

/**
 *  This field contains multiple options to a quiz question.
 * @export
 * @interface QuizPinOption
 */
export interface QuizPinOption {
    /**
     * 
     * @type {number}
     * @memberof QuizPinOption
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuizPinOption
     */
    'text'?: string;
}
/**
 * A specific quiz inquiry.
 * @export
 * @interface QuizPinQuestion
 */
export interface QuizPinQuestion {
    /**
     * 
     * @type {number}
     * @memberof QuizPinQuestion
     */
    'question_id'?: number;
    /**
     * 
     * @type {string}
     * @memberof QuizPinQuestion
     */
    'question_text'?: string;
    /**
     * 
     * @type {Array<QuizPinOption>}
     * @memberof QuizPinQuestion
     */
    'options'?: Array<QuizPinOption>;
}
/**
 * The result, and link out, based on the users choice.
 * @export
 * @interface QuizPinResult
 */
export interface QuizPinResult {
    /**
     * 
     * @type {string}
     * @memberof QuizPinResult
     */
    'organic_pin_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuizPinResult
     */
    'android_deep_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuizPinResult
     */
    'ios_deep_link'?: string;
    /**
     * 
     * @type {string}
     * @memberof QuizPinResult
     */
    'destination_url'?: string;
    /**
     * 
     * @type {number}
     * @memberof QuizPinResult
     */
    'result_id'?: number;
}
/**
 * 
 * @export
 * @interface RelatedTerms
 */
export interface RelatedTerms {
    /**
     * First input term. For example, if you pass \"?terms=clothes,workout\", then id will be \"clothes\"
     * @type {string}
     * @memberof RelatedTerms
     */
    'id'?: string;
    /**
     * Total number of related terms returned
     * @type {number}
     * @memberof RelatedTerms
     */
    'related_term_count'?: number;
    /**
     * The id of the advertiser.
     * @type {Array<RelatedTermsRelatedTermsListInner>}
     * @memberof RelatedTerms
     */
    'related_terms_list'?: Array<RelatedTermsRelatedTermsListInner>;
}
/**
 * 
 * @export
 * @interface RelatedTermsRelatedTermsListInner
 */
export interface RelatedTermsRelatedTermsListInner {
    /**
     * 
     * @type {string}
     * @memberof RelatedTermsRelatedTermsListInner
     */
    'term'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RelatedTermsRelatedTermsListInner
     */
    'related_terms'?: Array<string>;
}
/**
 * Reporting columns
 * @export
 * @enum {string}
 */

export const ReportingColumnAsync = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    OutboundCtr: 'OUTBOUND_CTR',
    CostPerOutboundClick: 'COST_PER_OUTBOUND_CLICK',
    CampaignName: 'CAMPAIGN_NAME',
    CampaignStatus: 'CAMPAIGN_STATUS',
    PinPromotionStatus: 'PIN_PROMOTION_STATUS',
    AdStatus: 'AD_STATUS',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignManagedStatus: 'CAMPAIGN_MANAGED_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupName: 'AD_GROUP_NAME',
    AdGroupStatus: 'AD_GROUP_STATUS',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    ProductGroupId: 'PRODUCT_GROUP_ID',
    ProductGroupStatus: 'PRODUCT_GROUP_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementPageVisit: 'TOTAL_ENGAGEMENT_PAGE_VISIT',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementCustom: 'TOTAL_ENGAGEMENT_CUSTOM',
    TotalEngagementAddToCart: 'TOTAL_ENGAGEMENT_ADD_TO_CART',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalEngagementSearch: 'TOTAL_ENGAGEMENT_SEARCH',
    TotalEngagementWatchVideo: 'TOTAL_ENGAGEMENT_WATCH_VIDEO',
    TotalEngagementViewCategory: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY',
    TotalEngagementAppInstall: 'TOTAL_ENGAGEMENT_APP_INSTALL',
    TotalEngagementUnknown: 'TOTAL_ENGAGEMENT_UNKNOWN',
    TotalClickPageVisit: 'TOTAL_CLICK_PAGE_VISIT',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickCustom: 'TOTAL_CLICK_CUSTOM',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalClickSearch: 'TOTAL_CLICK_SEARCH',
    TotalClickWatchVideo: 'TOTAL_CLICK_WATCH_VIDEO',
    TotalClickViewCategory: 'TOTAL_CLICK_VIEW_CATEGORY',
    TotalClickAppInstall: 'TOTAL_CLICK_APP_INSTALL',
    TotalClickUnknown: 'TOTAL_CLICK_UNKNOWN',
    TotalViewPageVisit: 'TOTAL_VIEW_PAGE_VISIT',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewCustom: 'TOTAL_VIEW_CUSTOM',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalViewSearch: 'TOTAL_VIEW_SEARCH',
    TotalViewWatchVideo: 'TOTAL_VIEW_WATCH_VIDEO',
    TotalViewViewCategory: 'TOTAL_VIEW_VIEW_CATEGORY',
    TotalViewAppInstall: 'TOTAL_VIEW_APP_INSTALL',
    TotalViewUnknown: 'TOTAL_VIEW_UNKNOWN',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementPageVisitValueInMicroDollar: 'TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCustomValueInMicroDollar: 'TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementAddToCartValueInMicroDollar: 'TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementLeadValueInMicroDollar: 'TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementSearchValueInMicroDollar: 'TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementWatchVideoValueInMicroDollar: 'TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementViewCategoryValueInMicroDollar: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementAppInstallValueInMicroDollar: 'TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementUnknownValueInMicroDollar: 'TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalClickPageVisitValueInMicroDollar: 'TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickCustomValueInMicroDollar: 'TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalClickAddToCartValueInMicroDollar: 'TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalClickLeadValueInMicroDollar: 'TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalClickSearchValueInMicroDollar: 'TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalClickWatchVideoValueInMicroDollar: 'TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalClickViewCategoryValueInMicroDollar: 'TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalClickAppInstallValueInMicroDollar: 'TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalClickUnknownValueInMicroDollar: 'TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalViewPageVisitValueInMicroDollar: 'TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewCustomValueInMicroDollar: 'TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalViewAddToCartValueInMicroDollar: 'TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalViewLeadValueInMicroDollar: 'TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalViewSearchValueInMicroDollar: 'TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalViewWatchVideoValueInMicroDollar: 'TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalViewViewCategoryValueInMicroDollar: 'TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalViewAppInstallValueInMicroDollar: 'TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalViewUnknownValueInMicroDollar: 'TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalConversionsValueInMicroDollar: 'TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementPageVisitQuantity: 'TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY',
    TotalEngagementSignupQuantity: 'TOTAL_ENGAGEMENT_SIGNUP_QUANTITY',
    TotalEngagementCheckoutQuantity: 'TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY',
    TotalEngagementCustomQuantity: 'TOTAL_ENGAGEMENT_CUSTOM_QUANTITY',
    TotalEngagementAddToCartQuantity: 'TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY',
    TotalEngagementLeadQuantity: 'TOTAL_ENGAGEMENT_LEAD_QUANTITY',
    TotalEngagementSearchQuantity: 'TOTAL_ENGAGEMENT_SEARCH_QUANTITY',
    TotalEngagementWatchVideoQuantity: 'TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY',
    TotalEngagementViewCategoryQuantity: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY',
    TotalEngagementUnknownQuantity: 'TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY',
    TotalClickPageVisitQuantity: 'TOTAL_CLICK_PAGE_VISIT_QUANTITY',
    TotalClickSignupQuantity: 'TOTAL_CLICK_SIGNUP_QUANTITY',
    TotalClickCheckoutQuantity: 'TOTAL_CLICK_CHECKOUT_QUANTITY',
    TotalClickCustomQuantity: 'TOTAL_CLICK_CUSTOM_QUANTITY',
    TotalClickAddToCartQuantity: 'TOTAL_CLICK_ADD_TO_CART_QUANTITY',
    TotalClickLeadQuantity: 'TOTAL_CLICK_LEAD_QUANTITY',
    TotalClickSearchQuantity: 'TOTAL_CLICK_SEARCH_QUANTITY',
    TotalClickWatchVideoQuantity: 'TOTAL_CLICK_WATCH_VIDEO_QUANTITY',
    TotalClickViewCategoryQuantity: 'TOTAL_CLICK_VIEW_CATEGORY_QUANTITY',
    TotalClickUnknownQuantity: 'TOTAL_CLICK_UNKNOWN_QUANTITY',
    TotalViewPageVisitQuantity: 'TOTAL_VIEW_PAGE_VISIT_QUANTITY',
    TotalViewSignupQuantity: 'TOTAL_VIEW_SIGNUP_QUANTITY',
    TotalViewCheckoutQuantity: 'TOTAL_VIEW_CHECKOUT_QUANTITY',
    TotalViewCustomQuantity: 'TOTAL_VIEW_CUSTOM_QUANTITY',
    TotalViewAddToCartQuantity: 'TOTAL_VIEW_ADD_TO_CART_QUANTITY',
    TotalViewLeadQuantity: 'TOTAL_VIEW_LEAD_QUANTITY',
    TotalViewSearchQuantity: 'TOTAL_VIEW_SEARCH_QUANTITY',
    TotalViewWatchVideoQuantity: 'TOTAL_VIEW_WATCH_VIDEO_QUANTITY',
    TotalViewViewCategoryQuantity: 'TOTAL_VIEW_VIEW_CATEGORY_QUANTITY',
    TotalViewUnknownQuantity: 'TOTAL_VIEW_UNKNOWN_QUANTITY',
    TotalConversionsQuantity: 'TOTAL_CONVERSIONS_QUANTITY',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    OnsiteCheckouts1: 'ONSITE_CHECKOUTS_1',
    PinPromotionName: 'PIN_PROMOTION_NAME',
    AdName: 'AD_NAME',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisitDesktopActionToDesktopConversion: 'TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalPageVisitDesktopActionToMobileConversion: 'TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalPageVisitDesktopActionToTabletConversion: 'TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisitMobileActionToDesktopConversion: 'TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalPageVisitMobileActionToMobileConversion: 'TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalPageVisitMobileActionToTabletConversion: 'TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisitTabletActionToDesktopConversion: 'TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalPageVisitTabletActionToMobileConversion: 'TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalPageVisitTabletActionToTabletConversion: 'TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalSignupDesktopActionToDesktopConversion: 'TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalSignupDesktopActionToMobileConversion: 'TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalSignupDesktopActionToTabletConversion: 'TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalSignupMobileActionToDesktopConversion: 'TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalSignupMobileActionToMobileConversion: 'TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalSignupMobileActionToTabletConversion: 'TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalSignupTabletActionToDesktopConversion: 'TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalSignupTabletActionToMobileConversion: 'TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalSignupTabletActionToTabletConversion: 'TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalCheckoutDesktopActionToDesktopConversion: 'TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalCheckoutDesktopActionToMobileConversion: 'TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalCheckoutDesktopActionToTabletConversion: 'TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalCheckoutMobileActionToDesktopConversion: 'TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalCheckoutMobileActionToMobileConversion: 'TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalCheckoutMobileActionToTabletConversion: 'TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalCheckoutTabletActionToDesktopConversion: 'TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalCheckoutTabletActionToMobileConversion: 'TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalCheckoutTabletActionToTabletConversion: 'TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalCustomDesktopActionToDesktopConversion: 'TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalCustomDesktopActionToMobileConversion: 'TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalCustomDesktopActionToTabletConversion: 'TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalCustomMobileActionToDesktopConversion: 'TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalCustomMobileActionToMobileConversion: 'TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalCustomMobileActionToTabletConversion: 'TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalCustomTabletActionToDesktopConversion: 'TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalCustomTabletActionToMobileConversion: 'TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalCustomTabletActionToTabletConversion: 'TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalAddToCartDesktopActionToDesktopConversion: 'TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalAddToCartDesktopActionToMobileConversion: 'TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalAddToCartDesktopActionToTabletConversion: 'TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalAddToCartMobileActionToDesktopConversion: 'TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalAddToCartMobileActionToMobileConversion: 'TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalAddToCartMobileActionToTabletConversion: 'TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalAddToCartTabletActionToDesktopConversion: 'TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalAddToCartTabletActionToMobileConversion: 'TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalAddToCartTabletActionToTabletConversion: 'TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalLeadDesktopActionToDesktopConversion: 'TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalLeadDesktopActionToMobileConversion: 'TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalLeadDesktopActionToTabletConversion: 'TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalLeadMobileActionToDesktopConversion: 'TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalLeadMobileActionToMobileConversion: 'TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalLeadMobileActionToTabletConversion: 'TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalLeadTabletActionToDesktopConversion: 'TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalLeadTabletActionToMobileConversion: 'TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalLeadTabletActionToTabletConversion: 'TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalSearchDesktopActionToDesktopConversion: 'TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalSearchDesktopActionToMobileConversion: 'TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalSearchDesktopActionToTabletConversion: 'TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalSearchMobileActionToDesktopConversion: 'TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalSearchMobileActionToMobileConversion: 'TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalSearchMobileActionToTabletConversion: 'TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalSearchTabletActionToDesktopConversion: 'TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalSearchTabletActionToMobileConversion: 'TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalSearchTabletActionToTabletConversion: 'TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalWatchVideoDesktopActionToDesktopConversion: 'TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalWatchVideoDesktopActionToMobileConversion: 'TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalWatchVideoDesktopActionToTabletConversion: 'TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalWatchVideoMobileActionToDesktopConversion: 'TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalWatchVideoMobileActionToMobileConversion: 'TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalWatchVideoMobileActionToTabletConversion: 'TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalWatchVideoTabletActionToDesktopConversion: 'TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalWatchVideoTabletActionToMobileConversion: 'TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalWatchVideoTabletActionToTabletConversion: 'TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalViewCategoryDesktopActionToDesktopConversion: 'TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalViewCategoryDesktopActionToMobileConversion: 'TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalViewCategoryDesktopActionToTabletConversion: 'TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalViewCategoryMobileActionToDesktopConversion: 'TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalViewCategoryMobileActionToMobileConversion: 'TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalViewCategoryMobileActionToTabletConversion: 'TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalViewCategoryTabletActionToDesktopConversion: 'TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalViewCategoryTabletActionToMobileConversion: 'TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalViewCategoryTabletActionToTabletConversion: 'TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalAppInstallDesktopActionToDesktopConversion: 'TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalAppInstallDesktopActionToMobileConversion: 'TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalAppInstallDesktopActionToTabletConversion: 'TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalAppInstallMobileActionToDesktopConversion: 'TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalAppInstallMobileActionToMobileConversion: 'TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalAppInstallMobileActionToTabletConversion: 'TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalAppInstallTabletActionToDesktopConversion: 'TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalAppInstallTabletActionToMobileConversion: 'TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalAppInstallTabletActionToTabletConversion: 'TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalUnknownDesktopActionToDesktopConversion: 'TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalUnknownDesktopActionToMobileConversion: 'TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalUnknownDesktopActionToTabletConversion: 'TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalUnknownMobileActionToDesktopConversion: 'TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalUnknownMobileActionToMobileConversion: 'TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalUnknownMobileActionToTabletConversion: 'TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalUnknownTabletActionToDesktopConversion: 'TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalUnknownTabletActionToMobileConversion: 'TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalUnknownTabletActionToTabletConversion: 'TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalAddToCart: 'TOTAL_ADD_TO_CART',
    TotalLead: 'TOTAL_LEAD',
    TotalSearch: 'TOTAL_SEARCH',
    TotalWatchVideo: 'TOTAL_WATCH_VIDEO',
    TotalViewCategory: 'TOTAL_VIEW_CATEGORY',
    TotalAppInstall: 'TOTAL_APP_INSTALL',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalAddToCartValueInMicroDollar: 'TOTAL_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalLeadValueInMicroDollar: 'TOTAL_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalSearchValueInMicroDollar: 'TOTAL_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWatchVideoValueInMicroDollar: 'TOTAL_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalViewCategoryValueInMicroDollar: 'TOTAL_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalAppInstallValueInMicroDollar: 'TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutQuantity: 'TOTAL_CHECKOUT_QUANTITY',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    AppInstallCostPerAction: 'APP_INSTALL_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    Video3SecViews1: 'VIDEO_3SEC_VIEWS_1',
    VideoP100Complete1: 'VIDEO_P100_COMPLETE_1',
    VideoP0Combined1: 'VIDEO_P0_COMBINED_1',
    VideoP25Combined1: 'VIDEO_P25_COMBINED_1',
    VideoP50Combined1: 'VIDEO_P50_COMBINED_1',
    VideoP75Combined1: 'VIDEO_P75_COMBINED_1',
    VideoP95Combined1: 'VIDEO_P95_COMBINED_1',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    CpvInMicroDollar: 'CPV_IN_MICRO_DOLLAR',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    CpcvInMicroDollar: 'CPCV_IN_MICRO_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    CpcvP95InMicroDollar: 'CPCV_P95_IN_MICRO_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    VideoAvgWatchtimeInSecond1: 'VIDEO_AVG_WATCHTIME_IN_SECOND_1',
    VideoAvgWatchtimeInSecond2: 'VIDEO_AVG_WATCHTIME_IN_SECOND_2',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalDestinationViews: 'TOTAL_DESTINATION_VIEWS',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    InappCheckoutRoas: 'INAPP_CHECKOUT_ROAS',
    TotalInappCheckout: 'TOTAL_INAPP_CHECKOUT',
    TotalInappCheckoutValueInMicroDollar: 'TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickCheckout: 'TOTAL_INAPP_CLICK_CHECKOUT',
    TotalInappClickCheckoutValueInMicroDollar: 'TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementCheckout: 'TOTAL_INAPP_ENGAGEMENT_CHECKOUT',
    TotalInappEngagementCheckoutValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewCheckout: 'TOTAL_INAPP_VIEW_CHECKOUT',
    TotalInappViewCheckoutValueInMicroDollar: 'TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    OfflineCheckoutCostPerAction: 'OFFLINE_CHECKOUT_COST_PER_ACTION',
    OfflineCheckoutRoas: 'OFFLINE_CHECKOUT_ROAS',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    TotalOfflineCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickCheckout: 'TOTAL_OFFLINE_CLICK_CHECKOUT',
    TotalOfflineClickCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementCheckout: 'TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT',
    TotalOfflineEngagementCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewCheckout: 'TOTAL_OFFLINE_VIEW_CHECKOUT',
    TotalOfflineViewCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    PinterestCheckoutCostPerAction: 'PINTEREST_CHECKOUT_COST_PER_ACTION',
    PinterestCheckoutRoas: 'PINTEREST_CHECKOUT_ROAS',
    TotalPinterestCheckout: 'TOTAL_PINTEREST_CHECKOUT',
    TotalPinterestCheckoutValueInMicroDollar: 'TOTAL_PINTEREST_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    WebAddToCartCostPerAction: 'WEB_ADD_TO_CART_COST_PER_ACTION',
    WebAddToCartRoas: 'WEB_ADD_TO_CART_ROAS',
    TotalWebAddToCart: 'TOTAL_WEB_ADD_TO_CART',
    TotalWebAddToCartValueInMicroDollar: 'TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickAddToCart: 'TOTAL_WEB_CLICK_ADD_TO_CART',
    TotalWebClickAddToCartValueInMicroDollar: 'TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementAddToCart: 'TOTAL_WEB_ENGAGEMENT_ADD_TO_CART',
    TotalWebEngagementAddToCartValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewAddToCart: 'TOTAL_WEB_VIEW_ADD_TO_CART',
    TotalWebViewAddToCartValueInMicroDollar: 'TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    InappAddToCartCostPerAction: 'INAPP_ADD_TO_CART_COST_PER_ACTION',
    InappAddToCartRoas: 'INAPP_ADD_TO_CART_ROAS',
    TotalInappAddToCart: 'TOTAL_INAPP_ADD_TO_CART',
    TotalInappAddToCartValueInMicroDollar: 'TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickAddToCart: 'TOTAL_INAPP_CLICK_ADD_TO_CART',
    TotalInappClickAddToCartValueInMicroDollar: 'TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementAddToCart: 'TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART',
    TotalInappEngagementAddToCartValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewAddToCart: 'TOTAL_INAPP_VIEW_ADD_TO_CART',
    TotalInappViewAddToCartValueInMicroDollar: 'TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    WebPageVisitCostPerAction: 'WEB_PAGE_VISIT_COST_PER_ACTION',
    WebPageVisitRoas: 'WEB_PAGE_VISIT_ROAS',
    TotalWebPageVisit: 'TOTAL_WEB_PAGE_VISIT',
    TotalWebPageVisitValueInMicroDollar: 'TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickPageVisit: 'TOTAL_WEB_CLICK_PAGE_VISIT',
    TotalWebClickPageVisitValueInMicroDollar: 'TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementPageVisit: 'TOTAL_WEB_ENGAGEMENT_PAGE_VISIT',
    TotalWebEngagementPageVisitValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewPageVisit: 'TOTAL_WEB_VIEW_PAGE_VISIT',
    TotalWebViewPageVisitValueInMicroDollar: 'TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    WebSignupCostPerAction: 'WEB_SIGNUP_COST_PER_ACTION',
    WebSignupRoas: 'WEB_SIGNUP_ROAS',
    TotalWebSignup: 'TOTAL_WEB_SIGNUP',
    TotalWebSignupValueInMicroDollar: 'TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickSignup: 'TOTAL_WEB_CLICK_SIGNUP',
    TotalWebClickSignupValueInMicroDollar: 'TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementSignup: 'TOTAL_WEB_ENGAGEMENT_SIGNUP',
    TotalWebEngagementSignupValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewSignup: 'TOTAL_WEB_VIEW_SIGNUP',
    TotalWebViewSignupValueInMicroDollar: 'TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    InappSignupCostPerAction: 'INAPP_SIGNUP_COST_PER_ACTION',
    InappSignupRoas: 'INAPP_SIGNUP_ROAS',
    TotalInappSignup: 'TOTAL_INAPP_SIGNUP',
    TotalInappSignupValueInMicroDollar: 'TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickSignup: 'TOTAL_INAPP_CLICK_SIGNUP',
    TotalInappClickSignupValueInMicroDollar: 'TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementSignup: 'TOTAL_INAPP_ENGAGEMENT_SIGNUP',
    TotalInappEngagementSignupValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewSignup: 'TOTAL_INAPP_VIEW_SIGNUP',
    TotalInappViewSignupValueInMicroDollar: 'TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    OfflineSignupCostPerAction: 'OFFLINE_SIGNUP_COST_PER_ACTION',
    OfflineSignupRoas: 'OFFLINE_SIGNUP_ROAS',
    TotalOfflineSignup: 'TOTAL_OFFLINE_SIGNUP',
    TotalOfflineSignupValueInMicroDollar: 'TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickSignup: 'TOTAL_OFFLINE_CLICK_SIGNUP',
    TotalOfflineClickSignupValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementSignup: 'TOTAL_OFFLINE_ENGAGEMENT_SIGNUP',
    TotalOfflineEngagementSignupValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewSignup: 'TOTAL_OFFLINE_VIEW_SIGNUP',
    TotalOfflineViewSignupValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    WebWatchVideoCostPerAction: 'WEB_WATCH_VIDEO_COST_PER_ACTION',
    WebWatchVideoRoas: 'WEB_WATCH_VIDEO_ROAS',
    TotalWebWatchVideo: 'TOTAL_WEB_WATCH_VIDEO',
    TotalWebWatchVideoValueInMicroDollar: 'TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickWatchVideo: 'TOTAL_WEB_CLICK_WATCH_VIDEO',
    TotalWebClickWatchVideoValueInMicroDollar: 'TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementWatchVideo: 'TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO',
    TotalWebEngagementWatchVideoValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewWatchVideo: 'TOTAL_WEB_VIEW_WATCH_VIDEO',
    TotalWebViewWatchVideoValueInMicroDollar: 'TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    WebLeadCostPerAction: 'WEB_LEAD_COST_PER_ACTION',
    WebLeadRoas: 'WEB_LEAD_ROAS',
    TotalWebLead: 'TOTAL_WEB_LEAD',
    TotalWebLeadValueInMicroDollar: 'TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickLead: 'TOTAL_WEB_CLICK_LEAD',
    TotalWebClickLeadValueInMicroDollar: 'TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementLead: 'TOTAL_WEB_ENGAGEMENT_LEAD',
    TotalWebEngagementLeadValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewLead: 'TOTAL_WEB_VIEW_LEAD',
    TotalWebViewLeadValueInMicroDollar: 'TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR',
    OfflineLeadCostPerAction: 'OFFLINE_LEAD_COST_PER_ACTION',
    OfflineLeadRoas: 'OFFLINE_LEAD_ROAS',
    TotalOfflineLead: 'TOTAL_OFFLINE_LEAD',
    TotalOfflineLeadValueInMicroDollar: 'TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickLead: 'TOTAL_OFFLINE_CLICK_LEAD',
    TotalOfflineClickLeadValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementLead: 'TOTAL_OFFLINE_ENGAGEMENT_LEAD',
    TotalOfflineEngagementLeadValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewLead: 'TOTAL_OFFLINE_VIEW_LEAD',
    TotalOfflineViewLeadValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR',
    WebSearchCostPerAction: 'WEB_SEARCH_COST_PER_ACTION',
    WebSearchRoas: 'WEB_SEARCH_ROAS',
    TotalWebSearch: 'TOTAL_WEB_SEARCH',
    TotalWebSearchValueInMicroDollar: 'TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickSearch: 'TOTAL_WEB_CLICK_SEARCH',
    TotalWebClickSearchValueInMicroDollar: 'TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementSearch: 'TOTAL_WEB_ENGAGEMENT_SEARCH',
    TotalWebEngagementSearchValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewSearch: 'TOTAL_WEB_VIEW_SEARCH',
    TotalWebViewSearchValueInMicroDollar: 'TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR',
    InappSearchCostPerAction: 'INAPP_SEARCH_COST_PER_ACTION',
    InappSearchRoas: 'INAPP_SEARCH_ROAS',
    TotalInappSearch: 'TOTAL_INAPP_SEARCH',
    TotalInappSearchValueInMicroDollar: 'TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickSearch: 'TOTAL_INAPP_CLICK_SEARCH',
    TotalInappClickSearchValueInMicroDollar: 'TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementSearch: 'TOTAL_INAPP_ENGAGEMENT_SEARCH',
    TotalInappEngagementSearchValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewSearch: 'TOTAL_INAPP_VIEW_SEARCH',
    TotalInappViewSearchValueInMicroDollar: 'TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR',
    WebViewCategoryCostPerAction: 'WEB_VIEW_CATEGORY_COST_PER_ACTION',
    WebViewCategoryRoas: 'WEB_VIEW_CATEGORY_ROAS',
    TotalWebViewCategory: 'TOTAL_WEB_VIEW_CATEGORY',
    TotalWebViewCategoryValueInMicroDollar: 'TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickViewCategory: 'TOTAL_WEB_CLICK_VIEW_CATEGORY',
    TotalWebClickViewCategoryValueInMicroDollar: 'TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementViewCategory: 'TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY',
    TotalWebEngagementViewCategoryValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewViewCategory: 'TOTAL_WEB_VIEW_VIEW_CATEGORY',
    TotalWebViewViewCategoryValueInMicroDollar: 'TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    WebCustomCostPerAction: 'WEB_CUSTOM_COST_PER_ACTION',
    WebCustomRoas: 'WEB_CUSTOM_ROAS',
    TotalWebCustom: 'TOTAL_WEB_CUSTOM',
    TotalWebCustomValueInMicroDollar: 'TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCustom: 'TOTAL_WEB_CLICK_CUSTOM',
    TotalWebClickCustomValueInMicroDollar: 'TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCustom: 'TOTAL_WEB_ENGAGEMENT_CUSTOM',
    TotalWebEngagementCustomValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCustom: 'TOTAL_WEB_VIEW_CUSTOM',
    TotalWebViewCustomValueInMicroDollar: 'TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    OfflineCustomCostPerAction: 'OFFLINE_CUSTOM_COST_PER_ACTION',
    OfflineCustomRoas: 'OFFLINE_CUSTOM_ROAS',
    TotalOfflineCustom: 'TOTAL_OFFLINE_CUSTOM',
    TotalOfflineCustomValueInMicroDollar: 'TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickCustom: 'TOTAL_OFFLINE_CLICK_CUSTOM',
    TotalOfflineClickCustomValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementCustom: 'TOTAL_OFFLINE_ENGAGEMENT_CUSTOM',
    TotalOfflineEngagementCustomValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewCustom: 'TOTAL_OFFLINE_VIEW_CUSTOM',
    TotalOfflineViewCustomValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    WebUnknownCostPerAction: 'WEB_UNKNOWN_COST_PER_ACTION',
    WebUnknownRoas: 'WEB_UNKNOWN_ROAS',
    TotalWebUnknown: 'TOTAL_WEB_UNKNOWN',
    TotalWebUnknownValueInMicroDollar: 'TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickUnknown: 'TOTAL_WEB_CLICK_UNKNOWN',
    TotalWebClickUnknownValueInMicroDollar: 'TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementUnknown: 'TOTAL_WEB_ENGAGEMENT_UNKNOWN',
    TotalWebEngagementUnknownValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewUnknown: 'TOTAL_WEB_VIEW_UNKNOWN',
    TotalWebViewUnknownValueInMicroDollar: 'TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    InappUnknownCostPerAction: 'INAPP_UNKNOWN_COST_PER_ACTION',
    InappUnknownRoas: 'INAPP_UNKNOWN_ROAS',
    TotalInappUnknown: 'TOTAL_INAPP_UNKNOWN',
    TotalInappUnknownValueInMicroDollar: 'TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickUnknown: 'TOTAL_INAPP_CLICK_UNKNOWN',
    TotalInappClickUnknownValueInMicroDollar: 'TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementUnknown: 'TOTAL_INAPP_ENGAGEMENT_UNKNOWN',
    TotalInappEngagementUnknownValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewUnknown: 'TOTAL_INAPP_VIEW_UNKNOWN',
    TotalInappViewUnknownValueInMicroDollar: 'TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    OfflineUnknownCostPerAction: 'OFFLINE_UNKNOWN_COST_PER_ACTION',
    OfflineUnknownRoas: 'OFFLINE_UNKNOWN_ROAS',
    TotalOfflineUnknown: 'TOTAL_OFFLINE_UNKNOWN',
    TotalOfflineUnknownValueInMicroDollar: 'TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickUnknown: 'TOTAL_OFFLINE_CLICK_UNKNOWN',
    TotalOfflineClickUnknownValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementUnknown: 'TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN',
    TotalOfflineEngagementUnknownValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewUnknown: 'TOTAL_OFFLINE_VIEW_UNKNOWN',
    TotalOfflineViewUnknownValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    InappAppInstallCostPerAction: 'INAPP_APP_INSTALL_COST_PER_ACTION',
    InappAppInstallRoas: 'INAPP_APP_INSTALL_ROAS',
    TotalInappAppInstall: 'TOTAL_INAPP_APP_INSTALL',
    TotalInappAppInstallValueInMicroDollar: 'TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickAppInstall: 'TOTAL_INAPP_CLICK_APP_INSTALL',
    TotalInappClickAppInstallValueInMicroDollar: 'TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementAppInstall: 'TOTAL_INAPP_ENGAGEMENT_APP_INSTALL',
    TotalInappEngagementAppInstallValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewAppInstall: 'TOTAL_INAPP_VIEW_APP_INSTALL',
    TotalInappViewAppInstallValueInMicroDollar: 'TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE',
    StandardAdFeedItemId: 'STANDARD_AD_FEED_ITEM_ID'
} as const;

export type ReportingColumnAsync = typeof ReportingColumnAsync[keyof typeof ReportingColumnAsync];


/**
 * 
 * @export
 * @interface ReportsStats200Response
 */
export interface ReportsStats200Response {
    /**
     * 
     * @type {Array<CatalogsReportStats>}
     * @memberof ReportsStats200Response
     */
    'items': Array<CatalogsReportStats>;
    /**
     * 
     * @type {string}
     * @memberof ReportsStats200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface RespondToInvitesResponseArray
 */
export interface RespondToInvitesResponseArray {
    /**
     * List of invite/request accept/decline status. If there is an error, an exception object will be returned. If the invite/request was successfully accepted/declined, an invite object will be returned.
     * @type {Array<RespondToInvitesResponseArrayItemsInner>}
     * @memberof RespondToInvitesResponseArray
     */
    'items'?: Array<RespondToInvitesResponseArrayItemsInner>;
}
/**
 * 
 * @export
 * @interface RespondToInvitesResponseArrayItemsInner
 */
export interface RespondToInvitesResponseArrayItemsInner {
    /**
     * 
     * @type {InviteExceptionResponse}
     * @memberof RespondToInvitesResponseArrayItemsInner
     */
    'exception'?: InviteExceptionResponse | null;
    /**
     * 
     * @type {BaseInviteDataResponse}
     * @memberof RespondToInvitesResponseArrayItemsInner
     */
    'invite'?: BaseInviteDataResponse | null;
}
/**
 * An internal role type used on business access, EMPLOYEE, ADMIN.
 * @export
 * @enum {string}
 */

export const Role = {
    Unknown: 'UNKNOWN',
    Owner: 'OWNER',
    Admin: 'ADMIN',
    Analyst: 'ANALYST',
    SosReader: 'SOS_READER',
    FinanceManager: 'FINANCE_MANAGER',
    AudienceManager: 'AUDIENCE_MANAGER',
    CampaignManager: 'CAMPAIGN_MANAGER',
    CatalogsManager: 'CATALOGS_MANAGER',
    RestrictedOwner: 'RESTRICTED_OWNER',
    ProfileManager: 'PROFILE_MANAGER',
    ProfilePublisher: 'PROFILE_PUBLISHER',
    ResourcePinnerListOwner: 'RESOURCE_PINNER_LIST_OWNER',
    ResourcePinnerListReader: 'RESOURCE_PINNER_LIST_READER',
    BizPinnerListSharer: 'BIZ_PINNER_LIST_SHARER',
    ResourceConversionTagsReader: 'RESOURCE_CONVERSION_TAGS_READER'
} as const;

export type Role = typeof Role[keyof typeof Role];


/**
 * 
 * @export
 * @interface SSIOAccountAddress
 */
export interface SSIOAccountAddress {
    /**
     * Address display
     * @type {string}
     * @memberof SSIOAccountAddress
     */
    'display'?: string;
    /**
     * Purpose for which the address is used, usually Billing or Businness
     * @type {string}
     * @memberof SSIOAccountAddress
     */
    'purpose'?: string;
    /**
     * Salesforce id for address
     * @type {string}
     * @memberof SSIOAccountAddress
     */
    'address_id'?: string;
    /**
     * Legal entity for this insertion order
     * @type {string}
     * @memberof SSIOAccountAddress
     */
    'order_legal_entity'?: string;
}
/**
 * 
 * @export
 * @interface SSIOAccountItem
 */
export interface SSIOAccountItem {
    /**
     * Salesforce id for billto_info
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'id'?: string;
    /**
     * Salesforce id for IO Terms and Conditions
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'io_terms_id'?: string;
    /**
     * Salesforce text for IO Terms and Conditions
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'io_terms'?: string;
    /**
     * Salesforce id for US Terms and Conditions
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'us_terms_id'?: string;
    /**
     * Salesforce text for US Terms and Conditions
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'us_terms'?: string;
    /**
     * Salesforce id for Rest of the World Terms and Conditions
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'row_terms_id'?: string;
    /**
     * Salesforce text for Rest of the World Terms and Conditions
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'row_terms'?: string;
    /**
     * Insertion Order Type - Pinterest Paper or Agency Paper
     * @type {string}
     * @memberof SSIOAccountItem
     */
    'io_type'?: string;
    /**
     * Address information that is associated with this account.
     * @type {Array<SSIOAccountAddress>}
     * @memberof SSIOAccountItem
     */
    'addresses'?: Array<SSIOAccountAddress>;
}
/**
 * 
 * @export
 * @interface SSIOAccountPMPName
 */
export interface SSIOAccountPMPName {
    /**
     * Display name
     * @type {string}
     * @memberof SSIOAccountPMPName
     */
    'name'?: string;
    /**
     * Salesforce id for PMP
     * @type {string}
     * @memberof SSIOAccountPMPName
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface SSIOAccountResponse
 */
export interface SSIOAccountResponse {
    /**
     * Advertiser eligible to create order lines
     * @type {boolean}
     * @memberof SSIOAccountResponse
     */
    'eligible'?: boolean;
    /**
     * Advertiser eligible to update order lines
     * @type {boolean}
     * @memberof SSIOAccountResponse
     */
    'can_edit'?: boolean;
    /**
     * An array of Salesforce account information that includes address, io terms, etc.
     * @type {Array<SSIOAccountItem>}
     * @memberof SSIOAccountResponse
     */
    'billto_infos'?: Array<SSIOAccountItem>;
    /**
     * 
     * @type {string}
     * @memberof SSIOAccountResponse
     */
    'currency'?: string;
    /**
     * 
     * @type {Array<SSIOAccountPMPName>}
     * @memberof SSIOAccountResponse
     */
    'pmp_names'?: Array<SSIOAccountPMPName>;
    /**
     * Error indicator from Salesforce which could be \"No Error\"
     * @type {string}
     * @memberof SSIOAccountResponse
     */
    'error'?: string;
}
/**
 * 
 * @export
 * @interface SSIOCreateInsertionOrderRequest
 */
export interface SSIOCreateInsertionOrderRequest {
    /**
     * Starting date of time period. Format: YYYY-MM-DD
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'start_date': string;
    /**
     * End date of time period. Format: YYYY-MM-DD
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'end_date'?: string;
    /**
     * The po number
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'po_number': string;
    /**
     * If Budget order line, the budget amount.
     * @type {number}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'budget_amount'?: number;
    /**
     * The billing contact first name
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'billing_contact_firstname': string;
    /**
     * The billing contact last name
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'billing_contact_lastname': string;
    /**
     * The billing contact email
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'billing_contact_email': string;
    /**
     * The media contact first name
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'media_contact_firstname': string;
    /**
     * The media contact last name
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'media_contact_lastname': string;
    /**
     * The media contact email
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'media_contact_email': string;
    /**
     * URL link for agency
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'agency_link'?: string;
    /**
     * The email of user submitting the insertion order
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'user_email'?: string;
    /**
     * The UTC timestamp (to the nearest sec) of when terms were accepted
     * @type {number}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'accepted_terms_time'?: number;
    /**
     * The pmp id
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'pmp_id': string;
    /**
     * The order name
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'order_name': string;
    /**
     * Type can be Budget or Perpetual
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'order_line_type': SSIOCreateInsertionOrderRequestOrderLineTypeEnum;
    /**
     * The SFDC id for the terms
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'accepted_terms_id': string;
    /**
     * The bill-to company id
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'billto_company_id': string;
    /**
     * The bill-to business address id
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'billto_business_address_id': string;
    /**
     * The bill-to billing address id
     * @type {string}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'billto_billing_address_id': string;
    /**
     * If Ongoing (perpetual) order line, the estimated monthly spend
     * @type {number}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'estimated_monthly_spend'?: number;
    /**
     * 
     * @type {Currency}
     * @memberof SSIOCreateInsertionOrderRequest
     */
    'currency_info': Currency;
}

export const SSIOCreateInsertionOrderRequestOrderLineTypeEnum = {
    Budget: 'BUDGET',
    Perpetuals: 'PERPETUALS'
} as const;

export type SSIOCreateInsertionOrderRequestOrderLineTypeEnum = typeof SSIOCreateInsertionOrderRequestOrderLineTypeEnum[keyof typeof SSIOCreateInsertionOrderRequestOrderLineTypeEnum];

/**
 * 
 * @export
 * @interface SSIOCreateInsertionOrderResponse
 */
export interface SSIOCreateInsertionOrderResponse {
    /**
     * Salesforce order id
     * @type {string}
     * @memberof SSIOCreateInsertionOrderResponse
     */
    'pin_order_id'?: string;
}
/**
 * 
 * @export
 * @interface SSIOEditInsertionOrderRequest
 */
export interface SSIOEditInsertionOrderRequest {
    /**
     * Starting date of time period. Format: YYYY-MM-DD
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'start_date'?: string;
    /**
     * End date of time period. Format: YYYY-MM-DD
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'end_date'?: string;
    /**
     * The po number
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'po_number'?: string;
    /**
     * If Budget order line, the budget amount.
     * @type {number}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'budget_amount'?: number;
    /**
     * The billing contact first name
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'billing_contact_firstname'?: string;
    /**
     * The billing contact last name
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'billing_contact_lastname'?: string;
    /**
     * The billing contact email
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'billing_contact_email'?: string;
    /**
     * The media contact first name
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'media_contact_firstname'?: string;
    /**
     * The media contact last name
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'media_contact_lastname'?: string;
    /**
     * The media contact email
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'media_contact_email'?: string;
    /**
     * URL link for agency
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'agency_link'?: string;
    /**
     * The email of user submitting the insertion order
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'user_email'?: string;
    /**
     * LineId in the Oracle DB
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'oracle_line_id'?: string;
    /**
     * OrderId in SFDC
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'salesforce_order_id'?: string;
    /**
     * OrderLineId in SFDC
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'salesforce_order_line_id'?: string;
    /**
     * Ads manager OrderLineId
     * @type {string}
     * @memberof SSIOEditInsertionOrderRequest
     */
    'ads_manager_order_line_id'?: string;
}
/**
 * 
 * @export
 * @interface SSIOEditInsertionOrderResponse
 */
export interface SSIOEditInsertionOrderResponse {
    /**
     * Salesforce order id
     * @type {string}
     * @memberof SSIOEditInsertionOrderResponse
     */
    'pin_order_id'?: string;
}
/**
 * 
 * @export
 * @interface SSIOInsertionOrderCommon
 */
export interface SSIOInsertionOrderCommon {
    /**
     * Starting date of time period. Format: YYYY-MM-DD
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'start_date'?: string;
    /**
     * End date of time period. Format: YYYY-MM-DD
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'end_date'?: string;
    /**
     * The po number
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'po_number'?: string;
    /**
     * If Budget order line, the budget amount.
     * @type {number}
     * @memberof SSIOInsertionOrderCommon
     */
    'budget_amount'?: number;
    /**
     * The billing contact first name
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'billing_contact_firstname'?: string;
    /**
     * The billing contact last name
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'billing_contact_lastname'?: string;
    /**
     * The billing contact email
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'billing_contact_email'?: string;
    /**
     * The media contact first name
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'media_contact_firstname'?: string;
    /**
     * The media contact last name
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'media_contact_lastname'?: string;
    /**
     * The media contact email
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'media_contact_email'?: string;
    /**
     * URL link for agency
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'agency_link'?: string;
    /**
     * The email of user submitting the insertion order
     * @type {string}
     * @memberof SSIOInsertionOrderCommon
     */
    'user_email'?: string;
}
/**
 * 
 * @export
 * @interface SSIOInsertionOrderStatus
 */
export interface SSIOInsertionOrderStatus {
    /**
     * Salesforce order id
     * @type {string}
     * @memberof SSIOInsertionOrderStatus
     */
    'pin_order_id'?: string;
    /**
     * Salesforce insertion order status
     * @type {string}
     * @memberof SSIOInsertionOrderStatus
     */
    'status'?: string;
    /**
     * Salesforce insertion order creation time
     * @type {string}
     * @memberof SSIOInsertionOrderStatus
     */
    'creation_time'?: string | null;
}
/**
 * 
 * @export
 * @interface SSIOInsertionOrderStatusResponse
 */
export interface SSIOInsertionOrderStatusResponse {
    /**
     * Salesforce order id
     * @type {string}
     * @memberof SSIOInsertionOrderStatusResponse
     */
    'pin_order_id'?: string;
    /**
     * Salesforce insertion order status
     * @type {string}
     * @memberof SSIOInsertionOrderStatusResponse
     */
    'status'?: string;
    /**
     * Salesforce insertion order creation time
     * @type {string}
     * @memberof SSIOInsertionOrderStatusResponse
     */
    'creation_time'?: string | null;
}
/**
 * 
 * @export
 * @interface SSIOOrderLine
 */
export interface SSIOOrderLine {
    /**
     * OrderLineId in SFDC
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'salesforce_order_line_id'?: string | null;
    /**
     * Ads manager OrderLineId
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'ads_manager_order_line_id'?: string | null;
    /**
     * The pin order id associated with the order line in SFDC
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'pin_order_id'?: string | null;
    /**
     * Last modified date.
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'last_modified_date_time'?: string | null;
    /**
     * Start date of the order line.
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'start_date'?: string | null;
    /**
     * End date of the order line.
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'end_date'?: string | null;
    /**
     * Bill To Company name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'bill_to_company_name'?: string | null;
    /**
     * Billing contact first name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'billing_contact_firstname'?: string | null;
    /**
     * Billing contact last name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'billing_contact_lastname'?: string | null;
    /**
     * Billing contact email
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'billing_contact_email'?: string | null;
    /**
     * Billing media email
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'media_contact_email'?: string | null;
    /**
     * Billing contact first name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'media_contact_firstname'?: string | null;
    /**
     * Billing contact first name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'media_contact_lastname'?: string | null;
    /**
     * 
     * @type {Currency}
     * @memberof SSIOOrderLine
     */
    'currency_info'?: Currency;
    /**
     * Agency link
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'agency_link'?: string | null;
    /**
     * The po number
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'po_number'?: string | null;
    /**
     * The order name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'order_name'?: string | null;
    /**
     * The Pinterest marketing partner name
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'pmp_name'?: string | null;
    /**
     * The SFDC id for the terms
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'accepted_terms_id'?: string | null;
    /**
     * The UTC timestamp (to the nearest sec) of when terms were accepted
     * @type {string}
     * @memberof SSIOOrderLine
     */
    'accepted_terms_time'?: string | null;
    /**
     * If Budget order line, the budget amount.
     * @type {number}
     * @memberof SSIOOrderLine
     */
    'budget_amount'?: number | null;
    /**
     * If Ongoing (perpetual) order line, the estimated monthly spend
     * @type {number}
     * @memberof SSIOOrderLine
     */
    'estimated_monthly_spend'?: number | null;
}


/**
 * 
 * @export
 * @interface SearchPartnerPins200Response
 */
export interface SearchPartnerPins200Response {
    /**
     * 
     * @type {Array<SummaryPin>}
     * @memberof SearchPartnerPins200Response
     */
    'items': Array<SummaryPin>;
    /**
     * 
     * @type {string}
     * @memberof SearchPartnerPins200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface SearchUserBoardsGet200Response
 */
export interface SearchUserBoardsGet200Response {
    /**
     * items
     * @type {Array<Board>}
     * @memberof SearchUserBoardsGet200Response
     */
    'items': Array<Board>;
    /**
     * 
     * @type {string}
     * @memberof SearchUserBoardsGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface SharedAudience
 */
export interface SharedAudience {
    /**
     * Unique identifier of an audience
     * @type {string}
     * @memberof SharedAudience
     */
    'audience_id': string;
    /**
     * 
     * @type {OperationType}
     * @memberof SharedAudience
     */
    'operation_type': OperationType;
    /**
     * List of ad account IDs to share with or revoke from.
     * @type {Array<string>}
     * @memberof SharedAudience
     */
    'recipient_account_ids': Array<string>;
}


/**
 * 
 * @export
 * @interface SharedAudienceAccount
 */
export interface SharedAudienceAccount {
    /**
     * Account ID (ad account or business ID).
     * @type {string}
     * @memberof SharedAudienceAccount
     */
    'account_id': string;
    /**
     * Account name.
     * @type {string}
     * @memberof SharedAudienceAccount
     */
    'account_name': string;
    /**
     * account type
     * @type {string}
     * @memberof SharedAudienceAccount
     */
    'account_type': SharedAudienceAccountAccountTypeEnum;
    /**
     * Epoch timestamp in seconds for the shared audience event
     * @type {number}
     * @memberof SharedAudienceAccount
     */
    'shared_on_timestamp': number;
}

export const SharedAudienceAccountAccountTypeEnum = {
    AdAccount: 'AD_ACCOUNT',
    BusinessAccount: 'BUSINESS_ACCOUNT'
} as const;

export type SharedAudienceAccountAccountTypeEnum = typeof SharedAudienceAccountAccountTypeEnum[keyof typeof SharedAudienceAccountAccountTypeEnum];

/**
 * 
 * @export
 * @interface SharedAudienceCommon
 */
export interface SharedAudienceCommon {
    /**
     * Unique identifier of an audience
     * @type {string}
     * @memberof SharedAudienceCommon
     */
    'audience_id'?: string;
    /**
     * 
     * @type {OperationType}
     * @memberof SharedAudienceCommon
     */
    'operation_type'?: OperationType;
}


/**
 * 
 * @export
 * @interface SharedAudienceResponse
 */
export interface SharedAudienceResponse {
    /**
     * Audience ID that was shared
     * @type {string}
     * @memberof SharedAudienceResponse
     */
    'audience_id'?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof SharedAudienceResponse
     */
    'permissions'?: Array<Role>;
    /**
     * Account IDs that received the audience
     * @type {Array<string>}
     * @memberof SharedAudienceResponse
     */
    'recipient_account_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SharedAudienceResponseCommon
 */
export interface SharedAudienceResponseCommon {
    /**
     * Audience ID that was shared
     * @type {string}
     * @memberof SharedAudienceResponseCommon
     */
    'audience_id'?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof SharedAudienceResponseCommon
     */
    'permissions'?: Array<Role>;
}
/**
 * 
 * @export
 * @interface SingleInterestTargetingOptionResponse
 */
export interface SingleInterestTargetingOptionResponse {
    /**
     * 
     * @type {string}
     * @memberof SingleInterestTargetingOptionResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SingleInterestTargetingOptionResponse
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SingleInterestTargetingOptionResponse
     */
    'child_interests'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof SingleInterestTargetingOptionResponse
     */
    'level'?: number;
}
/**
 * 
 * @export
 * @interface SsioInsertionOrdersStatusGetByAdAccount200Response
 */
export interface SsioInsertionOrdersStatusGetByAdAccount200Response {
    /**
     * Insertion orders status by ad acount id
     * @type {Array<SSIOInsertionOrderStatus>}
     * @memberof SsioInsertionOrdersStatusGetByAdAccount200Response
     */
    'items': Array<SSIOInsertionOrderStatus>;
    /**
     * 
     * @type {string}
     * @memberof SsioInsertionOrdersStatusGetByAdAccount200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface SsioOrderLinesGetByAdAccount200Response
 */
export interface SsioOrderLinesGetByAdAccount200Response {
    /**
     * SSIO order lines by ad acount id
     * @type {Array<SSIOOrderLine>}
     * @memberof SsioOrderLinesGetByAdAccount200Response
     */
    'items': Array<SSIOOrderLine>;
    /**
     * 
     * @type {string}
     * @memberof SsioOrderLinesGetByAdAccount200Response
     */
    'bookmark'?: string | null;
}
/**
 * Summarized pin information
 * @export
 * @interface SummaryPin
 */
export interface SummaryPin {
    /**
     * 
     * @type {PinMedia}
     * @memberof SummaryPin
     */
    'media'?: PinMedia;
    /**
     * 
     * @type {string}
     * @memberof SummaryPin
     */
    'alt_text'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SummaryPin
     */
    'link'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SummaryPin
     */
    'title'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof SummaryPin
     */
    'description'?: string | null;
}
/**
 * Advertiser\'s ISO two character country code.
 * @export
 * @enum {string}
 */

export const TargetingAdvertiserCountry = {
    Us: 'US',
    Gb: 'GB',
    Ca: 'CA',
    Ie: 'IE',
    Au: 'AU',
    Nz: 'NZ',
    Fr: 'FR',
    Se: 'SE',
    Il: 'IL',
    De: 'DE',
    At: 'AT',
    It: 'IT',
    Es: 'ES',
    Nl: 'NL',
    Be: 'BE',
    Pt: 'PT',
    Ch: 'CH',
    Hk: 'HK',
    Jp: 'JP',
    Kr: 'KR',
    Sg: 'SG',
    No: 'NO',
    Dk: 'DK',
    Fi: 'FI',
    Cy: 'CY',
    Lu: 'LU',
    Mt: 'MT',
    Pl: 'PL',
    Ro: 'RO',
    Hu: 'HU',
    Cz: 'CZ',
    Gr: 'GR',
    Sk: 'SK',
    Br: 'BR',
    Mx: 'MX',
    Ar: 'AR',
    Cl: 'CL',
    Co: 'CO'
} as const;

export type TargetingAdvertiserCountry = typeof TargetingAdvertiserCountry[keyof typeof TargetingAdvertiserCountry];


/**
 * Ad group targeting specification defining the ad group target audience. For example, `{\"APPTYPE\":[\"iphone\"], \"GENDER\":[\"male\"], \"LOCALE\":[\"en-US\"], \"LOCATION\":[\"501\"], \"AGE_BUCKET\":[\"25-34\"]}`
 * @export
 * @interface TargetingSpec
 */
export interface TargetingSpec {
    /**
     * Age ranges. If the AGE_BUCKET field is missing, the default behavior in terms of ad delivery is that **All age buckets** will be targeted.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'AGE_BUCKET'?: Array<TargetingSpecAGEBUCKETEnum> | null;
    /**
     * Allowed devices. If the APPTYPE field is missing, the default behavior in terms of ad delivery is that **All devices/apptypes** will be targeted.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'APPTYPE'?: Array<TargetingSpecAPPTYPEEnum> | null;
    /**
     * Excluded customer list IDs. Used to drive new customer acquisition goals. For example: [\"2542620905475\"]. Audience lists need to have at least 100 people with Pinterest accounts in them. If the AUDIENCE_EXCLUDE field is missing, the default behavior in terms of ad delivery is that **No users will be excluded**.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'AUDIENCE_EXCLUDE'?: Array<string> | null;
    /**
     * Targeted customer list IDs. For example: [\"2542620905473\"]. Audience lists need to have at least 100 people with Pinterest accounts in them Audience lists need to have at least 100 people with Pinterest accounts in them. If the AUDIENCE_INCLUDE field is missing, the default behavior in terms of ad delivery is that **All users will be included**.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'AUDIENCE_INCLUDE'?: Array<string> | null;
    /**
     * Targeted genders. Values: [\"unknown\",\"male\",\"female\"]. If the GENDER field is missing, the default behavior in terms of ad delivery is that **All genders will be targeted**.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'GENDER'?: Array<TargetingSpecGENDEREnum> | null;
    /**
     * Location region codes, e.g., \"BE-VOV\" (East Flanders, Belgium) For complete list, <a href=\"https://help.pinterest.com/sub/helpcenter/partner/pinterest_location_targeting_codes.xlsx\" target=\"_blank\">click here</a> or postal codes, e.g., \"US-94107\". Use either region codes or postal codes but not both. At least one of LOCATION or GEO must be specified. If the GEO field is missing, then only LOCATION values will be targeted (see LOCATION field below).
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'GEO'?: Array<string> | null;
    /**
     * Array of interest object IDs. If the INTEREST field is missing, the default behavior in terms of ad delivery is that **All interests will be targeted**.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'INTEREST'?: Array<string>;
    /**
     * 24 ISO 639-1 two letter language codes. If the LOCALE field is missing, the default behavior in terms of ad delivery is that **All languages will be targeted, only english non-sublanguage will be targeted**.
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'LOCALE'?: Array<string> | null;
    /**
     * 22 ISO Alpha 2 two letter country codes or US Nielsen DMA (Designated Market Area) codes (location region codes) (e.g., [\"US\", \"807\"]). For complete list, click here. Location-Country and Location-Metro codes apply. At least one of LOCATION or GEO must be specified. If the LOCATION field is missing, then only GEO values will be targeted (see GEO field above).
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'LOCATION'?: Array<string> | null;
    /**
     * Array of object: lookback_window [Integer]: Number of days ago to start lookback timeframe for dynamic retargeting tag_types [Array of integer]: Event types to target for dynamic retargeting exclusion_window [Integer]: Number of days ago to stop lookback timeframe for dynamic retargeting
     * @type {Array<TargetingSpecSHOPPINGRETARGETING>}
     * @memberof TargetingSpec
     */
    'SHOPPING_RETARGETING'?: Array<TargetingSpecSHOPPINGRETARGETING> | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof TargetingSpec
     */
    'TARGETING_STRATEGY'?: Array<TargetingSpecTARGETINGSTRATEGYEnum> | null;
}

export const TargetingSpecAGEBUCKETEnum = {
    _1824: '18-24',
    _21: '21+',
    _2534: '25-34',
    _3544: '35-44',
    _4549: '45-49',
    _5054: '50-54',
    _5564: '55-64',
    _65: '65+'
} as const;

export type TargetingSpecAGEBUCKETEnum = typeof TargetingSpecAGEBUCKETEnum[keyof typeof TargetingSpecAGEBUCKETEnum];
export const TargetingSpecAPPTYPEEnum = {
    AndroidMobile: 'android_mobile',
    AndroidTablet: 'android_tablet',
    Ipad: 'ipad',
    Iphone: 'iphone',
    Web: 'web',
    WebMobile: 'web_mobile'
} as const;

export type TargetingSpecAPPTYPEEnum = typeof TargetingSpecAPPTYPEEnum[keyof typeof TargetingSpecAPPTYPEEnum];
export const TargetingSpecGENDEREnum = {
    Unknown: 'unknown',
    Male: 'male',
    Female: 'female'
} as const;

export type TargetingSpecGENDEREnum = typeof TargetingSpecGENDEREnum[keyof typeof TargetingSpecGENDEREnum];
export const TargetingSpecTARGETINGSTRATEGYEnum = {
    ChooseYourOwn: 'CHOOSE_YOUR_OWN',
    FindNewCustomers: 'FIND_NEW_CUSTOMERS',
    ReconnectWithUsers: 'RECONNECT_WITH_USERS'
} as const;

export type TargetingSpecTARGETINGSTRATEGYEnum = typeof TargetingSpecTARGETINGSTRATEGYEnum[keyof typeof TargetingSpecTARGETINGSTRATEGYEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const TargetingSpecAppType = {
    AndroidMobile: 'android_mobile',
    AndroidTablet: 'android_tablet',
    Ipad: 'ipad',
    Iphone: 'iphone',
    Web: 'web',
    WebMobile: 'web_mobile'
} as const;

export type TargetingSpecAppType = typeof TargetingSpecAppType[keyof typeof TargetingSpecAppType];


/**
 * 
 * @export
 * @interface TargetingSpecSHOPPINGRETARGETING
 */
export interface TargetingSpecSHOPPINGRETARGETING {
    /**
     * Number of days ago to start lookback timeframe for dynamic retargeting
     * @type {number}
     * @memberof TargetingSpecSHOPPINGRETARGETING
     */
    'lookback_window'?: number;
    /**
     * Event types to target for dynamic retargeting
     * @type {Array<number>}
     * @memberof TargetingSpecSHOPPINGRETARGETING
     */
    'tag_types'?: Array<number>;
    /**
     * Number of days ago to stop lookback timeframe for dynamic retargeting
     * @type {number}
     * @memberof TargetingSpecSHOPPINGRETARGETING
     */
    'exclusion_window'?: number;
}
/**
 * Gets an audience size estimate for a set of given targeting spec data. <p>Returns:</p> An object containing an audience size estimate that has a reach estimate (number of unique users) against the given targeting template. This by default provides a monthly estimate. 
 * @export
 * @interface TargetingTemplateAudienceSizing
 */
export interface TargetingTemplateAudienceSizing {
    /**
     * 
     * @type {TargetingTemplateAudienceSizingReachEstimate}
     * @memberof TargetingTemplateAudienceSizing
     */
    'reach_estimate'?: TargetingTemplateAudienceSizingReachEstimate;
}
/**
 * 
 * @export
 * @interface TargetingTemplateAudienceSizingReachEstimate
 */
export interface TargetingTemplateAudienceSizingReachEstimate {
    /**
     * 
     * @type {number}
     * @memberof TargetingTemplateAudienceSizingReachEstimate
     */
    'estimate'?: number;
    /**
     * 
     * @type {number}
     * @memberof TargetingTemplateAudienceSizingReachEstimate
     */
    'lower_bound'?: number;
    /**
     * 
     * @type {number}
     * @memberof TargetingTemplateAudienceSizingReachEstimate
     */
    'upper_bound'?: number;
}
/**
 * 
 * @export
 * @interface TargetingTemplateCommon
 */
export interface TargetingTemplateCommon {
    /**
     * targeting template name
     * @type {string}
     * @memberof TargetingTemplateCommon
     */
    'name'?: string;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof TargetingTemplateCommon
     */
    'auto_targeting_enabled'?: boolean;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof TargetingTemplateCommon
     */
    'targeting_attributes'?: TargetingSpec;
    /**
     * 
     * @type {PlacementGroupType}
     * @memberof TargetingTemplateCommon
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {Array<TargetingTemplateKeyword>}
     * @memberof TargetingTemplateCommon
     */
    'keywords'?: Array<TargetingTemplateKeyword>;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof TargetingTemplateCommon
     */
    'tracking_urls'?: TrackingUrls | null;
}


/**
 * 
 * @export
 * @interface TargetingTemplateCreate
 */
export interface TargetingTemplateCreate {
    /**
     * Name of targeting template.
     * @type {string}
     * @memberof TargetingTemplateCreate
     */
    'name': string;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof TargetingTemplateCreate
     */
    'auto_targeting_enabled'?: boolean;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof TargetingTemplateCreate
     */
    'targeting_attributes': TargetingSpec;
    /**
     * 
     * @type {PlacementGroupType}
     * @memberof TargetingTemplateCreate
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {Array<TargetingTemplateKeyword>}
     * @memberof TargetingTemplateCreate
     */
    'keywords'?: Array<TargetingTemplateKeyword>;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof TargetingTemplateCreate
     */
    'tracking_urls'?: TrackingUrls | null;
}


/**
 * 
 * @export
 * @interface TargetingTemplateGetResponseData
 */
export interface TargetingTemplateGetResponseData {
    /**
     * targeting template name
     * @type {string}
     * @memberof TargetingTemplateGetResponseData
     */
    'name'?: string;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof TargetingTemplateGetResponseData
     */
    'auto_targeting_enabled'?: boolean;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof TargetingTemplateGetResponseData
     */
    'targeting_attributes'?: TargetingSpec;
    /**
     * 
     * @type {PlacementGroupType}
     * @memberof TargetingTemplateGetResponseData
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {Array<TargetingTemplateKeyword>}
     * @memberof TargetingTemplateGetResponseData
     */
    'keywords'?: Array<TargetingTemplateKeyword>;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof TargetingTemplateGetResponseData
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Targeting template ID.
     * @type {string}
     * @memberof TargetingTemplateGetResponseData
     */
    'id'?: string;
    /**
     * Targeting template created time. Unix timestamp in seconds.
     * @type {number}
     * @memberof TargetingTemplateGetResponseData
     */
    'created_time'?: number;
    /**
     * Targeting template updated time.Unix timestamp in seconds.
     * @type {number}
     * @memberof TargetingTemplateGetResponseData
     */
    'updated_time'?: number;
    /**
     * The ID of the advertiser that this targeting template belongs to.
     * @type {string}
     * @memberof TargetingTemplateGetResponseData
     */
    'ad_account_id'?: string;
    /**
     * Indicate targeting template is active or Deleted
     * @type {string}
     * @memberof TargetingTemplateGetResponseData
     */
    'status'?: TargetingTemplateGetResponseDataStatusEnum;
    /**
     * 
     * @type {TargetingTemplateAudienceSizing}
     * @memberof TargetingTemplateGetResponseData
     */
    'sizing'?: TargetingTemplateAudienceSizing | null;
    /**
     * Inform if the targeting template is valid (ex. would be false if has revoked audience)
     * @type {boolean}
     * @memberof TargetingTemplateGetResponseData
     */
    'valid'?: boolean | null;
}

export const TargetingTemplateGetResponseDataStatusEnum = {
    Active: 'ACTIVE',
    Deleted: 'DELETED'
} as const;

export type TargetingTemplateGetResponseDataStatusEnum = typeof TargetingTemplateGetResponseDataStatusEnum[keyof typeof TargetingTemplateGetResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface TargetingTemplateKeyword
 */
export interface TargetingTemplateKeyword {
    /**
     * 
     * @type {MatchType}
     * @memberof TargetingTemplateKeyword
     */
    'match_type'?: MatchType;
    /**
     * The keyword targeting (120 chars max).
     * @type {string}
     * @memberof TargetingTemplateKeyword
     */
    'value'?: string;
}


/**
 * 
 * @export
 * @interface TargetingTemplateList200Response
 */
export interface TargetingTemplateList200Response {
    /**
     * 
     * @type {Array<TargetingTemplateResponseData>}
     * @memberof TargetingTemplateList200Response
     */
    'items': Array<TargetingTemplateResponseData>;
    /**
     * 
     * @type {string}
     * @memberof TargetingTemplateList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface TargetingTemplateResponseData
 */
export interface TargetingTemplateResponseData {
    /**
     * targeting template name
     * @type {string}
     * @memberof TargetingTemplateResponseData
     */
    'name'?: string;
    /**
     * Enable auto-targeting for ad group. Also known as <a href=\"https://help.pinterest.com/en/business/article/expanded-targeting\" target=\"_blank\">\"expanded targeting\"</a>.
     * @type {boolean}
     * @memberof TargetingTemplateResponseData
     */
    'auto_targeting_enabled'?: boolean;
    /**
     * 
     * @type {TargetingSpec}
     * @memberof TargetingTemplateResponseData
     */
    'targeting_attributes'?: TargetingSpec;
    /**
     * 
     * @type {PlacementGroupType}
     * @memberof TargetingTemplateResponseData
     */
    'placement_group'?: PlacementGroupType;
    /**
     * 
     * @type {Array<TargetingTemplateKeyword>}
     * @memberof TargetingTemplateResponseData
     */
    'keywords'?: Array<TargetingTemplateKeyword>;
    /**
     * 
     * @type {TrackingUrls}
     * @memberof TargetingTemplateResponseData
     */
    'tracking_urls'?: TrackingUrls | null;
    /**
     * Targeting template ID.
     * @type {string}
     * @memberof TargetingTemplateResponseData
     */
    'id'?: string;
    /**
     * Targeting template created time. Unix timestamp in seconds.
     * @type {number}
     * @memberof TargetingTemplateResponseData
     */
    'created_time'?: number;
    /**
     * Targeting template updated time.Unix timestamp in seconds.
     * @type {number}
     * @memberof TargetingTemplateResponseData
     */
    'updated_time'?: number;
    /**
     * The ID of the advertiser that this targeting template belongs to.
     * @type {string}
     * @memberof TargetingTemplateResponseData
     */
    'ad_account_id'?: string;
    /**
     * Indicate targeting template is active or Deleted
     * @type {string}
     * @memberof TargetingTemplateResponseData
     */
    'status'?: TargetingTemplateResponseDataStatusEnum;
    /**
     * 
     * @type {TargetingTemplateAudienceSizing}
     * @memberof TargetingTemplateResponseData
     */
    'sizing'?: TargetingTemplateAudienceSizing | null;
}

export const TargetingTemplateResponseDataStatusEnum = {
    Active: 'ACTIVE',
    Deleted: 'DELETED'
} as const;

export type TargetingTemplateResponseDataStatusEnum = typeof TargetingTemplateResponseDataStatusEnum[keyof typeof TargetingTemplateResponseDataStatusEnum];

/**
 * 
 * @export
 * @interface TargetingTemplateUpdateRequest
 */
export interface TargetingTemplateUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof TargetingTemplateUpdateRequest
     */
    'operation_type': TargetingTemplateUpdateRequestOperationTypeEnum;
    /**
     * Targeting template ID
     * @type {string}
     * @memberof TargetingTemplateUpdateRequest
     */
    'id': string;
}

export const TargetingTemplateUpdateRequestOperationTypeEnum = {
    Remove: 'REMOVE'
} as const;

export type TargetingTemplateUpdateRequestOperationTypeEnum = typeof TargetingTemplateUpdateRequestOperationTypeEnum[keyof typeof TargetingTemplateUpdateRequestOperationTypeEnum];

/**
 * 
 * @export
 * @interface TargetingTypeFilter
 */
export interface TargetingTypeFilter {
    /**
     * List of targeting types. Requires `level` to be a value ending in `_TARGETING`. [\"AGE_BUCKET_AND_GENDER\"] is in BETA and not yet available to all users.
     * @type {Array<AdsAnalyticsTargetingType>}
     * @memberof TargetingTypeFilter
     */
    'targeting_types'?: Array<AdsAnalyticsTargetingType>;
}
/**
 * Template fields
 * @export
 * @interface TemplateResponse
 */
export interface TemplateResponse {
    /**
     * Template ID
     * @type {string}
     * @memberof TemplateResponse
     */
    'id'?: string;
    /**
     * ID of the Ad Account that owns the template
     * @type {string}
     * @memberof TemplateResponse
     */
    'ad_account_id'?: string;
    /**
     * IDs of the Ad Accounts that have access to this template
     * @type {Array<string>}
     * @memberof TemplateResponse
     */
    'ad_account_ids'?: Array<string>;
    /**
     * ID of the user who created the template
     * @type {string}
     * @memberof TemplateResponse
     */
    'user_id'?: string;
    /**
     * Template Name
     * @type {string}
     * @memberof TemplateResponse
     */
    'name'?: string | null;
    /**
     * The number of days prior to the day the report will be delivered at which the report will start
     * @type {number}
     * @memberof TemplateResponse
     */
    'report_start_relative_days_in_past'?: number;
    /**
     * The number of days prior to the day the report will be delivered at which the report will end
     * @type {number}
     * @memberof TemplateResponse
     */
    'report_end_relative_days_in_past'?: number;
    /**
     * 
     * @type {TemplateResponseDateRange}
     * @memberof TemplateResponse
     */
    'date_range'?: TemplateResponseDateRange;
    /**
     * 
     * @type {MetricsReportingLevel}
     * @memberof TemplateResponse
     */
    'report_level'?: MetricsReportingLevel;
    /**
     * 
     * @type {DataOutputFormat}
     * @memberof TemplateResponse
     */
    'report_format'?: DataOutputFormat;
    /**
     * A list of columns to be included in the report
     * @type {Array<string>}
     * @memberof TemplateResponse
     */
    'columns'?: Array<TemplateResponseColumnsEnum>;
    /**
     * 
     * @type {Granularity}
     * @memberof TemplateResponse
     */
    'granularity'?: Granularity;
    /**
     * The length of the sliding window over which view conversions will be attributed
     * @type {number}
     * @memberof TemplateResponse
     */
    'view_window_days'?: number;
    /**
     * The length of the sliding window over which click conversions will be attributed
     * @type {number}
     * @memberof TemplateResponse
     */
    'click_window_days'?: number;
    /**
     * The length of the sliding window over which engagement conversions will be attributed
     * @type {number}
     * @memberof TemplateResponse
     */
    'engagement_window_days'?: number;
    /**
     * Conversion report time type
     * @type {string}
     * @memberof TemplateResponse
     */
    'conversion_report_time_type'?: TemplateResponseConversionReportTimeTypeEnum;
    /**
     * A JSON representation of any filters to be applied before returning report data. Each filter object should contain all of the following fields:<br> \"field\": The column name<br> \"operator\": The operator. Allowed operators: [\"=\", \"!=\", \"in\", \"not_in\", \"~\", \">\", \"<\", \"contains_substring\"]<br> \"value\": A single value or a list of values
     * @type {string}
     * @memberof TemplateResponse
     */
    'filters_json'?: string | null;
    /**
     * A boolean value that indicates if the user owns the template
     * @type {boolean}
     * @memberof TemplateResponse
     */
    'is_owned_by_user'?: boolean;
    /**
     * A boolean value that indicates if this template has been used to create a scheduled report
     * @type {boolean}
     * @memberof TemplateResponse
     */
    'is_scheduled'?: boolean;
    /**
     * The surface used to create this template
     * @type {string}
     * @memberof TemplateResponse
     */
    'creation_source'?: TemplateResponseCreationSourceEnum;
    /**
     * A boolean that indicates if the template has been deleted
     * @type {boolean}
     * @memberof TemplateResponse
     */
    'is_deleted'?: boolean | null;
    /**
     * Time of last update in seconds since Unix epoch
     * @type {number}
     * @memberof TemplateResponse
     */
    'updated_time'?: number;
    /**
     * A list of custom column IDs
     * @type {Array<string>}
     * @memberof TemplateResponse
     */
    'custom_column_ids'?: Array<string> | null;
    /**
     * Reporting template type
     * @type {string}
     * @memberof TemplateResponse
     */
    'type'?: TemplateResponseTypeEnum;
    /**
     * The filter on the conversion ingestion source method for conversion metrics
     * @type {Array<string>}
     * @memberof TemplateResponse
     */
    'ingestion_sources'?: Array<TemplateResponseIngestionSourcesEnum> | null;
}

export const TemplateResponseColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    SpendInMicroUsDollar: 'SPEND_IN_MICRO_US_DOLLAR',
    BonusSpendInMicroDollar: 'BONUS_SPEND_IN_MICRO_DOLLAR',
    BonusSpendInDollar: 'BONUS_SPEND_IN_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    PaidClickthrough: 'PAID_CLICKTHROUGH',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    SpendInUsDollar: 'SPEND_IN_US_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    CpcInDollar: 'CPC_IN_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    OutboundCtr: 'OUTBOUND_CTR',
    CpcInMicroCurrency: 'CPC_IN_MICRO_CURRENCY',
    CpwInMicroDollar: 'CPW_IN_MICRO_DOLLAR',
    CpwInDollar: 'CPW_IN_DOLLAR',
    CostPerOutboundClick: 'COST_PER_OUTBOUND_CLICK',
    AdOnlyPin: 'AD_ONLY_PIN',
    CampaignName: 'CAMPAIGN_NAME',
    CampaignStatus: 'CAMPAIGN_STATUS',
    IsCampaignLearningPhase: 'IS_CAMPAIGN_LEARNING_PHASE',
    Date: 'DATE',
    DateAsTimestamp: 'DATE_AS_TIMESTAMP',
    BudgetInDollar: 'BUDGET_IN_DOLLAR',
    AvailableBudgetInDollar: 'AVAILABLE_BUDGET_IN_DOLLAR',
    TargetingType: 'TARGETING_TYPE',
    TargetingValue: 'TARGETING_VALUE',
    TargetingValueName: 'TARGETING_VALUE_NAME',
    PaidEvents: 'PAID_EVENTS',
    BonusEvents: 'BONUS_EVENTS',
    Insertion: 'INSERTION',
    LegacyCampaignId: 'LEGACY_CAMPAIGN_ID',
    HbaseId: 'HBASE_ID',
    PinDescription: 'PIN_DESCRIPTION',
    CampaignEndDate: 'CAMPAIGN_END_DATE',
    PinPromotionStatus: 'PIN_PROMOTION_STATUS',
    AdStatus: 'AD_STATUS',
    PinId: 'PIN_ID',
    CrossDeviceType: 'CROSS_DEVICE_TYPE',
    IngestionSource: 'INGESTION_SOURCE',
    SourcePlatform: 'SOURCE_PLATFORM',
    PinPromotionIsRunning: 'PIN_PROMOTION_IS_RUNNING',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    CpeInMicroDollar: 'CPE_IN_MICRO_DOLLAR',
    EcpeInMicroDollar: 'ECPE_IN_MICRO_DOLLAR',
    CpeInDollar: 'CPE_IN_DOLLAR',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    InternalEcpeInMicroDollar: 'INTERNAL_ECPE_IN_MICRO_DOLLAR',
    InternalEcpeInDollar: 'INTERNAL_ECPE_IN_DOLLAR',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    EcpmInDollar: 'ECPM_IN_DOLLAR',
    RepinRate: 'REPIN_RATE',
    RepinRate2: 'REPIN_RATE_2',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    AdvertiserOwnerUserId: 'ADVERTISER_OWNER_USER_ID',
    AdvertiserOwnerUserName: 'ADVERTISER_OWNER_USER_NAME',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    KeywordId: 'KEYWORD_ID',
    KeywordIsDeleted: 'KEYWORD_IS_DELETED',
    BrandSfdcAccountId: 'BRAND_SFDC_ACCOUNT_ID',
    CampaignActionType: 'CAMPAIGN_ACTION_TYPE',
    CampaignBidType: 'CAMPAIGN_BID_TYPE',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignManagedStatus: 'CAMPAIGN_MANAGED_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    BudgetType: 'BUDGET_TYPE',
    BudgetInLocalCurrency: 'BUDGET_IN_LOCAL_CURRENCY',
    AdGroupName: 'AD_GROUP_NAME',
    AdGroupStatus: 'AD_GROUP_STATUS',
    AdGroupEndDate: 'AD_GROUP_END_DATE',
    AdGroupBudgetType: 'AD_GROUP_BUDGET_TYPE',
    AdGroupBudgetInLocalCurrency: 'AD_GROUP_BUDGET_IN_LOCAL_CURRENCY',
    AdGroupSuggestedBudgetInLocalCurrency: 'AD_GROUP_SUGGESTED_BUDGET_IN_LOCAL_CURRENCY',
    AdGroupSuggestedBonusBudgetInLocalCurrency: 'AD_GROUP_SUGGESTED_BONUS_BUDGET_IN_LOCAL_CURRENCY',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    AdGroupActionType: 'AD_GROUP_ACTION_TYPE',
    AdGroupConversionLearningModeType: 'AD_GROUP_CONVERSION_LEARNING_MODE_TYPE',
    AdGroupTargetCpa: 'AD_GROUP_TARGET_CPA',
    AdGroupBidStrategyType: 'AD_GROUP_BID_STRATEGY_TYPE',
    AdGroupExperimentName: 'AD_GROUP_EXPERIMENT_NAME',
    AdGroupExperimentCell: 'AD_GROUP_EXPERIMENT_CELL',
    CampaignWebCloseupWhitelisted: 'CAMPAIGN_WEB_CLOSEUP_WHITELISTED',
    ProductGroupId: 'PRODUCT_GROUP_ID',
    ProductGroupDefinition: 'PRODUCT_GROUP_DEFINITION',
    ParentProductGroupId: 'PARENT_PRODUCT_GROUP_ID',
    ProductGroupType: 'PRODUCT_GROUP_TYPE',
    ProductGroupBidInMicroCurrency: 'PRODUCT_GROUP_BID_IN_MICRO_CURRENCY',
    ProductGroupStatus: 'PRODUCT_GROUP_STATUS',
    ProductGroupEntityStatus: 'PRODUCT_GROUP_ENTITY_STATUS',
    ProductGroupInclusion: 'PRODUCT_GROUP_INCLUSION',
    ProductGroupCreativeType: 'PRODUCT_GROUP_CREATIVE_TYPE',
    ItemId: 'ITEM_ID',
    ProductItemId: 'PRODUCT_ITEM_ID',
    InternalProductItemId: 'INTERNAL_PRODUCT_ITEM_ID',
    InternalProductItemIdStr: 'INTERNAL_PRODUCT_ITEM_ID_STR',
    ProductItemName: 'PRODUCT_ITEM_NAME',
    ProductItemImageUrl: 'PRODUCT_ITEM_IMAGE_URL',
    ProductItemPrice: 'PRODUCT_ITEM_PRICE',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    OrderLinePinRevShare: 'ORDER_LINE_PIN_REV_SHARE',
    OrderLinePaidType: 'ORDER_LINE_PAID_TYPE',
    SpendOrderLineId: 'SPEND_ORDER_LINE_ID',
    SpendOrderLinePaidType: 'SPEND_ORDER_LINE_PAID_TYPE',
    ConversionProductId: 'CONVERSION_PRODUCT_ID',
    ConversionProductName: 'CONVERSION_PRODUCT_NAME',
    ConversionProductBrand: 'CONVERSION_PRODUCT_BRAND',
    ConversionProductCategory: 'CONVERSION_PRODUCT_CATEGORY',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Like1: 'LIKE_1',
    Send1: 'SEND_1',
    Flag1: 'FLAG_1',
    Hide1: 'HIDE_1',
    Insertion1: 'INSERTION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    ClickthroughUser1: 'CLICKTHROUGH_USER_1',
    RepinUser1: 'REPIN_USER_1',
    ImpressionUser1: 'IMPRESSION_USER_1',
    LikeUser1: 'LIKE_USER_1',
    SendUser1: 'SEND_USER_1',
    FlagUser1: 'FLAG_USER_1',
    HideUser1: 'HIDE_USER_1',
    InsertionUser1: 'INSERTION_USER_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    Like2: 'LIKE_2',
    Send2: 'SEND_2',
    Flag2: 'FLAG_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    ClickthroughUser2: 'CLICKTHROUGH_USER_2',
    RepinUser2: 'REPIN_USER_2',
    ImpressionUser2: 'IMPRESSION_USER_2',
    LikeUser2: 'LIKE_USER_2',
    SendUser2: 'SEND_USER_2',
    FlagUser2: 'FLAG_USER_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalRepin: 'TOTAL_REPIN',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalLike: 'TOTAL_LIKE',
    TotalSend: 'TOTAL_SEND',
    TotalFlag: 'TOTAL_FLAG',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionUserHll: 'TOTAL_IMPRESSION_USER_HLL',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    TotalImpressionFrequencyHll: 'TOTAL_IMPRESSION_FREQUENCY_HLL',
    TotalOutboundClick: 'TOTAL_OUTBOUND_CLICK',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    EngagementPageVisit1: 'ENGAGEMENT_PAGE_VISIT_1',
    EngagementSignup1: 'ENGAGEMENT_SIGNUP_1',
    EngagementCheckout1: 'ENGAGEMENT_CHECKOUT_1',
    EngagementCustom1: 'ENGAGEMENT_CUSTOM_1',
    EngagementAddToCart1: 'ENGAGEMENT_ADD_TO_CART_1',
    EngagementLead1: 'ENGAGEMENT_LEAD_1',
    EngagementSearch1: 'ENGAGEMENT_SEARCH_1',
    EngagementWatchVideo1: 'ENGAGEMENT_WATCH_VIDEO_1',
    EngagementViewCategory1: 'ENGAGEMENT_VIEW_CATEGORY_1',
    EngagementAppInstall1: 'ENGAGEMENT_APP_INSTALL_1',
    EngagementUnknown1: 'ENGAGEMENT_UNKNOWN_1',
    ClickPageVisit1: 'CLICK_PAGE_VISIT_1',
    ClickSignup1: 'CLICK_SIGNUP_1',
    ClickCheckout1: 'CLICK_CHECKOUT_1',
    ClickCustom1: 'CLICK_CUSTOM_1',
    ClickAddToCart1: 'CLICK_ADD_TO_CART_1',
    ClickLead1: 'CLICK_LEAD_1',
    ClickSearch1: 'CLICK_SEARCH_1',
    ClickWatchVideo1: 'CLICK_WATCH_VIDEO_1',
    ClickViewCategory1: 'CLICK_VIEW_CATEGORY_1',
    ClickAppInstall1: 'CLICK_APP_INSTALL_1',
    ClickUnknown1: 'CLICK_UNKNOWN_1',
    ViewPageVisit1: 'VIEW_PAGE_VISIT_1',
    ViewSignup1: 'VIEW_SIGNUP_1',
    ViewCheckout1: 'VIEW_CHECKOUT_1',
    ViewCustom1: 'VIEW_CUSTOM_1',
    ViewAddToCart1: 'VIEW_ADD_TO_CART_1',
    ViewLead1: 'VIEW_LEAD_1',
    ViewSearch1: 'VIEW_SEARCH_1',
    ViewWatchVideo1: 'VIEW_WATCH_VIDEO_1',
    ViewViewCategory1: 'VIEW_VIEW_CATEGORY_1',
    ViewAppInstall1: 'VIEW_APP_INSTALL_1',
    ViewUnknown1: 'VIEW_UNKNOWN_1',
    Conversions1: 'CONVERSIONS_1',
    EngagementPageVisitValueInMicroDollar1: 'ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR_1',
    EngagementSignupValueInMicroDollar1: 'ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR_1',
    EngagementCheckoutValueInMicroDollar1: 'ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR_1',
    EngagementCustomValueInMicroDollar1: 'ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR_1',
    EngagementAddToCartValueInMicroDollar1: 'ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR_1',
    EngagementLeadValueInMicroDollar1: 'ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR_1',
    EngagementSearchValueInMicroDollar1: 'ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR_1',
    EngagementWatchVideoValueInMicroDollar1: 'ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR_1',
    EngagementViewCategoryValueInMicroDollar1: 'ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR_1',
    EngagementAppInstallValueInMicroDollar1: 'ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR_1',
    EngagementUnknownValueInMicroDollar1: 'ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR_1',
    ClickPageVisitValueInMicroDollar1: 'CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR_1',
    ClickSignupValueInMicroDollar1: 'CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR_1',
    ClickCheckoutValueInMicroDollar1: 'CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR_1',
    ClickCustomValueInMicroDollar1: 'CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR_1',
    ClickAddToCartValueInMicroDollar1: 'CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR_1',
    ClickLeadValueInMicroDollar1: 'CLICK_LEAD_VALUE_IN_MICRO_DOLLAR_1',
    ClickSearchValueInMicroDollar1: 'CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR_1',
    ClickWatchVideoValueInMicroDollar1: 'CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR_1',
    ClickViewCategoryValueInMicroDollar1: 'CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR_1',
    ClickAppInstallValueInMicroDollar1: 'CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR_1',
    ClickUnknownValueInMicroDollar1: 'CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR_1',
    ViewPageVisitValueInMicroDollar1: 'VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR_1',
    ViewSignupValueInMicroDollar1: 'VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR_1',
    ViewCheckoutValueInMicroDollar1: 'VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR_1',
    ViewCustomValueInMicroDollar1: 'VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR_1',
    ViewAddToCartValueInMicroDollar1: 'VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR_1',
    ViewLeadValueInMicroDollar1: 'VIEW_LEAD_VALUE_IN_MICRO_DOLLAR_1',
    ViewSearchValueInMicroDollar1: 'VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR_1',
    ViewWatchVideoValueInMicroDollar1: 'VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR_1',
    ViewViewCategoryValueInMicroDollar1: 'VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR_1',
    ViewAppInstallValueInMicroDollar1: 'VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR_1',
    ViewUnknownValueInMicroDollar1: 'VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR_1',
    ConversionsValueInMicroDollar1: 'CONVERSIONS_VALUE_IN_MICRO_DOLLAR_1',
    EngagementPageVisitQuantity1: 'ENGAGEMENT_PAGE_VISIT_QUANTITY_1',
    EngagementSignupQuantity1: 'ENGAGEMENT_SIGNUP_QUANTITY_1',
    EngagementCheckoutQuantity1: 'ENGAGEMENT_CHECKOUT_QUANTITY_1',
    EngagementCustomQuantity1: 'ENGAGEMENT_CUSTOM_QUANTITY_1',
    EngagementAddToCartQuantity1: 'ENGAGEMENT_ADD_TO_CART_QUANTITY_1',
    EngagementLeadQuantity1: 'ENGAGEMENT_LEAD_QUANTITY_1',
    EngagementSearchQuantity1: 'ENGAGEMENT_SEARCH_QUANTITY_1',
    EngagementWatchVideoQuantity1: 'ENGAGEMENT_WATCH_VIDEO_QUANTITY_1',
    EngagementViewCategoryQuantity1: 'ENGAGEMENT_VIEW_CATEGORY_QUANTITY_1',
    EngagementAppInstallQuantity1: 'ENGAGEMENT_APP_INSTALL_QUANTITY_1',
    EngagementUnknownQuantity1: 'ENGAGEMENT_UNKNOWN_QUANTITY_1',
    ClickPageVisitQuantity1: 'CLICK_PAGE_VISIT_QUANTITY_1',
    ClickSignupQuantity1: 'CLICK_SIGNUP_QUANTITY_1',
    ClickCheckoutQuantity1: 'CLICK_CHECKOUT_QUANTITY_1',
    ClickCustomQuantity1: 'CLICK_CUSTOM_QUANTITY_1',
    ClickAddToCartQuantity1: 'CLICK_ADD_TO_CART_QUANTITY_1',
    ClickLeadQuantity1: 'CLICK_LEAD_QUANTITY_1',
    ClickSearchQuantity1: 'CLICK_SEARCH_QUANTITY_1',
    ClickWatchVideoQuantity1: 'CLICK_WATCH_VIDEO_QUANTITY_1',
    ClickViewCategoryQuantity1: 'CLICK_VIEW_CATEGORY_QUANTITY_1',
    ClickAppInstallQuantity1: 'CLICK_APP_INSTALL_QUANTITY_1',
    ClickUnknownQuantity1: 'CLICK_UNKNOWN_QUANTITY_1',
    ViewPageVisitQuantity1: 'VIEW_PAGE_VISIT_QUANTITY_1',
    ViewSignupQuantity1: 'VIEW_SIGNUP_QUANTITY_1',
    ViewCheckoutQuantity1: 'VIEW_CHECKOUT_QUANTITY_1',
    ViewCustomQuantity1: 'VIEW_CUSTOM_QUANTITY_1',
    ViewAddToCartQuantity1: 'VIEW_ADD_TO_CART_QUANTITY_1',
    ViewLeadQuantity1: 'VIEW_LEAD_QUANTITY_1',
    ViewSearchQuantity1: 'VIEW_SEARCH_QUANTITY_1',
    ViewWatchVideoQuantity1: 'VIEW_WATCH_VIDEO_QUANTITY_1',
    ViewViewCategoryQuantity1: 'VIEW_VIEW_CATEGORY_QUANTITY_1',
    ViewAppInstallQuantity1: 'VIEW_APP_INSTALL_QUANTITY_1',
    ViewUnknownQuantity1: 'VIEW_UNKNOWN_QUANTITY_1',
    ConversionsQuantity1: 'CONVERSIONS_QUANTITY_1',
    EngagementPageVisit2: 'ENGAGEMENT_PAGE_VISIT_2',
    EngagementSignup2: 'ENGAGEMENT_SIGNUP_2',
    EngagementCheckout2: 'ENGAGEMENT_CHECKOUT_2',
    EngagementCustom2: 'ENGAGEMENT_CUSTOM_2',
    EngagementAddToCart2: 'ENGAGEMENT_ADD_TO_CART_2',
    EngagementLead2: 'ENGAGEMENT_LEAD_2',
    EngagementSearch2: 'ENGAGEMENT_SEARCH_2',
    EngagementWatchVideo2: 'ENGAGEMENT_WATCH_VIDEO_2',
    EngagementViewCategory2: 'ENGAGEMENT_VIEW_CATEGORY_2',
    EngagementAppInstall2: 'ENGAGEMENT_APP_INSTALL_2',
    EngagementUnknown2: 'ENGAGEMENT_UNKNOWN_2',
    ClickPageVisit2: 'CLICK_PAGE_VISIT_2',
    ClickSignup2: 'CLICK_SIGNUP_2',
    ClickCheckout2: 'CLICK_CHECKOUT_2',
    ClickCustom2: 'CLICK_CUSTOM_2',
    ClickAddToCart2: 'CLICK_ADD_TO_CART_2',
    ClickLead2: 'CLICK_LEAD_2',
    ClickSearch2: 'CLICK_SEARCH_2',
    ClickWatchVideo2: 'CLICK_WATCH_VIDEO_2',
    ClickViewCategory2: 'CLICK_VIEW_CATEGORY_2',
    ClickAppInstall2: 'CLICK_APP_INSTALL_2',
    ClickUnknown2: 'CLICK_UNKNOWN_2',
    ViewPageVisit2: 'VIEW_PAGE_VISIT_2',
    ViewSignup2: 'VIEW_SIGNUP_2',
    ViewCheckout2: 'VIEW_CHECKOUT_2',
    ViewCustom2: 'VIEW_CUSTOM_2',
    ViewAddToCart2: 'VIEW_ADD_TO_CART_2',
    ViewLead2: 'VIEW_LEAD_2',
    ViewSearch2: 'VIEW_SEARCH_2',
    ViewWatchVideo2: 'VIEW_WATCH_VIDEO_2',
    ViewViewCategory2: 'VIEW_VIEW_CATEGORY_2',
    ViewAppInstall2: 'VIEW_APP_INSTALL_2',
    ViewUnknown2: 'VIEW_UNKNOWN_2',
    Conversions2: 'CONVERSIONS_2',
    EngagementPageVisitValueInMicroDollar2: 'ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR_2',
    EngagementSignupValueInMicroDollar2: 'ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR_2',
    EngagementCheckoutValueInMicroDollar2: 'ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR_2',
    EngagementCustomValueInMicroDollar2: 'ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR_2',
    EngagementAddToCartValueInMicroDollar2: 'ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR_2',
    EngagementLeadValueInMicroDollar2: 'ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR_2',
    EngagementSearchValueInMicroDollar2: 'ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR_2',
    EngagementWatchVideoValueInMicroDollar2: 'ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR_2',
    EngagementViewCategoryValueInMicroDollar2: 'ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR_2',
    EngagementAppInstallValueInMicroDollar2: 'ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR_2',
    EngagementUnknownValueInMicroDollar2: 'ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR_2',
    ClickPageVisitValueInMicroDollar2: 'CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR_2',
    ClickSignupValueInMicroDollar2: 'CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR_2',
    ClickCheckoutValueInMicroDollar2: 'CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR_2',
    ClickCustomValueInMicroDollar2: 'CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR_2',
    ClickAddToCartValueInMicroDollar2: 'CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR_2',
    ClickLeadValueInMicroDollar2: 'CLICK_LEAD_VALUE_IN_MICRO_DOLLAR_2',
    ClickSearchValueInMicroDollar2: 'CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR_2',
    ClickWatchVideoValueInMicroDollar2: 'CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR_2',
    ClickViewCategoryValueInMicroDollar2: 'CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR_2',
    ClickAppInstallValueInMicroDollar2: 'CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR_2',
    ClickUnknownValueInMicroDollar2: 'CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR_2',
    ViewPageVisitValueInMicroDollar2: 'VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR_2',
    ViewSignupValueInMicroDollar2: 'VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR_2',
    ViewCheckoutValueInMicroDollar2: 'VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR_2',
    ViewCustomValueInMicroDollar2: 'VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR_2',
    ViewAddToCartValueInMicroDollar2: 'VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR_2',
    ViewLeadValueInMicroDollar2: 'VIEW_LEAD_VALUE_IN_MICRO_DOLLAR_2',
    ViewSearchValueInMicroDollar2: 'VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR_2',
    ViewWatchVideoValueInMicroDollar2: 'VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR_2',
    ViewViewCategoryValueInMicroDollar2: 'VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR_2',
    ViewAppInstallValueInMicroDollar2: 'VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR_2',
    ViewUnknownValueInMicroDollar2: 'VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR_2',
    ConversionsValueInMicroDollar2: 'CONVERSIONS_VALUE_IN_MICRO_DOLLAR_2',
    EngagementPageVisitQuantity2: 'ENGAGEMENT_PAGE_VISIT_QUANTITY_2',
    EngagementSignupQuantity2: 'ENGAGEMENT_SIGNUP_QUANTITY_2',
    EngagementCheckoutQuantity2: 'ENGAGEMENT_CHECKOUT_QUANTITY_2',
    EngagementCustomQuantity2: 'ENGAGEMENT_CUSTOM_QUANTITY_2',
    EngagementAddToCartQuantity2: 'ENGAGEMENT_ADD_TO_CART_QUANTITY_2',
    EngagementLeadQuantity2: 'ENGAGEMENT_LEAD_QUANTITY_2',
    EngagementSearchQuantity2: 'ENGAGEMENT_SEARCH_QUANTITY_2',
    EngagementWatchVideoQuantity2: 'ENGAGEMENT_WATCH_VIDEO_QUANTITY_2',
    EngagementViewCategoryQuantity2: 'ENGAGEMENT_VIEW_CATEGORY_QUANTITY_2',
    EngagementAppInstallQuantity2: 'ENGAGEMENT_APP_INSTALL_QUANTITY_2',
    EngagementUnknownQuantity2: 'ENGAGEMENT_UNKNOWN_QUANTITY_2',
    ClickPageVisitQuantity2: 'CLICK_PAGE_VISIT_QUANTITY_2',
    ClickSignupQuantity2: 'CLICK_SIGNUP_QUANTITY_2',
    ClickCheckoutQuantity2: 'CLICK_CHECKOUT_QUANTITY_2',
    ClickCustomQuantity2: 'CLICK_CUSTOM_QUANTITY_2',
    ClickAddToCartQuantity2: 'CLICK_ADD_TO_CART_QUANTITY_2',
    ClickLeadQuantity2: 'CLICK_LEAD_QUANTITY_2',
    ClickSearchQuantity2: 'CLICK_SEARCH_QUANTITY_2',
    ClickWatchVideoQuantity2: 'CLICK_WATCH_VIDEO_QUANTITY_2',
    ClickViewCategoryQuantity2: 'CLICK_VIEW_CATEGORY_QUANTITY_2',
    ClickAppInstallQuantity2: 'CLICK_APP_INSTALL_QUANTITY_2',
    ClickUnknownQuantity2: 'CLICK_UNKNOWN_QUANTITY_2',
    ViewPageVisitQuantity2: 'VIEW_PAGE_VISIT_QUANTITY_2',
    ViewSignupQuantity2: 'VIEW_SIGNUP_QUANTITY_2',
    ViewCheckoutQuantity2: 'VIEW_CHECKOUT_QUANTITY_2',
    ViewCustomQuantity2: 'VIEW_CUSTOM_QUANTITY_2',
    ViewAddToCartQuantity2: 'VIEW_ADD_TO_CART_QUANTITY_2',
    ViewLeadQuantity2: 'VIEW_LEAD_QUANTITY_2',
    ViewSearchQuantity2: 'VIEW_SEARCH_QUANTITY_2',
    ViewWatchVideoQuantity2: 'VIEW_WATCH_VIDEO_QUANTITY_2',
    ViewViewCategoryQuantity2: 'VIEW_VIEW_CATEGORY_QUANTITY_2',
    ViewAppInstallQuantity2: 'VIEW_APP_INSTALL_QUANTITY_2',
    ViewUnknownQuantity2: 'VIEW_UNKNOWN_QUANTITY_2',
    ConversionsQuantity2: 'CONVERSIONS_QUANTITY_2',
    TotalEngagementPageVisit: 'TOTAL_ENGAGEMENT_PAGE_VISIT',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementCustom: 'TOTAL_ENGAGEMENT_CUSTOM',
    TotalEngagementAddToCart: 'TOTAL_ENGAGEMENT_ADD_TO_CART',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalEngagementSearch: 'TOTAL_ENGAGEMENT_SEARCH',
    TotalEngagementWatchVideo: 'TOTAL_ENGAGEMENT_WATCH_VIDEO',
    TotalEngagementViewCategory: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY',
    TotalEngagementAppInstall: 'TOTAL_ENGAGEMENT_APP_INSTALL',
    TotalEngagementUnknown: 'TOTAL_ENGAGEMENT_UNKNOWN',
    TotalClickPageVisit: 'TOTAL_CLICK_PAGE_VISIT',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickCustom: 'TOTAL_CLICK_CUSTOM',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalClickSearch: 'TOTAL_CLICK_SEARCH',
    TotalClickWatchVideo: 'TOTAL_CLICK_WATCH_VIDEO',
    TotalClickViewCategory: 'TOTAL_CLICK_VIEW_CATEGORY',
    TotalClickAppInstall: 'TOTAL_CLICK_APP_INSTALL',
    TotalClickUnknown: 'TOTAL_CLICK_UNKNOWN',
    TotalViewPageVisit: 'TOTAL_VIEW_PAGE_VISIT',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewCustom: 'TOTAL_VIEW_CUSTOM',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalViewSearch: 'TOTAL_VIEW_SEARCH',
    TotalViewWatchVideo: 'TOTAL_VIEW_WATCH_VIDEO',
    TotalViewViewCategory: 'TOTAL_VIEW_VIEW_CATEGORY',
    TotalViewAppInstall: 'TOTAL_VIEW_APP_INSTALL',
    TotalViewUnknown: 'TOTAL_VIEW_UNKNOWN',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalWebConversions: 'TOTAL_WEB_CONVERSIONS',
    TotalInappConversions: 'TOTAL_INAPP_CONVERSIONS',
    TotalOfflineConversions: 'TOTAL_OFFLINE_CONVERSIONS',
    TotalEngagementPageVisitValueInMicroDollar: 'TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementPageVisitValueInDollar: 'TOTAL_ENGAGEMENT_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementSignupValueInDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_DOLLAR',
    TotalEngagementCustomValueInMicroDollar: 'TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCustomValueInDollar: 'TOTAL_ENGAGEMENT_CUSTOM_VALUE_IN_DOLLAR',
    TotalEngagementAddToCartValueInMicroDollar: 'TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementAddToCartValueInDollar: 'TOTAL_ENGAGEMENT_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalEngagementLeadValueInMicroDollar: 'TOTAL_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementLeadValueInDollar: 'TOTAL_ENGAGEMENT_LEAD_VALUE_IN_DOLLAR',
    TotalEngagementSearchValueInMicroDollar: 'TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementSearchValueInDollar: 'TOTAL_ENGAGEMENT_SEARCH_VALUE_IN_DOLLAR',
    TotalEngagementWatchVideoValueInMicroDollar: 'TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementWatchVideoValueInDollar: 'TOTAL_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalEngagementViewCategoryValueInMicroDollar: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementViewCategoryValueInDollar: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalEngagementAppInstallValueInMicroDollar: 'TOTAL_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementUnknownValueInMicroDollar: 'TOTAL_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalClickPageVisitValueInMicroDollar: 'TOTAL_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalClickPageVisitValueInDollar: 'TOTAL_CLICK_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_DOLLAR',
    TotalClickCustomValueInMicroDollar: 'TOTAL_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalClickCustomValueInDollar: 'TOTAL_CLICK_CUSTOM_VALUE_IN_DOLLAR',
    TotalClickAddToCartValueInMicroDollar: 'TOTAL_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalClickAddToCartValueInDollar: 'TOTAL_CLICK_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalClickLeadValueInMicroDollar: 'TOTAL_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalClickLeadValueInDollar: 'TOTAL_CLICK_LEAD_VALUE_IN_DOLLAR',
    TotalClickSearchValueInMicroDollar: 'TOTAL_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalClickSearchValueInDollar: 'TOTAL_CLICK_SEARCH_VALUE_IN_DOLLAR',
    TotalClickWatchVideoValueInMicroDollar: 'TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalClickWatchVideoValueInDollar: 'TOTAL_CLICK_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalClickViewCategoryValueInMicroDollar: 'TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalClickViewCategoryValueInDollar: 'TOTAL_CLICK_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalClickAppInstallValueInMicroDollar: 'TOTAL_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalClickUnknownValueInMicroDollar: 'TOTAL_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalViewPageVisitValueInMicroDollar: 'TOTAL_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalViewPageVisitValueInDollar: 'TOTAL_VIEW_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_DOLLAR',
    TotalViewCustomValueInMicroDollar: 'TOTAL_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalViewCustomValueInDollar: 'TOTAL_VIEW_CUSTOM_VALUE_IN_DOLLAR',
    TotalViewAddToCartValueInMicroDollar: 'TOTAL_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalViewAddToCartValueInDollar: 'TOTAL_VIEW_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalViewLeadValueInMicroDollar: 'TOTAL_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalViewLeadValueInDollar: 'TOTAL_VIEW_LEAD_VALUE_IN_DOLLAR',
    TotalViewSearchValueInMicroDollar: 'TOTAL_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalViewSearchValueInDollar: 'TOTAL_VIEW_SEARCH_VALUE_IN_DOLLAR',
    TotalViewWatchVideoValueInMicroDollar: 'TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalViewWatchVideoValueInDollar: 'TOTAL_VIEW_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalViewViewCategoryValueInMicroDollar: 'TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalViewViewCategoryValueInDollar: 'TOTAL_VIEW_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalViewAppInstallValueInMicroDollar: 'TOTAL_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalViewUnknownValueInMicroDollar: 'TOTAL_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalConversionsValueInMicroDollar: 'TOTAL_CONVERSIONS_VALUE_IN_MICRO_DOLLAR',
    TotalConversionsValueInDollar: 'TOTAL_CONVERSIONS_VALUE_IN_DOLLAR',
    TotalEngagementPageVisitQuantity: 'TOTAL_ENGAGEMENT_PAGE_VISIT_QUANTITY',
    TotalEngagementSignupQuantity: 'TOTAL_ENGAGEMENT_SIGNUP_QUANTITY',
    TotalEngagementCheckoutQuantity: 'TOTAL_ENGAGEMENT_CHECKOUT_QUANTITY',
    TotalEngagementCustomQuantity: 'TOTAL_ENGAGEMENT_CUSTOM_QUANTITY',
    TotalEngagementAddToCartQuantity: 'TOTAL_ENGAGEMENT_ADD_TO_CART_QUANTITY',
    TotalEngagementLeadQuantity: 'TOTAL_ENGAGEMENT_LEAD_QUANTITY',
    TotalEngagementSearchQuantity: 'TOTAL_ENGAGEMENT_SEARCH_QUANTITY',
    TotalEngagementWatchVideoQuantity: 'TOTAL_ENGAGEMENT_WATCH_VIDEO_QUANTITY',
    TotalEngagementViewCategoryQuantity: 'TOTAL_ENGAGEMENT_VIEW_CATEGORY_QUANTITY',
    TotalEngagementAppInstallQuantity: 'TOTAL_ENGAGEMENT_APP_INSTALL_QUANTITY',
    TotalEngagementUnknownQuantity: 'TOTAL_ENGAGEMENT_UNKNOWN_QUANTITY',
    TotalClickPageVisitQuantity: 'TOTAL_CLICK_PAGE_VISIT_QUANTITY',
    TotalClickSignupQuantity: 'TOTAL_CLICK_SIGNUP_QUANTITY',
    TotalClickCheckoutQuantity: 'TOTAL_CLICK_CHECKOUT_QUANTITY',
    TotalClickCustomQuantity: 'TOTAL_CLICK_CUSTOM_QUANTITY',
    TotalClickAddToCartQuantity: 'TOTAL_CLICK_ADD_TO_CART_QUANTITY',
    TotalClickLeadQuantity: 'TOTAL_CLICK_LEAD_QUANTITY',
    TotalClickSearchQuantity: 'TOTAL_CLICK_SEARCH_QUANTITY',
    TotalClickWatchVideoQuantity: 'TOTAL_CLICK_WATCH_VIDEO_QUANTITY',
    TotalClickViewCategoryQuantity: 'TOTAL_CLICK_VIEW_CATEGORY_QUANTITY',
    TotalClickAppInstallQuantity: 'TOTAL_CLICK_APP_INSTALL_QUANTITY',
    TotalClickUnknownQuantity: 'TOTAL_CLICK_UNKNOWN_QUANTITY',
    TotalViewPageVisitQuantity: 'TOTAL_VIEW_PAGE_VISIT_QUANTITY',
    TotalViewSignupQuantity: 'TOTAL_VIEW_SIGNUP_QUANTITY',
    TotalViewCheckoutQuantity: 'TOTAL_VIEW_CHECKOUT_QUANTITY',
    TotalViewCustomQuantity: 'TOTAL_VIEW_CUSTOM_QUANTITY',
    TotalViewAddToCartQuantity: 'TOTAL_VIEW_ADD_TO_CART_QUANTITY',
    TotalViewLeadQuantity: 'TOTAL_VIEW_LEAD_QUANTITY',
    TotalViewSearchQuantity: 'TOTAL_VIEW_SEARCH_QUANTITY',
    TotalViewWatchVideoQuantity: 'TOTAL_VIEW_WATCH_VIDEO_QUANTITY',
    TotalViewViewCategoryQuantity: 'TOTAL_VIEW_VIEW_CATEGORY_QUANTITY',
    TotalViewAppInstallQuantity: 'TOTAL_VIEW_APP_INSTALL_QUANTITY',
    TotalViewUnknownQuantity: 'TOTAL_VIEW_UNKNOWN_QUANTITY',
    TotalConversionsQuantity: 'TOTAL_CONVERSIONS_QUANTITY',
    CostPerConversionInDollar: 'COST_PER_CONVERSION_IN_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    AppInstallsCpaBillable: 'APP_INSTALLS_CPA_BILLABLE',
    AppInstallsClick: 'APP_INSTALLS_CLICK',
    AppInstallsCloseuprepin: 'APP_INSTALLS_CLOSEUPREPIN',
    AppInstallsView: 'APP_INSTALLS_VIEW',
    AppInstalls: 'APP_INSTALLS',
    AppInstallsEngagement: 'APP_INSTALLS_ENGAGEMENT',
    AppInstallsClick1: 'APP_INSTALLS_CLICK_1',
    AppInstallsClick2: 'APP_INSTALLS_CLICK_2',
    AppInstallsView1: 'APP_INSTALLS_VIEW_1',
    AppInstallsView2: 'APP_INSTALLS_VIEW_2',
    AppInstallsEngagement1: 'APP_INSTALLS_ENGAGEMENT_1',
    AppInstallsEngagement2: 'APP_INSTALLS_ENGAGEMENT_2',
    AppInstalls1: 'APP_INSTALLS_1',
    AppInstalls2: 'APP_INSTALLS_2',
    CpiInMicroDollar: 'CPI_IN_MICRO_DOLLAR',
    EcpiInMicroDollar: 'ECPI_IN_MICRO_DOLLAR',
    CpiInDollar: 'CPI_IN_DOLLAR',
    EcpiInDollar: 'ECPI_IN_DOLLAR',
    OnsiteCheckoutsCpaBillable1: 'ONSITE_CHECKOUTS_CPA_BILLABLE_1',
    OnsiteCheckoutsCpaBillable2: 'ONSITE_CHECKOUTS_CPA_BILLABLE_2',
    OnsiteCheckoutsCpaBillable: 'ONSITE_CHECKOUTS_CPA_BILLABLE',
    OnsiteCheckoutsValue1: 'ONSITE_CHECKOUTS_VALUE_1',
    OnsiteCheckoutsValue2: 'ONSITE_CHECKOUTS_VALUE_2',
    OnsiteCheckoutsValue: 'ONSITE_CHECKOUTS_VALUE',
    OnsiteCheckouts1: 'ONSITE_CHECKOUTS_1',
    OnsiteCheckouts2: 'ONSITE_CHECKOUTS_2',
    OnsiteCheckouts: 'ONSITE_CHECKOUTS',
    OnsiteCheckoutsValueInMicroDollar1: 'ONSITE_CHECKOUTS_VALUE_IN_MICRO_DOLLAR_1',
    OnsiteCheckoutsValueInMicroDollar2: 'ONSITE_CHECKOUTS_VALUE_IN_MICRO_DOLLAR_2',
    ConversionRate: 'CONVERSION_RATE',
    AverageCheckoutValue: 'AVERAGE_CHECKOUT_VALUE',
    ReturnOnAdvertiserSpend: 'RETURN_ON_ADVERTISER_SPEND',
    BuyButtonClicks1: 'BUY_BUTTON_CLICKS_1',
    BuyButtonClicks2: 'BUY_BUTTON_CLICKS_2',
    TotalBuyButtonClicks: 'TOTAL_BUY_BUTTON_CLICKS',
    OrderDropoffRate: 'ORDER_DROPOFF_RATE',
    OnsiteCheckoutsValueInMicroDollar: 'ONSITE_CHECKOUTS_VALUE_IN_MICRO_DOLLAR',
    OnsiteCheckoutsValueInDollar: 'ONSITE_CHECKOUTS_VALUE_IN_DOLLAR',
    PinPromotionName: 'PIN_PROMOTION_NAME',
    AdName: 'AD_NAME',
    LifetimeImpressionUser1: 'LIFETIME_IMPRESSION_USER_1',
    PinPromotionCampaignId: 'PIN_PROMOTION_CAMPAIGN_ID',
    PinPromotionCampaignName: 'PIN_PROMOTION_CAMPAIGN_NAME',
    PinPromotionCampaignActionType: 'PIN_PROMOTION_CAMPAIGN_ACTION_TYPE',
    TotalLifetimeImpressionUser: 'TOTAL_LIFETIME_IMPRESSION_USER',
    PinPromotionCampaignStatus: 'PIN_PROMOTION_CAMPAIGN_STATUS',
    PinPromotionCampaignManagedStatus: 'PIN_PROMOTION_CAMPAIGN_MANAGED_STATUS',
    PinPromotionCampaignEntityStatus: 'PIN_PROMOTION_CAMPAIGN_ENTITY_STATUS',
    PinPromotionAdGroupId: 'PIN_PROMOTION_AD_GROUP_ID',
    PinPromotionAdGroupName: 'PIN_PROMOTION_AD_GROUP_NAME',
    PinPromotionAdGroupStatus: 'PIN_PROMOTION_AD_GROUP_STATUS',
    PinPromotionAdGroupEntityStatus: 'PIN_PROMOTION_AD_GROUP_ENTITY_STATUS',
    PinPromotionCreativeType: 'PIN_PROMOTION_CREATIVE_TYPE',
    PinPromotionEntityStatus: 'PIN_PROMOTION_ENTITY_STATUS',
    PinPromotionCreativeTypeV2: 'PIN_PROMOTION_CREATIVE_TYPE_V2',
    PinPromotionReviewStatus: 'PIN_PROMOTION_REVIEW_STATUS',
    AdGroupCampaignActionType: 'AD_GROUP_CAMPAIGN_ACTION_TYPE',
    AdGroupCampaignId: 'AD_GROUP_CAMPAIGN_ID',
    AdGroupCampaignName: 'AD_GROUP_CAMPAIGN_NAME',
    AdGroupCampaignStatus: 'AD_GROUP_CAMPAIGN_STATUS',
    AdGroupCreativeType: 'AD_GROUP_CREATIVE_TYPE',
    AdGroupCampaignManagedStatus: 'AD_GROUP_CAMPAIGN_MANAGED_STATUS',
    AdGroupCampaignEntityStatus: 'AD_GROUP_CAMPAIGN_ENTITY_STATUS',
    AdGroupStartDate: 'AD_GROUP_START_DATE',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    AdGroupBidInMicroCurrency: 'AD_GROUP_BID_IN_MICRO_CURRENCY',
    CampaignAdGroupStartDate: 'CAMPAIGN_AD_GROUP_START_DATE',
    CampaignAdGroupEndDate: 'CAMPAIGN_AD_GROUP_END_DATE',
    CampaignNumberOfAdGroups: 'CAMPAIGN_NUMBER_OF_AD_GROUPS',
    AdGroupNumberOfPinPromotions: 'AD_GROUP_NUMBER_OF_PIN_PROMOTIONS',
    TodaySpendInLocalCurrency: 'TODAY_SPEND_IN_LOCAL_CURRENCY',
    TotalLifetimeSpendInLocalCurrency: 'TOTAL_LIFETIME_SPEND_IN_LOCAL_CURRENCY',
    BudgetUtilization: 'BUDGET_UTILIZATION',
    AdGroupOptimization: 'AD_GROUP_OPTIMIZATION',
    InsertionOrder: 'INSERTION_ORDER',
    AdGroupBonusBudget: 'AD_GROUP_BONUS_BUDGET',
    Frequency: 'FREQUENCY',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    CampaignCreativeType: 'CAMPAIGN_CREATIVE_TYPE',
    AdGroupPlacementGroupType: 'AD_GROUP_PLACEMENT_GROUP_TYPE',
    AdGroupIsPrefetchEnabled: 'AD_GROUP_IS_PREFETCH_ENABLED',
    CampaignBudgetOptimization: 'CAMPAIGN_BUDGET_OPTIMIZATION',
    CampaignStartDate: 'CAMPAIGN_START_DATE',
    IsAutomatedCampaign: 'IS_AUTOMATED_CAMPAIGN',
    IsPremiereCampaign: 'IS_PREMIERE_CAMPAIGN',
    FlexibleDailyBudgets: 'FLEXIBLE_DAILY_BUDGETS',
    IsPerformancePlusCampaign: 'IS_PERFORMANCE_PLUS_CAMPAIGN',
    IsDcoFormatEnhancment: 'IS_DCO_FORMAT_ENHANCMENT',
    PercentCrossDeviceConversions: 'PERCENT_CROSS_DEVICE_CONVERSIONS',
    PageVisitPercentCrossDeviceConversions: 'PAGE_VISIT_PERCENT_CROSS_DEVICE_CONVERSIONS',
    SignupPercentCrossDeviceConversions: 'SIGNUP_PERCENT_CROSS_DEVICE_CONVERSIONS',
    CheckoutPercentCrossDeviceConversions: 'CHECKOUT_PERCENT_CROSS_DEVICE_CONVERSIONS',
    CustomPercentCrossDeviceConversions: 'CUSTOM_PERCENT_CROSS_DEVICE_CONVERSIONS',
    AddToCartPercentCrossDeviceConversions: 'ADD_TO_CART_PERCENT_CROSS_DEVICE_CONVERSIONS',
    LeadPercentCrossDeviceConversions: 'LEAD_PERCENT_CROSS_DEVICE_CONVERSIONS',
    SearchPercentCrossDeviceConversions: 'SEARCH_PERCENT_CROSS_DEVICE_CONVERSIONS',
    WatchVideoPercentCrossDeviceConversions: 'WATCH_VIDEO_PERCENT_CROSS_DEVICE_CONVERSIONS',
    ViewCategoryPercentCrossDeviceConversions: 'VIEW_CATEGORY_PERCENT_CROSS_DEVICE_CONVERSIONS',
    AppInstallPercentCrossDeviceConversions: 'APP_INSTALL_PERCENT_CROSS_DEVICE_CONVERSIONS',
    UnknownPercentCrossDeviceConversions: 'UNKNOWN_PERCENT_CROSS_DEVICE_CONVERSIONS',
    TotalDesktopActionToDesktopConversion: 'TOTAL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalDesktopActionToMobileConversion: 'TOTAL_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalDesktopActionToTabletConversion: 'TOTAL_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalMobileActionToDesktopConversion: 'TOTAL_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalMobileActionToMobileConversion: 'TOTAL_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalMobileActionToTabletConversion: 'TOTAL_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalTabletActionToDesktopConversion: 'TOTAL_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalTabletActionToMobileConversion: 'TOTAL_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalTabletActionToTabletConversion: 'TOTAL_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisitDesktopActionToDesktopConversion: 'TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalPageVisitDesktopActionToMobileConversion: 'TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalPageVisitDesktopActionToTabletConversion: 'TOTAL_PAGE_VISIT_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisitMobileActionToDesktopConversion: 'TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalPageVisitMobileActionToMobileConversion: 'TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalPageVisitMobileActionToTabletConversion: 'TOTAL_PAGE_VISIT_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisitTabletActionToDesktopConversion: 'TOTAL_PAGE_VISIT_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalPageVisitTabletActionToMobileConversion: 'TOTAL_PAGE_VISIT_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalPageVisitTabletActionToTabletConversion: 'TOTAL_PAGE_VISIT_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalSignupDesktopActionToDesktopConversion: 'TOTAL_SIGNUP_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalSignupDesktopActionToMobileConversion: 'TOTAL_SIGNUP_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalSignupDesktopActionToTabletConversion: 'TOTAL_SIGNUP_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalSignupMobileActionToDesktopConversion: 'TOTAL_SIGNUP_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalSignupMobileActionToMobileConversion: 'TOTAL_SIGNUP_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalSignupMobileActionToTabletConversion: 'TOTAL_SIGNUP_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalSignupTabletActionToDesktopConversion: 'TOTAL_SIGNUP_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalSignupTabletActionToMobileConversion: 'TOTAL_SIGNUP_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalSignupTabletActionToTabletConversion: 'TOTAL_SIGNUP_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalCheckoutDesktopActionToDesktopConversion: 'TOTAL_CHECKOUT_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalCheckoutDesktopActionToMobileConversion: 'TOTAL_CHECKOUT_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalCheckoutDesktopActionToTabletConversion: 'TOTAL_CHECKOUT_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalCheckoutMobileActionToDesktopConversion: 'TOTAL_CHECKOUT_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalCheckoutMobileActionToMobileConversion: 'TOTAL_CHECKOUT_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalCheckoutMobileActionToTabletConversion: 'TOTAL_CHECKOUT_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalCheckoutTabletActionToDesktopConversion: 'TOTAL_CHECKOUT_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalCheckoutTabletActionToMobileConversion: 'TOTAL_CHECKOUT_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalCheckoutTabletActionToTabletConversion: 'TOTAL_CHECKOUT_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalCustomDesktopActionToDesktopConversion: 'TOTAL_CUSTOM_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalCustomDesktopActionToMobileConversion: 'TOTAL_CUSTOM_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalCustomDesktopActionToTabletConversion: 'TOTAL_CUSTOM_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalCustomMobileActionToDesktopConversion: 'TOTAL_CUSTOM_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalCustomMobileActionToMobileConversion: 'TOTAL_CUSTOM_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalCustomMobileActionToTabletConversion: 'TOTAL_CUSTOM_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalCustomTabletActionToDesktopConversion: 'TOTAL_CUSTOM_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalCustomTabletActionToMobileConversion: 'TOTAL_CUSTOM_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalCustomTabletActionToTabletConversion: 'TOTAL_CUSTOM_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalAddToCartDesktopActionToDesktopConversion: 'TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalAddToCartDesktopActionToMobileConversion: 'TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalAddToCartDesktopActionToTabletConversion: 'TOTAL_ADD_TO_CART_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalAddToCartMobileActionToDesktopConversion: 'TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalAddToCartMobileActionToMobileConversion: 'TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalAddToCartMobileActionToTabletConversion: 'TOTAL_ADD_TO_CART_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalAddToCartTabletActionToDesktopConversion: 'TOTAL_ADD_TO_CART_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalAddToCartTabletActionToMobileConversion: 'TOTAL_ADD_TO_CART_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalAddToCartTabletActionToTabletConversion: 'TOTAL_ADD_TO_CART_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalLeadDesktopActionToDesktopConversion: 'TOTAL_LEAD_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalLeadDesktopActionToMobileConversion: 'TOTAL_LEAD_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalLeadDesktopActionToTabletConversion: 'TOTAL_LEAD_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalLeadMobileActionToDesktopConversion: 'TOTAL_LEAD_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalLeadMobileActionToMobileConversion: 'TOTAL_LEAD_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalLeadMobileActionToTabletConversion: 'TOTAL_LEAD_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalLeadTabletActionToDesktopConversion: 'TOTAL_LEAD_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalLeadTabletActionToMobileConversion: 'TOTAL_LEAD_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalLeadTabletActionToTabletConversion: 'TOTAL_LEAD_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalSearchDesktopActionToDesktopConversion: 'TOTAL_SEARCH_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalSearchDesktopActionToMobileConversion: 'TOTAL_SEARCH_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalSearchDesktopActionToTabletConversion: 'TOTAL_SEARCH_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalSearchMobileActionToDesktopConversion: 'TOTAL_SEARCH_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalSearchMobileActionToMobileConversion: 'TOTAL_SEARCH_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalSearchMobileActionToTabletConversion: 'TOTAL_SEARCH_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalSearchTabletActionToDesktopConversion: 'TOTAL_SEARCH_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalSearchTabletActionToMobileConversion: 'TOTAL_SEARCH_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalSearchTabletActionToTabletConversion: 'TOTAL_SEARCH_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalWatchVideoDesktopActionToDesktopConversion: 'TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalWatchVideoDesktopActionToMobileConversion: 'TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalWatchVideoDesktopActionToTabletConversion: 'TOTAL_WATCH_VIDEO_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalWatchVideoMobileActionToDesktopConversion: 'TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalWatchVideoMobileActionToMobileConversion: 'TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalWatchVideoMobileActionToTabletConversion: 'TOTAL_WATCH_VIDEO_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalWatchVideoTabletActionToDesktopConversion: 'TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalWatchVideoTabletActionToMobileConversion: 'TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalWatchVideoTabletActionToTabletConversion: 'TOTAL_WATCH_VIDEO_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalViewCategoryDesktopActionToDesktopConversion: 'TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalViewCategoryDesktopActionToMobileConversion: 'TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalViewCategoryDesktopActionToTabletConversion: 'TOTAL_VIEW_CATEGORY_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalViewCategoryMobileActionToDesktopConversion: 'TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalViewCategoryMobileActionToMobileConversion: 'TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalViewCategoryMobileActionToTabletConversion: 'TOTAL_VIEW_CATEGORY_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalViewCategoryTabletActionToDesktopConversion: 'TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalViewCategoryTabletActionToMobileConversion: 'TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalViewCategoryTabletActionToTabletConversion: 'TOTAL_VIEW_CATEGORY_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalAppInstallDesktopActionToDesktopConversion: 'TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalAppInstallDesktopActionToMobileConversion: 'TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalAppInstallDesktopActionToTabletConversion: 'TOTAL_APP_INSTALL_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalAppInstallMobileActionToDesktopConversion: 'TOTAL_APP_INSTALL_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalAppInstallMobileActionToMobileConversion: 'TOTAL_APP_INSTALL_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalAppInstallMobileActionToTabletConversion: 'TOTAL_APP_INSTALL_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalAppInstallTabletActionToDesktopConversion: 'TOTAL_APP_INSTALL_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalAppInstallTabletActionToMobileConversion: 'TOTAL_APP_INSTALL_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalAppInstallTabletActionToTabletConversion: 'TOTAL_APP_INSTALL_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalUnknownDesktopActionToDesktopConversion: 'TOTAL_UNKNOWN_DESKTOP_ACTION_TO_DESKTOP_CONVERSION',
    TotalUnknownDesktopActionToMobileConversion: 'TOTAL_UNKNOWN_DESKTOP_ACTION_TO_MOBILE_CONVERSION',
    TotalUnknownDesktopActionToTabletConversion: 'TOTAL_UNKNOWN_DESKTOP_ACTION_TO_TABLET_CONVERSION',
    TotalUnknownMobileActionToDesktopConversion: 'TOTAL_UNKNOWN_MOBILE_ACTION_TO_DESKTOP_CONVERSION',
    TotalUnknownMobileActionToMobileConversion: 'TOTAL_UNKNOWN_MOBILE_ACTION_TO_MOBILE_CONVERSION',
    TotalUnknownMobileActionToTabletConversion: 'TOTAL_UNKNOWN_MOBILE_ACTION_TO_TABLET_CONVERSION',
    TotalUnknownTabletActionToDesktopConversion: 'TOTAL_UNKNOWN_TABLET_ACTION_TO_DESKTOP_CONVERSION',
    TotalUnknownTabletActionToMobileConversion: 'TOTAL_UNKNOWN_TABLET_ACTION_TO_MOBILE_CONVERSION',
    TotalUnknownTabletActionToTabletConversion: 'TOTAL_UNKNOWN_TABLET_ACTION_TO_TABLET_CONVERSION',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalAddToCart: 'TOTAL_ADD_TO_CART',
    TotalLead: 'TOTAL_LEAD',
    TotalSearch: 'TOTAL_SEARCH',
    TotalWatchVideo: 'TOTAL_WATCH_VIDEO',
    TotalViewCategory: 'TOTAL_VIEW_CATEGORY',
    TotalAppInstall: 'TOTAL_APP_INSTALL',
    TotalUnknown: 'TOTAL_UNKNOWN',
    TotalPageVisitValueInMicroDollar: 'TOTAL_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalAddToCartValueInMicroDollar: 'TOTAL_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalLeadValueInMicroDollar: 'TOTAL_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalSearchValueInMicroDollar: 'TOTAL_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWatchVideoValueInMicroDollar: 'TOTAL_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalViewCategoryValueInMicroDollar: 'TOTAL_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalAppInstallValueInMicroDollar: 'TOTAL_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalUnknownValueInMicroDollar: 'TOTAL_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    AveragePageVisitValueInMicroDollar: 'AVERAGE_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    AverageSignupValueInMicroDollar: 'AVERAGE_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    AverageCheckoutValueInMicroDollar: 'AVERAGE_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    AverageCustomValueInMicroDollar: 'AVERAGE_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    AverageAddToCartValueInMicroDollar: 'AVERAGE_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    AverageLeadValueInMicroDollar: 'AVERAGE_LEAD_VALUE_IN_MICRO_DOLLAR',
    AverageSearchValueInMicroDollar: 'AVERAGE_SEARCH_VALUE_IN_MICRO_DOLLAR',
    AverageWatchVideoValueInMicroDollar: 'AVERAGE_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    AverageViewCategoryValueInMicroDollar: 'AVERAGE_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    AverageUnknownValueInMicroDollar: 'AVERAGE_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    AveragePageVisitValueInMicroUsDollar: 'AVERAGE_PAGE_VISIT_VALUE_IN_MICRO_US_DOLLAR',
    AverageSignupValueInMicroUsDollar: 'AVERAGE_SIGNUP_VALUE_IN_MICRO_US_DOLLAR',
    AverageCheckoutValueInMicroUsDollar: 'AVERAGE_CHECKOUT_VALUE_IN_MICRO_US_DOLLAR',
    AverageCustomValueInMicroUsDollar: 'AVERAGE_CUSTOM_VALUE_IN_MICRO_US_DOLLAR',
    AverageAddToCartValueInMicroUsDollar: 'AVERAGE_ADD_TO_CART_VALUE_IN_MICRO_US_DOLLAR',
    AverageLeadValueInMicroUsDollar: 'AVERAGE_LEAD_VALUE_IN_MICRO_US_DOLLAR',
    AverageSearchValueInMicroUsDollar: 'AVERAGE_SEARCH_VALUE_IN_MICRO_US_DOLLAR',
    AverageWatchVideoValueInMicroUsDollar: 'AVERAGE_WATCH_VIDEO_VALUE_IN_MICRO_US_DOLLAR',
    AverageViewCategoryValueInMicroUsDollar: 'AVERAGE_VIEW_CATEGORY_VALUE_IN_MICRO_US_DOLLAR',
    AverageUnknownValueInMicroUsDollar: 'AVERAGE_UNKNOWN_VALUE_IN_MICRO_US_DOLLAR',
    TotalPageVisitValueInMicroUsDollar: 'TOTAL_PAGE_VISIT_VALUE_IN_MICRO_US_DOLLAR',
    TotalSignupValueInMicroUsDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_US_DOLLAR',
    TotalCheckoutValueInMicroUsDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_US_DOLLAR',
    TotalCustomValueInMicroUsDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_US_DOLLAR',
    TotalAddToCartValueInMicroUsDollar: 'TOTAL_ADD_TO_CART_VALUE_IN_MICRO_US_DOLLAR',
    TotalLeadValueInMicroUsDollar: 'TOTAL_LEAD_VALUE_IN_MICRO_US_DOLLAR',
    TotalSearchValueInMicroUsDollar: 'TOTAL_SEARCH_VALUE_IN_MICRO_US_DOLLAR',
    TotalWatchVideoValueInMicroUsDollar: 'TOTAL_WATCH_VIDEO_VALUE_IN_MICRO_US_DOLLAR',
    TotalViewCategoryValueInMicroUsDollar: 'TOTAL_VIEW_CATEGORY_VALUE_IN_MICRO_US_DOLLAR',
    TotalUnknownValueInMicroUsDollar: 'TOTAL_UNKNOWN_VALUE_IN_MICRO_US_DOLLAR',
    TotalPageVisitQuantity: 'TOTAL_PAGE_VISIT_QUANTITY',
    TotalSignupQuantity: 'TOTAL_SIGNUP_QUANTITY',
    TotalCheckoutQuantity: 'TOTAL_CHECKOUT_QUANTITY',
    TotalCustomQuantity: 'TOTAL_CUSTOM_QUANTITY',
    TotalAddToCartQuantity: 'TOTAL_ADD_TO_CART_QUANTITY',
    TotalLeadQuantity: 'TOTAL_LEAD_QUANTITY',
    TotalSearchQuantity: 'TOTAL_SEARCH_QUANTITY',
    TotalWatchVideoQuantity: 'TOTAL_WATCH_VIDEO_QUANTITY',
    TotalViewCategoryQuantity: 'TOTAL_VIEW_CATEGORY_QUANTITY',
    TotalAppInstallQuantity: 'TOTAL_APP_INSTALL_QUANTITY',
    TotalUnknownQuantity: 'TOTAL_UNKNOWN_QUANTITY',
    TotalPageVisitValueInDollar: 'TOTAL_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalSignupValueInDollar: 'TOTAL_SIGNUP_VALUE_IN_DOLLAR',
    TotalCheckoutValueInDollar: 'TOTAL_CHECKOUT_VALUE_IN_DOLLAR',
    TotalCustomValueInDollar: 'TOTAL_CUSTOM_VALUE_IN_DOLLAR',
    TotalAddToCartValueInDollar: 'TOTAL_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalLeadValueInDollar: 'TOTAL_LEAD_VALUE_IN_DOLLAR',
    TotalSearchValueInDollar: 'TOTAL_SEARCH_VALUE_IN_DOLLAR',
    TotalWatchVideoValueInDollar: 'TOTAL_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalViewCategoryValueInDollar: 'TOTAL_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalAppInstallValueInDollar: 'TOTAL_APP_INSTALL_VALUE_IN_DOLLAR',
    TotalUnknownValueInDollar: 'TOTAL_UNKNOWN_VALUE_IN_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    SignupCostPerAction: 'SIGNUP_COST_PER_ACTION',
    CheckoutCostPerAction: 'CHECKOUT_COST_PER_ACTION',
    CustomCostPerAction: 'CUSTOM_COST_PER_ACTION',
    AddToCartCostPerAction: 'ADD_TO_CART_COST_PER_ACTION',
    LeadCostPerAction: 'LEAD_COST_PER_ACTION',
    SearchCostPerAction: 'SEARCH_COST_PER_ACTION',
    WatchVideoCostPerAction: 'WATCH_VIDEO_COST_PER_ACTION',
    ViewCategoryCostPerAction: 'VIEW_CATEGORY_COST_PER_ACTION',
    AppInstallCostPerAction: 'APP_INSTALL_COST_PER_ACTION',
    UnknownCostPerAction: 'UNKNOWN_COST_PER_ACTION',
    AdGroupCpaInMicroCurrency: 'AD_GROUP_CPA_IN_MICRO_CURRENCY',
    PageVisitCostPerActionInUsDollar: 'PAGE_VISIT_COST_PER_ACTION_IN_US_DOLLAR',
    SignupCostPerActionInUsDollar: 'SIGNUP_COST_PER_ACTION_IN_US_DOLLAR',
    CheckoutCostPerActionInUsDollar: 'CHECKOUT_COST_PER_ACTION_IN_US_DOLLAR',
    CustomCostPerActionInUsDollar: 'CUSTOM_COST_PER_ACTION_IN_US_DOLLAR',
    AddToCartCostPerActionInUsDollar: 'ADD_TO_CART_COST_PER_ACTION_IN_US_DOLLAR',
    LeadCostPerActionInUsDollar: 'LEAD_COST_PER_ACTION_IN_US_DOLLAR',
    SearchCostPerActionInUsDollar: 'SEARCH_COST_PER_ACTION_IN_US_DOLLAR',
    WatchVideoCostPerActionInUsDollar: 'WATCH_VIDEO_COST_PER_ACTION_IN_US_DOLLAR',
    ViewCategoryCostPerActionInUsDollar: 'VIEW_CATEGORY_COST_PER_ACTION_IN_US_DOLLAR',
    UnknownCostPerActionInUsDollar: 'UNKNOWN_COST_PER_ACTION_IN_US_DOLLAR',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    SignupRoas: 'SIGNUP_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    AddToCartRoas: 'ADD_TO_CART_ROAS',
    LeadRoas: 'LEAD_ROAS',
    SearchRoas: 'SEARCH_ROAS',
    WatchVideoRoas: 'WATCH_VIDEO_ROAS',
    ViewCategoryRoas: 'VIEW_CATEGORY_ROAS',
    AppInstallRoas: 'APP_INSTALL_ROAS',
    UnknownRoas: 'UNKNOWN_ROAS',
    Roas: 'ROAS',
    ClickRoas: 'CLICK_ROAS',
    EngagementRoas: 'ENGAGEMENT_ROAS',
    ViewRoas: 'VIEW_ROAS',
    Hour: 'HOUR',
    BoardEngagement: 'BOARD_ENGAGEMENT',
    BoardInsertion: 'BOARD_INSERTION',
    BoardImpression: 'BOARD_IMPRESSION',
    BoardFollow: 'BOARD_FOLLOW',
    BoardSend: 'BOARD_SEND',
    BoardHide: 'BOARD_HIDE',
    ProductGroupCampaignId: 'PRODUCT_GROUP_CAMPAIGN_ID',
    ProductGroupCampaignName: 'PRODUCT_GROUP_CAMPAIGN_NAME',
    ProductGroupCampaignActionType: 'PRODUCT_GROUP_CAMPAIGN_ACTION_TYPE',
    ProductGroupCampaignStatus: 'PRODUCT_GROUP_CAMPAIGN_STATUS',
    ProductGroupCampaignManagedStatus: 'PRODUCT_GROUP_CAMPAIGN_MANAGED_STATUS',
    ProductGroupAdGroupId: 'PRODUCT_GROUP_AD_GROUP_ID',
    ProductGroupAdGroupName: 'PRODUCT_GROUP_AD_GROUP_NAME',
    ProductGroupAdGroupStatus: 'PRODUCT_GROUP_AD_GROUP_STATUS',
    PromotedCatalogProductGroupReferenceId: 'PROMOTED_CATALOG_PRODUCT_GROUP_REFERENCE_ID',
    PromotedCatalogProductGroupReferenceName: 'PROMOTED_CATALOG_PRODUCT_GROUP_REFERENCE_NAME',
    PromotedCatalogProductGroupId: 'PROMOTED_CATALOG_PRODUCT_GROUP_ID',
    PromotedCatalogProductGroupBidInMicroCurrency: 'PROMOTED_CATALOG_PRODUCT_GROUP_BID_IN_MICRO_CURRENCY',
    PromotedCatalogProductGroupStatus: 'PROMOTED_CATALOG_PRODUCT_GROUP_STATUS',
    PromotedCatalogProductGroupEntityStatus: 'PROMOTED_CATALOG_PRODUCT_GROUP_ENTITY_STATUS',
    PromotedCatalogProductGroupCampaignId: 'PROMOTED_CATALOG_PRODUCT_GROUP_CAMPAIGN_ID',
    PromotedCatalogProductGroupCampaignName: 'PROMOTED_CATALOG_PRODUCT_GROUP_CAMPAIGN_NAME',
    PromotedCatalogProductGroupCampaignActionType: 'PROMOTED_CATALOG_PRODUCT_GROUP_CAMPAIGN_ACTION_TYPE',
    PromotedCatalogProductGroupCampaignStatus: 'PROMOTED_CATALOG_PRODUCT_GROUP_CAMPAIGN_STATUS',
    PromotedCatalogProductGroupCampaignManagedStatus: 'PROMOTED_CATALOG_PRODUCT_GROUP_CAMPAIGN_MANAGED_STATUS',
    PromotedCatalogProductGroupAdGroupId: 'PROMOTED_CATALOG_PRODUCT_GROUP_AD_GROUP_ID',
    PromotedCatalogProductGroupAdGroupName: 'PROMOTED_CATALOG_PRODUCT_GROUP_AD_GROUP_NAME',
    PromotedCatalogProductGroupAdGroupStatus: 'PROMOTED_CATALOG_PRODUCT_GROUP_AD_GROUP_STATUS',
    PromotedCatalogProductGroupTrackingTemplateUrl: 'PROMOTED_CATALOG_PRODUCT_GROUP_TRACKING_TEMPLATE_URL',
    Video3SecViews1: 'VIDEO_3SEC_VIEWS_1',
    VideoP0Complete1: 'VIDEO_P0_COMPLETE_1',
    VideoP25Complete1: 'VIDEO_P25_COMPLETE_1',
    VideoP50Complete1: 'VIDEO_P50_COMPLETE_1',
    VideoP75Complete1: 'VIDEO_P75_COMPLETE_1',
    VideoP95Complete1: 'VIDEO_P95_COMPLETE_1',
    VideoP97Complete1: 'VIDEO_P97_COMPLETE_1',
    VideoP100Complete1: 'VIDEO_P100_COMPLETE_1',
    VideoP0Combined1: 'VIDEO_P0_COMBINED_1',
    VideoP25Combined1: 'VIDEO_P25_COMBINED_1',
    VideoP50Combined1: 'VIDEO_P50_COMBINED_1',
    VideoP75Combined1: 'VIDEO_P75_COMBINED_1',
    VideoP95Combined1: 'VIDEO_P95_COMBINED_1',
    VideoP97Combined1: 'VIDEO_P97_COMBINED_1',
    VideoP100Combined1: 'VIDEO_P100_COMBINED_1',
    VideoAvgWatchtime1: 'VIDEO_AVG_WATCHTIME_1',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    VideoViewRate1: 'VIDEO_VIEW_RATE_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP0Complete2: 'VIDEO_P0_COMPLETE_2',
    VideoP25Complete2: 'VIDEO_P25_COMPLETE_2',
    VideoP50Complete2: 'VIDEO_P50_COMPLETE_2',
    VideoP75Complete2: 'VIDEO_P75_COMPLETE_2',
    VideoP95Complete2: 'VIDEO_P95_COMPLETE_2',
    VideoP97Complete2: 'VIDEO_P97_COMPLETE_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoP97Combined2: 'VIDEO_P97_COMBINED_2',
    VideoP100Combined2: 'VIDEO_P100_COMBINED_2',
    VideoAvgWatchtime2: 'VIDEO_AVG_WATCHTIME_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    VideoViewRate2: 'VIDEO_VIEW_RATE_2',
    PaidVideoView: 'PAID_VIDEO_VIEW',
    PaidVideoImpression: 'PAID_VIDEO_IMPRESSION',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    CpvInMicroDollar: 'CPV_IN_MICRO_DOLLAR',
    CpvInDollar: 'CPV_IN_DOLLAR',
    Cp3SvInMicroDollar: 'CP3SV_IN_MICRO_DOLLAR',
    Cp3SvInDollar: 'CP3SV_IN_DOLLAR',
    EcpvInMicroDollar: 'ECPV_IN_MICRO_DOLLAR',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    Ecp3SvInMicroDollar: 'ECP3SV_IN_MICRO_DOLLAR',
    Ecp3SvInDollar: 'ECP3SV_IN_DOLLAR',
    CpcvInDollar: 'CPCV_IN_DOLLAR',
    CpcvInMicroDollar: 'CPCV_IN_MICRO_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvInMicroDollar: 'ECPCV_IN_MICRO_DOLLAR',
    CpcvP95InDollar: 'CPCV_P95_IN_DOLLAR',
    CpcvP95InMicroDollar: 'CPCV_P95_IN_MICRO_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    EcpcvP95InMicroDollar: 'ECPCV_P95_IN_MICRO_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP0Complete: 'TOTAL_VIDEO_P0_COMPLETE',
    TotalVideoP25Complete: 'TOTAL_VIDEO_P25_COMPLETE',
    TotalVideoP50Complete: 'TOTAL_VIDEO_P50_COMPLETE',
    TotalVideoP75Complete: 'TOTAL_VIDEO_P75_COMPLETE',
    TotalVideoP95Complete: 'TOTAL_VIDEO_P95_COMPLETE',
    TotalVideoP97Complete: 'TOTAL_VIDEO_P97_COMPLETE',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoP97Combined: 'TOTAL_VIDEO_P97_COMBINED',
    TotalVideoP100Combined: 'TOTAL_VIDEO_P100_COMBINED',
    TotalVideoAvgWatchtime: 'TOTAL_VIDEO_AVG_WATCHTIME',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoViewRate: 'TOTAL_VIDEO_VIEW_RATE',
    VideoV50Watchtime1: 'VIDEO_V50_WATCHTIME_1',
    VideoV50Watchtime2: 'VIDEO_V50_WATCHTIME_2',
    TotalVideoV50Watchtime: 'TOTAL_VIDEO_V50_WATCHTIME',
    VideoSumV50WatchtimeInMillisecond1: 'VIDEO_SUM_V50_WATCHTIME_IN_MILLISECOND_1',
    VideoSumV50WatchtimeInMillisecond2: 'VIDEO_SUM_V50_WATCHTIME_IN_MILLISECOND_2',
    TotalVideoSumV50WatchtimeInMillisecond: 'TOTAL_VIDEO_SUM_V50_WATCHTIME_IN_MILLISECOND',
    VideoSumV50WatchtimeInSecond1: 'VIDEO_SUM_V50_WATCHTIME_IN_SECOND_1',
    VideoSumV50WatchtimeInSecond2: 'VIDEO_SUM_V50_WATCHTIME_IN_SECOND_2',
    TotalVideoSumV50WatchtimeInSecond: 'TOTAL_VIDEO_SUM_V50_WATCHTIME_IN_SECOND',
    VideoAvgWatchtimeInMillisecond1: 'VIDEO_AVG_WATCHTIME_IN_MILLISECOND_1',
    VideoAvgWatchtimeInMillisecond2: 'VIDEO_AVG_WATCHTIME_IN_MILLISECOND_2',
    TotalVideoAvgWatchtimeInMillisecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_MILLISECOND',
    VideoAvgWatchtimeInSecond1: 'VIDEO_AVG_WATCHTIME_IN_SECOND_1',
    VideoAvgWatchtimeInSecond2: 'VIDEO_AVG_WATCHTIME_IN_SECOND_2',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    DeliveryStatusNoFanout: 'DELIVERY_STATUS_NO_FANOUT',
    DeliveryStatusWithFanout: 'DELIVERY_STATUS_WITH_FANOUT',
    KeywordCompetitionBand: 'KEYWORD_COMPETITION_BAND',
    KeywordQueryVolume: 'KEYWORD_QUERY_VOLUME',
    KeywordValue: 'KEYWORD_VALUE',
    KeywordMatchType: 'KEYWORD_MATCH_TYPE',
    KeywordBidInMicroCurrency: 'KEYWORD_BID_IN_MICRO_CURRENCY',
    KeywordUserQuery: 'KEYWORD_USER_QUERY',
    KeywordSqrKeywordValue: 'KEYWORD_SQR_KEYWORD_VALUE',
    KeywordAdGroupId: 'KEYWORD_AD_GROUP_ID',
    KeywordAdGroupName: 'KEYWORD_AD_GROUP_NAME',
    KeywordCampaignId: 'KEYWORD_CAMPAIGN_ID',
    KeywordCampaignName: 'KEYWORD_CAMPAIGN_NAME',
    KeywordSearchTermAdGroupId: 'KEYWORD_SEARCH_TERM_AD_GROUP_ID',
    KeywordSearchTermAdGroupName: 'KEYWORD_SEARCH_TERM_AD_GROUP_NAME',
    KeywordSearchTermCampaignId: 'KEYWORD_SEARCH_TERM_CAMPAIGN_ID',
    KeywordSearchTermCampaignName: 'KEYWORD_SEARCH_TERM_CAMPAIGN_NAME',
    NegativeKeywordAdGroupId: 'NEGATIVE_KEYWORD_AD_GROUP_ID',
    NegativeKeywordAdGroupName: 'NEGATIVE_KEYWORD_AD_GROUP_NAME',
    NegativeKeywordCampaignId: 'NEGATIVE_KEYWORD_CAMPAIGN_ID',
    NegativeKeywordCampaignName: 'NEGATIVE_KEYWORD_CAMPAIGN_NAME',
    OneTapV2WebsiteView1: 'ONE_TAP_V2_WEBSITE_VIEW_1',
    OneTapV2WebsiteView2: 'ONE_TAP_V2_WEBSITE_VIEW_2',
    TotalOneTapV2WebsiteView: 'TOTAL_ONE_TAP_V2_WEBSITE_VIEW',
    OneTapV2WebsiteViewUser1: 'ONE_TAP_V2_WEBSITE_VIEW_USER_1',
    OneTapV2WebsiteViewUser2: 'ONE_TAP_V2_WEBSITE_VIEW_USER_2',
    TotalLandingPageViews: 'TOTAL_LANDING_PAGE_VIEWS',
    LandingPageViews1: 'LANDING_PAGE_VIEWS_1',
    LandingPageViews2: 'LANDING_PAGE_VIEWS_2',
    CostPerLandingPageView: 'COST_PER_LANDING_PAGE_VIEW',
    LandingPageViewRate: 'LANDING_PAGE_VIEW_RATE',
    TotalDestinationViews: 'TOTAL_DESTINATION_VIEWS',
    DestinationViews1: 'DESTINATION_VIEWS_1',
    DestinationViews2: 'DESTINATION_VIEWS_2',
    CostPerDestinationViewInDollar: 'COST_PER_DESTINATION_VIEW_IN_DOLLAR',
    CostPerDestinationViewInMicroDollar: 'COST_PER_DESTINATION_VIEW_IN_MICRO_DOLLAR',
    DestinationViewRate: 'DESTINATION_VIEW_RATE',
    CarouselSlotIndex: 'CAROUSEL_SLOT_INDEX',
    CarouselId: 'CAROUSEL_ID',
    CarouselSlotPromotionId: 'CAROUSEL_SLOT_PROMOTION_ID',
    CarouselSlotImpression1: 'CAROUSEL_SLOT_IMPRESSION_1',
    CarouselSlotImpression2: 'CAROUSEL_SLOT_IMPRESSION_2',
    TotalCarouselSlotImpression: 'TOTAL_CAROUSEL_SLOT_IMPRESSION',
    CarouselSlotImpressionUser1: 'CAROUSEL_SLOT_IMPRESSION_USER_1',
    CarouselSlotImpressionUser2: 'CAROUSEL_SLOT_IMPRESSION_USER_2',
    CarouselSlotClickthrough1: 'CAROUSEL_SLOT_CLICKTHROUGH_1',
    CarouselSlotClickthrough2: 'CAROUSEL_SLOT_CLICKTHROUGH_2',
    TotalCarouselSlotClickthrough: 'TOTAL_CAROUSEL_SLOT_CLICKTHROUGH',
    CarouselSlotClickthroughUser1: 'CAROUSEL_SLOT_CLICKTHROUGH_USER_1',
    CarouselSlotClickthroughUser2: 'CAROUSEL_SLOT_CLICKTHROUGH_USER_2',
    CarouselSlotSideswipe1: 'CAROUSEL_SLOT_SIDESWIPE_1',
    CarouselSlotSideswipe2: 'CAROUSEL_SLOT_SIDESWIPE_2',
    TotalCarouselSlotSideswipe: 'TOTAL_CAROUSEL_SLOT_SIDESWIPE',
    CarouselSlotSideswipeUser1: 'CAROUSEL_SLOT_SIDESWIPE_USER_1',
    CarouselSlotSideswipeUser2: 'CAROUSEL_SLOT_SIDESWIPE_USER_2',
    CarouselSlotViewWebsite1: 'CAROUSEL_SLOT_VIEW_WEBSITE_1',
    CarouselSlotViewWebsite2: 'CAROUSEL_SLOT_VIEW_WEBSITE_2',
    TotalCarouselSlotViewWebsite: 'TOTAL_CAROUSEL_SLOT_VIEW_WEBSITE',
    CarouselSlotViewWebsiteUser1: 'CAROUSEL_SLOT_VIEW_WEBSITE_USER_1',
    CarouselSlotViewWebsiteUser2: 'CAROUSEL_SLOT_VIEW_WEBSITE_USER_2',
    CollectionPinItemImpression1: 'COLLECTION_PIN_ITEM_IMPRESSION_1',
    CollectionPinItemImpression2: 'COLLECTION_PIN_ITEM_IMPRESSION_2',
    TotalCollectionPinItemImpression: 'TOTAL_COLLECTION_PIN_ITEM_IMPRESSION',
    CollectionPinItemClickthrough1: 'COLLECTION_PIN_ITEM_CLICKTHROUGH_1',
    CollectionPinItemClickthrough2: 'COLLECTION_PIN_ITEM_CLICKTHROUGH_2',
    TotalCollectionPinItemClickthrough: 'TOTAL_COLLECTION_PIN_ITEM_CLICKTHROUGH',
    HoldoutExperiment: 'HOLDOUT_EXPERIMENT',
    AdGroupHoldoutExperiment: 'AD_GROUP_HOLDOUT_EXPERIMENT',
    PinPromotionHoldoutExperiment: 'PIN_PROMOTION_HOLDOUT_EXPERIMENT',
    MultiObjectiveResult: 'MULTI_OBJECTIVE_RESULT',
    MultiObjectiveCost: 'MULTI_OBJECTIVE_COST',
    MultiObjectiveResultDescription: 'MULTI_OBJECTIVE_RESULT_DESCRIPTION',
    MultiObjectiveCostDescription: 'MULTI_OBJECTIVE_COST_DESCRIPTION',
    DateRange: 'DATE_RANGE',
    DateRangeStart: 'DATE_RANGE_START',
    DateRangeEnd: 'DATE_RANGE_END',
    ReportDateStart: 'REPORT_DATE_START',
    ReportDateEnd: 'REPORT_DATE_END',
    PinnerListName: 'PINNER_LIST_NAME',
    PinnerListType: 'PINNER_LIST_TYPE',
    OrderValue: 'ORDER_VALUE',
    OrderQuantity: 'ORDER_QUANTITY',
    AdvertiserName: 'ADVERTISER_NAME',
    AdvertiserCurrency: 'ADVERTISER_CURRENCY',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    SpendYesterdayInDollar: 'SPEND_YESTERDAY_IN_DOLLAR',
    PinPromotionRejectionLabels: 'PIN_PROMOTION_REJECTION_LABELS',
    PinPromotionDestinationUrl: 'PIN_PROMOTION_DESTINATION_URL',
    VideoCompletionRate: 'VIDEO_COMPLETION_RATE',
    CampaignBookingReference: 'CAMPAIGN_BOOKING_REFERENCE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebCheckoutValueInDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckoutValueInDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckoutValueInDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckoutValueInDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    InappCheckoutRoas: 'INAPP_CHECKOUT_ROAS',
    TotalInappCheckout: 'TOTAL_INAPP_CHECKOUT',
    TotalInappCheckoutValueInMicroDollar: 'TOTAL_INAPP_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappCheckoutValueInDollar: 'TOTAL_INAPP_CHECKOUT_VALUE_IN_DOLLAR',
    TotalInappClickCheckout: 'TOTAL_INAPP_CLICK_CHECKOUT',
    TotalInappClickCheckoutValueInMicroDollar: 'TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickCheckoutValueInDollar: 'TOTAL_INAPP_CLICK_CHECKOUT_VALUE_IN_DOLLAR',
    TotalInappEngagementCheckout: 'TOTAL_INAPP_ENGAGEMENT_CHECKOUT',
    TotalInappEngagementCheckoutValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementCheckoutValueInDollar: 'TOTAL_INAPP_ENGAGEMENT_CHECKOUT_VALUE_IN_DOLLAR',
    TotalInappViewCheckout: 'TOTAL_INAPP_VIEW_CHECKOUT',
    TotalInappViewCheckoutValueInMicroDollar: 'TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewCheckoutValueInDollar: 'TOTAL_INAPP_VIEW_CHECKOUT_VALUE_IN_DOLLAR',
    OfflineCheckoutCostPerAction: 'OFFLINE_CHECKOUT_COST_PER_ACTION',
    OfflineCheckoutRoas: 'OFFLINE_CHECKOUT_ROAS',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    TotalOfflineCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineCheckoutValueInDollar: 'TOTAL_OFFLINE_CHECKOUT_VALUE_IN_DOLLAR',
    TotalOfflineClickCheckout: 'TOTAL_OFFLINE_CLICK_CHECKOUT',
    TotalOfflineClickCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickCheckoutValueInDollar: 'TOTAL_OFFLINE_CLICK_CHECKOUT_VALUE_IN_DOLLAR',
    TotalOfflineEngagementCheckout: 'TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT',
    TotalOfflineEngagementCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementCheckoutValueInDollar: 'TOTAL_OFFLINE_ENGAGEMENT_CHECKOUT_VALUE_IN_DOLLAR',
    TotalOfflineViewCheckout: 'TOTAL_OFFLINE_VIEW_CHECKOUT',
    TotalOfflineViewCheckoutValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewCheckoutValueInDollar: 'TOTAL_OFFLINE_VIEW_CHECKOUT_VALUE_IN_DOLLAR',
    PinterestCheckoutCostPerAction: 'PINTEREST_CHECKOUT_COST_PER_ACTION',
    PinterestCheckoutRoas: 'PINTEREST_CHECKOUT_ROAS',
    TotalPinterestCheckout: 'TOTAL_PINTEREST_CHECKOUT',
    TotalPinterestCheckoutValueInMicroDollar: 'TOTAL_PINTEREST_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalPinterestCheckoutValueInDollar: 'TOTAL_PINTEREST_CHECKOUT_VALUE_IN_DOLLAR',
    WebAddToCartCostPerAction: 'WEB_ADD_TO_CART_COST_PER_ACTION',
    WebAddToCartRoas: 'WEB_ADD_TO_CART_ROAS',
    TotalWebAddToCart: 'TOTAL_WEB_ADD_TO_CART',
    TotalWebAddToCartValueInMicroDollar: 'TOTAL_WEB_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebAddToCartValueInDollar: 'TOTAL_WEB_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalWebClickAddToCart: 'TOTAL_WEB_CLICK_ADD_TO_CART',
    TotalWebClickAddToCartValueInMicroDollar: 'TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickAddToCartValueInDollar: 'TOTAL_WEB_CLICK_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalWebEngagementAddToCart: 'TOTAL_WEB_ENGAGEMENT_ADD_TO_CART',
    TotalWebEngagementAddToCartValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewAddToCart: 'TOTAL_WEB_VIEW_ADD_TO_CART',
    TotalWebViewAddToCartValueInMicroDollar: 'TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewAddToCartValueInDollar: 'TOTAL_WEB_VIEW_ADD_TO_CART_VALUE_IN_DOLLAR',
    InappAddToCartCostPerAction: 'INAPP_ADD_TO_CART_COST_PER_ACTION',
    InappAddToCartRoas: 'INAPP_ADD_TO_CART_ROAS',
    TotalInappAddToCart: 'TOTAL_INAPP_ADD_TO_CART',
    TotalInappAddToCartValueInMicroDollar: 'TOTAL_INAPP_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappAddToCartValueInDollar: 'TOTAL_INAPP_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalInappClickAddToCart: 'TOTAL_INAPP_CLICK_ADD_TO_CART',
    TotalInappClickAddToCartValueInMicroDollar: 'TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickAddToCartValueInDollar: 'TOTAL_INAPP_CLICK_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalInappEngagementAddToCart: 'TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART',
    TotalInappEngagementAddToCartValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementAddToCartValueInDollar: 'TOTAL_INAPP_ENGAGEMENT_ADD_TO_CART_VALUE_IN_DOLLAR',
    TotalInappViewAddToCart: 'TOTAL_INAPP_VIEW_ADD_TO_CART',
    TotalInappViewAddToCartValueInMicroDollar: 'TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewAddToCartValueInDollar: 'TOTAL_INAPP_VIEW_ADD_TO_CART_VALUE_IN_DOLLAR',
    WebPageVisitCostPerAction: 'WEB_PAGE_VISIT_COST_PER_ACTION',
    WebPageVisitRoas: 'WEB_PAGE_VISIT_ROAS',
    TotalWebPageVisit: 'TOTAL_WEB_PAGE_VISIT',
    TotalWebPageVisitValueInMicroDollar: 'TOTAL_WEB_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebPageVisitValueInDollar: 'TOTAL_WEB_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalWebClickPageVisit: 'TOTAL_WEB_CLICK_PAGE_VISIT',
    TotalWebClickPageVisitValueInMicroDollar: 'TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickPageVisitValueInDollar: 'TOTAL_WEB_CLICK_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalWebEngagementPageVisit: 'TOTAL_WEB_ENGAGEMENT_PAGE_VISIT',
    TotalWebEngagementPageVisitValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementPageVisitValueInDollar: 'TOTAL_WEB_ENGAGEMENT_PAGE_VISIT_VALUE_IN_DOLLAR',
    TotalWebViewPageVisit: 'TOTAL_WEB_VIEW_PAGE_VISIT',
    TotalWebViewPageVisitValueInMicroDollar: 'TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewPageVisitValueInDollar: 'TOTAL_WEB_VIEW_PAGE_VISIT_VALUE_IN_DOLLAR',
    WebSignupCostPerAction: 'WEB_SIGNUP_COST_PER_ACTION',
    WebSignupRoas: 'WEB_SIGNUP_ROAS',
    TotalWebSignup: 'TOTAL_WEB_SIGNUP',
    TotalWebSignupValueInMicroDollar: 'TOTAL_WEB_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebSignupValueInDollar: 'TOTAL_WEB_SIGNUP_VALUE_IN_DOLLAR',
    TotalWebClickSignup: 'TOTAL_WEB_CLICK_SIGNUP',
    TotalWebClickSignupValueInMicroDollar: 'TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickSignupValueInDollar: 'TOTAL_WEB_CLICK_SIGNUP_VALUE_IN_DOLLAR',
    TotalWebEngagementSignup: 'TOTAL_WEB_ENGAGEMENT_SIGNUP',
    TotalWebEngagementSignupValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementSignupValueInDollar: 'TOTAL_WEB_ENGAGEMENT_SIGNUP_VALUE_IN_DOLLAR',
    TotalWebViewSignup: 'TOTAL_WEB_VIEW_SIGNUP',
    TotalWebViewSignupValueInMicroDollar: 'TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewSignupValueInDollar: 'TOTAL_WEB_VIEW_SIGNUP_VALUE_IN_DOLLAR',
    InappSignupCostPerAction: 'INAPP_SIGNUP_COST_PER_ACTION',
    InappSignupRoas: 'INAPP_SIGNUP_ROAS',
    TotalInappSignup: 'TOTAL_INAPP_SIGNUP',
    TotalInappSignupValueInMicroDollar: 'TOTAL_INAPP_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappSignupValueInDollar: 'TOTAL_INAPP_SIGNUP_VALUE_IN_DOLLAR',
    TotalInappClickSignup: 'TOTAL_INAPP_CLICK_SIGNUP',
    TotalInappClickSignupValueInMicroDollar: 'TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickSignupValueInDollar: 'TOTAL_INAPP_CLICK_SIGNUP_VALUE_IN_DOLLAR',
    TotalInappEngagementSignup: 'TOTAL_INAPP_ENGAGEMENT_SIGNUP',
    TotalInappEngagementSignupValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementSignupValueInDollar: 'TOTAL_INAPP_ENGAGEMENT_SIGNUP_VALUE_IN_DOLLAR',
    TotalInappViewSignup: 'TOTAL_INAPP_VIEW_SIGNUP',
    TotalInappViewSignupValueInMicroDollar: 'TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewSignupValueInDollar: 'TOTAL_INAPP_VIEW_SIGNUP_VALUE_IN_DOLLAR',
    OfflineSignupCostPerAction: 'OFFLINE_SIGNUP_COST_PER_ACTION',
    OfflineSignupRoas: 'OFFLINE_SIGNUP_ROAS',
    TotalOfflineSignup: 'TOTAL_OFFLINE_SIGNUP',
    TotalOfflineSignupValueInMicroDollar: 'TOTAL_OFFLINE_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineSignupValueInDollar: 'TOTAL_OFFLINE_SIGNUP_VALUE_IN_DOLLAR',
    TotalOfflineClickSignup: 'TOTAL_OFFLINE_CLICK_SIGNUP',
    TotalOfflineClickSignupValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickSignupValueInDollar: 'TOTAL_OFFLINE_CLICK_SIGNUP_VALUE_IN_DOLLAR',
    TotalOfflineEngagementSignup: 'TOTAL_OFFLINE_ENGAGEMENT_SIGNUP',
    TotalOfflineEngagementSignupValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementSignupValueInDollar: 'TOTAL_OFFLINE_ENGAGEMENT_SIGNUP_VALUE_IN_DOLLAR',
    TotalOfflineViewSignup: 'TOTAL_OFFLINE_VIEW_SIGNUP',
    TotalOfflineViewSignupValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewSignupValueInDollar: 'TOTAL_OFFLINE_VIEW_SIGNUP_VALUE_IN_DOLLAR',
    WebWatchVideoCostPerAction: 'WEB_WATCH_VIDEO_COST_PER_ACTION',
    WebWatchVideoRoas: 'WEB_WATCH_VIDEO_ROAS',
    TotalWebWatchVideo: 'TOTAL_WEB_WATCH_VIDEO',
    TotalWebWatchVideoValueInMicroDollar: 'TOTAL_WEB_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebWatchVideoValueInDollar: 'TOTAL_WEB_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalWebClickWatchVideo: 'TOTAL_WEB_CLICK_WATCH_VIDEO',
    TotalWebClickWatchVideoValueInMicroDollar: 'TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickWatchVideoValueInDollar: 'TOTAL_WEB_CLICK_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalWebEngagementWatchVideo: 'TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO',
    TotalWebEngagementWatchVideoValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementWatchVideoValueInDollar: 'TOTAL_WEB_ENGAGEMENT_WATCH_VIDEO_VALUE_IN_DOLLAR',
    TotalWebViewWatchVideo: 'TOTAL_WEB_VIEW_WATCH_VIDEO',
    TotalWebViewWatchVideoValueInMicroDollar: 'TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewWatchVideoValueInDollar: 'TOTAL_WEB_VIEW_WATCH_VIDEO_VALUE_IN_DOLLAR',
    WebLeadCostPerAction: 'WEB_LEAD_COST_PER_ACTION',
    WebLeadRoas: 'WEB_LEAD_ROAS',
    TotalWebLead: 'TOTAL_WEB_LEAD',
    TotalWebLeadValueInMicroDollar: 'TOTAL_WEB_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebLeadValueInDollar: 'TOTAL_WEB_LEAD_VALUE_IN_DOLLAR',
    TotalWebClickLead: 'TOTAL_WEB_CLICK_LEAD',
    TotalWebClickLeadValueInMicroDollar: 'TOTAL_WEB_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickLeadValueInDollar: 'TOTAL_WEB_CLICK_LEAD_VALUE_IN_DOLLAR',
    TotalWebEngagementLead: 'TOTAL_WEB_ENGAGEMENT_LEAD',
    TotalWebEngagementLeadValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementLeadValueInDollar: 'TOTAL_WEB_ENGAGEMENT_LEAD_VALUE_IN_DOLLAR',
    TotalWebViewLead: 'TOTAL_WEB_VIEW_LEAD',
    TotalWebViewLeadValueInMicroDollar: 'TOTAL_WEB_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewLeadValueInDollar: 'TOTAL_WEB_VIEW_LEAD_VALUE_IN_DOLLAR',
    OfflineLeadCostPerAction: 'OFFLINE_LEAD_COST_PER_ACTION',
    OfflineLeadRoas: 'OFFLINE_LEAD_ROAS',
    TotalOfflineLead: 'TOTAL_OFFLINE_LEAD',
    TotalOfflineLeadValueInMicroDollar: 'TOTAL_OFFLINE_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineLeadValueInDollar: 'TOTAL_OFFLINE_LEAD_VALUE_IN_DOLLAR',
    TotalOfflineClickLead: 'TOTAL_OFFLINE_CLICK_LEAD',
    TotalOfflineClickLeadValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickLeadValueInDollar: 'TOTAL_OFFLINE_CLICK_LEAD_VALUE_IN_DOLLAR',
    TotalOfflineEngagementLead: 'TOTAL_OFFLINE_ENGAGEMENT_LEAD',
    TotalOfflineEngagementLeadValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementLeadValueInDollar: 'TOTAL_OFFLINE_ENGAGEMENT_LEAD_VALUE_IN_DOLLAR',
    TotalOfflineViewLead: 'TOTAL_OFFLINE_VIEW_LEAD',
    TotalOfflineViewLeadValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewLeadValueInDollar: 'TOTAL_OFFLINE_VIEW_LEAD_VALUE_IN_DOLLAR',
    WebSearchCostPerAction: 'WEB_SEARCH_COST_PER_ACTION',
    WebSearchRoas: 'WEB_SEARCH_ROAS',
    TotalWebSearch: 'TOTAL_WEB_SEARCH',
    TotalWebSearchValueInMicroDollar: 'TOTAL_WEB_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebSearchValueInDollar: 'TOTAL_WEB_SEARCH_VALUE_IN_DOLLAR',
    TotalWebClickSearch: 'TOTAL_WEB_CLICK_SEARCH',
    TotalWebClickSearchValueInMicroDollar: 'TOTAL_WEB_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickSearchValueInDollar: 'TOTAL_WEB_CLICK_SEARCH_VALUE_IN_DOLLAR',
    TotalWebEngagementSearch: 'TOTAL_WEB_ENGAGEMENT_SEARCH',
    TotalWebEngagementSearchValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementSearchValueInDollar: 'TOTAL_WEB_ENGAGEMENT_SEARCH_VALUE_IN_DOLLAR',
    TotalWebViewSearch: 'TOTAL_WEB_VIEW_SEARCH',
    TotalWebViewSearchValueInMicroDollar: 'TOTAL_WEB_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewSearchValueInDollar: 'TOTAL_WEB_VIEW_SEARCH_VALUE_IN_DOLLAR',
    InappSearchCostPerAction: 'INAPP_SEARCH_COST_PER_ACTION',
    InappSearchRoas: 'INAPP_SEARCH_ROAS',
    TotalInappSearch: 'TOTAL_INAPP_SEARCH',
    TotalInappSearchValueInMicroDollar: 'TOTAL_INAPP_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappSearchValueInDollar: 'TOTAL_INAPP_SEARCH_VALUE_IN_DOLLAR',
    TotalInappClickSearch: 'TOTAL_INAPP_CLICK_SEARCH',
    TotalInappClickSearchValueInMicroDollar: 'TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickSearchValueInDollar: 'TOTAL_INAPP_CLICK_SEARCH_VALUE_IN_DOLLAR',
    TotalInappEngagementSearch: 'TOTAL_INAPP_ENGAGEMENT_SEARCH',
    TotalInappEngagementSearchValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementSearchValueInDollar: 'TOTAL_INAPP_ENGAGEMENT_SEARCH_VALUE_IN_DOLLAR',
    TotalInappViewSearch: 'TOTAL_INAPP_VIEW_SEARCH',
    TotalInappViewSearchValueInMicroDollar: 'TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewSearchValueInDollar: 'TOTAL_INAPP_VIEW_SEARCH_VALUE_IN_DOLLAR',
    WebViewCategoryCostPerAction: 'WEB_VIEW_CATEGORY_COST_PER_ACTION',
    WebViewCategoryRoas: 'WEB_VIEW_CATEGORY_ROAS',
    TotalWebViewCategory: 'TOTAL_WEB_VIEW_CATEGORY',
    TotalWebViewCategoryValueInMicroDollar: 'TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCategoryValueInDollar: 'TOTAL_WEB_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalWebClickViewCategory: 'TOTAL_WEB_CLICK_VIEW_CATEGORY',
    TotalWebClickViewCategoryValueInMicroDollar: 'TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickViewCategoryValueInDollar: 'TOTAL_WEB_CLICK_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalWebEngagementViewCategory: 'TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY',
    TotalWebEngagementViewCategoryValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementViewCategoryValueInDollar: 'TOTAL_WEB_ENGAGEMENT_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    TotalWebViewViewCategory: 'TOTAL_WEB_VIEW_VIEW_CATEGORY',
    TotalWebViewViewCategoryValueInMicroDollar: 'TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewViewCategoryValueInDollar: 'TOTAL_WEB_VIEW_VIEW_CATEGORY_VALUE_IN_DOLLAR',
    WebCustomCostPerAction: 'WEB_CUSTOM_COST_PER_ACTION',
    WebCustomRoas: 'WEB_CUSTOM_ROAS',
    TotalWebCustom: 'TOTAL_WEB_CUSTOM',
    TotalWebCustomValueInMicroDollar: 'TOTAL_WEB_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebCustomValueInDollar: 'TOTAL_WEB_CUSTOM_VALUE_IN_DOLLAR',
    TotalWebClickCustom: 'TOTAL_WEB_CLICK_CUSTOM',
    TotalWebClickCustomValueInMicroDollar: 'TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCustomValueInDollar: 'TOTAL_WEB_CLICK_CUSTOM_VALUE_IN_DOLLAR',
    TotalWebEngagementCustom: 'TOTAL_WEB_ENGAGEMENT_CUSTOM',
    TotalWebEngagementCustomValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCustomValueInDollar: 'TOTAL_WEB_ENGAGEMENT_CUSTOM_VALUE_IN_DOLLAR',
    TotalWebViewCustom: 'TOTAL_WEB_VIEW_CUSTOM',
    TotalWebViewCustomValueInMicroDollar: 'TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCustomValueInDollar: 'TOTAL_WEB_VIEW_CUSTOM_VALUE_IN_DOLLAR',
    OfflineCustomCostPerAction: 'OFFLINE_CUSTOM_COST_PER_ACTION',
    OfflineCustomRoas: 'OFFLINE_CUSTOM_ROAS',
    TotalOfflineCustom: 'TOTAL_OFFLINE_CUSTOM',
    TotalOfflineCustomValueInMicroDollar: 'TOTAL_OFFLINE_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineCustomValueInDollar: 'TOTAL_OFFLINE_CUSTOM_VALUE_IN_DOLLAR',
    TotalOfflineClickCustom: 'TOTAL_OFFLINE_CLICK_CUSTOM',
    TotalOfflineClickCustomValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickCustomValueInDollar: 'TOTAL_OFFLINE_CLICK_CUSTOM_VALUE_IN_DOLLAR',
    TotalOfflineEngagementCustom: 'TOTAL_OFFLINE_ENGAGEMENT_CUSTOM',
    TotalOfflineEngagementCustomValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementCustomValueInDollar: 'TOTAL_OFFLINE_ENGAGEMENT_CUSTOM_VALUE_IN_DOLLAR',
    TotalOfflineViewCustom: 'TOTAL_OFFLINE_VIEW_CUSTOM',
    TotalOfflineViewCustomValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewCustomValueInDollar: 'TOTAL_OFFLINE_VIEW_CUSTOM_VALUE_IN_DOLLAR',
    WebUnknownCostPerAction: 'WEB_UNKNOWN_COST_PER_ACTION',
    WebUnknownRoas: 'WEB_UNKNOWN_ROAS',
    TotalWebUnknown: 'TOTAL_WEB_UNKNOWN',
    TotalWebUnknownValueInMicroDollar: 'TOTAL_WEB_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebUnknownValueInDollar: 'TOTAL_WEB_UNKNOWN_VALUE_IN_DOLLAR',
    TotalWebClickUnknown: 'TOTAL_WEB_CLICK_UNKNOWN',
    TotalWebClickUnknownValueInMicroDollar: 'TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickUnknownValueInDollar: 'TOTAL_WEB_CLICK_UNKNOWN_VALUE_IN_DOLLAR',
    TotalWebEngagementUnknown: 'TOTAL_WEB_ENGAGEMENT_UNKNOWN',
    TotalWebEngagementUnknownValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementUnknownValueInDollar: 'TOTAL_WEB_ENGAGEMENT_UNKNOWN_VALUE_IN_DOLLAR',
    TotalWebViewUnknown: 'TOTAL_WEB_VIEW_UNKNOWN',
    TotalWebViewUnknownValueInMicroDollar: 'TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewUnknownValueInDollar: 'TOTAL_WEB_VIEW_UNKNOWN_VALUE_IN_DOLLAR',
    InappUnknownCostPerAction: 'INAPP_UNKNOWN_COST_PER_ACTION',
    InappUnknownRoas: 'INAPP_UNKNOWN_ROAS',
    TotalInappUnknown: 'TOTAL_INAPP_UNKNOWN',
    TotalInappUnknownValueInMicroDollar: 'TOTAL_INAPP_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappUnknownValueInDollar: 'TOTAL_INAPP_UNKNOWN_VALUE_IN_DOLLAR',
    TotalInappClickUnknown: 'TOTAL_INAPP_CLICK_UNKNOWN',
    TotalInappClickUnknownValueInMicroDollar: 'TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickUnknownValueInDollar: 'TOTAL_INAPP_CLICK_UNKNOWN_VALUE_IN_DOLLAR',
    TotalInappEngagementUnknown: 'TOTAL_INAPP_ENGAGEMENT_UNKNOWN',
    TotalInappEngagementUnknownValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementUnknownValueInDollar: 'TOTAL_INAPP_ENGAGEMENT_UNKNOWN_VALUE_IN_DOLLAR',
    TotalInappViewUnknown: 'TOTAL_INAPP_VIEW_UNKNOWN',
    TotalInappViewUnknownValueInMicroDollar: 'TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewUnknownValueInDollar: 'TOTAL_INAPP_VIEW_UNKNOWN_VALUE_IN_DOLLAR',
    OfflineUnknownCostPerAction: 'OFFLINE_UNKNOWN_COST_PER_ACTION',
    OfflineUnknownRoas: 'OFFLINE_UNKNOWN_ROAS',
    TotalOfflineUnknown: 'TOTAL_OFFLINE_UNKNOWN',
    TotalOfflineUnknownValueInMicroDollar: 'TOTAL_OFFLINE_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineUnknownValueInDollar: 'TOTAL_OFFLINE_UNKNOWN_VALUE_IN_DOLLAR',
    TotalOfflineClickUnknown: 'TOTAL_OFFLINE_CLICK_UNKNOWN',
    TotalOfflineClickUnknownValueInMicroDollar: 'TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineClickUnknownValueInDollar: 'TOTAL_OFFLINE_CLICK_UNKNOWN_VALUE_IN_DOLLAR',
    TotalOfflineEngagementUnknown: 'TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN',
    TotalOfflineEngagementUnknownValueInMicroDollar: 'TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineEngagementUnknownValueInDollar: 'TOTAL_OFFLINE_ENGAGEMENT_UNKNOWN_VALUE_IN_DOLLAR',
    TotalOfflineViewUnknown: 'TOTAL_OFFLINE_VIEW_UNKNOWN',
    TotalOfflineViewUnknownValueInMicroDollar: 'TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_MICRO_DOLLAR',
    TotalOfflineViewUnknownValueInDollar: 'TOTAL_OFFLINE_VIEW_UNKNOWN_VALUE_IN_DOLLAR',
    InappAppInstallCostPerAction: 'INAPP_APP_INSTALL_COST_PER_ACTION',
    InappAppInstallRoas: 'INAPP_APP_INSTALL_ROAS',
    TotalInappAppInstall: 'TOTAL_INAPP_APP_INSTALL',
    TotalInappAppInstallValueInMicroDollar: 'TOTAL_INAPP_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappAppInstallValueInDollar: 'TOTAL_INAPP_APP_INSTALL_VALUE_IN_DOLLAR',
    TotalInappClickAppInstall: 'TOTAL_INAPP_CLICK_APP_INSTALL',
    TotalInappClickAppInstallValueInMicroDollar: 'TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappClickAppInstallValueInDollar: 'TOTAL_INAPP_CLICK_APP_INSTALL_VALUE_IN_DOLLAR',
    TotalInappEngagementAppInstall: 'TOTAL_INAPP_ENGAGEMENT_APP_INSTALL',
    TotalInappEngagementAppInstallValueInMicroDollar: 'TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappEngagementAppInstallValueInDollar: 'TOTAL_INAPP_ENGAGEMENT_APP_INSTALL_VALUE_IN_DOLLAR',
    TotalInappViewAppInstall: 'TOTAL_INAPP_VIEW_APP_INSTALL',
    TotalInappViewAppInstallValueInMicroDollar: 'TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_MICRO_DOLLAR',
    TotalInappViewAppInstallValueInDollar: 'TOTAL_INAPP_VIEW_APP_INSTALL_VALUE_IN_DOLLAR',
    IdeaPinPageForward1: 'IDEA_PIN_PAGE_FORWARD_1',
    IdeaPinPageForward2: 'IDEA_PIN_PAGE_FORWARD_2',
    IdeaPinPageBackward1: 'IDEA_PIN_PAGE_BACKWARD_1',
    IdeaPinPageBackward2: 'IDEA_PIN_PAGE_BACKWARD_2',
    TotalIdeaPinPageForward: 'TOTAL_IDEA_PIN_PAGE_FORWARD',
    TotalIdeaPinPageBackward: 'TOTAL_IDEA_PIN_PAGE_BACKWARD',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    CpmInUsDollar: 'CPM_IN_US_DOLLAR',
    EcpcInUsDollar: 'ECPC_IN_US_DOLLAR',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizStarted: 'QUIZ_STARTED',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseSubpageCloseupInternal: '_SHOWCASE_SUBPAGE_CLOSEUP_INTERNAL',
    ShowcaseCardLanding: 'SHOWCASE_CARD_LANDING',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE',
    StandardAdFeedItemId: 'STANDARD_AD_FEED_ITEM_ID',
    IsStandardFeedAd: 'IS_STANDARD_FEED_AD',
    TargetingGender: 'TARGETING_GENDER',
    TargetingCreativeType: 'TARGETING_CREATIVE_TYPE',
    TargetingCountry: 'TARGETING_COUNTRY',
    TargetingLocation: 'TARGETING_LOCATION',
    TargetingApptype: 'TARGETING_APPTYPE',
    TargetingLocationCode: 'TARGETING_LOCATION_CODE',
    TargetingMediaType: 'TARGETING_MEDIA_TYPE',
    TotalConversionProductQuantity: 'TOTAL_CONVERSION_PRODUCT_QUANTITY',
    TotalWebConversionProductQuantity: 'TOTAL_WEB_CONVERSION_PRODUCT_QUANTITY',
    TotalInappConversionProductQuantity: 'TOTAL_INAPP_CONVERSION_PRODUCT_QUANTITY',
    TotalOfflineConversionProductQuantity: 'TOTAL_OFFLINE_CONVERSION_PRODUCT_QUANTITY',
    TotalConversionProductValue: 'TOTAL_CONVERSION_PRODUCT_VALUE',
    TotalWebConversionProductValue: 'TOTAL_WEB_CONVERSION_PRODUCT_VALUE',
    TotalInappConversionProductValue: 'TOTAL_INAPP_CONVERSION_PRODUCT_VALUE',
    TotalOfflineConversionProductValue: 'TOTAL_OFFLINE_CONVERSION_PRODUCT_VALUE',
    TotalConversionProductValueInMicroUnits: 'TOTAL_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebConversionProductValueInMicroUnits: 'TOTAL_WEB_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalInappConversionProductValueInMicroUnits: 'TOTAL_INAPP_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalOfflineConversionProductValueInMicroUnits: 'TOTAL_OFFLINE_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalConversionProductValueInUsd: 'TOTAL_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebConversionProductValueInUsd: 'TOTAL_WEB_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalInappConversionProductValueInUsd: 'TOTAL_INAPP_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalOfflineConversionProductValueInUsd: 'TOTAL_OFFLINE_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalConversionProductValueInMicroUsd: 'TOTAL_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebConversionProductValueInMicroUsd: 'TOTAL_WEB_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalInappConversionProductValueInMicroUsd: 'TOTAL_INAPP_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalOfflineConversionProductValueInMicroUsd: 'TOTAL_OFFLINE_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    ConversionProductCountUnique: 'CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalCheckoutConversionProductQuantity: 'TOTAL_CHECKOUT_CONVERSION_PRODUCT_QUANTITY',
    TotalCheckoutConversionProductValue: 'TOTAL_CHECKOUT_CONVERSION_PRODUCT_VALUE',
    TotalCheckoutConversionProductValueInMicroUnits: 'TOTAL_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalCheckoutConversionProductValueInUsd: 'TOTAL_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalCheckoutConversionProductValueInMicroUsd: 'TOTAL_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebCheckoutConversionProductQuantity: 'TOTAL_WEB_CHECKOUT_CONVERSION_PRODUCT_QUANTITY',
    TotalWebCheckoutConversionProductValue: 'TOTAL_WEB_CHECKOUT_CONVERSION_PRODUCT_VALUE',
    TotalWebCheckoutConversionProductValueInMicroUnits: 'TOTAL_WEB_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebCheckoutConversionProductValueInUsd: 'TOTAL_WEB_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebCheckoutConversionProductValueInMicroUsd: 'TOTAL_WEB_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalInappCheckoutConversionProductQuantity: 'TOTAL_INAPP_CHECKOUT_CONVERSION_PRODUCT_QUANTITY',
    TotalInappCheckoutConversionProductValue: 'TOTAL_INAPP_CHECKOUT_CONVERSION_PRODUCT_VALUE',
    TotalInappCheckoutConversionProductValueInMicroUnits: 'TOTAL_INAPP_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalInappCheckoutConversionProductValueInUsd: 'TOTAL_INAPP_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalInappCheckoutConversionProductValueInMicroUsd: 'TOTAL_INAPP_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalOfflineCheckoutConversionProductQuantity: 'TOTAL_OFFLINE_CHECKOUT_CONVERSION_PRODUCT_QUANTITY',
    TotalOfflineCheckoutConversionProductValue: 'TOTAL_OFFLINE_CHECKOUT_CONVERSION_PRODUCT_VALUE',
    TotalOfflineCheckoutConversionProductValueInMicroUnits: 'TOTAL_OFFLINE_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalOfflineCheckoutConversionProductValueInUsd: 'TOTAL_OFFLINE_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalOfflineCheckoutConversionProductValueInMicroUsd: 'TOTAL_OFFLINE_CHECKOUT_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalAddToCartConversionProductQuantity: 'TOTAL_ADD_TO_CART_CONVERSION_PRODUCT_QUANTITY',
    TotalAddToCartConversionProductValue: 'TOTAL_ADD_TO_CART_CONVERSION_PRODUCT_VALUE',
    TotalAddToCartConversionProductValueInMicroUnits: 'TOTAL_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalAddToCartConversionProductValueInUsd: 'TOTAL_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalAddToCartConversionProductValueInMicroUsd: 'TOTAL_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebAddToCartConversionProductQuantity: 'TOTAL_WEB_ADD_TO_CART_CONVERSION_PRODUCT_QUANTITY',
    TotalWebAddToCartConversionProductValue: 'TOTAL_WEB_ADD_TO_CART_CONVERSION_PRODUCT_VALUE',
    TotalWebAddToCartConversionProductValueInMicroUnits: 'TOTAL_WEB_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebAddToCartConversionProductValueInUsd: 'TOTAL_WEB_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebAddToCartConversionProductValueInMicroUsd: 'TOTAL_WEB_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalInappAddToCartConversionProductQuantity: 'TOTAL_INAPP_ADD_TO_CART_CONVERSION_PRODUCT_QUANTITY',
    TotalInappAddToCartConversionProductValue: 'TOTAL_INAPP_ADD_TO_CART_CONVERSION_PRODUCT_VALUE',
    TotalInappAddToCartConversionProductValueInMicroUnits: 'TOTAL_INAPP_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalInappAddToCartConversionProductValueInUsd: 'TOTAL_INAPP_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalInappAddToCartConversionProductValueInMicroUsd: 'TOTAL_INAPP_ADD_TO_CART_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalPageVisitConversionProductQuantity: 'TOTAL_PAGE_VISIT_CONVERSION_PRODUCT_QUANTITY',
    TotalPageVisitConversionProductValue: 'TOTAL_PAGE_VISIT_CONVERSION_PRODUCT_VALUE',
    TotalPageVisitConversionProductValueInMicroUnits: 'TOTAL_PAGE_VISIT_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalPageVisitConversionProductValueInUsd: 'TOTAL_PAGE_VISIT_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalPageVisitConversionProductValueInMicroUsd: 'TOTAL_PAGE_VISIT_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebPageVisitConversionProductQuantity: 'TOTAL_WEB_PAGE_VISIT_CONVERSION_PRODUCT_QUANTITY',
    TotalWebPageVisitConversionProductValue: 'TOTAL_WEB_PAGE_VISIT_CONVERSION_PRODUCT_VALUE',
    TotalWebPageVisitConversionProductValueInMicroUnits: 'TOTAL_WEB_PAGE_VISIT_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebPageVisitConversionProductValueInUsd: 'TOTAL_WEB_PAGE_VISIT_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebPageVisitConversionProductValueInMicroUsd: 'TOTAL_WEB_PAGE_VISIT_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalSignupConversionProductQuantity: 'TOTAL_SIGNUP_CONVERSION_PRODUCT_QUANTITY',
    TotalSignupConversionProductValue: 'TOTAL_SIGNUP_CONVERSION_PRODUCT_VALUE',
    TotalSignupConversionProductValueInMicroUnits: 'TOTAL_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalSignupConversionProductValueInUsd: 'TOTAL_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalSignupConversionProductValueInMicroUsd: 'TOTAL_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebSignupConversionProductQuantity: 'TOTAL_WEB_SIGNUP_CONVERSION_PRODUCT_QUANTITY',
    TotalWebSignupConversionProductValue: 'TOTAL_WEB_SIGNUP_CONVERSION_PRODUCT_VALUE',
    TotalWebSignupConversionProductValueInMicroUnits: 'TOTAL_WEB_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebSignupConversionProductValueInUsd: 'TOTAL_WEB_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebSignupConversionProductValueInMicroUsd: 'TOTAL_WEB_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalInappSignupConversionProductQuantity: 'TOTAL_INAPP_SIGNUP_CONVERSION_PRODUCT_QUANTITY',
    TotalInappSignupConversionProductValue: 'TOTAL_INAPP_SIGNUP_CONVERSION_PRODUCT_VALUE',
    TotalInappSignupConversionProductValueInMicroUnits: 'TOTAL_INAPP_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalInappSignupConversionProductValueInUsd: 'TOTAL_INAPP_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalInappSignupConversionProductValueInMicroUsd: 'TOTAL_INAPP_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalOfflineSignupConversionProductQuantity: 'TOTAL_OFFLINE_SIGNUP_CONVERSION_PRODUCT_QUANTITY',
    TotalOfflineSignupConversionProductValue: 'TOTAL_OFFLINE_SIGNUP_CONVERSION_PRODUCT_VALUE',
    TotalOfflineSignupConversionProductValueInMicroUnits: 'TOTAL_OFFLINE_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalOfflineSignupConversionProductValueInUsd: 'TOTAL_OFFLINE_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalOfflineSignupConversionProductValueInMicroUsd: 'TOTAL_OFFLINE_SIGNUP_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWatchVideoConversionProductQuantity: 'TOTAL_WATCH_VIDEO_CONVERSION_PRODUCT_QUANTITY',
    TotalWatchVideoConversionProductValue: 'TOTAL_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE',
    TotalWatchVideoConversionProductValueInMicroUnits: 'TOTAL_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWatchVideoConversionProductValueInUsd: 'TOTAL_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWatchVideoConversionProductValueInMicroUsd: 'TOTAL_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebWatchVideoConversionProductQuantity: 'TOTAL_WEB_WATCH_VIDEO_CONVERSION_PRODUCT_QUANTITY',
    TotalWebWatchVideoConversionProductValue: 'TOTAL_WEB_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE',
    TotalWebWatchVideoConversionProductValueInMicroUnits: 'TOTAL_WEB_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebWatchVideoConversionProductValueInUsd: 'TOTAL_WEB_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebWatchVideoConversionProductValueInMicroUsd: 'TOTAL_WEB_WATCH_VIDEO_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalLeadConversionProductQuantity: 'TOTAL_LEAD_CONVERSION_PRODUCT_QUANTITY',
    TotalLeadConversionProductValue: 'TOTAL_LEAD_CONVERSION_PRODUCT_VALUE',
    TotalLeadConversionProductValueInMicroUnits: 'TOTAL_LEAD_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalLeadConversionProductValueInUsd: 'TOTAL_LEAD_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalLeadConversionProductValueInMicroUsd: 'TOTAL_LEAD_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebLeadConversionProductQuantity: 'TOTAL_WEB_LEAD_CONVERSION_PRODUCT_QUANTITY',
    TotalWebLeadConversionProductValue: 'TOTAL_WEB_LEAD_CONVERSION_PRODUCT_VALUE',
    TotalWebLeadConversionProductValueInMicroUnits: 'TOTAL_WEB_LEAD_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebLeadConversionProductValueInUsd: 'TOTAL_WEB_LEAD_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebLeadConversionProductValueInMicroUsd: 'TOTAL_WEB_LEAD_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalOfflineLeadConversionProductQuantity: 'TOTAL_OFFLINE_LEAD_CONVERSION_PRODUCT_QUANTITY',
    TotalOfflineLeadConversionProductValue: 'TOTAL_OFFLINE_LEAD_CONVERSION_PRODUCT_VALUE',
    TotalOfflineLeadConversionProductValueInMicroUnits: 'TOTAL_OFFLINE_LEAD_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalOfflineLeadConversionProductValueInUsd: 'TOTAL_OFFLINE_LEAD_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalOfflineLeadConversionProductValueInMicroUsd: 'TOTAL_OFFLINE_LEAD_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalSearchConversionProductQuantity: 'TOTAL_SEARCH_CONVERSION_PRODUCT_QUANTITY',
    TotalSearchConversionProductValue: 'TOTAL_SEARCH_CONVERSION_PRODUCT_VALUE',
    TotalSearchConversionProductValueInMicroUnits: 'TOTAL_SEARCH_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalSearchConversionProductValueInUsd: 'TOTAL_SEARCH_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalSearchConversionProductValueInMicroUsd: 'TOTAL_SEARCH_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebSearchConversionProductQuantity: 'TOTAL_WEB_SEARCH_CONVERSION_PRODUCT_QUANTITY',
    TotalWebSearchConversionProductValue: 'TOTAL_WEB_SEARCH_CONVERSION_PRODUCT_VALUE',
    TotalWebSearchConversionProductValueInMicroUnits: 'TOTAL_WEB_SEARCH_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebSearchConversionProductValueInUsd: 'TOTAL_WEB_SEARCH_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebSearchConversionProductValueInMicroUsd: 'TOTAL_WEB_SEARCH_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalInappSearchConversionProductQuantity: 'TOTAL_INAPP_SEARCH_CONVERSION_PRODUCT_QUANTITY',
    TotalInappSearchConversionProductValue: 'TOTAL_INAPP_SEARCH_CONVERSION_PRODUCT_VALUE',
    TotalInappSearchConversionProductValueInMicroUnits: 'TOTAL_INAPP_SEARCH_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalInappSearchConversionProductValueInUsd: 'TOTAL_INAPP_SEARCH_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalInappSearchConversionProductValueInMicroUsd: 'TOTAL_INAPP_SEARCH_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalViewCategoryConversionProductQuantity: 'TOTAL_VIEW_CATEGORY_CONVERSION_PRODUCT_QUANTITY',
    TotalViewCategoryConversionProductValue: 'TOTAL_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE',
    TotalViewCategoryConversionProductValueInMicroUnits: 'TOTAL_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalViewCategoryConversionProductValueInUsd: 'TOTAL_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalViewCategoryConversionProductValueInMicroUsd: 'TOTAL_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebViewCategoryConversionProductQuantity: 'TOTAL_WEB_VIEW_CATEGORY_CONVERSION_PRODUCT_QUANTITY',
    TotalWebViewCategoryConversionProductValue: 'TOTAL_WEB_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE',
    TotalWebViewCategoryConversionProductValueInMicroUnits: 'TOTAL_WEB_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebViewCategoryConversionProductValueInUsd: 'TOTAL_WEB_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebViewCategoryConversionProductValueInMicroUsd: 'TOTAL_WEB_VIEW_CATEGORY_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalCustomConversionProductQuantity: 'TOTAL_CUSTOM_CONVERSION_PRODUCT_QUANTITY',
    TotalCustomConversionProductValue: 'TOTAL_CUSTOM_CONVERSION_PRODUCT_VALUE',
    TotalCustomConversionProductValueInMicroUnits: 'TOTAL_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalCustomConversionProductValueInUsd: 'TOTAL_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalCustomConversionProductValueInMicroUsd: 'TOTAL_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebCustomConversionProductQuantity: 'TOTAL_WEB_CUSTOM_CONVERSION_PRODUCT_QUANTITY',
    TotalWebCustomConversionProductValue: 'TOTAL_WEB_CUSTOM_CONVERSION_PRODUCT_VALUE',
    TotalWebCustomConversionProductValueInMicroUnits: 'TOTAL_WEB_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebCustomConversionProductValueInUsd: 'TOTAL_WEB_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebCustomConversionProductValueInMicroUsd: 'TOTAL_WEB_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalOfflineCustomConversionProductQuantity: 'TOTAL_OFFLINE_CUSTOM_CONVERSION_PRODUCT_QUANTITY',
    TotalOfflineCustomConversionProductValue: 'TOTAL_OFFLINE_CUSTOM_CONVERSION_PRODUCT_VALUE',
    TotalOfflineCustomConversionProductValueInMicroUnits: 'TOTAL_OFFLINE_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalOfflineCustomConversionProductValueInUsd: 'TOTAL_OFFLINE_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalOfflineCustomConversionProductValueInMicroUsd: 'TOTAL_OFFLINE_CUSTOM_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalUnknownConversionProductQuantity: 'TOTAL_UNKNOWN_CONVERSION_PRODUCT_QUANTITY',
    TotalUnknownConversionProductValue: 'TOTAL_UNKNOWN_CONVERSION_PRODUCT_VALUE',
    TotalUnknownConversionProductValueInMicroUnits: 'TOTAL_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalUnknownConversionProductValueInUsd: 'TOTAL_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalUnknownConversionProductValueInMicroUsd: 'TOTAL_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalWebUnknownConversionProductQuantity: 'TOTAL_WEB_UNKNOWN_CONVERSION_PRODUCT_QUANTITY',
    TotalWebUnknownConversionProductValue: 'TOTAL_WEB_UNKNOWN_CONVERSION_PRODUCT_VALUE',
    TotalWebUnknownConversionProductValueInMicroUnits: 'TOTAL_WEB_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalWebUnknownConversionProductValueInUsd: 'TOTAL_WEB_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalWebUnknownConversionProductValueInMicroUsd: 'TOTAL_WEB_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalInappUnknownConversionProductQuantity: 'TOTAL_INAPP_UNKNOWN_CONVERSION_PRODUCT_QUANTITY',
    TotalInappUnknownConversionProductValue: 'TOTAL_INAPP_UNKNOWN_CONVERSION_PRODUCT_VALUE',
    TotalInappUnknownConversionProductValueInMicroUnits: 'TOTAL_INAPP_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalInappUnknownConversionProductValueInUsd: 'TOTAL_INAPP_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalInappUnknownConversionProductValueInMicroUsd: 'TOTAL_INAPP_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalOfflineUnknownConversionProductQuantity: 'TOTAL_OFFLINE_UNKNOWN_CONVERSION_PRODUCT_QUANTITY',
    TotalOfflineUnknownConversionProductValue: 'TOTAL_OFFLINE_UNKNOWN_CONVERSION_PRODUCT_VALUE',
    TotalOfflineUnknownConversionProductValueInMicroUnits: 'TOTAL_OFFLINE_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_UNITS',
    TotalOfflineUnknownConversionProductValueInUsd: 'TOTAL_OFFLINE_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_USD',
    TotalOfflineUnknownConversionProductValueInMicroUsd: 'TOTAL_OFFLINE_UNKNOWN_CONVERSION_PRODUCT_VALUE_IN_MICRO_USD',
    TotalCheckoutConversionProductCountUnique: 'TOTAL_CHECKOUT_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebCheckoutConversionProductCountUnique: 'TOTAL_WEB_CHECKOUT_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalInappCheckoutConversionProductCountUnique: 'TOTAL_INAPP_CHECKOUT_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalOfflineCheckoutConversionProductCountUnique: 'TOTAL_OFFLINE_CHECKOUT_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalAddToCartConversionProductCountUnique: 'TOTAL_ADD_TO_CART_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebAddToCartConversionProductCountUnique: 'TOTAL_WEB_ADD_TO_CART_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalInappAddToCartConversionProductCountUnique: 'TOTAL_INAPP_ADD_TO_CART_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalPageVisitConversionProductCountUnique: 'TOTAL_PAGE_VISIT_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebPageVisitConversionProductCountUnique: 'TOTAL_WEB_PAGE_VISIT_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalSignupConversionProductCountUnique: 'TOTAL_SIGNUP_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebSignupConversionProductCountUnique: 'TOTAL_WEB_SIGNUP_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalInappSignupConversionProductCountUnique: 'TOTAL_INAPP_SIGNUP_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalOfflineSignupConversionProductCountUnique: 'TOTAL_OFFLINE_SIGNUP_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWatchVideoConversionProductCountUnique: 'TOTAL_WATCH_VIDEO_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebWatchVideoConversionProductCountUnique: 'TOTAL_WEB_WATCH_VIDEO_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalLeadConversionProductCountUnique: 'TOTAL_LEAD_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebLeadConversionProductCountUnique: 'TOTAL_WEB_LEAD_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalOfflineLeadConversionProductCountUnique: 'TOTAL_OFFLINE_LEAD_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalSearchConversionProductCountUnique: 'TOTAL_SEARCH_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebSearchConversionProductCountUnique: 'TOTAL_WEB_SEARCH_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalInappSearchConversionProductCountUnique: 'TOTAL_INAPP_SEARCH_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalViewCategoryConversionProductCountUnique: 'TOTAL_VIEW_CATEGORY_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebViewCategoryConversionProductCountUnique: 'TOTAL_WEB_VIEW_CATEGORY_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalCustomConversionProductCountUnique: 'TOTAL_CUSTOM_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebCustomConversionProductCountUnique: 'TOTAL_WEB_CUSTOM_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalOfflineCustomConversionProductCountUnique: 'TOTAL_OFFLINE_CUSTOM_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalUnknownConversionProductCountUnique: 'TOTAL_UNKNOWN_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalWebUnknownConversionProductCountUnique: 'TOTAL_WEB_UNKNOWN_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalInappUnknownConversionProductCountUnique: 'TOTAL_INAPP_UNKNOWN_CONVERSION_PRODUCT_COUNT_UNIQUE',
    TotalOfflineUnknownConversionProductCountUnique: 'TOTAL_OFFLINE_UNKNOWN_CONVERSION_PRODUCT_COUNT_UNIQUE'
} as const;

export type TemplateResponseColumnsEnum = typeof TemplateResponseColumnsEnum[keyof typeof TemplateResponseColumnsEnum];
export const TemplateResponseConversionReportTimeTypeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;

export type TemplateResponseConversionReportTimeTypeEnum = typeof TemplateResponseConversionReportTimeTypeEnum[keyof typeof TemplateResponseConversionReportTimeTypeEnum];
export const TemplateResponseCreationSourceEnum = {
    Api: 'ADS_API',
    ManagerReportingPage: 'ADS_MANAGER_REPORTING_PAGE',
    ManagerReportBuilder: 'ADS_MANAGER_REPORT_BUILDER'
} as const;

export type TemplateResponseCreationSourceEnum = typeof TemplateResponseCreationSourceEnum[keyof typeof TemplateResponseCreationSourceEnum];
export const TemplateResponseTypeEnum = {
    Unspecified: 'UNSPECIFIED',
    Bulk: 'BULK',
    Overview: 'OVERVIEW',
    Table: 'TABLE'
} as const;

export type TemplateResponseTypeEnum = typeof TemplateResponseTypeEnum[keyof typeof TemplateResponseTypeEnum];
export const TemplateResponseIngestionSourcesEnum = {
    Tag: 'TAG',
    Mmp: 'MMP',
    FileUpload: 'FILE_UPLOAD',
    ConversionsApi: 'CONVERSIONS_API',
    Native: 'NATIVE'
} as const;

export type TemplateResponseIngestionSourcesEnum = typeof TemplateResponseIngestionSourcesEnum[keyof typeof TemplateResponseIngestionSourcesEnum];

/**
 * 
 * @export
 * @interface TemplateResponseDateRange
 */
export interface TemplateResponseDateRange {
    /**
     * 
     * @type {TemplateResponseDateRangeDynamicDateRange}
     * @memberof TemplateResponseDateRange
     */
    'dynamic_date_range'?: TemplateResponseDateRangeDynamicDateRange | null;
    /**
     * 
     * @type {TemplateResponseDateRangeRelativeDateRange}
     * @memberof TemplateResponseDateRange
     */
    'relative_date_range'?: TemplateResponseDateRangeRelativeDateRange | null;
    /**
     * 
     * @type {TemplateResponseDateRangeAbsoluteDateRange}
     * @memberof TemplateResponseDateRange
     */
    'absolute_date_range'?: TemplateResponseDateRangeAbsoluteDateRange | null;
}
/**
 * The absolute date range of the template
 * @export
 * @interface TemplateResponseDateRangeAbsoluteDateRange
 */
export interface TemplateResponseDateRangeAbsoluteDateRange {
    /**
     * The date range type
     * @type {string}
     * @memberof TemplateResponseDateRangeAbsoluteDateRange
     */
    'type'?: string;
    /**
     * The start date of the date range
     * @type {number}
     * @memberof TemplateResponseDateRangeAbsoluteDateRange
     */
    'start_date'?: number;
    /**
     * The end date of the date range
     * @type {number}
     * @memberof TemplateResponseDateRangeAbsoluteDateRange
     */
    'end_date'?: number;
}
/**
 * The dynamic date range of the template
 * @export
 * @interface TemplateResponseDateRangeDynamicDateRange
 */
export interface TemplateResponseDateRangeDynamicDateRange {
    /**
     * The date range type
     * @type {string}
     * @memberof TemplateResponseDateRangeDynamicDateRange
     */
    'type'?: string;
    /**
     * The dynamic range type
     * @type {string}
     * @memberof TemplateResponseDateRangeDynamicDateRange
     */
    'range'?: TemplateResponseDateRangeDynamicDateRangeRangeEnum;
}

export const TemplateResponseDateRangeDynamicDateRangeRangeEnum = {
    YearToDate: 'YEAR_TO_DATE',
    QuarterToDate: 'QUARTER_TO_DATE',
    MonthToDate: 'MONTH_TO_DATE',
    LastMonth: 'LAST_MONTH'
} as const;

export type TemplateResponseDateRangeDynamicDateRangeRangeEnum = typeof TemplateResponseDateRangeDynamicDateRangeRangeEnum[keyof typeof TemplateResponseDateRangeDynamicDateRangeRangeEnum];

/**
 * The relative date range of the template
 * @export
 * @interface TemplateResponseDateRangeRelativeDateRange
 */
export interface TemplateResponseDateRangeRelativeDateRange {
    /**
     * The date range type
     * @type {string}
     * @memberof TemplateResponseDateRangeRelativeDateRange
     */
    'type'?: string;
    /**
     * The start date of the date range
     * @type {number}
     * @memberof TemplateResponseDateRangeRelativeDateRange
     */
    'start_days_in_past'?: number;
    /**
     * The end date of the date range
     * @type {number}
     * @memberof TemplateResponseDateRangeRelativeDateRange
     */
    'end_days_in_past'?: number;
}
/**
 * 
 * @export
 * @interface TemplatesList200Response
 */
export interface TemplatesList200Response {
    /**
     * 
     * @type {Array<TemplateResponse>}
     * @memberof TemplatesList200Response
     */
    'items': Array<TemplateResponse>;
    /**
     * 
     * @type {string}
     * @memberof TemplatesList200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface TermsOfService
 */
export interface TermsOfService {
    /**
     * The ID of the terms of service
     * @type {string}
     * @memberof TermsOfService
     */
    'id'?: string;
    /**
     * The terms of service content
     * @type {string}
     * @memberof TermsOfService
     */
    'html'?: string | null;
    /**
     * Whether the ad account has accepted terms of service.
     * @type {boolean}
     * @memberof TermsOfService
     */
    'has_accepted'?: boolean;
    /**
     * The ID of the ad account.
     * @type {string}
     * @memberof TermsOfService
     */
    'ad_account_id'?: string;
}
/**
 * 
 * @export
 * @interface TopPinsAnalyticsResponse
 */
export interface TopPinsAnalyticsResponse {
    /**
     * 
     * @type {TopPinsAnalyticsResponseDateAvailability}
     * @memberof TopPinsAnalyticsResponse
     */
    'date_availability'?: TopPinsAnalyticsResponseDateAvailability;
    /**
     * 
     * @type {Array<TopPinsAnalyticsResponsePinsInner>}
     * @memberof TopPinsAnalyticsResponse
     */
    'pins'?: Array<TopPinsAnalyticsResponsePinsInner>;
    /**
     * 
     * @type {string}
     * @memberof TopPinsAnalyticsResponse
     */
    'sort_by'?: TopPinsAnalyticsResponseSortByEnum;
}

export const TopPinsAnalyticsResponseSortByEnum = {
    Engagement: 'ENGAGEMENT',
    Save: 'SAVE',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    PinClick: 'PIN_CLICK'
} as const;

export type TopPinsAnalyticsResponseSortByEnum = typeof TopPinsAnalyticsResponseSortByEnum[keyof typeof TopPinsAnalyticsResponseSortByEnum];

/**
 * 
 * @export
 * @interface TopPinsAnalyticsResponseDateAvailability
 */
export interface TopPinsAnalyticsResponseDateAvailability {
    /**
     * 
     * @type {number}
     * @memberof TopPinsAnalyticsResponseDateAvailability
     */
    'latest_available_timestamp'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof TopPinsAnalyticsResponseDateAvailability
     */
    'is_realtime'?: boolean;
}
/**
 * Array with metrics, status, and pin id for the requested metric
 * @export
 * @interface TopPinsAnalyticsResponsePinsInner
 */
export interface TopPinsAnalyticsResponsePinsInner {
    /**
     * The metric name and daily value for each requested metric
     * @type {{ [key: string]: number; }}
     * @memberof TopPinsAnalyticsResponsePinsInner
     */
    'metrics'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: DataStatus; }}
     * @memberof TopPinsAnalyticsResponsePinsInner
     */
    'data_status'?: { [key: string]: DataStatus; };
    /**
     * The pin id
     * @type {string}
     * @memberof TopPinsAnalyticsResponsePinsInner
     */
    'pin_id'?: string;
}
/**
 * 
 * @export
 * @interface TopVideoPinsAnalyticsResponse
 */
export interface TopVideoPinsAnalyticsResponse {
    /**
     * 
     * @type {TopPinsAnalyticsResponseDateAvailability}
     * @memberof TopVideoPinsAnalyticsResponse
     */
    'date_availability'?: TopPinsAnalyticsResponseDateAvailability;
    /**
     * 
     * @type {Array<TopVideoPinsAnalyticsResponsePinsInner>}
     * @memberof TopVideoPinsAnalyticsResponse
     */
    'pins'?: Array<TopVideoPinsAnalyticsResponsePinsInner>;
    /**
     * 
     * @type {string}
     * @memberof TopVideoPinsAnalyticsResponse
     */
    'sort_by'?: TopVideoPinsAnalyticsResponseSortByEnum;
}

export const TopVideoPinsAnalyticsResponseSortByEnum = {
    Save: 'SAVE',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    VideoMrcView: 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime: 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime: 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView: 'QUARTILE_95_PERCENT_VIEW',
    Video10SView: 'VIDEO_10S_VIEW',
    VideoStart: 'VIDEO_START'
} as const;

export type TopVideoPinsAnalyticsResponseSortByEnum = typeof TopVideoPinsAnalyticsResponseSortByEnum[keyof typeof TopVideoPinsAnalyticsResponseSortByEnum];

/**
 * Array with metrics, status, and pin id for the requested metric
 * @export
 * @interface TopVideoPinsAnalyticsResponsePinsInner
 */
export interface TopVideoPinsAnalyticsResponsePinsInner {
    /**
     * The metric name and daily value for each requested metric
     * @type {{ [key: string]: number; }}
     * @memberof TopVideoPinsAnalyticsResponsePinsInner
     */
    'metrics'?: { [key: string]: number; };
    /**
     * 
     * @type {{ [key: string]: DataStatus; }}
     * @memberof TopVideoPinsAnalyticsResponsePinsInner
     */
    'data_status'?: { [key: string]: DataStatus; };
    /**
     * The pin id
     * @type {string}
     * @memberof TopVideoPinsAnalyticsResponsePinsInner
     */
    'pin_id'?: string;
}
/**
 * Third-party tracking URLs. Up to three tracking URLs - with a max length of 2,000 - are supported for each event type. Tracking URLs set at the ad group or ad level can override those set at the campaign level. For more information, see <a href=\"https://help.pinterest.com/en/business/article/third-party-and-dynamic-tracking\" target=\"_blank\">Third-party and dynamic tracking</a>.
 * @export
 * @interface TrackingUrls
 */
export interface TrackingUrls {
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingUrls
     */
    'impression'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingUrls
     */
    'click'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingUrls
     */
    'engagement'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingUrls
     */
    'buyable_button'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof TrackingUrls
     */
    'audience_verification'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TrendType = {
    Growing: 'growing',
    Monthly: 'monthly',
    Yearly: 'yearly',
    Seasonal: 'seasonal'
} as const;

export type TrendType = typeof TrendType[keyof typeof TrendType];


/**
 * 
 * @export
 * @interface TrendingKeywordsResponse
 */
export interface TrendingKeywordsResponse {
    /**
     * The top trending keywords for the specified trend type in the requested region.<br /> Results are ordered, with the first element in the array representing the #1 top trend.
     * @type {Array<TrendingKeywordsResponseTrendsInner>}
     * @memberof TrendingKeywordsResponse
     */
    'trends'?: Array<TrendingKeywordsResponseTrendsInner>;
}
/**
 * 
 * @export
 * @interface TrendingKeywordsResponseTrendsInner
 */
export interface TrendingKeywordsResponseTrendsInner {
    /**
     * The keyword that is trending.
     * @type {string}
     * @memberof TrendingKeywordsResponseTrendsInner
     */
    'keyword'?: string;
    /**
     * The week-over-week percent change in search volume for this keyword.<br /> For example, a value of \"50\" would represent a 50% increase in searches in the last seven days compared to the week prior.<br /> **Note**: growth rates are rounded, with a maximum of +/- 10000% change.  A value of 10001 indicates that this keyword experienced > 10000% week-over-week growth.
     * @type {number}
     * @memberof TrendingKeywordsResponseTrendsInner
     */
    'pct_growth_wow'?: number;
    /**
     * The month-over-month percent change in search volume for this keyword.<br /> For example, a value of \"400\" would represent a 400% increase in searches in the last 30 days compared to the month prior.<br /> **Note**: growth rates are rounded, with a maximum of +/- 10000% change.  A value of 10001 indicates that this keyword experienced > 10000% month-over-month growth.
     * @type {number}
     * @memberof TrendingKeywordsResponseTrendsInner
     */
    'pct_growth_mom'?: number;
    /**
     * The year-over-year percent change in search volume for this keyword.<br /> For example, a value of \"-5\" would represent a 5% decrease in searches in the last 365 days compared to the month prior.<br /> **Note**: growth rates are rounded, with a maximum of +/- 10000% change.  A value of 10001 indicates that this keyword experienced > 10000% year-over-year growth.
     * @type {number}
     * @memberof TrendingKeywordsResponseTrendsInner
     */
    'pct_growth_yoy'?: number;
    /**
     * 
     * @type {TrendingKeywordsResponseTrendsInnerTimeSeries}
     * @memberof TrendingKeywordsResponseTrendsInner
     */
    'time_series'?: TrendingKeywordsResponseTrendsInnerTimeSeries;
}
/**
 * A sequence of weekly observations of the relative search volume for this keyword over the past year.<br /> These values are normalized to a [0-100] range, and can be used to visualize the history of user interest in this keyword. By default, normalization is applied independently to the time series of each keyword, but the `normalize_against_group` query parameter can be used in cases where you wish to compare relative volume between keywords.<br /> **Note**: The date of each observation is in ISO-8601 format and represents the *end* of the week.  For example, a value of `2023-10-31` would include searches that happened between `2023-10-25` and `2023-10-31`.
 * @export
 * @interface TrendingKeywordsResponseTrendsInnerTimeSeries
 */
export interface TrendingKeywordsResponseTrendsInnerTimeSeries {
    [key: string]: number | any;

    /**
     * 
     * @type {string}
     * @memberof TrendingKeywordsResponseTrendsInnerTimeSeries
     */
    'date'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TrendsSupportedRegion = {
    Us: 'US',
    Ca: 'CA',
    De: 'DE',
    Fr: 'FR',
    Es: 'ES',
    It: 'IT',
    Deatch: 'DE+AT+CH',
    Gbie: 'GB+IE',
    Itesptgrmt: 'IT+ES+PT+GR+MT',
    Plrohuskcz: 'PL+RO+HU+SK+CZ',
    Sedkfino: 'SE+DK+FI+NO',
    Nlbelu: 'NL+BE+LU',
    Ar: 'AR',
    Br: 'BR',
    Co: 'CO',
    Mx: 'MX',
    Mxarcocl: 'MX+AR+CO+CL',
    Aunz: 'AU+NZ'
} as const;

export type TrendsSupportedRegion = typeof TrendsSupportedRegion[keyof typeof TrendsSupportedRegion];


/**
 * 
 * @export
 * @interface UpdatableItemAttributes
 */
export interface UpdatableItemAttributes {
    /**
     * Allows advertisers to specify a separate URL that can be used to track traffic coming from Pinterest shopping ads. Must send full URL including trackingdo not send tracking parameters only. At this time we do not support impression tracking. Must begin with http:// or https://.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'ad_link'?: string | null;
    /**
     * Set this attribute to TRUE if you\'re submitting items that are considered adult. These will not be shown on Pinterest.
     * @type {boolean}
     * @memberof UpdatableItemAttributes
     */
    'adult'?: boolean | null;
    /**
     * The age group to apply a demographic range to the product. Must be one of the following values (upper or lowercased): newborn , infant, toddler, kids, or adult.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'age_group'?: string | null;
    /**
     * The availability of the product. Must be one of the following values (upper or lowercased): in stock, out of stock , preorder.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'availability'?: string;
    /**
     * Average reviews for the item. Can be a number from 1-5.
     * @type {number}
     * @memberof UpdatableItemAttributes
     */
    'average_review_rating'?: number | null;
    /**
     * The brand of the product.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'brand'?: string | null;
    /**
     * This attribute is not supported anymore.
     * @type {boolean}
     * @memberof UpdatableItemAttributes
     * @deprecated
     */
    'checkout_enabled'?: boolean | null;
    /**
     * The primary color of the product.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'color'?: string | null;
    /**
     * The condition of the product. Must be one of the following values (upper or lowercased): new, used, or refurbished.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'condition'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'custom_label_0'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'custom_label_1'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'custom_label_2'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'custom_label_3'?: string | null;
    /**
     * <p><= 1000 characters</p> <p>Custom grouping of products.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'custom_label_4'?: string | null;
    /**
     * <p><= 10000 characters</p> <p>The description of the product.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'description'?: string;
    /**
     * The item is free to ship.
     * @type {boolean}
     * @memberof UpdatableItemAttributes
     */
    'free_shipping_label'?: boolean | null;
    /**
     * The minimum order purchase necessary for the customer to get free shipping. Only relevant if free shipping is offered.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'free_shipping_limit'?: string | null;
    /**
     * The gender associated with the product. Must be one of the following values (upper or lowercased): male, female , or unisex.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'gender'?: string | null;
    /**
     * The categorization of the product based on the standardized Google Product Taxonomy. This is a set taxonomy. Both the text values and numeric codes are accepted.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'google_product_category'?: string | null;
    /**
     * The unique universal product identifier.
     * @type {number}
     * @memberof UpdatableItemAttributes
     */
    'gtin'?: number | null;
    /**
     * <p><= 127 characters</p> <p>The user-created unique ID that represents the product. Only Unicode characters are accepted.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     * @deprecated
     */
    'id'?: string;
    /**
     * <p><= 127 characters</p> <p>The parent ID of the product.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'item_group_id'?: string | null;
    /**
     * The millisecond timestamp when the item was lastly modified by the merchant.
     * @type {number}
     * @memberof UpdatableItemAttributes
     */
    'last_updated_time'?: number | null;
    /**
     * <p><= 511 characters</p> <p>The landing page for the product.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'link'?: string;
    /**
     * The material used to make the product.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'material'?: string | null;
    /**
     * The minimum advertised price of the product. It supports the following formats, \"19.99 USD\", \"19.99USD\" and \"19.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'min_ad_price'?: string | null;
    /**
     * The mobile-optimized version of your landing page. Must begin with http:// or https://.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'mobile_link'?: string | null;
    /**
     * Manufacturer Part Number are alpha-numeric codes created by the manufacturer of a product to uniquely identify it among all products from the same manufacturer.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'mpn'?: string | null;
    /**
     * The number of ratings for the item.
     * @type {number}
     * @memberof UpdatableItemAttributes
     */
    'number_of_ratings'?: number | null;
    /**
     * The number of reviews available for the item.
     * @type {number}
     * @memberof UpdatableItemAttributes
     */
    'number_of_reviews'?: number | null;
    /**
     * The description of the pattern used for the product.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'pattern'?: string | null;
    /**
     * The price of the product. It supports the following formats, \"24.99 USD\", \"24.99USD\" and \"24.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'price'?: string;
    /**
     * <p><= 1000 characters</p> <p>The categorization of your product based on your custom product taxonomy. Subcategories must be sent separated by  > . The > must be wrapped by spaces. We do not recognize any other delimiters such as comma or pipe.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'product_type'?: string | null;
    /**
     * The discounted price of the product. The sale_price must be lower than the price. It supports the following formats, \"14.99 USD\", \"14.99USD\" and \"14.99\". If the currency is not included, we default to US dollars.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'sale_price'?: string | null;
    /**
     * Shipping consists of one group of up to four elements, country, region, service (all optional) and price (required). All colons, even for blank values, are required.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'shipping'?: string | null;
    /**
     * The height of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'shipping_height'?: string | null;
    /**
     * The weight of the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'shipping_weight'?: string | null;
    /**
     * The width of the package needed to ship the product. Ensure there is a space between the numeric string and the metric.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'shipping_width'?: string | null;
    /**
     * The size of the product.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'size'?: string | null;
    /**
     * Indicates the countrys sizing system in which you are submitting your product. Must be one of the following values (upper or lowercased): US, UK, EU, DE , FR, JP, CN, IT,  BR, MEX, or AU.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'size_system'?: string | null;
    /**
     * Additional description for the size. Must be one of the following values (upper or lowercased): regular, petite , plus, big_and_tall, or maternity.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'size_type'?: string | null;
    /**
     * Tax consists of one group of up to four elements, country, region, rate (all required) and tax_ship (optional). All colons, even for blank values, are required.
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'tax'?: string | null;
    /**
     * <p><= 500 characters</p> <p>The name of the product.</p>
     * @type {string}
     * @memberof UpdatableItemAttributes
     */
    'title'?: string;
    /**
     * Options for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed.
     * @type {Array<string>}
     * @memberof UpdatableItemAttributes
     */
    'variant_names'?: Array<string> | null;
    /**
     * Option values for this variant. People will see these options next to your Pin and can select the one they want. List them in the order you want them displayed. The order of the variant values must be consistent with the order of the variant names.
     * @type {Array<string>}
     * @memberof UpdatableItemAttributes
     */
    'variant_values'?: Array<string> | null;
}
/**
 * 
 * @export
 * @interface UpdateAssetGroupBody
 */
export interface UpdateAssetGroupBody {
    /**
     * A list of asset groups and the data that will be used to update them.
     * @type {Array<UpdateAssetGroupBodyAssetGroupsToUpdateInner>}
     * @memberof UpdateAssetGroupBody
     */
    'asset_groups_to_update'?: Array<UpdateAssetGroupBodyAssetGroupsToUpdateInner>;
}
/**
 * 
 * @export
 * @interface UpdateAssetGroupBodyAssetGroupsToUpdateInner
 */
export interface UpdateAssetGroupBodyAssetGroupsToUpdateInner {
    /**
     * Unique identifier of the asset group to update.
     * @type {string}
     * @memberof UpdateAssetGroupBodyAssetGroupsToUpdateInner
     */
    'asset_group_id': string;
    /**
     * Asset Group name
     * @type {string}
     * @memberof UpdateAssetGroupBodyAssetGroupsToUpdateInner
     */
    'name'?: string;
    /**
     * Asset group description
     * @type {string}
     * @memberof UpdateAssetGroupBodyAssetGroupsToUpdateInner
     */
    'description'?: string;
    /**
     * Asset Group Types. Note: The asset group types are used for user reference and categorization purposes only and do not impact the functionality of the asset group.
     * @type {Array<AssetGroupType>}
     * @memberof UpdateAssetGroupBodyAssetGroupsToUpdateInner
     */
    'asset_group_types'?: Array<AssetGroupType>;
    /**
     * A list of asset ids to add to the asset group.
     * @type {Array<string>}
     * @memberof UpdateAssetGroupBodyAssetGroupsToUpdateInner
     */
    'assets_to_add'?: Array<string>;
    /**
     * A list of asset ids to remove from the asset group.
     * @type {Array<string>}
     * @memberof UpdateAssetGroupBodyAssetGroupsToUpdateInner
     */
    'assets_to_remove'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateAssetGroupResponse
 */
export interface UpdateAssetGroupResponse {
    /**
     * A list of successfully edited asset groups.
     * @type {Array<AssetGroupBinding>}
     * @memberof UpdateAssetGroupResponse
     */
    'updated_asset_groups'?: Array<AssetGroupBinding>;
    /**
     * A list of errors associated with the asset groups. Will be returned if there is an error.
     * @type {Array<UpdateAssetGroupResponseExceptionsInner>}
     * @memberof UpdateAssetGroupResponse
     */
    'exceptions'?: Array<UpdateAssetGroupResponseExceptionsInner> | null;
}
/**
 * 
 * @export
 * @interface UpdateAssetGroupResponseExceptionsInner
 */
export interface UpdateAssetGroupResponseExceptionsInner {
    /**
     * Error code associated with the error editing asset group.
     * @type {number}
     * @memberof UpdateAssetGroupResponseExceptionsInner
     */
    'code'?: number;
    /**
     * Error message associated with the error editing asset group.
     * @type {string}
     * @memberof UpdateAssetGroupResponseExceptionsInner
     */
    'message'?: string;
    /**
     * Asset group id of the exception.
     * @type {string}
     * @memberof UpdateAssetGroupResponseExceptionsInner
     */
    'asset_group_id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateInvitesResultsResponseArray
 */
export interface UpdateInvitesResultsResponseArray {
    /**
     * List of invite/Request action status. If there is an error, an exception object will be returned. If the action was successfully completed, an invite object will be returned.
     * @type {Array<UpdateInvitesResultsResponseArrayItemsInner>}
     * @memberof UpdateInvitesResultsResponseArray
     */
    'items'?: Array<UpdateInvitesResultsResponseArrayItemsInner>;
}
/**
 * 
 * @export
 * @interface UpdateInvitesResultsResponseArrayItemsInner
 */
export interface UpdateInvitesResultsResponseArrayItemsInner {
    /**
     * 
     * @type {InviteExceptionResponse}
     * @memberof UpdateInvitesResultsResponseArrayItemsInner
     */
    'exception'?: InviteExceptionResponse | null;
    /**
     * 
     * @type {InviteBusinessRoleBinding}
     * @memberof UpdateInvitesResultsResponseArrayItemsInner
     */
    'invite'?: InviteBusinessRoleBinding | null;
}
/**
 * bid option field to apply operation updates to
 * @export
 * @enum {string}
 */

export const UpdateMaskBidOptionField = {
    Bid: 'BID',
    AppTypeBidMultiplierSet: 'APP_TYPE_BID_MULTIPLIER_SET',
    PlacementBidMultiplierSet: 'PLACEMENT_BID_MULTIPLIER_SET'
} as const;

export type UpdateMaskBidOptionField = typeof UpdateMaskBidOptionField[keyof typeof UpdateMaskBidOptionField];


/**
 * The field types supported by the update mask
 * @export
 * @enum {string}
 */

export const UpdateMaskFieldType = {
    AdLink: 'ad_link',
    Adult: 'adult',
    AgeGroup: 'age_group',
    Availability: 'availability',
    AverageReviewRating: 'average_review_rating',
    Brand: 'brand',
    CheckoutEnabled: 'checkout_enabled',
    Color: 'color',
    Condition: 'condition',
    CustomLabel0: 'custom_label_0',
    CustomLabel1: 'custom_label_1',
    CustomLabel2: 'custom_label_2',
    CustomLabel3: 'custom_label_3',
    CustomLabel4: 'custom_label_4',
    Description: 'description',
    FreeShippingLabel: 'free_shipping_label',
    FreeShippingLimit: 'free_shipping_limit',
    Gender: 'gender',
    GoogleProductCategory: 'google_product_category',
    Gtin: 'gtin',
    ItemGroupId: 'item_group_id',
    LastUpdatedTime: 'last_updated_time',
    Link: 'link',
    Material: 'material',
    MinAdPrice: 'min_ad_price',
    Mpn: 'mpn',
    NumberOfRatings: 'number_of_ratings',
    NumberOfReviews: 'number_of_reviews',
    Pattern: 'pattern',
    Price: 'price',
    ProductType: 'product_type',
    SalePrice: 'sale_price',
    Shipping: 'shipping',
    ShippingHeight: 'shipping_height',
    ShippingWeight: 'shipping_weight',
    ShippingWidth: 'shipping_width',
    Size: 'size',
    SizeSystem: 'size_system',
    SizeType: 'size_type',
    Tax: 'tax',
    Title: 'title',
    VariantNames: 'variant_names',
    VariantValues: 'variant_values'
} as const;

export type UpdateMaskFieldType = typeof UpdateMaskFieldType[keyof typeof UpdateMaskFieldType];


/**
 * An object with a list of all the new accesses.
 * @export
 * @interface UpdateMemberAssetAccessBody
 */
export interface UpdateMemberAssetAccessBody {
    /**
     * 
     * @type {Array<UpdateMemberAssetAccessBodyAccessesInner>}
     * @memberof UpdateMemberAssetAccessBody
     */
    'accesses': Array<UpdateMemberAssetAccessBodyAccessesInner>;
}
/**
 * 
 * @export
 * @interface UpdateMemberAssetAccessBodyAccessesInner
 */
export interface UpdateMemberAssetAccessBodyAccessesInner {
    /**
     * Id of the asset to update.
     * @type {string}
     * @memberof UpdateMemberAssetAccessBodyAccessesInner
     */
    'asset_id': string;
    /**
     * Unique identifier of the member on which to perform the update
     * @type {string}
     * @memberof UpdateMemberAssetAccessBodyAccessesInner
     */
    'member_id': string;
    /**
     * A non-empty array of permissions to assign to the member.
     * @type {Array<Permissions>}
     * @memberof UpdateMemberAssetAccessBodyAccessesInner
     */
    'permissions': Array<Permissions>;
}
/**
 * 
 * @export
 * @interface UpdateMemberAssetsResultsResponseArray
 */
export interface UpdateMemberAssetsResultsResponseArray {
    /**
     * List of assigned/updated member asset access. If there is an error, an exception object will be returned. If the action was successfully completed, a response object will be returned.
     * @type {Array<UpdateMemberAssetsResultsResponseArrayItemsInner>}
     * @memberof UpdateMemberAssetsResultsResponseArray
     */
    'items'?: Array<UpdateMemberAssetsResultsResponseArrayItemsInner>;
}
/**
 * 
 * @export
 * @interface UpdateMemberAssetsResultsResponseArrayItemsInner
 */
export interface UpdateMemberAssetsResultsResponseArrayItemsInner {
    /**
     * 
     * @type {UsersForIndividualAssetResponse}
     * @memberof UpdateMemberAssetsResultsResponseArrayItemsInner
     */
    'response'?: UsersForIndividualAssetResponse;
}
/**
 * Single instance of a business member to have its role updated
 * @export
 * @interface UpdateMemberBusinessRoleBody
 */
export interface UpdateMemberBusinessRoleBody {
    /**
     * 
     * @type {BusinessRoleForMembers}
     * @memberof UpdateMemberBusinessRoleBody
     */
    'business_role': BusinessRoleForMembers;
    /**
     * Unique identifier of the member
     * @type {string}
     * @memberof UpdateMemberBusinessRoleBody
     */
    'member_id': string;
}


/**
 * 
 * @export
 * @interface UpdateMemberResult
 */
export interface UpdateMemberResult {
    /**
     * The access level a member has to the business. Values are case-sensitive. <br> - EMPLOYEE: Can only view and access assets you assign to them. They cannot see details about other employees, partners, or other assets. <br> - BIZ_ADMIN: Have full control of roles and can add employees and partners as well as grant asset access.
     * @type {string}
     * @memberof UpdateMemberResult
     */
    'business_role'?: string;
    /**
     * Unique identifier of the business member.
     * @type {string}
     * @memberof UpdateMemberResult
     */
    'member_id'?: string;
}
/**
 * 
 * @export
 * @interface UpdateMemberResultsResponseArray
 */
export interface UpdateMemberResultsResponseArray {
    /**
     * List of members with updated business access role.
     * @type {Array<UpdateMemberResult>}
     * @memberof UpdateMemberResultsResponseArray
     */
    'items'?: Array<UpdateMemberResult>;
}
/**
 * 
 * @export
 * @interface UpdatePartnerAssetAccessBody
 */
export interface UpdatePartnerAssetAccessBody {
    /**
     * 
     * @type {Array<UpdatePartnerAssetAccessBodyAccessesInner>}
     * @memberof UpdatePartnerAssetAccessBody
     */
    'accesses': Array<UpdatePartnerAssetAccessBodyAccessesInner>;
}
/**
 * 
 * @export
 * @interface UpdatePartnerAssetAccessBodyAccessesInner
 */
export interface UpdatePartnerAssetAccessBodyAccessesInner {
    /**
     * Unique identifier of a business partner to update asset access to.
     * @type {string}
     * @memberof UpdatePartnerAssetAccessBodyAccessesInner
     */
    'partner_id': string;
    /**
     * Unique identifier of the business asset.
     * @type {string}
     * @memberof UpdatePartnerAssetAccessBodyAccessesInner
     */
    'asset_id': string;
    /**
     * A non-empty array of permissions to assign to the partner.
     * @type {Array<Permissions>}
     * @memberof UpdatePartnerAssetAccessBodyAccessesInner
     */
    'permissions': Array<Permissions>;
}
/**
 * An object containing the permissions a business partner has on the asset.
 * @export
 * @interface UpdatePartnerAssetsResult
 */
export interface UpdatePartnerAssetsResult {
    /**
     * Unique identifier of a business asset.
     * @type {string}
     * @memberof UpdatePartnerAssetsResult
     */
    'asset_id'?: string;
    /**
     * Type of asset. Currently we only support AD_ACCOUNT and PROFILE, and ASSET_GROUP.
     * @type {string}
     * @memberof UpdatePartnerAssetsResult
     */
    'asset_type'?: string;
    /**
     * Unique identifier of a business partner.
     * @type {string}
     * @memberof UpdatePartnerAssetsResult
     */
    'partner_id'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof UpdatePartnerAssetsResult
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdatePartnerAssetsResultsResponseArray
 */
export interface UpdatePartnerAssetsResultsResponseArray {
    /**
     * List of assigned/updated partner asset access.
     * @type {Array<UpdatePartnerAssetsResult>}
     * @memberof UpdatePartnerAssetsResultsResponseArray
     */
    'items'?: Array<UpdatePartnerAssetsResult>;
}
/**
 * 
 * @export
 * @interface UpdatePartnerResultsResponseArray
 */
export interface UpdatePartnerResultsResponseArray {
    /**
     * 
     * @type {Array<UpdatePartnerResultsResponseArrayItemsInner>}
     * @memberof UpdatePartnerResultsResponseArray
     */
    'items'?: Array<UpdatePartnerResultsResponseArrayItemsInner>;
}
/**
 * 
 * @export
 * @interface UpdatePartnerResultsResponseArrayItemsInner
 */
export interface UpdatePartnerResultsResponseArrayItemsInner {
    /**
     * 
     * @type {BusinessAccessError}
     * @memberof UpdatePartnerResultsResponseArrayItemsInner
     */
    'exception'?: BusinessAccessError | null;
    /**
     * 
     * @type {string}
     * @memberof UpdatePartnerResultsResponseArrayItemsInner
     */
    'member_or_partner_id'?: string | null;
}
/**
 * 
 * @export
 * @interface UserAccountFollowedInterests200Response
 */
export interface UserAccountFollowedInterests200Response {
    /**
     * 
     * @type {Array<Interest>}
     * @memberof UserAccountFollowedInterests200Response
     */
    'items': Array<Interest>;
    /**
     * 
     * @type {string}
     * @memberof UserAccountFollowedInterests200Response
     */
    'bookmark'?: string | null;
}
/**
 * 
 * @export
 * @interface UserBusinessRoleBinding
 */
export interface UserBusinessRoleBinding {
    /**
     * 
     * @type {BusinessMemberAssetsSummary}
     * @memberof UserBusinessRoleBinding
     */
    'assets_summary'?: BusinessMemberAssetsSummary | null;
    /**
     * The access level a user has on the business. This can be EMPLOYEE, BIZ_ADMIN, or PARTNER.
     * @type {Array<string>}
     * @memberof UserBusinessRoleBinding
     */
    'business_roles'?: Array<string>;
    /**
     * Metadata for the business that created the business relationship.
     * @type {BusinessAccessUserSummary}
     * @memberof UserBusinessRoleBinding
     */
    'created_by_business'?: BusinessAccessUserSummary | null;
    /**
     * Metadata for the user that created the business relationship.
     * @type {BusinessAccessUserSummary}
     * @memberof UserBusinessRoleBinding
     */
    'created_by_user'?: BusinessAccessUserSummary | null;
    /**
     * The time the business relationship was created. Returned in milliseconds.
     * @type {number}
     * @memberof UserBusinessRoleBinding
     */
    'created_time'?: number | null;
    /**
     * Unique identifier of the business member/business partner/employer.
     * @type {string}
     * @memberof UserBusinessRoleBinding
     */
    'id'?: string;
    /**
     * This field is only relevant when business_role=\"PARTNER\". <br>If is_shared_partner=FALSE, the partner can access your business assets. If assets_summary is not empty, the assets listed are your business assets the partner has access to. <br>If is_shared_partner=TRUE, you can access the partner\'s business asset. If assets_summary is not empty, the assets listed are the partner\'s business assets you have access to.
     * @type {boolean}
     * @memberof UserBusinessRoleBinding
     */
    'is_shared_partner'?: boolean;
    /**
     * Metadata for the business member/business partner/employer.
     * @type {BusinessAccessUserSummary}
     * @memberof UserBusinessRoleBinding
     */
    'user'?: BusinessAccessUserSummary | null;
}
/**
 * Specifies the type of followees to be kept when filtering them.
 * @export
 * @enum {string}
 */

export const UserFollowingFeedType = {
    All: 'ALL',
    Ranked: 'RANKED',
    CreatorOnly: 'CREATOR_ONLY',
    RankedCreatorOnly: 'RANKED_CREATOR_ONLY'
} as const;

export type UserFollowingFeedType = typeof UserFollowingFeedType[keyof typeof UserFollowingFeedType];


/**
 * 
 * @export
 * @interface UserFollowingGet200Response
 */
export interface UserFollowingGet200Response {
    /**
     * Users
     * @type {Array<UserSummary>}
     * @memberof UserFollowingGet200Response
     */
    'items': Array<UserSummary>;
    /**
     * 
     * @type {string}
     * @memberof UserFollowingGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * User list operation type (add or remove)
 * @export
 * @enum {string}
 */

export const UserListOperationType = {
    Add: 'ADD',
    Remove: 'REMOVE'
} as const;

export type UserListOperationType = typeof UserListOperationType[keyof typeof UserListOperationType];


/**
 * User list type
 * @export
 * @enum {string}
 */

export const UserListType = {
    Email: 'EMAIL',
    Idfa: 'IDFA',
    Maid: 'MAID',
    LrId: 'LR_ID',
    DlxId: 'DLX_ID',
    HashedPinnerId: 'HASHED_PINNER_ID'
} as const;

export type UserListType = typeof UserListType[keyof typeof UserListType];


/**
 * An object containing the permissions a business member/partner has on the asset.
 * @export
 * @interface UserSingleAssetBinding
 */
export interface UserSingleAssetBinding {
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof UserSingleAssetBinding
     */
    'permissions'?: Array<string>;
    /**
     * 
     * @type {BusinessAccessUserSummary}
     * @memberof UserSingleAssetBinding
     */
    'user'?: BusinessAccessUserSummary;
}
/**
 * 
 * @export
 * @interface UserSummary
 */
export interface UserSummary {
    /**
     * Username
     * @type {string}
     * @memberof UserSummary
     */
    'username'?: string;
    /**
     * Always \"user\"
     * @type {string}
     * @memberof UserSummary
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface UserWebsiteSummary
 */
export interface UserWebsiteSummary {
    /**
     * Website with path or domain only
     * @type {string}
     * @memberof UserWebsiteSummary
     */
    'website'?: string;
    /**
     * Status of the verification process
     * @type {string}
     * @memberof UserWebsiteSummary
     */
    'status'?: string;
    /**
     * UTC timestamp when the verification happened - sometimes missing
     * @type {string}
     * @memberof UserWebsiteSummary
     */
    'verified_at'?: string;
}
/**
 * 
 * @export
 * @interface UserWebsiteVerificationCode
 */
export interface UserWebsiteVerificationCode {
    /**
     * Code to check against the user claiming the website
     * @type {string}
     * @memberof UserWebsiteVerificationCode
     */
    'verification_code'?: string;
    /**
     * DNS TXT record to check against for the website to be claimed
     * @type {string}
     * @memberof UserWebsiteVerificationCode
     */
    'dns_txt_record'?: string;
    /**
     * Metatag the verification process searchs for the website to be claimed
     * @type {string}
     * @memberof UserWebsiteVerificationCode
     */
    'metatag'?: string;
    /**
     * File expected to find on the website being claimed
     * @type {string}
     * @memberof UserWebsiteVerificationCode
     */
    'filename'?: string;
    /**
     * A full html file to upload to the website in order for it to be claimed
     * @type {string}
     * @memberof UserWebsiteVerificationCode
     */
    'file_content'?: string;
}
/**
 * User website verification request
 * @export
 * @interface UserWebsiteVerifyRequest
 */
export interface UserWebsiteVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof UserWebsiteVerifyRequest
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserWebsiteVerifyRequest
     */
    'verification_method'?: UserWebsiteVerifyRequestVerificationMethodEnum;
}

export const UserWebsiteVerifyRequestVerificationMethodEnum = {
    Filename: 'FILENAME',
    Metatag: 'METATAG',
    Dnstxt: 'DNSTXT'
} as const;

export type UserWebsiteVerifyRequestVerificationMethodEnum = typeof UserWebsiteVerifyRequestVerificationMethodEnum[keyof typeof UserWebsiteVerifyRequestVerificationMethodEnum];

/**
 * 
 * @export
 * @interface UserWebsitesGet200Response
 */
export interface UserWebsitesGet200Response {
    /**
     * 
     * @type {Array<UserWebsiteSummary>}
     * @memberof UserWebsitesGet200Response
     */
    'items': Array<UserWebsiteSummary>;
    /**
     * 
     * @type {string}
     * @memberof UserWebsitesGet200Response
     */
    'bookmark'?: string | null;
}
/**
 * An object containing the permissions a business member has on the asset.
 * @export
 * @interface UsersForIndividualAssetResponse
 */
export interface UsersForIndividualAssetResponse {
    /**
     * Unique identifier of a business asset.
     * @type {string}
     * @memberof UsersForIndividualAssetResponse
     */
    'asset_id'?: string;
    /**
     * Unique identifier of the business member with asset access.
     * @type {string}
     * @memberof UsersForIndividualAssetResponse
     */
    'member_id'?: string;
    /**
     * Permission levels member or partner has on an asset.
     * @type {Array<string>}
     * @memberof UsersForIndividualAssetResponse
     */
    'permissions'?: Array<string>;
}
/**
 * 
 * @export
 * @interface VideoMetadata
 */
export interface VideoMetadata {
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    'item_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof VideoMetadata
     */
    'cover_image_url'?: string;
    /**
     * Video url (720p). </p><strong>Note:</strong> This field is limited and not available to all apps.
     * @type {string}
     * @memberof VideoMetadata
     */
    'video_url'?: string | null;
    /**
     * Duration (in milliseconds)
     * @type {number}
     * @memberof VideoMetadata
     */
    'duration'?: number;
    /**
     * Height (in pixels)
     * @type {number}
     * @memberof VideoMetadata
     */
    'height'?: number;
    /**
     * Width (in pixels)
     * @type {number}
     * @memberof VideoMetadata
     */
    'width'?: number;
}

/**
 * AdAccountsApi - axios parameter creator
 * @export
 */
export const AdAccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get analytics for the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time.
         * @summary Get ad account analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdAccountAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdAccountAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdAccountAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountAnalytics: async (adAccountId: string, startDate: string, endDate: string, columns: Array<AdAccountAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdAccountAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdAccountAnalyticsViewWindowDaysEnum, conversionReportTime?: AdAccountAnalyticsConversionReportTimeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountAnalytics', 'adAccountId', adAccountId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('adAccountAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('adAccountAnalytics', 'endDate', endDate)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('adAccountAnalytics', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('adAccountAnalytics', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get targeting analytics for an ad account. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for an ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdAccountTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdAccountTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdAccountTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountTargetingAnalyticsGet: async (adAccountId: string, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdAccountTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdAccountTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdAccountTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountTargetingAnalyticsGet', 'adAccountId', adAccountId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('adAccountTargetingAnalyticsGet', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('adAccountTargetingAnalyticsGet', 'endDate', endDate)
            // verify required parameter 'targetingTypes' is not null or undefined
            assertParamExists('adAccountTargetingAnalyticsGet', 'targetingTypes', targetingTypes)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('adAccountTargetingAnalyticsGet', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('adAccountTargetingAnalyticsGet', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/targeting_analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (targetingTypes) {
                localVarQueryParameter['targeting_types'] = targetingTypes.join(COLLECTION_FORMATS.csv);
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }

            if (attributionTypes !== undefined) {
                localVarQueryParameter['attribution_types'] = attributionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new ad account. Different ad accounts can support different currencies, payment methods, etc. An ad account is needed to create campaigns, ad groups, and ads; other accounts (your employees or partners) can be assigned business access and appropriate roles to access an ad account. <p/> You can set up up to 50 ad accounts per user. (The user must have a business account to create an ad account.) <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/create-an-advertiser-account\">Create an advertiser account</a>.
         * @summary Create ad account
         * @param {AdAccountCreateRequest} adAccountCreateRequest Ad account to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsCreate: async (adAccountCreateRequest: AdAccountCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountCreateRequest' is not null or undefined
            assertParamExists('adAccountsCreate', 'adAccountCreateRequest', adAccountCreateRequest)
            const localVarPath = `/ad_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adAccountCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an ad account
         * @summary Get ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsGet: async (adAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountsGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the ad_accounts that the \"operation user_account\" has access to. - This includes ad_accounts they own and ad_accounts that are owned by others who have granted them <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>.
         * @summary List ad accounts
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {boolean} [includeSharedAccounts] Include shared ad accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsList: async (bookmark?: string, pageSize?: number, includeSharedAccounts?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/ad_accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (includeSharedAccounts !== undefined) {
                localVarQueryParameter['include_shared_accounts'] = includeSharedAccounts;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This creates an asynchronous mmm report based on the given request. It returns a token that you can use to download the report when it is ready. NOTE: An additional limit of 5 queries per minute per advertiser applies to this endpoint while it\'s in beta release.
         * @summary Create a request for a Marketing Mix Modeling (MMM) report
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {CreateMMMReportRequest} createMMMReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsCreateMmmReport: async (adAccountId: string, createMMMReportRequest: CreateMMMReportRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('analyticsCreateMmmReport', 'adAccountId', adAccountId)
            // verify required parameter 'createMMMReportRequest' is not null or undefined
            assertParamExists('analyticsCreateMmmReport', 'createMMMReportRequest', createMMMReportRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/mmm_reports`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMMMReportRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a token that you can use to download the report when it is ready. Note that this endpoint requires the parameters to be passed as JSON-formatted in the request body. This endpoint does not support URL query parameters. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 914 days before the current date in UTC time and the max time range supported is 186 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days. - If level is PRODUCT_ITEM, the furthest back you can are allowed to pull data is 92 days before the current date in UTC time and the max time range supported is 31 days. - If level is PRODUCT_ITEM, ad_ids and ad_statuses parameters are not allowed. Any columns related to pin promotion and ad is not allowed either.
         * @summary Create async request for an account analytics report
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdsAnalyticsCreateAsyncRequest} adsAnalyticsCreateAsyncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsCreateReport: async (adAccountId: string, adsAnalyticsCreateAsyncRequest: AdsAnalyticsCreateAsyncRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('analyticsCreateReport', 'adAccountId', adAccountId)
            // verify required parameter 'adsAnalyticsCreateAsyncRequest' is not null or undefined
            assertParamExists('analyticsCreateReport', 'adsAnalyticsCreateAsyncRequest', adsAnalyticsCreateAsyncRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/reports`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adsAnalyticsCreateAsyncRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This takes a template ID and an optional custom timeframe and constructs an asynchronous report based on the template. It returns a token that you can use to download the report when it is ready.
         * @summary Create async request for an analytics report using a template
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} templateId Unique identifier of a template.
         * @param {string} [startDate] Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years back from today.
         * @param {string} [endDate] Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years past start date.
         * @param {Granularity} [granularity] TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsCreateTemplateReport: async (adAccountId: string, templateId: string, startDate?: string, endDate?: string, granularity?: Granularity, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('analyticsCreateTemplateReport', 'adAccountId', adAccountId)
            // verify required parameter 'templateId' is not null or undefined
            assertParamExists('analyticsCreateTemplateReport', 'templateId', templateId)
            const localVarPath = `/ad_accounts/{ad_account_id}/templates/{template_id}/reports`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"template_id"}}`, encodeURIComponent(String(templateId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an mmm report for an ad account. This returns a URL to an mmm metrics report given a token returned from the create mmm report endpoint.
         * @summary Get advertiser Marketing Mix Modeling (MMM) report.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} token Token returned from the post request creation call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetMmmReport: async (adAccountId: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('analyticsGetMmmReport', 'adAccountId', adAccountId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('analyticsGetMmmReport', 'token', token)
            const localVarPath = `/ad_accounts/{ad_account_id}/mmm_reports`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a URL to an analytics report given a token returned from the post request report creation call. You can use the URL to download the report. The link is valid for five minutes and the report is valid for one hour. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
         * @summary Get the account analytics report created by the async call
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} token Token returned from the post request creation call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetReport: async (adAccountId: string, token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('analyticsGetReport', 'adAccountId', adAccountId)
            // verify required parameter 'token' is not null or undefined
            assertParamExists('analyticsGetReport', 'token', token)
            const localVarPath = `/ad_accounts/{ad_account_id}/reports`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an ad account and all the ads data associated with that account. A string message is returned indicating the status of the delete operation.  Note: This endpoint is only allowed in the Pinterest API Sandbox (https://api-sandbox.pinterest.com/v5). Go to /docs/developer-tools/sandbox/ for more information.
         * @summary Delete ads data for ad account in API Sandbox
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxDelete: async (adAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('sandboxDelete', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/sandbox`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets all Templates associated with an ad account ID.
         * @summary List templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {TemplatesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesList: async (adAccountId: string, pageSize?: number, order?: TemplatesListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('templatesList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/templates`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdAccountsApi - functional programming interface
 * @export
 */
export const AdAccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdAccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get analytics for the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time.
         * @summary Get ad account analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdAccountAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdAccountAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdAccountAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountAnalytics(adAccountId: string, startDate: string, endDate: string, columns: Array<AdAccountAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdAccountAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdAccountAnalyticsViewWindowDaysEnum, conversionReportTime?: AdAccountAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdAccountAnalyticsResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountAnalytics(adAccountId, startDate, endDate, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.adAccountAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get targeting analytics for an ad account. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for an ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdAccountTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdAccountTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdAccountTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountTargetingAnalyticsGet(adAccountId: string, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdAccountTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdAccountTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdAccountTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountTargetingAnalyticsGet(adAccountId, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.adAccountTargetingAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new ad account. Different ad accounts can support different currencies, payment methods, etc. An ad account is needed to create campaigns, ad groups, and ads; other accounts (your employees or partners) can be assigned business access and appropriate roles to access an ad account. <p/> You can set up up to 50 ad accounts per user. (The user must have a business account to create an ad account.) <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/create-an-advertiser-account\">Create an advertiser account</a>.
         * @summary Create ad account
         * @param {AdAccountCreateRequest} adAccountCreateRequest Ad account to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsCreate(adAccountCreateRequest: AdAccountCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsCreate(adAccountCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.adAccountsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an ad account
         * @summary Get ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsGet(adAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccount>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsGet(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.adAccountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the ad_accounts that the \"operation user_account\" has access to. - This includes ad_accounts they own and ad_accounts that are owned by others who have granted them <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>.
         * @summary List ad accounts
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {boolean} [includeSharedAccounts] Include shared ad accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsList(bookmark?: string, pageSize?: number, includeSharedAccounts?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsList(bookmark, pageSize, includeSharedAccounts, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.adAccountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This creates an asynchronous mmm report based on the given request. It returns a token that you can use to download the report when it is ready. NOTE: An additional limit of 5 queries per minute per advertiser applies to this endpoint while it\'s in beta release.
         * @summary Create a request for a Marketing Mix Modeling (MMM) report
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {CreateMMMReportRequest} createMMMReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsCreateMmmReport(adAccountId: string, createMMMReportRequest: CreateMMMReportRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateMMMReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsCreateMmmReport(adAccountId, createMMMReportRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.analyticsCreateMmmReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This returns a token that you can use to download the report when it is ready. Note that this endpoint requires the parameters to be passed as JSON-formatted in the request body. This endpoint does not support URL query parameters. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 914 days before the current date in UTC time and the max time range supported is 186 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days. - If level is PRODUCT_ITEM, the furthest back you can are allowed to pull data is 92 days before the current date in UTC time and the max time range supported is 31 days. - If level is PRODUCT_ITEM, ad_ids and ad_statuses parameters are not allowed. Any columns related to pin promotion and ad is not allowed either.
         * @summary Create async request for an account analytics report
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdsAnalyticsCreateAsyncRequest} adsAnalyticsCreateAsyncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsCreateReport(adAccountId: string, adsAnalyticsCreateAsyncRequest: AdsAnalyticsCreateAsyncRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsAnalyticsCreateAsyncResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsCreateReport(adAccountId, adsAnalyticsCreateAsyncRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.analyticsCreateReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This takes a template ID and an optional custom timeframe and constructs an asynchronous report based on the template. It returns a token that you can use to download the report when it is ready.
         * @summary Create async request for an analytics report using a template
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} templateId Unique identifier of a template.
         * @param {string} [startDate] Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years back from today.
         * @param {string} [endDate] Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years past start date.
         * @param {Granularity} [granularity] TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsCreateTemplateReport(adAccountId: string, templateId: string, startDate?: string, endDate?: string, granularity?: Granularity, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsAnalyticsCreateAsyncResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsCreateTemplateReport(adAccountId, templateId, startDate, endDate, granularity, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.analyticsCreateTemplateReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an mmm report for an ad account. This returns a URL to an mmm metrics report given a token returned from the create mmm report endpoint.
         * @summary Get advertiser Marketing Mix Modeling (MMM) report.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} token Token returned from the post request creation call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetMmmReport(adAccountId: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetMMMReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetMmmReport(adAccountId, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.analyticsGetMmmReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This returns a URL to an analytics report given a token returned from the post request report creation call. You can use the URL to download the report. The link is valid for five minutes and the report is valid for one hour. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
         * @summary Get the account analytics report created by the async call
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} token Token returned from the post request creation call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async analyticsGetReport(adAccountId: string, token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsAnalyticsGetAsyncResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.analyticsGetReport(adAccountId, token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.analyticsGetReport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete an ad account and all the ads data associated with that account. A string message is returned indicating the status of the delete operation.  Note: This endpoint is only allowed in the Pinterest API Sandbox (https://api-sandbox.pinterest.com/v5). Go to /docs/developer-tools/sandbox/ for more information.
         * @summary Delete ads data for ad account in API Sandbox
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sandboxDelete(adAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sandboxDelete(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.sandboxDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets all Templates associated with an ad account ID.
         * @summary List templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {TemplatesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templatesList(adAccountId: string, pageSize?: number, order?: TemplatesListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TemplatesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templatesList(adAccountId, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdAccountsApi.templatesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdAccountsApi - factory interface
 * @export
 */
export const AdAccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdAccountsApiFp(configuration)
    return {
        /**
         * Get analytics for the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time.
         * @summary Get ad account analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdAccountAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdAccountAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdAccountAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountAnalytics(adAccountId: string, startDate: string, endDate: string, columns: Array<AdAccountAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdAccountAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdAccountAnalyticsViewWindowDaysEnum, conversionReportTime?: AdAccountAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<AdAccountAnalyticsResponseInner>> {
            return localVarFp.adAccountAnalytics(adAccountId, startDate, endDate, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get targeting analytics for an ad account. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for an ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdAccountTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdAccountTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdAccountTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdAccountTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountTargetingAnalyticsGet(adAccountId: string, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdAccountTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdAccountTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdAccountTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): AxiosPromise<MetricsResponse> {
            return localVarFp.adAccountTargetingAnalyticsGet(adAccountId, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new ad account. Different ad accounts can support different currencies, payment methods, etc. An ad account is needed to create campaigns, ad groups, and ads; other accounts (your employees or partners) can be assigned business access and appropriate roles to access an ad account. <p/> You can set up up to 50 ad accounts per user. (The user must have a business account to create an ad account.) <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/create-an-advertiser-account\">Create an advertiser account</a>.
         * @summary Create ad account
         * @param {AdAccountCreateRequest} adAccountCreateRequest Ad account to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsCreate(adAccountCreateRequest: AdAccountCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdAccount> {
            return localVarFp.adAccountsCreate(adAccountCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an ad account
         * @summary Get ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsGet(adAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdAccount> {
            return localVarFp.adAccountsGet(adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the ad_accounts that the \"operation user_account\" has access to. - This includes ad_accounts they own and ad_accounts that are owned by others who have granted them <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>.
         * @summary List ad accounts
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {boolean} [includeSharedAccounts] Include shared ad accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsList(bookmark?: string, pageSize?: number, includeSharedAccounts?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AdAccountsList200Response> {
            return localVarFp.adAccountsList(bookmark, pageSize, includeSharedAccounts, options).then((request) => request(axios, basePath));
        },
        /**
         * This creates an asynchronous mmm report based on the given request. It returns a token that you can use to download the report when it is ready. NOTE: An additional limit of 5 queries per minute per advertiser applies to this endpoint while it\'s in beta release.
         * @summary Create a request for a Marketing Mix Modeling (MMM) report
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {CreateMMMReportRequest} createMMMReportRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsCreateMmmReport(adAccountId: string, createMMMReportRequest: CreateMMMReportRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateMMMReportResponse> {
            return localVarFp.analyticsCreateMmmReport(adAccountId, createMMMReportRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a token that you can use to download the report when it is ready. Note that this endpoint requires the parameters to be passed as JSON-formatted in the request body. This endpoint does not support URL query parameters. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 914 days before the current date in UTC time and the max time range supported is 186 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days. - If level is PRODUCT_ITEM, the furthest back you can are allowed to pull data is 92 days before the current date in UTC time and the max time range supported is 31 days. - If level is PRODUCT_ITEM, ad_ids and ad_statuses parameters are not allowed. Any columns related to pin promotion and ad is not allowed either.
         * @summary Create async request for an account analytics report
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdsAnalyticsCreateAsyncRequest} adsAnalyticsCreateAsyncRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsCreateReport(adAccountId: string, adsAnalyticsCreateAsyncRequest: AdsAnalyticsCreateAsyncRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdsAnalyticsCreateAsyncResponse> {
            return localVarFp.analyticsCreateReport(adAccountId, adsAnalyticsCreateAsyncRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This takes a template ID and an optional custom timeframe and constructs an asynchronous report based on the template. It returns a token that you can use to download the report when it is ready.
         * @summary Create async request for an analytics report using a template
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} templateId Unique identifier of a template.
         * @param {string} [startDate] Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years back from today.
         * @param {string} [endDate] Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years past start date.
         * @param {Granularity} [granularity] TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsCreateTemplateReport(adAccountId: string, templateId: string, startDate?: string, endDate?: string, granularity?: Granularity, options?: RawAxiosRequestConfig): AxiosPromise<AdsAnalyticsCreateAsyncResponse> {
            return localVarFp.analyticsCreateTemplateReport(adAccountId, templateId, startDate, endDate, granularity, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an mmm report for an ad account. This returns a URL to an mmm metrics report given a token returned from the create mmm report endpoint.
         * @summary Get advertiser Marketing Mix Modeling (MMM) report.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} token Token returned from the post request creation call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetMmmReport(adAccountId: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<GetMMMReportResponse> {
            return localVarFp.analyticsGetMmmReport(adAccountId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a URL to an analytics report given a token returned from the post request report creation call. You can use the URL to download the report. The link is valid for five minutes and the report is valid for one hour. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
         * @summary Get the account analytics report created by the async call
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} token Token returned from the post request creation call
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        analyticsGetReport(adAccountId: string, token: string, options?: RawAxiosRequestConfig): AxiosPromise<AdsAnalyticsGetAsyncResponse> {
            return localVarFp.analyticsGetReport(adAccountId, token, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an ad account and all the ads data associated with that account. A string message is returned indicating the status of the delete operation.  Note: This endpoint is only allowed in the Pinterest API Sandbox (https://api-sandbox.pinterest.com/v5). Go to /docs/developer-tools/sandbox/ for more information.
         * @summary Delete ads data for ad account in API Sandbox
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sandboxDelete(adAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.sandboxDelete(adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets all Templates associated with an ad account ID.
         * @summary List templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {TemplatesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templatesList(adAccountId: string, pageSize?: number, order?: TemplatesListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<TemplatesList200Response> {
            return localVarFp.templatesList(adAccountId, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdAccountsApi - object-oriented interface
 * @export
 * @class AdAccountsApi
 * @extends {BaseAPI}
 */
export class AdAccountsApi extends BaseAPI {
    /**
     * Get analytics for the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time.
     * @summary Get ad account analytics
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<AdAccountAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {AdAccountAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdAccountAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdAccountAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {AdAccountAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public adAccountAnalytics(adAccountId: string, startDate: string, endDate: string, columns: Array<AdAccountAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdAccountAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdAccountAnalyticsViewWindowDaysEnum, conversionReportTime?: AdAccountAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).adAccountAnalytics(adAccountId, startDate, endDate, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get targeting analytics for an ad account. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get targeting analytics for an ad account
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
     * @param {Array<AdAccountTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {AdAccountTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdAccountTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {AdAccountTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public adAccountTargetingAnalyticsGet(adAccountId: string, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdAccountTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdAccountTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdAccountTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdAccountTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).adAccountTargetingAnalyticsGet(adAccountId, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new ad account. Different ad accounts can support different currencies, payment methods, etc. An ad account is needed to create campaigns, ad groups, and ads; other accounts (your employees or partners) can be assigned business access and appropriate roles to access an ad account. <p/> You can set up up to 50 ad accounts per user. (The user must have a business account to create an ad account.) <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/create-an-advertiser-account\">Create an advertiser account</a>.
     * @summary Create ad account
     * @param {AdAccountCreateRequest} adAccountCreateRequest Ad account to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public adAccountsCreate(adAccountCreateRequest: AdAccountCreateRequest, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).adAccountsCreate(adAccountCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an ad account
     * @summary Get ad account
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public adAccountsGet(adAccountId: string, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).adAccountsGet(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the ad_accounts that the \"operation user_account\" has access to. - This includes ad_accounts they own and ad_accounts that are owned by others who have granted them <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>.
     * @summary List ad accounts
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {boolean} [includeSharedAccounts] Include shared ad accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public adAccountsList(bookmark?: string, pageSize?: number, includeSharedAccounts?: boolean, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).adAccountsList(bookmark, pageSize, includeSharedAccounts, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This creates an asynchronous mmm report based on the given request. It returns a token that you can use to download the report when it is ready. NOTE: An additional limit of 5 queries per minute per advertiser applies to this endpoint while it\'s in beta release.
     * @summary Create a request for a Marketing Mix Modeling (MMM) report
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {CreateMMMReportRequest} createMMMReportRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public analyticsCreateMmmReport(adAccountId: string, createMMMReportRequest: CreateMMMReportRequest, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).analyticsCreateMmmReport(adAccountId, createMMMReportRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a token that you can use to download the report when it is ready. Note that this endpoint requires the parameters to be passed as JSON-formatted in the request body. This endpoint does not support URL query parameters. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 914 days before the current date in UTC time and the max time range supported is 186 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days. - If level is PRODUCT_ITEM, the furthest back you can are allowed to pull data is 92 days before the current date in UTC time and the max time range supported is 31 days. - If level is PRODUCT_ITEM, ad_ids and ad_statuses parameters are not allowed. Any columns related to pin promotion and ad is not allowed either.
     * @summary Create async request for an account analytics report
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AdsAnalyticsCreateAsyncRequest} adsAnalyticsCreateAsyncRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public analyticsCreateReport(adAccountId: string, adsAnalyticsCreateAsyncRequest: AdsAnalyticsCreateAsyncRequest, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).analyticsCreateReport(adAccountId, adsAnalyticsCreateAsyncRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This takes a template ID and an optional custom timeframe and constructs an asynchronous report based on the template. It returns a token that you can use to download the report when it is ready.
     * @summary Create async request for an analytics report using a template
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} templateId Unique identifier of a template.
     * @param {string} [startDate] Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years back from today.
     * @param {string} [endDate] Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 2.5 years past start date.
     * @param {Granularity} [granularity] TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public analyticsCreateTemplateReport(adAccountId: string, templateId: string, startDate?: string, endDate?: string, granularity?: Granularity, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).analyticsCreateTemplateReport(adAccountId, templateId, startDate, endDate, granularity, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an mmm report for an ad account. This returns a URL to an mmm metrics report given a token returned from the create mmm report endpoint.
     * @summary Get advertiser Marketing Mix Modeling (MMM) report.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} token Token returned from the post request creation call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public analyticsGetMmmReport(adAccountId: string, token: string, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).analyticsGetMmmReport(adAccountId, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a URL to an analytics report given a token returned from the post request report creation call. You can use the URL to download the report. The link is valid for five minutes and the report is valid for one hour. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
     * @summary Get the account analytics report created by the async call
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} token Token returned from the post request creation call
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public analyticsGetReport(adAccountId: string, token: string, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).analyticsGetReport(adAccountId, token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an ad account and all the ads data associated with that account. A string message is returned indicating the status of the delete operation.  Note: This endpoint is only allowed in the Pinterest API Sandbox (https://api-sandbox.pinterest.com/v5). Go to /docs/developer-tools/sandbox/ for more information.
     * @summary Delete ads data for ad account in API Sandbox
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public sandboxDelete(adAccountId: string, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).sandboxDelete(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets all Templates associated with an ad account ID.
     * @summary List templates
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {TemplatesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdAccountsApi
     */
    public templatesList(adAccountId: string, pageSize?: number, order?: TemplatesListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return AdAccountsApiFp(this.configuration).templatesList(adAccountId, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AdAccountAnalyticsColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type AdAccountAnalyticsColumnsEnum = typeof AdAccountAnalyticsColumnsEnum[keyof typeof AdAccountAnalyticsColumnsEnum];
/**
 * @export
 */
export const AdAccountAnalyticsClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdAccountAnalyticsClickWindowDaysEnum = typeof AdAccountAnalyticsClickWindowDaysEnum[keyof typeof AdAccountAnalyticsClickWindowDaysEnum];
/**
 * @export
 */
export const AdAccountAnalyticsEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdAccountAnalyticsEngagementWindowDaysEnum = typeof AdAccountAnalyticsEngagementWindowDaysEnum[keyof typeof AdAccountAnalyticsEngagementWindowDaysEnum];
/**
 * @export
 */
export const AdAccountAnalyticsViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdAccountAnalyticsViewWindowDaysEnum = typeof AdAccountAnalyticsViewWindowDaysEnum[keyof typeof AdAccountAnalyticsViewWindowDaysEnum];
/**
 * @export
 */
export const AdAccountAnalyticsConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type AdAccountAnalyticsConversionReportTimeEnum = typeof AdAccountAnalyticsConversionReportTimeEnum[keyof typeof AdAccountAnalyticsConversionReportTimeEnum];
/**
 * @export
 */
export const AdAccountTargetingAnalyticsGetColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type AdAccountTargetingAnalyticsGetColumnsEnum = typeof AdAccountTargetingAnalyticsGetColumnsEnum[keyof typeof AdAccountTargetingAnalyticsGetColumnsEnum];
/**
 * @export
 */
export const AdAccountTargetingAnalyticsGetClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdAccountTargetingAnalyticsGetClickWindowDaysEnum = typeof AdAccountTargetingAnalyticsGetClickWindowDaysEnum[keyof typeof AdAccountTargetingAnalyticsGetClickWindowDaysEnum];
/**
 * @export
 */
export const AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum = typeof AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum[keyof typeof AdAccountTargetingAnalyticsGetEngagementWindowDaysEnum];
/**
 * @export
 */
export const AdAccountTargetingAnalyticsGetViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdAccountTargetingAnalyticsGetViewWindowDaysEnum = typeof AdAccountTargetingAnalyticsGetViewWindowDaysEnum[keyof typeof AdAccountTargetingAnalyticsGetViewWindowDaysEnum];
/**
 * @export
 */
export const AdAccountTargetingAnalyticsGetConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type AdAccountTargetingAnalyticsGetConversionReportTimeEnum = typeof AdAccountTargetingAnalyticsGetConversionReportTimeEnum[keyof typeof AdAccountTargetingAnalyticsGetConversionReportTimeEnum];
/**
 * @export
 */
export const TemplatesListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type TemplatesListOrderEnum = typeof TemplatesListOrderEnum[keyof typeof TemplatesListOrderEnum];


/**
 * AdGroupsApi - axios parameter creator
 * @export
 */
export const AdGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get analytics for the specified ad groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get ad group analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
         * @param {Array<AdGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsAnalytics: async (adAccountId: string, startDate: string, endDate: string, adGroupIds: Array<string>, columns: Array<AdGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdGroupsAnalyticsConversionReportTimeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsAnalytics', 'adAccountId', adAccountId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('adGroupsAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('adGroupsAnalytics', 'endDate', endDate)
            // verify required parameter 'adGroupIds' is not null or undefined
            assertParamExists('adGroupsAnalytics', 'adGroupIds', adGroupIds)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('adGroupsAnalytics', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('adGroupsAnalytics', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups/analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (adGroupIds) {
                localVarQueryParameter['ad_group_ids'] = adGroupIds;
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get potential audience size for an ad group with given targeting criteria.  Potential audience size estimates the number of people you may be able to reach per month with your campaign.  It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
         * @summary Get audience sizing
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdGroupAudienceSizingRequest} [adGroupAudienceSizingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsAudienceSizing: async (adAccountId: string, adGroupAudienceSizingRequest?: AdGroupAudienceSizingRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsAudienceSizing', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups/audience_sizing`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adGroupAudienceSizingRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List bid floors for your campaign configuration. Bid floors are given in microcurrency values based on the currency in the bid floor specification. <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li>  </ul> For more on bid floors see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-your-bid\"> Set your bid</a>.
         * @summary Get bid floors
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BidFloorRequest} bidFloorRequest Parameters to get bid_floor info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsBidFloorGet: async (adAccountId: string, bidFloorRequest: BidFloorRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsBidFloorGet', 'adAccountId', adAccountId)
            // verify required parameter 'bidFloorRequest' is not null or undefined
            assertParamExists('adGroupsBidFloorGet', 'bidFloorRequest', bidFloorRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/bid_floor`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bidFloorRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple new ad groups. All ads in a given ad group will have the same budget, bid, run dates, targeting, and placement (search, browse, other). For more information, <a href=\"https://help.pinterest.com/en/business/article/campaign-structure\" target=\"_blank\"> click here</a>.</p> <strong>Note:</strong> - \'bid_in_micro_currency\' and \'budget_in_micro_currency\' should be expressed in microcurrency amounts based on the currency field set in the advertiser\'s profile.<p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul> - Ad groups belong to ad campaigns. Some types of campaigns (e.g. budget optimization) have limits on the number of ad groups they can hold. If you exceed those limits, you will get an error message. - Start and end time cannot be set for ad groups that belong to CBO campaigns. Currently, campaigns with the following objective types: TRAFFIC, AWARENESS, WEB_CONVERSIONS, and CATALOG_SALES will default to CBO.
         * @summary Create ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdGroupCreateRequest>} adGroupCreateRequest List of ad groups to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsCreate: async (adAccountId: string, adGroupCreateRequest: Array<AdGroupCreateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'adGroupCreateRequest' is not null or undefined
            assertParamExists('adGroupsCreate', 'adGroupCreateRequest', adGroupCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
         * @summary Get ad group
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} adGroupId Unique identifier of an ad group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsGet: async (adAccountId: string, adGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsGet', 'adAccountId', adAccountId)
            // verify required parameter 'adGroupId' is not null or undefined
            assertParamExists('adGroupsGet', 'adGroupId', adGroupId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups/{ad_group_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"ad_group_id"}}`, encodeURIComponent(String(adGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ad groups based on provided campaign IDs or ad group IDs.(campaign_ids or ad_group_ids). <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id. Do not provide both.
         * @summary List ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
         * @param {Array<AdGroupsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AdGroupsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {boolean} [translateInterestsToNames] Return interests as text names (if value is true) rather than topic IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsList: async (adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, entityStatuses?: Array<AdGroupsListEntityStatusesEnum>, pageSize?: number, order?: AdGroupsListOrderEnum, bookmark?: string, translateInterestsToNames?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (campaignIds) {
                localVarQueryParameter['campaign_ids'] = campaignIds;
            }

            if (adGroupIds) {
                localVarQueryParameter['ad_group_ids'] = adGroupIds;
            }

            if (entityStatuses) {
                localVarQueryParameter['entity_statuses'] = entityStatuses;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (translateInterestsToNames !== undefined) {
                localVarQueryParameter['translate_interests_to_names'] = translateInterestsToNames;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get targeting analytics for one or more ad groups. For the requested ad group(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdGroupsTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdGroupsTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdGroupsTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsTargetingAnalyticsGet: async (adAccountId: string, adGroupIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdGroupsTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdGroupsTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdGroupsTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'adAccountId', adAccountId)
            // verify required parameter 'adGroupIds' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'adGroupIds', adGroupIds)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'endDate', endDate)
            // verify required parameter 'targetingTypes' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'targetingTypes', targetingTypes)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('adGroupsTargetingAnalyticsGet', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups/targeting_analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (adGroupIds) {
                localVarQueryParameter['ad_group_ids'] = adGroupIds;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (targetingTypes) {
                localVarQueryParameter['targeting_types'] = targetingTypes.join(COLLECTION_FORMATS.csv);
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }

            if (attributionTypes !== undefined) {
                localVarQueryParameter['attribution_types'] = attributionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple existing ad groups.
         * @summary Update ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdGroupUpdateRequest>} adGroupUpdateRequest List of ad groups to update, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsUpdate: async (adAccountId: string, adGroupUpdateRequest: Array<AdGroupUpdateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adGroupsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'adGroupUpdateRequest' is not null or undefined
            assertParamExists('adGroupsUpdate', 'adGroupUpdateRequest', adGroupUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_groups`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdGroupsApi - functional programming interface
 * @export
 */
export const AdGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get analytics for the specified ad groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get ad group analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
         * @param {Array<AdGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsAnalytics(adAccountId: string, startDate: string, endDate: string, adGroupIds: Array<string>, columns: Array<AdGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdGroupsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdGroupsAnalyticsResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsAnalytics(adAccountId, startDate, endDate, adGroupIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get potential audience size for an ad group with given targeting criteria.  Potential audience size estimates the number of people you may be able to reach per month with your campaign.  It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
         * @summary Get audience sizing
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdGroupAudienceSizingRequest} [adGroupAudienceSizingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsAudienceSizing(adAccountId: string, adGroupAudienceSizingRequest?: AdGroupAudienceSizingRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdGroupAudienceSizingResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsAudienceSizing(adAccountId, adGroupAudienceSizingRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsAudienceSizing']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List bid floors for your campaign configuration. Bid floors are given in microcurrency values based on the currency in the bid floor specification. <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li>  </ul> For more on bid floors see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-your-bid\"> Set your bid</a>.
         * @summary Get bid floors
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BidFloorRequest} bidFloorRequest Parameters to get bid_floor info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsBidFloorGet(adAccountId: string, bidFloorRequest: BidFloorRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BidFloor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsBidFloorGet(adAccountId, bidFloorRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsBidFloorGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create multiple new ad groups. All ads in a given ad group will have the same budget, bid, run dates, targeting, and placement (search, browse, other). For more information, <a href=\"https://help.pinterest.com/en/business/article/campaign-structure\" target=\"_blank\"> click here</a>.</p> <strong>Note:</strong> - \'bid_in_micro_currency\' and \'budget_in_micro_currency\' should be expressed in microcurrency amounts based on the currency field set in the advertiser\'s profile.<p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul> - Ad groups belong to ad campaigns. Some types of campaigns (e.g. budget optimization) have limits on the number of ad groups they can hold. If you exceed those limits, you will get an error message. - Start and end time cannot be set for ad groups that belong to CBO campaigns. Currently, campaigns with the following objective types: TRAFFIC, AWARENESS, WEB_CONVERSIONS, and CATALOG_SALES will default to CBO.
         * @summary Create ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdGroupCreateRequest>} adGroupCreateRequest List of ad groups to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsCreate(adAccountId: string, adGroupCreateRequest: Array<AdGroupCreateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdGroupArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsCreate(adAccountId, adGroupCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
         * @summary Get ad group
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} adGroupId Unique identifier of an ad group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsGet(adAccountId: string, adGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsGet(adAccountId, adGroupId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List ad groups based on provided campaign IDs or ad group IDs.(campaign_ids or ad_group_ids). <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id. Do not provide both.
         * @summary List ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
         * @param {Array<AdGroupsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AdGroupsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {boolean} [translateInterestsToNames] Return interests as text names (if value is true) rather than topic IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsList(adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, entityStatuses?: Array<AdGroupsListEntityStatusesEnum>, pageSize?: number, order?: AdGroupsListOrderEnum, bookmark?: string, translateInterestsToNames?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdGroupsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsList(adAccountId, campaignIds, adGroupIds, entityStatuses, pageSize, order, bookmark, translateInterestsToNames, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get targeting analytics for one or more ad groups. For the requested ad group(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdGroupsTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdGroupsTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdGroupsTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsTargetingAnalyticsGet(adAccountId: string, adGroupIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdGroupsTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdGroupsTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdGroupsTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsTargetingAnalyticsGet(adAccountId, adGroupIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsTargetingAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple existing ad groups.
         * @summary Update ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdGroupUpdateRequest>} adGroupUpdateRequest List of ad groups to update, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adGroupsUpdate(adAccountId: string, adGroupUpdateRequest: Array<AdGroupUpdateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdGroupArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adGroupsUpdate(adAccountId, adGroupUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdGroupsApi.adGroupsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdGroupsApi - factory interface
 * @export
 */
export const AdGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdGroupsApiFp(configuration)
    return {
        /**
         * Get analytics for the specified ad groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get ad group analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
         * @param {Array<AdGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsAnalytics(adAccountId: string, startDate: string, endDate: string, adGroupIds: Array<string>, columns: Array<AdGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdGroupsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<AdGroupsAnalyticsResponseInner>> {
            return localVarFp.adGroupsAnalytics(adAccountId, startDate, endDate, adGroupIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Get potential audience size for an ad group with given targeting criteria.  Potential audience size estimates the number of people you may be able to reach per month with your campaign.  It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
         * @summary Get audience sizing
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdGroupAudienceSizingRequest} [adGroupAudienceSizingRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsAudienceSizing(adAccountId: string, adGroupAudienceSizingRequest?: AdGroupAudienceSizingRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdGroupAudienceSizingResponse> {
            return localVarFp.adGroupsAudienceSizing(adAccountId, adGroupAudienceSizingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List bid floors for your campaign configuration. Bid floors are given in microcurrency values based on the currency in the bid floor specification. <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li>  </ul> For more on bid floors see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-your-bid\"> Set your bid</a>.
         * @summary Get bid floors
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BidFloorRequest} bidFloorRequest Parameters to get bid_floor info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsBidFloorGet(adAccountId: string, bidFloorRequest: BidFloorRequest, options?: RawAxiosRequestConfig): AxiosPromise<BidFloor> {
            return localVarFp.adGroupsBidFloorGet(adAccountId, bidFloorRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple new ad groups. All ads in a given ad group will have the same budget, bid, run dates, targeting, and placement (search, browse, other). For more information, <a href=\"https://help.pinterest.com/en/business/article/campaign-structure\" target=\"_blank\"> click here</a>.</p> <strong>Note:</strong> - \'bid_in_micro_currency\' and \'budget_in_micro_currency\' should be expressed in microcurrency amounts based on the currency field set in the advertiser\'s profile.<p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul> - Ad groups belong to ad campaigns. Some types of campaigns (e.g. budget optimization) have limits on the number of ad groups they can hold. If you exceed those limits, you will get an error message. - Start and end time cannot be set for ad groups that belong to CBO campaigns. Currently, campaigns with the following objective types: TRAFFIC, AWARENESS, WEB_CONVERSIONS, and CATALOG_SALES will default to CBO.
         * @summary Create ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdGroupCreateRequest>} adGroupCreateRequest List of ad groups to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsCreate(adAccountId: string, adGroupCreateRequest: Array<AdGroupCreateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<AdGroupArrayResponse> {
            return localVarFp.adGroupsCreate(adAccountId, adGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
         * @summary Get ad group
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} adGroupId Unique identifier of an ad group.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsGet(adAccountId: string, adGroupId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdGroupResponse> {
            return localVarFp.adGroupsGet(adAccountId, adGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List ad groups based on provided campaign IDs or ad group IDs.(campaign_ids or ad_group_ids). <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id. Do not provide both.
         * @summary List ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
         * @param {Array<AdGroupsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AdGroupsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {boolean} [translateInterestsToNames] Return interests as text names (if value is true) rather than topic IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsList(adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, entityStatuses?: Array<AdGroupsListEntityStatusesEnum>, pageSize?: number, order?: AdGroupsListOrderEnum, bookmark?: string, translateInterestsToNames?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<AdGroupsList200Response> {
            return localVarFp.adGroupsList(adAccountId, campaignIds, adGroupIds, entityStatuses, pageSize, order, bookmark, translateInterestsToNames, options).then((request) => request(axios, basePath));
        },
        /**
         * Get targeting analytics for one or more ad groups. For the requested ad group(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdGroupsTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdGroupsTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdGroupsTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdGroupsTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsTargetingAnalyticsGet(adAccountId: string, adGroupIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdGroupsTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdGroupsTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdGroupsTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): AxiosPromise<MetricsResponse> {
            return localVarFp.adGroupsTargetingAnalyticsGet(adAccountId, adGroupIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple existing ad groups.
         * @summary Update ad groups
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdGroupUpdateRequest>} adGroupUpdateRequest List of ad groups to update, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adGroupsUpdate(adAccountId: string, adGroupUpdateRequest: Array<AdGroupUpdateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<AdGroupArrayResponse> {
            return localVarFp.adGroupsUpdate(adAccountId, adGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdGroupsApi - object-oriented interface
 * @export
 * @class AdGroupsApi
 * @extends {BaseAPI}
 */
export class AdGroupsApi extends BaseAPI {
    /**
     * Get analytics for the specified ad groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get ad group analytics
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
     * @param {Array<AdGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {AdGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {AdGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsAnalytics(adAccountId: string, startDate: string, endDate: string, adGroupIds: Array<string>, columns: Array<AdGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdGroupsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsAnalytics(adAccountId, startDate, endDate, adGroupIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get potential audience size for an ad group with given targeting criteria.  Potential audience size estimates the number of people you may be able to reach per month with your campaign.  It is based on historical advertising data and the targeting criteria you select. It does not guarantee results or take into account factors such as bid, budget, schedule, seasonality or product experiments.
     * @summary Get audience sizing
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AdGroupAudienceSizingRequest} [adGroupAudienceSizingRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsAudienceSizing(adAccountId: string, adGroupAudienceSizingRequest?: AdGroupAudienceSizingRequest, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsAudienceSizing(adAccountId, adGroupAudienceSizingRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List bid floors for your campaign configuration. Bid floors are given in microcurrency values based on the currency in the bid floor specification. <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li>  </ul> For more on bid floors see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-your-bid\"> Set your bid</a>.
     * @summary Get bid floors
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {BidFloorRequest} bidFloorRequest Parameters to get bid_floor info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsBidFloorGet(adAccountId: string, bidFloorRequest: BidFloorRequest, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsBidFloorGet(adAccountId, bidFloorRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple new ad groups. All ads in a given ad group will have the same budget, bid, run dates, targeting, and placement (search, browse, other). For more information, <a href=\"https://help.pinterest.com/en/business/article/campaign-structure\" target=\"_blank\"> click here</a>.</p> <strong>Note:</strong> - \'bid_in_micro_currency\' and \'budget_in_micro_currency\' should be expressed in microcurrency amounts based on the currency field set in the advertiser\'s profile.<p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul> - Ad groups belong to ad campaigns. Some types of campaigns (e.g. budget optimization) have limits on the number of ad groups they can hold. If you exceed those limits, you will get an error message. - Start and end time cannot be set for ad groups that belong to CBO campaigns. Currently, campaigns with the following objective types: TRAFFIC, AWARENESS, WEB_CONVERSIONS, and CATALOG_SALES will default to CBO.
     * @summary Create ad groups
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<AdGroupCreateRequest>} adGroupCreateRequest List of ad groups to create, size limit [1, 30].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsCreate(adAccountId: string, adGroupCreateRequest: Array<AdGroupCreateRequest>, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsCreate(adAccountId, adGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
     * @summary Get ad group
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} adGroupId Unique identifier of an ad group.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsGet(adAccountId: string, adGroupId: string, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsGet(adAccountId, adGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ad groups based on provided campaign IDs or ad group IDs.(campaign_ids or ad_group_ids). <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id. Do not provide both.
     * @summary List ad groups
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
     * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
     * @param {Array<AdGroupsListEntityStatusesEnum>} [entityStatuses] Entity status
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {AdGroupsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {boolean} [translateInterestsToNames] Return interests as text names (if value is true) rather than topic IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsList(adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, entityStatuses?: Array<AdGroupsListEntityStatusesEnum>, pageSize?: number, order?: AdGroupsListOrderEnum, bookmark?: string, translateInterestsToNames?: boolean, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsList(adAccountId, campaignIds, adGroupIds, entityStatuses, pageSize, order, bookmark, translateInterestsToNames, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get targeting analytics for one or more ad groups. For the requested ad group(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get targeting analytics for ad groups
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} adGroupIds List of Ad group Ids to use to filter the results.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<AdsAnalyticsTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
     * @param {Array<AdGroupsTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {AdGroupsTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdGroupsTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {AdGroupsTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsTargetingAnalyticsGet(adAccountId: string, adGroupIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsTargetingType>, columns: Array<AdGroupsTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdGroupsTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdGroupsTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdGroupsTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsTargetingAnalyticsGet(adAccountId, adGroupIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple existing ad groups.
     * @summary Update ad groups
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<AdGroupUpdateRequest>} adGroupUpdateRequest List of ad groups to update, size limit [1, 30].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdGroupsApi
     */
    public adGroupsUpdate(adAccountId: string, adGroupUpdateRequest: Array<AdGroupUpdateRequest>, options?: RawAxiosRequestConfig) {
        return AdGroupsApiFp(this.configuration).adGroupsUpdate(adAccountId, adGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AdGroupsAnalyticsColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type AdGroupsAnalyticsColumnsEnum = typeof AdGroupsAnalyticsColumnsEnum[keyof typeof AdGroupsAnalyticsColumnsEnum];
/**
 * @export
 */
export const AdGroupsAnalyticsClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdGroupsAnalyticsClickWindowDaysEnum = typeof AdGroupsAnalyticsClickWindowDaysEnum[keyof typeof AdGroupsAnalyticsClickWindowDaysEnum];
/**
 * @export
 */
export const AdGroupsAnalyticsEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdGroupsAnalyticsEngagementWindowDaysEnum = typeof AdGroupsAnalyticsEngagementWindowDaysEnum[keyof typeof AdGroupsAnalyticsEngagementWindowDaysEnum];
/**
 * @export
 */
export const AdGroupsAnalyticsViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdGroupsAnalyticsViewWindowDaysEnum = typeof AdGroupsAnalyticsViewWindowDaysEnum[keyof typeof AdGroupsAnalyticsViewWindowDaysEnum];
/**
 * @export
 */
export const AdGroupsAnalyticsConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type AdGroupsAnalyticsConversionReportTimeEnum = typeof AdGroupsAnalyticsConversionReportTimeEnum[keyof typeof AdGroupsAnalyticsConversionReportTimeEnum];
/**
 * @export
 */
export const AdGroupsListEntityStatusesEnum = {
    Active: 'ACTIVE',
    Paused: 'PAUSED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;
export type AdGroupsListEntityStatusesEnum = typeof AdGroupsListEntityStatusesEnum[keyof typeof AdGroupsListEntityStatusesEnum];
/**
 * @export
 */
export const AdGroupsListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type AdGroupsListOrderEnum = typeof AdGroupsListOrderEnum[keyof typeof AdGroupsListOrderEnum];
/**
 * @export
 */
export const AdGroupsTargetingAnalyticsGetColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type AdGroupsTargetingAnalyticsGetColumnsEnum = typeof AdGroupsTargetingAnalyticsGetColumnsEnum[keyof typeof AdGroupsTargetingAnalyticsGetColumnsEnum];
/**
 * @export
 */
export const AdGroupsTargetingAnalyticsGetClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdGroupsTargetingAnalyticsGetClickWindowDaysEnum = typeof AdGroupsTargetingAnalyticsGetClickWindowDaysEnum[keyof typeof AdGroupsTargetingAnalyticsGetClickWindowDaysEnum];
/**
 * @export
 */
export const AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum = typeof AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum[keyof typeof AdGroupsTargetingAnalyticsGetEngagementWindowDaysEnum];
/**
 * @export
 */
export const AdGroupsTargetingAnalyticsGetViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdGroupsTargetingAnalyticsGetViewWindowDaysEnum = typeof AdGroupsTargetingAnalyticsGetViewWindowDaysEnum[keyof typeof AdGroupsTargetingAnalyticsGetViewWindowDaysEnum];
/**
 * @export
 */
export const AdGroupsTargetingAnalyticsGetConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type AdGroupsTargetingAnalyticsGetConversionReportTimeEnum = typeof AdGroupsTargetingAnalyticsGetConversionReportTimeEnum[keyof typeof AdGroupsTargetingAnalyticsGetConversionReportTimeEnum];


/**
 * AdsApi - axios parameter creator
 * @export
 */
export const AdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an ad preview given an ad account ID and either an existing organic pin ID or the URL for an image to be used to create the Pin and the ad. <p/> If you are creating a preview from an existing Pin, that Pin must be promotable: that is, it must have a clickthrough link and meet other requirements. (See <a href=\"https://help.pinterest.com/en/business/article/promoted-pins-overview\" target=\"_blank\">Ads Overview</a>.) <p/> You can view the returned preview URL on a webpage or iframe for 7 days, after which the URL expires. Collection ads are not currently supported ad preview.
         * @summary Create ad preview with pin or image
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdPreviewRequest} adPreviewRequest Create ad preview with pin or image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adPreviewsCreate: async (adAccountId: string, adPreviewRequest: AdPreviewRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adPreviewsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'adPreviewRequest' is not null or undefined
            assertParamExists('adPreviewsCreate', 'adPreviewRequest', adPreviewRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ad_previews`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adPreviewRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get targeting analytics for one or more ads. For the requested ad(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} adIds List of Ad Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsAdTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adTargetingAnalyticsGet: async (adAccountId: string, adIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsAdTargetingType>, columns: Array<AdTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'adAccountId', adAccountId)
            // verify required parameter 'adIds' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'adIds', adIds)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'endDate', endDate)
            // verify required parameter 'targetingTypes' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'targetingTypes', targetingTypes)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('adTargetingAnalyticsGet', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads/targeting_analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (adIds) {
                localVarQueryParameter['ad_ids'] = adIds;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (targetingTypes) {
                localVarQueryParameter['targeting_types'] = targetingTypes.join(COLLECTION_FORMATS.csv);
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }

            if (attributionTypes !== undefined) {
                localVarQueryParameter['attribution_types'] = attributionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics for the specified ads in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - The request must contain either ad_ids or both campaign_ids and pin_ids. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get ad analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
         * @param {AdsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {Array<string>} [pinIds] List of Pin IDs.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsAnalytics: async (adAccountId: string, startDate: string, endDate: string, columns: Array<AdsAnalyticsColumnsEnum>, granularity: Granularity, adIds?: Array<string>, clickWindowDays?: AdsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdsAnalyticsConversionReportTimeEnum, pinIds?: Array<string>, campaignIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsAnalytics', 'adAccountId', adAccountId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('adsAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('adsAnalytics', 'endDate', endDate)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('adsAnalytics', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('adsAnalytics', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads/analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (adIds) {
                localVarQueryParameter['ad_ids'] = adIds;
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }

            if (pinIds) {
                localVarQueryParameter['pin_ids'] = pinIds;
            }

            if (campaignIds) {
                localVarQueryParameter['campaign_ids'] = campaignIds;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple new ads. Request must contain ad_group_id, creative_type, and the source Pin pin_id.
         * @summary Create ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdCreateRequest>} adCreateRequest List of ads to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsCreate: async (adAccountId: string, adCreateRequest: Array<AdCreateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'adCreateRequest' is not null or undefined
            assertParamExists('adsCreate', 'adCreateRequest', adCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
         * @summary Get ad
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} adId Unique identifier of an ad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsGet: async (adAccountId: string, adId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsGet', 'adAccountId', adAccountId)
            // verify required parameter 'adId' is not null or undefined
            assertParamExists('adsGet', 'adId', adId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads/{ad_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"ad_id"}}`, encodeURIComponent(String(adId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ads that meet the filters provided:   - Listed campaign ids or ad group ids or ad ids   - Listed entity statuses <p/> If no filter is provided, all ads in the ad account are returned. <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id or ad_id. Do not provide more than one type. <p/> Review status is provided for each ad; if review_status is REJECTED, the rejected_reasons field will contain additional information. For more, see <a href=\"https://policy.pinterest.com/en/advertising-guidelines\">Pinterest advertising standards</a>.
         * @summary List ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
         * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
         * @param {Array<AdsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AdsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsList: async (adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, adIds?: Array<string>, entityStatuses?: Array<AdsListEntityStatusesEnum>, pageSize?: number, order?: AdsListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (campaignIds) {
                localVarQueryParameter['campaign_ids'] = campaignIds;
            }

            if (adGroupIds) {
                localVarQueryParameter['ad_group_ids'] = adGroupIds;
            }

            if (adIds) {
                localVarQueryParameter['ad_ids'] = adIds;
            }

            if (entityStatuses) {
                localVarQueryParameter['entity_statuses'] = entityStatuses;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple existing ads
         * @summary Update ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdUpdateRequest>} adUpdateRequest List of ads to update, size limit [1, 30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsUpdate: async (adAccountId: string, adUpdateRequest: Array<AdUpdateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'adUpdateRequest' is not null or undefined
            assertParamExists('adsUpdate', 'adUpdateRequest', adUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdsApi - functional programming interface
 * @export
 */
export const AdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an ad preview given an ad account ID and either an existing organic pin ID or the URL for an image to be used to create the Pin and the ad. <p/> If you are creating a preview from an existing Pin, that Pin must be promotable: that is, it must have a clickthrough link and meet other requirements. (See <a href=\"https://help.pinterest.com/en/business/article/promoted-pins-overview\" target=\"_blank\">Ads Overview</a>.) <p/> You can view the returned preview URL on a webpage or iframe for 7 days, after which the URL expires. Collection ads are not currently supported ad preview.
         * @summary Create ad preview with pin or image
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdPreviewRequest} adPreviewRequest Create ad preview with pin or image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adPreviewsCreate(adAccountId: string, adPreviewRequest: AdPreviewRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdPreviewURLResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adPreviewsCreate(adAccountId, adPreviewRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adPreviewsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get targeting analytics for one or more ads. For the requested ad(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} adIds List of Ad Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsAdTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adTargetingAnalyticsGet(adAccountId: string, adIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsAdTargetingType>, columns: Array<AdTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adTargetingAnalyticsGet(adAccountId, adIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adTargetingAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics for the specified ads in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - The request must contain either ad_ids or both campaign_ids and pin_ids. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get ad analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
         * @param {AdsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {Array<string>} [pinIds] List of Pin IDs.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsAnalytics(adAccountId: string, startDate: string, endDate: string, columns: Array<AdsAnalyticsColumnsEnum>, granularity: Granularity, adIds?: Array<string>, clickWindowDays?: AdsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdsAnalyticsConversionReportTimeEnum, pinIds?: Array<string>, campaignIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AdsAnalyticsResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsAnalytics(adAccountId, startDate, endDate, columns, granularity, adIds, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, pinIds, campaignIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create multiple new ads. Request must contain ad_group_id, creative_type, and the source Pin pin_id.
         * @summary Create ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdCreateRequest>} adCreateRequest List of ads to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsCreate(adAccountId: string, adCreateRequest: Array<AdCreateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsCreate(adAccountId, adCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
         * @summary Get ad
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} adId Unique identifier of an ad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsGet(adAccountId: string, adId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsGet(adAccountId, adId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List ads that meet the filters provided:   - Listed campaign ids or ad group ids or ad ids   - Listed entity statuses <p/> If no filter is provided, all ads in the ad account are returned. <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id or ad_id. Do not provide more than one type. <p/> Review status is provided for each ad; if review_status is REJECTED, the rejected_reasons field will contain additional information. For more, see <a href=\"https://policy.pinterest.com/en/advertising-guidelines\">Pinterest advertising standards</a>.
         * @summary List ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
         * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
         * @param {Array<AdsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AdsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsList(adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, adIds?: Array<string>, entityStatuses?: Array<AdsListEntityStatusesEnum>, pageSize?: number, order?: AdsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsList(adAccountId, campaignIds, adGroupIds, adIds, entityStatuses, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple existing ads
         * @summary Update ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdUpdateRequest>} adUpdateRequest List of ads to update, size limit [1, 30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsUpdate(adAccountId: string, adUpdateRequest: Array<AdUpdateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsUpdate(adAccountId, adUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdsApi.adsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdsApi - factory interface
 * @export
 */
export const AdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdsApiFp(configuration)
    return {
        /**
         * Create an ad preview given an ad account ID and either an existing organic pin ID or the URL for an image to be used to create the Pin and the ad. <p/> If you are creating a preview from an existing Pin, that Pin must be promotable: that is, it must have a clickthrough link and meet other requirements. (See <a href=\"https://help.pinterest.com/en/business/article/promoted-pins-overview\" target=\"_blank\">Ads Overview</a>.) <p/> You can view the returned preview URL on a webpage or iframe for 7 days, after which the URL expires. Collection ads are not currently supported ad preview.
         * @summary Create ad preview with pin or image
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdPreviewRequest} adPreviewRequest Create ad preview with pin or image.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adPreviewsCreate(adAccountId: string, adPreviewRequest: AdPreviewRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdPreviewURLResponse> {
            return localVarFp.adPreviewsCreate(adAccountId, adPreviewRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get targeting analytics for one or more ads. For the requested ad(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} adIds List of Ad Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsAdTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<AdTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {AdTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adTargetingAnalyticsGet(adAccountId: string, adIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsAdTargetingType>, columns: Array<AdTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): AxiosPromise<MetricsResponse> {
            return localVarFp.adTargetingAnalyticsGet(adAccountId, adIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics for the specified ads in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - The request must contain either ad_ids or both campaign_ids and pin_ids. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get ad analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
         * @param {AdsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {AdsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {AdsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {Array<string>} [pinIds] List of Pin IDs.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsAnalytics(adAccountId: string, startDate: string, endDate: string, columns: Array<AdsAnalyticsColumnsEnum>, granularity: Granularity, adIds?: Array<string>, clickWindowDays?: AdsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdsAnalyticsConversionReportTimeEnum, pinIds?: Array<string>, campaignIds?: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<Array<AdsAnalyticsResponseInner>> {
            return localVarFp.adsAnalytics(adAccountId, startDate, endDate, columns, granularity, adIds, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, pinIds, campaignIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple new ads. Request must contain ad_group_id, creative_type, and the source Pin pin_id.
         * @summary Create ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdCreateRequest>} adCreateRequest List of ads to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsCreate(adAccountId: string, adCreateRequest: Array<AdCreateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<AdArrayResponse> {
            return localVarFp.adsCreate(adAccountId, adCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
         * @summary Get ad
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} adId Unique identifier of an ad.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsGet(adAccountId: string, adId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdResponse> {
            return localVarFp.adsGet(adAccountId, adId, options).then((request) => request(axios, basePath));
        },
        /**
         * List ads that meet the filters provided:   - Listed campaign ids or ad group ids or ad ids   - Listed entity statuses <p/> If no filter is provided, all ads in the ad account are returned. <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id or ad_id. Do not provide more than one type. <p/> Review status is provided for each ad; if review_status is REJECTED, the rejected_reasons field will contain additional information. For more, see <a href=\"https://policy.pinterest.com/en/advertising-guidelines\">Pinterest advertising standards</a>.
         * @summary List ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
         * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
         * @param {Array<AdsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AdsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsList(adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, adIds?: Array<string>, entityStatuses?: Array<AdsListEntityStatusesEnum>, pageSize?: number, order?: AdsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdsList200Response> {
            return localVarFp.adsList(adAccountId, campaignIds, adGroupIds, adIds, entityStatuses, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple existing ads
         * @summary Update ads
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<AdUpdateRequest>} adUpdateRequest List of ads to update, size limit [1, 30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsUpdate(adAccountId: string, adUpdateRequest: Array<AdUpdateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<AdArrayResponse> {
            return localVarFp.adsUpdate(adAccountId, adUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdsApi - object-oriented interface
 * @export
 * @class AdsApi
 * @extends {BaseAPI}
 */
export class AdsApi extends BaseAPI {
    /**
     * Create an ad preview given an ad account ID and either an existing organic pin ID or the URL for an image to be used to create the Pin and the ad. <p/> If you are creating a preview from an existing Pin, that Pin must be promotable: that is, it must have a clickthrough link and meet other requirements. (See <a href=\"https://help.pinterest.com/en/business/article/promoted-pins-overview\" target=\"_blank\">Ads Overview</a>.) <p/> You can view the returned preview URL on a webpage or iframe for 7 days, after which the URL expires. Collection ads are not currently supported ad preview.
     * @summary Create ad preview with pin or image
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AdPreviewRequest} adPreviewRequest Create ad preview with pin or image.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adPreviewsCreate(adAccountId: string, adPreviewRequest: AdPreviewRequest, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adPreviewsCreate(adAccountId, adPreviewRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get targeting analytics for one or more ads. For the requested ad(s) and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get targeting analytics for ads
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} adIds List of Ad Ids to use to filter the results.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<AdsAnalyticsAdTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
     * @param {Array<AdTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {AdTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {AdTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adTargetingAnalyticsGet(adAccountId: string, adIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsAdTargetingType>, columns: Array<AdTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: AdTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: AdTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: AdTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: AdTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adTargetingAnalyticsGet(adAccountId, adIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics for the specified ads in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - The request must contain either ad_ids or both campaign_ids and pin_ids. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get ad analytics
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<AdsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
     * @param {AdsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {AdsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {AdsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {Array<string>} [pinIds] List of Pin IDs.
     * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adsAnalytics(adAccountId: string, startDate: string, endDate: string, columns: Array<AdsAnalyticsColumnsEnum>, granularity: Granularity, adIds?: Array<string>, clickWindowDays?: AdsAnalyticsClickWindowDaysEnum, engagementWindowDays?: AdsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: AdsAnalyticsViewWindowDaysEnum, conversionReportTime?: AdsAnalyticsConversionReportTimeEnum, pinIds?: Array<string>, campaignIds?: Array<string>, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsAnalytics(adAccountId, startDate, endDate, columns, granularity, adIds, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, pinIds, campaignIds, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple new ads. Request must contain ad_group_id, creative_type, and the source Pin pin_id.
     * @summary Create ads
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<AdCreateRequest>} adCreateRequest List of ads to create, size limit [1, 30].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adsCreate(adAccountId: string, adCreateRequest: Array<AdCreateRequest>, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsCreate(adAccountId, adCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific ad given the ad ID. If your pin is rejected, rejected_reasons will contain additional information from the Ad Review process. For more information about our policies and rejection reasons see the <a href=\"https://www.pinterest.com/_/_/policy/advertising-guidelines/\" target=\"_blank\">Pinterest advertising standards</a>.
     * @summary Get ad
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} adId Unique identifier of an ad.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adsGet(adAccountId: string, adId: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsGet(adAccountId, adId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ads that meet the filters provided:   - Listed campaign ids or ad group ids or ad ids   - Listed entity statuses <p/> If no filter is provided, all ads in the ad account are returned. <p/> <strong>Note:</strong><p/> Provide only campaign_id or ad_group_id or ad_id. Do not provide more than one type. <p/> Review status is provided for each ad; if review_status is REJECTED, the rejected_reasons field will contain additional information. For more, see <a href=\"https://policy.pinterest.com/en/advertising-guidelines\">Pinterest advertising standards</a>.
     * @summary List ads
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
     * @param {Array<string>} [adGroupIds] List of Ad group Ids to use to filter the results.
     * @param {Array<string>} [adIds] List of Ad Ids to use to filter the results.
     * @param {Array<AdsListEntityStatusesEnum>} [entityStatuses] Entity status
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {AdsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adsList(adAccountId: string, campaignIds?: Array<string>, adGroupIds?: Array<string>, adIds?: Array<string>, entityStatuses?: Array<AdsListEntityStatusesEnum>, pageSize?: number, order?: AdsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsList(adAccountId, campaignIds, adGroupIds, adIds, entityStatuses, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple existing ads
     * @summary Update ads
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<AdUpdateRequest>} adUpdateRequest List of ads to update, size limit [1, 30]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdsApi
     */
    public adsUpdate(adAccountId: string, adUpdateRequest: Array<AdUpdateRequest>, options?: RawAxiosRequestConfig) {
        return AdsApiFp(this.configuration).adsUpdate(adAccountId, adUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AdTargetingAnalyticsGetColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type AdTargetingAnalyticsGetColumnsEnum = typeof AdTargetingAnalyticsGetColumnsEnum[keyof typeof AdTargetingAnalyticsGetColumnsEnum];
/**
 * @export
 */
export const AdTargetingAnalyticsGetClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdTargetingAnalyticsGetClickWindowDaysEnum = typeof AdTargetingAnalyticsGetClickWindowDaysEnum[keyof typeof AdTargetingAnalyticsGetClickWindowDaysEnum];
/**
 * @export
 */
export const AdTargetingAnalyticsGetEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdTargetingAnalyticsGetEngagementWindowDaysEnum = typeof AdTargetingAnalyticsGetEngagementWindowDaysEnum[keyof typeof AdTargetingAnalyticsGetEngagementWindowDaysEnum];
/**
 * @export
 */
export const AdTargetingAnalyticsGetViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdTargetingAnalyticsGetViewWindowDaysEnum = typeof AdTargetingAnalyticsGetViewWindowDaysEnum[keyof typeof AdTargetingAnalyticsGetViewWindowDaysEnum];
/**
 * @export
 */
export const AdTargetingAnalyticsGetConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type AdTargetingAnalyticsGetConversionReportTimeEnum = typeof AdTargetingAnalyticsGetConversionReportTimeEnum[keyof typeof AdTargetingAnalyticsGetConversionReportTimeEnum];
/**
 * @export
 */
export const AdsAnalyticsColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type AdsAnalyticsColumnsEnum = typeof AdsAnalyticsColumnsEnum[keyof typeof AdsAnalyticsColumnsEnum];
/**
 * @export
 */
export const AdsAnalyticsClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdsAnalyticsClickWindowDaysEnum = typeof AdsAnalyticsClickWindowDaysEnum[keyof typeof AdsAnalyticsClickWindowDaysEnum];
/**
 * @export
 */
export const AdsAnalyticsEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdsAnalyticsEngagementWindowDaysEnum = typeof AdsAnalyticsEngagementWindowDaysEnum[keyof typeof AdsAnalyticsEngagementWindowDaysEnum];
/**
 * @export
 */
export const AdsAnalyticsViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type AdsAnalyticsViewWindowDaysEnum = typeof AdsAnalyticsViewWindowDaysEnum[keyof typeof AdsAnalyticsViewWindowDaysEnum];
/**
 * @export
 */
export const AdsAnalyticsConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type AdsAnalyticsConversionReportTimeEnum = typeof AdsAnalyticsConversionReportTimeEnum[keyof typeof AdsAnalyticsConversionReportTimeEnum];
/**
 * @export
 */
export const AdsListEntityStatusesEnum = {
    Active: 'ACTIVE',
    Paused: 'PAUSED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;
export type AdsListEntityStatusesEnum = typeof AdsListEntityStatusesEnum[keyof typeof AdsListEntityStatusesEnum];
/**
 * @export
 */
export const AdsListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type AdsListOrderEnum = typeof AdsListOrderEnum[keyof typeof AdsListOrderEnum];


/**
 * AdvancedAuctionApi - axios parameter creator
 * @export
 */
export const AdvancedAuctionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the bid options for a batch of retail catalog items.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
         * @summary Get item bid options (POST)
         * @param {AdvancedAuctionItemsGetRequest} advancedAuctionItemsGetRequest Request object used to get bid options values for a batch of retail catalog items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedAuctionItemsGetPost: async (advancedAuctionItemsGetRequest: AdvancedAuctionItemsGetRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'advancedAuctionItemsGetRequest' is not null or undefined
            assertParamExists('advancedAuctionItemsGetPost', 'advancedAuctionItemsGetRequest', advancedAuctionItemsGetRequest)
            const localVarPath = `/advanced_auction/items/get`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read", "catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(advancedAuctionItemsGetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint supports multiple operations on a set of one or more bid options (bid price and bid adjustments for targeting categories) for retail catalog items. These advanced auction settings are applied in campaigns using objective_type `CATALOG_SALES` and ad groups using bid_strategy_type `MAX_BID`.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/modify-items-in-batch/\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
         * @summary Operate on item level bid options
         * @param {AdvancedAuctionItemsSubmitRequest} advancedAuctionItemsSubmitRequest Request object used to upsert or delete bid options for a batch of retail catalog items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedAuctionItemsSubmitPost: async (advancedAuctionItemsSubmitRequest: AdvancedAuctionItemsSubmitRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'advancedAuctionItemsSubmitRequest' is not null or undefined
            assertParamExists('advancedAuctionItemsSubmitPost', 'advancedAuctionItemsSubmitRequest', advancedAuctionItemsSubmitRequest)
            const localVarPath = `/advanced_auction/items/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write", "catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(advancedAuctionItemsSubmitRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvancedAuctionApi - functional programming interface
 * @export
 */
export const AdvancedAuctionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdvancedAuctionApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the bid options for a batch of retail catalog items.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
         * @summary Get item bid options (POST)
         * @param {AdvancedAuctionItemsGetRequest} advancedAuctionItemsGetRequest Request object used to get bid options values for a batch of retail catalog items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advancedAuctionItemsGetPost(advancedAuctionItemsGetRequest: AdvancedAuctionItemsGetRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdvancedAuctionItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advancedAuctionItemsGetPost(advancedAuctionItemsGetRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdvancedAuctionApi.advancedAuctionItemsGetPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint supports multiple operations on a set of one or more bid options (bid price and bid adjustments for targeting categories) for retail catalog items. These advanced auction settings are applied in campaigns using objective_type `CATALOG_SALES` and ad groups using bid_strategy_type `MAX_BID`.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/modify-items-in-batch/\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
         * @summary Operate on item level bid options
         * @param {AdvancedAuctionItemsSubmitRequest} advancedAuctionItemsSubmitRequest Request object used to upsert or delete bid options for a batch of retail catalog items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async advancedAuctionItemsSubmitPost(advancedAuctionItemsSubmitRequest: AdvancedAuctionItemsSubmitRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdvancedAuctionProcessedItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.advancedAuctionItemsSubmitPost(advancedAuctionItemsSubmitRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdvancedAuctionApi.advancedAuctionItemsSubmitPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdvancedAuctionApi - factory interface
 * @export
 */
export const AdvancedAuctionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdvancedAuctionApiFp(configuration)
    return {
        /**
         * Get the bid options for a batch of retail catalog items.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
         * @summary Get item bid options (POST)
         * @param {AdvancedAuctionItemsGetRequest} advancedAuctionItemsGetRequest Request object used to get bid options values for a batch of retail catalog items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedAuctionItemsGetPost(advancedAuctionItemsGetRequest: AdvancedAuctionItemsGetRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdvancedAuctionItems> {
            return localVarFp.advancedAuctionItemsGetPost(advancedAuctionItemsGetRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint supports multiple operations on a set of one or more bid options (bid price and bid adjustments for targeting categories) for retail catalog items. These advanced auction settings are applied in campaigns using objective_type `CATALOG_SALES` and ad groups using bid_strategy_type `MAX_BID`.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/modify-items-in-batch/\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
         * @summary Operate on item level bid options
         * @param {AdvancedAuctionItemsSubmitRequest} advancedAuctionItemsSubmitRequest Request object used to upsert or delete bid options for a batch of retail catalog items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        advancedAuctionItemsSubmitPost(advancedAuctionItemsSubmitRequest: AdvancedAuctionItemsSubmitRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdvancedAuctionProcessedItems> {
            return localVarFp.advancedAuctionItemsSubmitPost(advancedAuctionItemsSubmitRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdvancedAuctionApi - object-oriented interface
 * @export
 * @class AdvancedAuctionApi
 * @extends {BaseAPI}
 */
export class AdvancedAuctionApi extends BaseAPI {
    /**
     * Get the bid options for a batch of retail catalog items.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
     * @summary Get item bid options (POST)
     * @param {AdvancedAuctionItemsGetRequest} advancedAuctionItemsGetRequest Request object used to get bid options values for a batch of retail catalog items
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvancedAuctionApi
     */
    public advancedAuctionItemsGetPost(advancedAuctionItemsGetRequest: AdvancedAuctionItemsGetRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return AdvancedAuctionApiFp(this.configuration).advancedAuctionItemsGetPost(advancedAuctionItemsGetRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint supports multiple operations on a set of one or more bid options (bid price and bid adjustments for targeting categories) for retail catalog items. These advanced auction settings are applied in campaigns using objective_type `CATALOG_SALES` and ad groups using bid_strategy_type `MAX_BID`.  The catalog must be owned by the \"operation user_account\". <a href=\"/docs/api-features/modify-items-in-batch/\" target=\"_blank\">See detailed documentation here.</a> By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: `Owner`, `Admin`.  This endpoint is not available to all users.
     * @summary Operate on item level bid options
     * @param {AdvancedAuctionItemsSubmitRequest} advancedAuctionItemsSubmitRequest Request object used to upsert or delete bid options for a batch of retail catalog items
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvancedAuctionApi
     */
    public advancedAuctionItemsSubmitPost(advancedAuctionItemsSubmitRequest: AdvancedAuctionItemsSubmitRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return AdvancedAuctionApiFp(this.configuration).advancedAuctionItemsSubmitPost(advancedAuctionItemsSubmitRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AudienceInsightsApi - axios parameter creator
 * @export
 */
export const AudienceInsightsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Audience Insights for an ad account. The response will return insights for 3 types of audiences: the ad account\'s engaged audience on Pinterest, the ad account\'s total audience on Pinterest and Pinterest\'s total audience.<p/> <a href=\"https://help.pinterest.com/en/business/article/audience-insights\" target=\"_blank\">Learn more about Audience Insights</a>.
         * @summary Get audience insights
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceInsightType} audienceInsightType Type of audience insights.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienceInsightsGet: async (adAccountId: string, audienceInsightType: AudienceInsightType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audienceInsightsGet', 'adAccountId', adAccountId)
            // verify required parameter 'audienceInsightType' is not null or undefined
            assertParamExists('audienceInsightsGet', 'audienceInsightType', audienceInsightType)
            const localVarPath = `/ad_accounts/{ad_account_id}/audience_insights`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (audienceInsightType !== undefined) {
                localVarQueryParameter['audience_insight_type'] = audienceInsightType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the scope and type of available audiences, which along with a date, is an audience that has recently had an interaction (referred to here as a type) on pins. Interacted pins can belong to at least the most common **partner** or **Pinterest** scopes. This means that user interactions made on advertiser or partner pins will have the **partner** scope. You can also have user interactions performed in general on Pinterest with the **Pinterest** scope. In that case, you can then use the returned type and scope values together on requests to other endpoints to retrieve insight metrics for a desired audience.
         * @summary Get audience insights scope and type
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienceInsightsScopeAndTypeGet: async (adAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audienceInsightsScopeAndTypeGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/insights/audiences`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudienceInsightsApi - functional programming interface
 * @export
 */
export const AudienceInsightsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudienceInsightsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Audience Insights for an ad account. The response will return insights for 3 types of audiences: the ad account\'s engaged audience on Pinterest, the ad account\'s total audience on Pinterest and Pinterest\'s total audience.<p/> <a href=\"https://help.pinterest.com/en/business/article/audience-insights\" target=\"_blank\">Learn more about Audience Insights</a>.
         * @summary Get audience insights
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceInsightType} audienceInsightType Type of audience insights.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audienceInsightsGet(adAccountId: string, audienceInsightType: AudienceInsightType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudienceInsightsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audienceInsightsGet(adAccountId, audienceInsightType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceInsightsApi.audienceInsightsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the scope and type of available audiences, which along with a date, is an audience that has recently had an interaction (referred to here as a type) on pins. Interacted pins can belong to at least the most common **partner** or **Pinterest** scopes. This means that user interactions made on advertiser or partner pins will have the **partner** scope. You can also have user interactions performed in general on Pinterest with the **Pinterest** scope. In that case, you can then use the returned type and scope values together on requests to other endpoints to retrieve insight metrics for a desired audience.
         * @summary Get audience insights scope and type
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audienceInsightsScopeAndTypeGet(adAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudienceDefinitionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audienceInsightsScopeAndTypeGet(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceInsightsApi.audienceInsightsScopeAndTypeGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudienceInsightsApi - factory interface
 * @export
 */
export const AudienceInsightsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudienceInsightsApiFp(configuration)
    return {
        /**
         * Get Audience Insights for an ad account. The response will return insights for 3 types of audiences: the ad account\'s engaged audience on Pinterest, the ad account\'s total audience on Pinterest and Pinterest\'s total audience.<p/> <a href=\"https://help.pinterest.com/en/business/article/audience-insights\" target=\"_blank\">Learn more about Audience Insights</a>.
         * @summary Get audience insights
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceInsightType} audienceInsightType Type of audience insights.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienceInsightsGet(adAccountId: string, audienceInsightType: AudienceInsightType, options?: RawAxiosRequestConfig): AxiosPromise<AudienceInsightsResponse> {
            return localVarFp.audienceInsightsGet(adAccountId, audienceInsightType, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the scope and type of available audiences, which along with a date, is an audience that has recently had an interaction (referred to here as a type) on pins. Interacted pins can belong to at least the most common **partner** or **Pinterest** scopes. This means that user interactions made on advertiser or partner pins will have the **partner** scope. You can also have user interactions performed in general on Pinterest with the **Pinterest** scope. In that case, you can then use the returned type and scope values together on requests to other endpoints to retrieve insight metrics for a desired audience.
         * @summary Get audience insights scope and type
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audienceInsightsScopeAndTypeGet(adAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<AudienceDefinitionResponse> {
            return localVarFp.audienceInsightsScopeAndTypeGet(adAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudienceInsightsApi - object-oriented interface
 * @export
 * @class AudienceInsightsApi
 * @extends {BaseAPI}
 */
export class AudienceInsightsApi extends BaseAPI {
    /**
     * Get Audience Insights for an ad account. The response will return insights for 3 types of audiences: the ad account\'s engaged audience on Pinterest, the ad account\'s total audience on Pinterest and Pinterest\'s total audience.<p/> <a href=\"https://help.pinterest.com/en/business/article/audience-insights\" target=\"_blank\">Learn more about Audience Insights</a>.
     * @summary Get audience insights
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AudienceInsightType} audienceInsightType Type of audience insights.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceInsightsApi
     */
    public audienceInsightsGet(adAccountId: string, audienceInsightType: AudienceInsightType, options?: RawAxiosRequestConfig) {
        return AudienceInsightsApiFp(this.configuration).audienceInsightsGet(adAccountId, audienceInsightType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the scope and type of available audiences, which along with a date, is an audience that has recently had an interaction (referred to here as a type) on pins. Interacted pins can belong to at least the most common **partner** or **Pinterest** scopes. This means that user interactions made on advertiser or partner pins will have the **partner** scope. You can also have user interactions performed in general on Pinterest with the **Pinterest** scope. In that case, you can then use the returned type and scope values together on requests to other endpoints to retrieve insight metrics for a desired audience.
     * @summary Get audience insights scope and type
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceInsightsApi
     */
    public audienceInsightsScopeAndTypeGet(adAccountId: string, options?: RawAxiosRequestConfig) {
        return AudienceInsightsApiFp(this.configuration).audienceInsightsScopeAndTypeGet(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AudienceSharingApi - axios parameter creator
 * @export
 */
export const AudienceSharingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all ad accounts and/or businesses that have access to a specific audience. The audience must be owned by the requesting ad account.
         * @summary List accounts with access to an audience owned by an ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of the audience to use to filter the results.
         * @param {AudienceAccountType} accountType Filter accounts by account type.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsAudiencesSharedAccountsList: async (adAccountId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountsAudiencesSharedAccountsList', 'adAccountId', adAccountId)
            // verify required parameter 'audienceId' is not null or undefined
            assertParamExists('adAccountsAudiencesSharedAccountsList', 'audienceId', audienceId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('adAccountsAudiencesSharedAccountsList', 'accountType', accountType)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences/shared/accounts`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (audienceId !== undefined) {
                localVarQueryParameter['audience_id'] = audienceId;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['account_type'] = accountType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all ad accounts and/or businesses that have access to a specific audience. The audience must either be owned by an ad account in the requesting business, or it must have been shared with the requesting business. If the requesting business is not the owner of the audience, only ad accounts owned by the requesting business will be returned.
         * @summary List accounts with access to an audience owned by a business
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} audienceId Unique identifier of the audience to use to filter the results.
         * @param {AudienceAccountType} accountType Filter accounts by account type.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAccountAudiencesSharedAccountsList: async (businessId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessAccountAudiencesSharedAccountsList', 'businessId', businessId)
            // verify required parameter 'audienceId' is not null or undefined
            assertParamExists('businessAccountAudiencesSharedAccountsList', 'audienceId', audienceId)
            // verify required parameter 'accountType' is not null or undefined
            assertParamExists('businessAccountAudiencesSharedAccountsList', 'accountType', accountType)
            const localVarPath = `/businesses/{business_id}/audiences/shared/accounts`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (audienceId !== undefined) {
                localVarQueryParameter['audience_id'] = audienceId;
            }

            if (accountType !== undefined) {
                localVarQueryParameter['account_type'] = accountType;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of received audiences for the given business.
         * @summary List received audiences for a business
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {SharedAudiencesForBusinessListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedAudiencesForBusinessList: async (businessId: string, bookmark?: string, order?: SharedAudiencesForBusinessListOrderEnum, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('sharedAudiencesForBusinessList', 'businessId', businessId)
            const localVarPath = `/businesses/{business_id}/audiences`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * From an ad account, share a specific audience with another ad account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient ad account(s) must be in the same <a href=\'https://help.pinterest.com/en/business/article/create-and-manage-accounts\'>Pinterest Business Hierarchy</a> as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing between ad accounts
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SharedAudience} sharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdAccountToAdAccountSharedAudience: async (adAccountId: string, sharedAudience: SharedAudience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('updateAdAccountToAdAccountSharedAudience', 'adAccountId', adAccountId)
            // verify required parameter 'sharedAudience' is not null or undefined
            assertParamExists('updateAdAccountToAdAccountSharedAudience', 'sharedAudience', sharedAudience)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences/ad_accounts/shared`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharedAudience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * From an ad account, share a specific audience with a business account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient business account must be in the same business hierarchy as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing from an ad account to businesses
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BusinessSharedAudience} businessSharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdAccountToBusinessSharedAudience: async (adAccountId: string, businessSharedAudience: BusinessSharedAudience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('updateAdAccountToBusinessSharedAudience', 'adAccountId', adAccountId)
            // verify required parameter 'businessSharedAudience' is not null or undefined
            assertParamExists('updateAdAccountToBusinessSharedAudience', 'businessSharedAudience', businessSharedAudience)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences/businesses/shared`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessSharedAudience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * From a business, share a specific audience with other ad account(s), or revoke access to a previously shared audience. <ul> <li>If the business is the owner of the audience, it can share with any ad account within the same business hierarchy.</li> <li>If the business is the recipient of the audience, it can share with any of its owned ad accounts.</li> </ul> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing from a business to ad accounts
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {SharedAudience} sharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessToAdAccountSharedAudience: async (businessId: string, sharedAudience: SharedAudience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updateBusinessToAdAccountSharedAudience', 'businessId', businessId)
            // verify required parameter 'sharedAudience' is not null or undefined
            assertParamExists('updateBusinessToAdAccountSharedAudience', 'sharedAudience', sharedAudience)
            const localVarPath = `/businesses/{business_id}/audiences/ad_accounts/shared`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sharedAudience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * From a business, share a specific audience with another business account, or revoke access to a previously shared audience. Only the audience owner can share the audience with other businesses, and the recipient business must be within the same business hierarchy.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing between businesses
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {BusinessSharedAudience} businessSharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessToBusinessSharedAudience: async (businessId: string, businessSharedAudience: BusinessSharedAudience, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updateBusinessToBusinessSharedAudience', 'businessId', businessId)
            // verify required parameter 'businessSharedAudience' is not null or undefined
            assertParamExists('updateBusinessToBusinessSharedAudience', 'businessSharedAudience', businessSharedAudience)
            const localVarPath = `/businesses/{business_id}/audiences/businesses/shared`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessSharedAudience, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudienceSharingApi - functional programming interface
 * @export
 */
export const AudienceSharingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudienceSharingApiAxiosParamCreator(configuration)
    return {
        /**
         * List all ad accounts and/or businesses that have access to a specific audience. The audience must be owned by the requesting ad account.
         * @summary List accounts with access to an audience owned by an ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of the audience to use to filter the results.
         * @param {AudienceAccountType} accountType Filter accounts by account type.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsAudiencesSharedAccountsList(adAccountId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountsAudiencesSharedAccountsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsAudiencesSharedAccountsList(adAccountId, audienceId, accountType, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.adAccountsAudiencesSharedAccountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List all ad accounts and/or businesses that have access to a specific audience. The audience must either be owned by an ad account in the requesting business, or it must have been shared with the requesting business. If the requesting business is not the owner of the audience, only ad accounts owned by the requesting business will be returned.
         * @summary List accounts with access to an audience owned by a business
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} audienceId Unique identifier of the audience to use to filter the results.
         * @param {AudienceAccountType} accountType Filter accounts by account type.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessAccountAudiencesSharedAccountsList(businessId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountsAudiencesSharedAccountsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessAccountAudiencesSharedAccountsList(businessId, audienceId, accountType, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.businessAccountAudiencesSharedAccountsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of received audiences for the given business.
         * @summary List received audiences for a business
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {SharedAudiencesForBusinessListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sharedAudiencesForBusinessList(businessId: string, bookmark?: string, order?: SharedAudiencesForBusinessListOrderEnum, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudiencesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sharedAudiencesForBusinessList(businessId, bookmark, order, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.sharedAudiencesForBusinessList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * From an ad account, share a specific audience with another ad account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient ad account(s) must be in the same <a href=\'https://help.pinterest.com/en/business/article/create-and-manage-accounts\'>Pinterest Business Hierarchy</a> as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing between ad accounts
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SharedAudience} sharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdAccountToAdAccountSharedAudience(adAccountId: string, sharedAudience: SharedAudience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedAudienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdAccountToAdAccountSharedAudience(adAccountId, sharedAudience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.updateAdAccountToAdAccountSharedAudience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * From an ad account, share a specific audience with a business account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient business account must be in the same business hierarchy as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing from an ad account to businesses
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BusinessSharedAudience} businessSharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAdAccountToBusinessSharedAudience(adAccountId: string, businessSharedAudience: BusinessSharedAudience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessSharedAudienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAdAccountToBusinessSharedAudience(adAccountId, businessSharedAudience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.updateAdAccountToBusinessSharedAudience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * From a business, share a specific audience with other ad account(s), or revoke access to a previously shared audience. <ul> <li>If the business is the owner of the audience, it can share with any ad account within the same business hierarchy.</li> <li>If the business is the recipient of the audience, it can share with any of its owned ad accounts.</li> </ul> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing from a business to ad accounts
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {SharedAudience} sharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessToAdAccountSharedAudience(businessId: string, sharedAudience: SharedAudience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SharedAudienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessToAdAccountSharedAudience(businessId, sharedAudience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.updateBusinessToAdAccountSharedAudience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * From a business, share a specific audience with another business account, or revoke access to a previously shared audience. Only the audience owner can share the audience with other businesses, and the recipient business must be within the same business hierarchy.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing between businesses
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {BusinessSharedAudience} businessSharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessToBusinessSharedAudience(businessId: string, businessSharedAudience: BusinessSharedAudience, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessSharedAudienceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessToBusinessSharedAudience(businessId, businessSharedAudience, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudienceSharingApi.updateBusinessToBusinessSharedAudience']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudienceSharingApi - factory interface
 * @export
 */
export const AudienceSharingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudienceSharingApiFp(configuration)
    return {
        /**
         * List all ad accounts and/or businesses that have access to a specific audience. The audience must be owned by the requesting ad account.
         * @summary List accounts with access to an audience owned by an ad account
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of the audience to use to filter the results.
         * @param {AudienceAccountType} accountType Filter accounts by account type.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsAudiencesSharedAccountsList(adAccountId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdAccountsAudiencesSharedAccountsList200Response> {
            return localVarFp.adAccountsAudiencesSharedAccountsList(adAccountId, audienceId, accountType, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * List all ad accounts and/or businesses that have access to a specific audience. The audience must either be owned by an ad account in the requesting business, or it must have been shared with the requesting business. If the requesting business is not the owner of the audience, only ad accounts owned by the requesting business will be returned.
         * @summary List accounts with access to an audience owned by a business
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} audienceId Unique identifier of the audience to use to filter the results.
         * @param {AudienceAccountType} accountType Filter accounts by account type.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAccountAudiencesSharedAccountsList(businessId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdAccountsAudiencesSharedAccountsList200Response> {
            return localVarFp.businessAccountAudiencesSharedAccountsList(businessId, audienceId, accountType, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of received audiences for the given business.
         * @summary List received audiences for a business
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {SharedAudiencesForBusinessListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sharedAudiencesForBusinessList(businessId: string, bookmark?: string, order?: SharedAudiencesForBusinessListOrderEnum, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<AudiencesList200Response> {
            return localVarFp.sharedAudiencesForBusinessList(businessId, bookmark, order, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * From an ad account, share a specific audience with another ad account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient ad account(s) must be in the same <a href=\'https://help.pinterest.com/en/business/article/create-and-manage-accounts\'>Pinterest Business Hierarchy</a> as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing between ad accounts
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SharedAudience} sharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdAccountToAdAccountSharedAudience(adAccountId: string, sharedAudience: SharedAudience, options?: RawAxiosRequestConfig): AxiosPromise<SharedAudienceResponse> {
            return localVarFp.updateAdAccountToAdAccountSharedAudience(adAccountId, sharedAudience, options).then((request) => request(axios, basePath));
        },
        /**
         * From an ad account, share a specific audience with a business account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient business account must be in the same business hierarchy as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing from an ad account to businesses
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BusinessSharedAudience} businessSharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAdAccountToBusinessSharedAudience(adAccountId: string, businessSharedAudience: BusinessSharedAudience, options?: RawAxiosRequestConfig): AxiosPromise<BusinessSharedAudienceResponse> {
            return localVarFp.updateAdAccountToBusinessSharedAudience(adAccountId, businessSharedAudience, options).then((request) => request(axios, basePath));
        },
        /**
         * From a business, share a specific audience with other ad account(s), or revoke access to a previously shared audience. <ul> <li>If the business is the owner of the audience, it can share with any ad account within the same business hierarchy.</li> <li>If the business is the recipient of the audience, it can share with any of its owned ad accounts.</li> </ul> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing from a business to ad accounts
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {SharedAudience} sharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessToAdAccountSharedAudience(businessId: string, sharedAudience: SharedAudience, options?: RawAxiosRequestConfig): AxiosPromise<SharedAudienceResponse> {
            return localVarFp.updateBusinessToAdAccountSharedAudience(businessId, sharedAudience, options).then((request) => request(axios, basePath));
        },
        /**
         * From a business, share a specific audience with another business account, or revoke access to a previously shared audience. Only the audience owner can share the audience with other businesses, and the recipient business must be within the same business hierarchy.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
         * @summary Update audience sharing between businesses
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {BusinessSharedAudience} businessSharedAudience 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessToBusinessSharedAudience(businessId: string, businessSharedAudience: BusinessSharedAudience, options?: RawAxiosRequestConfig): AxiosPromise<BusinessSharedAudienceResponse> {
            return localVarFp.updateBusinessToBusinessSharedAudience(businessId, businessSharedAudience, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudienceSharingApi - object-oriented interface
 * @export
 * @class AudienceSharingApi
 * @extends {BaseAPI}
 */
export class AudienceSharingApi extends BaseAPI {
    /**
     * List all ad accounts and/or businesses that have access to a specific audience. The audience must be owned by the requesting ad account.
     * @summary List accounts with access to an audience owned by an ad account
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} audienceId Unique identifier of the audience to use to filter the results.
     * @param {AudienceAccountType} accountType Filter accounts by account type.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public adAccountsAudiencesSharedAccountsList(adAccountId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).adAccountsAudiencesSharedAccountsList(adAccountId, audienceId, accountType, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all ad accounts and/or businesses that have access to a specific audience. The audience must either be owned by an ad account in the requesting business, or it must have been shared with the requesting business. If the requesting business is not the owner of the audience, only ad accounts owned by the requesting business will be returned.
     * @summary List accounts with access to an audience owned by a business
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {string} audienceId Unique identifier of the audience to use to filter the results.
     * @param {AudienceAccountType} accountType Filter accounts by account type.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public businessAccountAudiencesSharedAccountsList(businessId: string, audienceId: string, accountType: AudienceAccountType, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).businessAccountAudiencesSharedAccountsList(businessId, audienceId, accountType, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of received audiences for the given business.
     * @summary List received audiences for a business
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {SharedAudiencesForBusinessListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public sharedAudiencesForBusinessList(businessId: string, bookmark?: string, order?: SharedAudiencesForBusinessListOrderEnum, pageSize?: number, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).sharedAudiencesForBusinessList(businessId, bookmark, order, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * From an ad account, share a specific audience with another ad account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient ad account(s) must be in the same <a href=\'https://help.pinterest.com/en/business/article/create-and-manage-accounts\'>Pinterest Business Hierarchy</a> as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
     * @summary Update audience sharing between ad accounts
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {SharedAudience} sharedAudience 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public updateAdAccountToAdAccountSharedAudience(adAccountId: string, sharedAudience: SharedAudience, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).updateAdAccountToAdAccountSharedAudience(adAccountId, sharedAudience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * From an ad account, share a specific audience with a business account, or revoke access to a previously shared audience. Only the audience owner account can share the audience. The recipient business account must be in the same business hierarchy as the business owner of the ad account.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
     * @summary Update audience sharing from an ad account to businesses
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {BusinessSharedAudience} businessSharedAudience 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public updateAdAccountToBusinessSharedAudience(adAccountId: string, businessSharedAudience: BusinessSharedAudience, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).updateAdAccountToBusinessSharedAudience(adAccountId, businessSharedAudience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * From a business, share a specific audience with other ad account(s), or revoke access to a previously shared audience. <ul> <li>If the business is the owner of the audience, it can share with any ad account within the same business hierarchy.</li> <li>If the business is the recipient of the audience, it can share with any of its owned ad accounts.</li> </ul> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
     * @summary Update audience sharing from a business to ad accounts
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {SharedAudience} sharedAudience 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public updateBusinessToAdAccountSharedAudience(businessId: string, sharedAudience: SharedAudience, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).updateBusinessToAdAccountSharedAudience(businessId, sharedAudience, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * From a business, share a specific audience with another business account, or revoke access to a previously shared audience. Only the audience owner can share the audience with other businesses, and the recipient business must be within the same business hierarchy.<br> This endpoint is not available to all apps.<a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.
     * @summary Update audience sharing between businesses
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {BusinessSharedAudience} businessSharedAudience 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudienceSharingApi
     */
    public updateBusinessToBusinessSharedAudience(businessId: string, businessSharedAudience: BusinessSharedAudience, options?: RawAxiosRequestConfig) {
        return AudienceSharingApiFp(this.configuration).updateBusinessToBusinessSharedAudience(businessId, businessSharedAudience, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SharedAudiencesForBusinessListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type SharedAudiencesForBusinessListOrderEnum = typeof SharedAudiencesForBusinessListOrderEnum[keyof typeof SharedAudiencesForBusinessListOrderEnum];


/**
 * AudiencesApi - axios parameter creator
 * @export
 */
export const AudiencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an audience you can use in targeting for specific ad groups. Targeting combines customer information with the ways users interact with Pinterest to help you reach specific groups of users; you can include or exclude specific audience_ids when you create an ad group. <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.
         * @summary Create audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceCreateRequest} audienceCreateRequest List of ads to create, size limit [1, 30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesCreate: async (adAccountId: string, audienceCreateRequest: AudienceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audiencesCreate', 'adAccountId', adAccountId)
            // verify required parameter 'audienceCreateRequest' is not null or undefined
            assertParamExists('audiencesCreate', 'audienceCreateRequest', audienceCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(audienceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a custom audience and find the audiences you want your ads to reach.
         * @summary Create custom audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceCreateCustomRequest} audienceCreateCustomRequest Custom audience to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesCreateCustom: async (adAccountId: string, audienceCreateCustomRequest: AudienceCreateCustomRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audiencesCreateCustom', 'adAccountId', adAccountId)
            // verify required parameter 'audienceCreateCustomRequest' is not null or undefined
            assertParamExists('audiencesCreateCustom', 'audienceCreateCustomRequest', audienceCreateCustomRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences/custom`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(audienceCreateCustomRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific audience given the audience ID.
         * @summary Get audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of an audience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesGet: async (adAccountId: string, audienceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audiencesGet', 'adAccountId', adAccountId)
            // verify required parameter 'audienceId' is not null or undefined
            assertParamExists('audiencesGet', 'audienceId', audienceId)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences/{audience_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"audience_id"}}`, encodeURIComponent(String(audienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of audiences for the ad account.
         * @summary List audiences
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {AudiencesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. For received audiences, it is sorted by sharing event time. Note that higher-value IDs are associated with more-recently added items.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AudiencesListOwnershipTypeEnum} [ownershipType] Filter audiences by ownership type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesList: async (adAccountId: string, bookmark?: string, order?: AudiencesListOrderEnum, pageSize?: number, ownershipType?: AudiencesListOwnershipTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audiencesList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (ownershipType !== undefined) {
                localVarQueryParameter['ownership_type'] = ownershipType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update (edit or remove) an existing targeting audience.
         * @summary Update audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of an audience
         * @param {AudienceUpdateRequest} [audienceUpdateRequest] The audience to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesUpdate: async (adAccountId: string, audienceId: string, audienceUpdateRequest?: AudienceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('audiencesUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'audienceId' is not null or undefined
            assertParamExists('audiencesUpdate', 'audienceId', audienceId)
            const localVarPath = `/ad_accounts/{ad_account_id}/audiences/{audience_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"audience_id"}}`, encodeURIComponent(String(audienceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(audienceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AudiencesApi - functional programming interface
 * @export
 */
export const AudiencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AudiencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an audience you can use in targeting for specific ad groups. Targeting combines customer information with the ways users interact with Pinterest to help you reach specific groups of users; you can include or exclude specific audience_ids when you create an ad group. <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.
         * @summary Create audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceCreateRequest} audienceCreateRequest List of ads to create, size limit [1, 30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audiencesCreate(adAccountId: string, audienceCreateRequest: AudienceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Audience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audiencesCreate(adAccountId, audienceCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.audiencesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a custom audience and find the audiences you want your ads to reach.
         * @summary Create custom audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceCreateCustomRequest} audienceCreateCustomRequest Custom audience to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audiencesCreateCustom(adAccountId: string, audienceCreateCustomRequest: AudienceCreateCustomRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Audience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audiencesCreateCustom(adAccountId, audienceCreateCustomRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.audiencesCreateCustom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific audience given the audience ID.
         * @summary Get audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of an audience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audiencesGet(adAccountId: string, audienceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Audience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audiencesGet(adAccountId, audienceId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.audiencesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get list of audiences for the ad account.
         * @summary List audiences
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {AudiencesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. For received audiences, it is sorted by sharing event time. Note that higher-value IDs are associated with more-recently added items.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AudiencesListOwnershipTypeEnum} [ownershipType] Filter audiences by ownership type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audiencesList(adAccountId: string, bookmark?: string, order?: AudiencesListOrderEnum, pageSize?: number, ownershipType?: AudiencesListOwnershipTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AudiencesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audiencesList(adAccountId, bookmark, order, pageSize, ownershipType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.audiencesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update (edit or remove) an existing targeting audience.
         * @summary Update audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of an audience
         * @param {AudienceUpdateRequest} [audienceUpdateRequest] The audience to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async audiencesUpdate(adAccountId: string, audienceId: string, audienceUpdateRequest?: AudienceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Audience>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.audiencesUpdate(adAccountId, audienceId, audienceUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AudiencesApi.audiencesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AudiencesApi - factory interface
 * @export
 */
export const AudiencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AudiencesApiFp(configuration)
    return {
        /**
         * Create an audience you can use in targeting for specific ad groups. Targeting combines customer information with the ways users interact with Pinterest to help you reach specific groups of users; you can include or exclude specific audience_ids when you create an ad group. <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.
         * @summary Create audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceCreateRequest} audienceCreateRequest List of ads to create, size limit [1, 30]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesCreate(adAccountId: string, audienceCreateRequest: AudienceCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Audience> {
            return localVarFp.audiencesCreate(adAccountId, audienceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a custom audience and find the audiences you want your ads to reach.
         * @summary Create custom audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AudienceCreateCustomRequest} audienceCreateCustomRequest Custom audience to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesCreateCustom(adAccountId: string, audienceCreateCustomRequest: AudienceCreateCustomRequest, options?: RawAxiosRequestConfig): AxiosPromise<Audience> {
            return localVarFp.audiencesCreateCustom(adAccountId, audienceCreateCustomRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific audience given the audience ID.
         * @summary Get audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of an audience
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesGet(adAccountId: string, audienceId: string, options?: RawAxiosRequestConfig): AxiosPromise<Audience> {
            return localVarFp.audiencesGet(adAccountId, audienceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of audiences for the ad account.
         * @summary List audiences
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {AudiencesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. For received audiences, it is sorted by sharing event time. Note that higher-value IDs are associated with more-recently added items.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {AudiencesListOwnershipTypeEnum} [ownershipType] Filter audiences by ownership type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesList(adAccountId: string, bookmark?: string, order?: AudiencesListOrderEnum, pageSize?: number, ownershipType?: AudiencesListOwnershipTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<AudiencesList200Response> {
            return localVarFp.audiencesList(adAccountId, bookmark, order, pageSize, ownershipType, options).then((request) => request(axios, basePath));
        },
        /**
         * Update (edit or remove) an existing targeting audience.
         * @summary Update audience
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} audienceId Unique identifier of an audience
         * @param {AudienceUpdateRequest} [audienceUpdateRequest] The audience to be updated.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        audiencesUpdate(adAccountId: string, audienceId: string, audienceUpdateRequest?: AudienceUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<Audience> {
            return localVarFp.audiencesUpdate(adAccountId, audienceId, audienceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AudiencesApi - object-oriented interface
 * @export
 * @class AudiencesApi
 * @extends {BaseAPI}
 */
export class AudiencesApi extends BaseAPI {
    /**
     * Create an audience you can use in targeting for specific ad groups. Targeting combines customer information with the ways users interact with Pinterest to help you reach specific groups of users; you can include or exclude specific audience_ids when you create an ad group. <p/> For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.
     * @summary Create audience
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AudienceCreateRequest} audienceCreateRequest List of ads to create, size limit [1, 30]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public audiencesCreate(adAccountId: string, audienceCreateRequest: AudienceCreateRequest, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).audiencesCreate(adAccountId, audienceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a custom audience and find the audiences you want your ads to reach.
     * @summary Create custom audience
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AudienceCreateCustomRequest} audienceCreateCustomRequest Custom audience to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public audiencesCreateCustom(adAccountId: string, audienceCreateCustomRequest: AudienceCreateCustomRequest, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).audiencesCreateCustom(adAccountId, audienceCreateCustomRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific audience given the audience ID.
     * @summary Get audience
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} audienceId Unique identifier of an audience
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public audiencesGet(adAccountId: string, audienceId: string, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).audiencesGet(adAccountId, audienceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of audiences for the ad account.
     * @summary List audiences
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {AudiencesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. For received audiences, it is sorted by sharing event time. Note that higher-value IDs are associated with more-recently added items.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {AudiencesListOwnershipTypeEnum} [ownershipType] Filter audiences by ownership type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public audiencesList(adAccountId: string, bookmark?: string, order?: AudiencesListOrderEnum, pageSize?: number, ownershipType?: AudiencesListOwnershipTypeEnum, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).audiencesList(adAccountId, bookmark, order, pageSize, ownershipType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update (edit or remove) an existing targeting audience.
     * @summary Update audience
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} audienceId Unique identifier of an audience
     * @param {AudienceUpdateRequest} [audienceUpdateRequest] The audience to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AudiencesApi
     */
    public audiencesUpdate(adAccountId: string, audienceId: string, audienceUpdateRequest?: AudienceUpdateRequest, options?: RawAxiosRequestConfig) {
        return AudiencesApiFp(this.configuration).audiencesUpdate(adAccountId, audienceId, audienceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AudiencesListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type AudiencesListOrderEnum = typeof AudiencesListOrderEnum[keyof typeof AudiencesListOrderEnum];
/**
 * @export
 */
export const AudiencesListOwnershipTypeEnum = {
    Owned: 'OWNED',
    Received: 'RECEIVED'
} as const;
export type AudiencesListOwnershipTypeEnum = typeof AudiencesListOwnershipTypeEnum[keyof typeof AudiencesListOwnershipTypeEnum];


/**
 * BillingApi - axios parameter creator
 * @export
 */
export const BillingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Redeem ads credit on behalf of the ad account id and apply it towards billing.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Redeem ad credits
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdsCreditRedeemRequest} adsCreditRedeemRequest Redeem ad credits request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsCreditRedeem: async (adAccountId: string, adsCreditRedeemRequest: AdsCreditRedeemRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsCreditRedeem', 'adAccountId', adAccountId)
            // verify required parameter 'adsCreditRedeemRequest' is not null or undefined
            assertParamExists('adsCreditRedeem', 'adsCreditRedeemRequest', adsCreditRedeemRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads_credit/redeem`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write", "billing:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adsCreditRedeemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the list of discounts applied to the account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get ads credit discounts
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsCreditsDiscountsGet: async (adAccountId: string, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adsCreditsDiscountsGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ads_credit/discounts`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read", "billing:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing profiles in the advertiser account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get billing profiles
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} isActive Return active billing profiles, if false return all billing profiles.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProfilesGet: async (adAccountId: string, isActive: boolean, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('billingProfilesGet', 'adAccountId', adAccountId)
            // verify required parameter 'isActive' is not null or undefined
            assertParamExists('billingProfilesGet', 'isActive', isActive)
            const localVarPath = `/ad_accounts/{ad_account_id}/billing_profiles`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read", "billing:read"], configuration)

            if (isActive !== undefined) {
                localVarQueryParameter['is_active'] = isActive;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Salesforce account details including bill-to information to be used in insertion orders process for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get Salesforce account details including bill-to information.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioAccountsGet: async (adAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ssioAccountsGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ssio/accounts`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Create insertion order through SSIO.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SSIOCreateInsertionOrderRequest} sSIOCreateInsertionOrderRequest Order line to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrderCreate: async (adAccountId: string, sSIOCreateInsertionOrderRequest: SSIOCreateInsertionOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ssioInsertionOrderCreate', 'adAccountId', adAccountId)
            // verify required parameter 'sSIOCreateInsertionOrderRequest' is not null or undefined
            assertParamExists('ssioInsertionOrderCreate', 'sSIOCreateInsertionOrderRequest', sSIOCreateInsertionOrderRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ssio/insertion_orders`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSIOCreateInsertionOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Edit insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Edit insertion order through SSIO.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SSIOEditInsertionOrderRequest} sSIOEditInsertionOrderRequest Order line to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrderEdit: async (adAccountId: string, sSIOEditInsertionOrderRequest: SSIOEditInsertionOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ssioInsertionOrderEdit', 'adAccountId', adAccountId)
            // verify required parameter 'sSIOEditInsertionOrderRequest' is not null or undefined
            assertParamExists('ssioInsertionOrderEdit', 'sSIOEditInsertionOrderRequest', sSIOEditInsertionOrderRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/ssio/insertion_orders`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sSIOEditInsertionOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insertion order status for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get insertion order status by ad account id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrdersStatusGetByAdAccount: async (adAccountId: string, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ssioInsertionOrdersStatusGetByAdAccount', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ssio/insertion_orders/status`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insertion order status for pin order id <code>pin_order_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get insertion order status by pin order id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} pinOrderId The pin order id associated with the ssio insertion order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrdersStatusGetByPinOrderId: async (adAccountId: string, pinOrderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ssioInsertionOrdersStatusGetByPinOrderId', 'adAccountId', adAccountId)
            // verify required parameter 'pinOrderId' is not null or undefined
            assertParamExists('ssioInsertionOrdersStatusGetByPinOrderId', 'pinOrderId', pinOrderId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ssio/insertion_orders/{pin_order_id}/status`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"pin_order_id"}}`, encodeURIComponent(String(pinOrderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Salesforce order lines for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get Salesforce order lines by ad account id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [pinOrderId] The pin order id associated with the ssio insertino order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioOrderLinesGetByAdAccount: async (adAccountId: string, bookmark?: string, pageSize?: number, pinOrderId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ssioOrderLinesGetByAdAccount', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/ssio/order_lines`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pinOrderId !== undefined) {
                localVarQueryParameter['pin_order_id'] = pinOrderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingApi - functional programming interface
 * @export
 */
export const BillingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingApiAxiosParamCreator(configuration)
    return {
        /**
         * Redeem ads credit on behalf of the ad account id and apply it towards billing.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Redeem ad credits
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdsCreditRedeemRequest} adsCreditRedeemRequest Redeem ad credits request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsCreditRedeem(adAccountId: string, adsCreditRedeemRequest: AdsCreditRedeemRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCreditRedeemResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsCreditRedeem(adAccountId, adsCreditRedeemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.adsCreditRedeem']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the list of discounts applied to the account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get ads credit discounts
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adsCreditsDiscountsGet(adAccountId: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdsCreditsDiscountsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adsCreditsDiscountsGet(adAccountId, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.adsCreditsDiscountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get billing profiles in the advertiser account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get billing profiles
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} isActive Return active billing profiles, if false return all billing profiles.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProfilesGet(adAccountId: string, isActive: boolean, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BillingProfilesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProfilesGet(adAccountId, isActive, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.billingProfilesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Salesforce account details including bill-to information to be used in insertion orders process for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get Salesforce account details including bill-to information.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssioAccountsGet(adAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSIOAccountResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssioAccountsGet(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.ssioAccountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Create insertion order through SSIO.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SSIOCreateInsertionOrderRequest} sSIOCreateInsertionOrderRequest Order line to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssioInsertionOrderCreate(adAccountId: string, sSIOCreateInsertionOrderRequest: SSIOCreateInsertionOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSIOCreateInsertionOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssioInsertionOrderCreate(adAccountId, sSIOCreateInsertionOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.ssioInsertionOrderCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Edit insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Edit insertion order through SSIO.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SSIOEditInsertionOrderRequest} sSIOEditInsertionOrderRequest Order line to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssioInsertionOrderEdit(adAccountId: string, sSIOEditInsertionOrderRequest: SSIOEditInsertionOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSIOEditInsertionOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssioInsertionOrderEdit(adAccountId, sSIOEditInsertionOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.ssioInsertionOrderEdit']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get insertion order status for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get insertion order status by ad account id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssioInsertionOrdersStatusGetByAdAccount(adAccountId: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsioInsertionOrdersStatusGetByAdAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssioInsertionOrdersStatusGetByAdAccount(adAccountId, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.ssioInsertionOrdersStatusGetByAdAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get insertion order status for pin order id <code>pin_order_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get insertion order status by pin order id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} pinOrderId The pin order id associated with the ssio insertion order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssioInsertionOrdersStatusGetByPinOrderId(adAccountId: string, pinOrderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SSIOInsertionOrderStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssioInsertionOrdersStatusGetByPinOrderId(adAccountId, pinOrderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.ssioInsertionOrdersStatusGetByPinOrderId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Salesforce order lines for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get Salesforce order lines by ad account id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [pinOrderId] The pin order id associated with the ssio insertino order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ssioOrderLinesGetByAdAccount(adAccountId: string, bookmark?: string, pageSize?: number, pinOrderId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SsioOrderLinesGetByAdAccount200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssioOrderLinesGetByAdAccount(adAccountId, bookmark, pageSize, pinOrderId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BillingApi.ssioOrderLinesGetByAdAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BillingApi - factory interface
 * @export
 */
export const BillingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingApiFp(configuration)
    return {
        /**
         * Redeem ads credit on behalf of the ad account id and apply it towards billing.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Redeem ad credits
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdsCreditRedeemRequest} adsCreditRedeemRequest Redeem ad credits request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsCreditRedeem(adAccountId: string, adsCreditRedeemRequest: AdsCreditRedeemRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdsCreditRedeemResponse> {
            return localVarFp.adsCreditRedeem(adAccountId, adsCreditRedeemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the list of discounts applied to the account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get ads credit discounts
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adsCreditsDiscountsGet(adAccountId: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<AdsCreditsDiscountsGet200Response> {
            return localVarFp.adsCreditsDiscountsGet(adAccountId, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing profiles in the advertiser account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get billing profiles
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} isActive Return active billing profiles, if false return all billing profiles.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProfilesGet(adAccountId: string, isActive: boolean, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<BillingProfilesGet200Response> {
            return localVarFp.billingProfilesGet(adAccountId, isActive, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Salesforce account details including bill-to information to be used in insertion orders process for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get Salesforce account details including bill-to information.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioAccountsGet(adAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<SSIOAccountResponse> {
            return localVarFp.ssioAccountsGet(adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Create insertion order through SSIO.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SSIOCreateInsertionOrderRequest} sSIOCreateInsertionOrderRequest Order line to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrderCreate(adAccountId: string, sSIOCreateInsertionOrderRequest: SSIOCreateInsertionOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<SSIOCreateInsertionOrderResponse> {
            return localVarFp.ssioInsertionOrderCreate(adAccountId, sSIOCreateInsertionOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Edit insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Edit insertion order through SSIO.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {SSIOEditInsertionOrderRequest} sSIOEditInsertionOrderRequest Order line to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrderEdit(adAccountId: string, sSIOEditInsertionOrderRequest: SSIOEditInsertionOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<SSIOEditInsertionOrderResponse> {
            return localVarFp.ssioInsertionOrderEdit(adAccountId, sSIOEditInsertionOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insertion order status for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get insertion order status by ad account id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrdersStatusGetByAdAccount(adAccountId: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<SsioInsertionOrdersStatusGetByAdAccount200Response> {
            return localVarFp.ssioInsertionOrdersStatusGetByAdAccount(adAccountId, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insertion order status for pin order id <code>pin_order_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get insertion order status by pin order id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} pinOrderId The pin order id associated with the ssio insertion order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioInsertionOrdersStatusGetByPinOrderId(adAccountId: string, pinOrderId: string, options?: RawAxiosRequestConfig): AxiosPromise<SSIOInsertionOrderStatusResponse> {
            return localVarFp.ssioInsertionOrdersStatusGetByPinOrderId(adAccountId, pinOrderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Salesforce order lines for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
         * @summary Get Salesforce order lines by ad account id.
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [pinOrderId] The pin order id associated with the ssio insertino order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssioOrderLinesGetByAdAccount(adAccountId: string, bookmark?: string, pageSize?: number, pinOrderId?: string, options?: RawAxiosRequestConfig): AxiosPromise<SsioOrderLinesGetByAdAccount200Response> {
            return localVarFp.ssioOrderLinesGetByAdAccount(adAccountId, bookmark, pageSize, pinOrderId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingApi - object-oriented interface
 * @export
 * @class BillingApi
 * @extends {BaseAPI}
 */
export class BillingApi extends BaseAPI {
    /**
     * Redeem ads credit on behalf of the ad account id and apply it towards billing.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Redeem ad credits
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AdsCreditRedeemRequest} adsCreditRedeemRequest Redeem ad credits request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public adsCreditRedeem(adAccountId: string, adsCreditRedeemRequest: AdsCreditRedeemRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).adsCreditRedeem(adAccountId, adsCreditRedeemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the list of discounts applied to the account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Get ads credit discounts
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public adsCreditsDiscountsGet(adAccountId: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).adsCreditsDiscountsGet(adAccountId, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing profiles in the advertiser account.  <strong>This endpoint might not be available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Get billing profiles
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {boolean} isActive Return active billing profiles, if false return all billing profiles.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public billingProfilesGet(adAccountId: string, isActive: boolean, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).billingProfilesGet(adAccountId, isActive, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Salesforce account details including bill-to information to be used in insertion orders process for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
     * @summary Get Salesforce account details including bill-to information.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public ssioAccountsGet(adAccountId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).ssioAccountsGet(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
     * @summary Create insertion order through SSIO.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {SSIOCreateInsertionOrderRequest} sSIOCreateInsertionOrderRequest Order line to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public ssioInsertionOrderCreate(adAccountId: string, sSIOCreateInsertionOrderRequest: SSIOCreateInsertionOrderRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).ssioInsertionOrderCreate(adAccountId, sSIOCreateInsertionOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Edit insertion order through SSIO for <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
     * @summary Edit insertion order through SSIO.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {SSIOEditInsertionOrderRequest} sSIOEditInsertionOrderRequest Order line to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public ssioInsertionOrderEdit(adAccountId: string, sSIOEditInsertionOrderRequest: SSIOEditInsertionOrderRequest, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).ssioInsertionOrderEdit(adAccountId, sSIOEditInsertionOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insertion order status for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
     * @summary Get insertion order status by ad account id.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public ssioInsertionOrdersStatusGetByAdAccount(adAccountId: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).ssioInsertionOrdersStatusGetByAdAccount(adAccountId, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insertion order status for pin order id <code>pin_order_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
     * @summary Get insertion order status by pin order id.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} pinOrderId The pin order id associated with the ssio insertion order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public ssioInsertionOrdersStatusGetByPinOrderId(adAccountId: string, pinOrderId: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).ssioInsertionOrdersStatusGetByPinOrderId(adAccountId, pinOrderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Salesforce order lines for account id <code>ad_account_id</code>. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Finance, Campaign.
     * @summary Get Salesforce order lines by ad account id.
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [pinOrderId] The pin order id associated with the ssio insertino order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingApi
     */
    public ssioOrderLinesGetByAdAccount(adAccountId: string, bookmark?: string, pageSize?: number, pinOrderId?: string, options?: RawAxiosRequestConfig) {
        return BillingApiFp(this.configuration).ssioOrderLinesGetByAdAccount(adAccountId, bookmark, pageSize, pinOrderId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BoardsApi - axios parameter creator
 * @export
 */
export const BoardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Create board section
         * @param {string} boardId Unique identifier of a board.
         * @param {BoardSection} boardSection Create a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsCreate: async (boardId: string, boardSection: BoardSection, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardSectionsCreate', 'boardId', boardId)
            // verify required parameter 'boardSection' is not null or undefined
            assertParamExists('boardSectionsCreate', 'boardSection', boardSection)
            const localVarPath = `/boards/{board_id}/sections`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boardSection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Delete board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsDelete: async (boardId: string, sectionId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardSectionsDelete', 'boardId', boardId)
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('boardSectionsDelete', 'sectionId', sectionId)
            const localVarPath = `/boards/{board_id}/sections/{section_id}`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all board sections from a board owned by the \"operation user_account\" - or a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List board sections
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsList: async (boardId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardSectionsList', 'boardId', boardId)
            const localVarPath = `/boards/{board_id}/sections`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the Pins on a board section of a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List Pins on board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsListPins: async (boardId: string, sectionId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardSectionsListPins', 'boardId', boardId)
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('boardSectionsListPins', 'sectionId', sectionId)
            const localVarPath = `/boards/{board_id}/sections/{section_id}/pins`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "pins:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Update board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {BoardSection} boardSection Update a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsUpdate: async (boardId: string, sectionId: string, boardSection: BoardSection, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardSectionsUpdate', 'boardId', boardId)
            // verify required parameter 'sectionId' is not null or undefined
            assertParamExists('boardSectionsUpdate', 'sectionId', sectionId)
            // verify required parameter 'boardSection' is not null or undefined
            assertParamExists('boardSectionsUpdate', 'boardSection', boardSection)
            const localVarPath = `/boards/{board_id}/sections/{section_id}`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)))
                .replace(`{${"section_id"}}`, encodeURIComponent(String(sectionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boardSection, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a board owned by the \"operation user_account\". Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Create board
         * @param {Board} board Create a board using a single board json object.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsCreate: async (board: Board, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'board' is not null or undefined
            assertParamExists('boardsCreate', 'board', board)
            const localVarPath = `/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(board, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a board owned by the \"operation user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Delete board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsDelete: async (boardId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardsDelete', 'boardId', boardId)
            const localVarPath = `/boards/{board_id}`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a board owned by the operation user_account - or a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Get board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsGet: async (boardId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardsGet', 'boardId', boardId)
            const localVarPath = `/boards/{board_id}`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the boards owned by the \"operation user_account\" + group boards where this account is a collaborator Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". Optional: Specify a privacy type (public, protected, or secret) to indicate which boards to return. - If no privacy is specified, all boards that can be returned (based on the scopes of the token and ad_account role if applicable) will be returned.
         * @summary List boards
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {BoardsListPrivacyEnum} [privacy] Privacy setting for a board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsList: async (adAccountId?: string, bookmark?: string, pageSize?: number, privacy?: BoardsListPrivacyEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (privacy !== undefined) {
                localVarQueryParameter['privacy'] = privacy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the Pins on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List Pins on board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {Array<BoardsListPinsCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsListPins: async (boardId: string, bookmark?: string, pageSize?: number, creativeTypes?: Array<BoardsListPinsCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardsListPins', 'boardId', boardId)
            const localVarPath = `/boards/{board_id}/pins`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "pins:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (creativeTypes) {
                localVarQueryParameter['creative_types'] = creativeTypes;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (pinMetrics !== undefined) {
                localVarQueryParameter['pin_metrics'] = pinMetrics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a board owned by the \"operating user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Update board
         * @param {string} boardId Unique identifier of a board.
         * @param {BoardUpdate} boardUpdate Update a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsUpdate: async (boardId: string, boardUpdate: BoardUpdate, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'boardId' is not null or undefined
            assertParamExists('boardsUpdate', 'boardId', boardId)
            // verify required parameter 'boardUpdate' is not null or undefined
            assertParamExists('boardsUpdate', 'boardUpdate', boardUpdate)
            const localVarPath = `/boards/{board_id}`
                .replace(`{${"board_id"}}`, encodeURIComponent(String(boardId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(boardUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BoardsApi - functional programming interface
 * @export
 */
export const BoardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BoardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Create board section
         * @param {string} boardId Unique identifier of a board.
         * @param {BoardSection} boardSection Create a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSectionsCreate(boardId: string, boardSection: BoardSection, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardSection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSectionsCreate(boardId, boardSection, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardSectionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Delete board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSectionsDelete(boardId: string, sectionId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSectionsDelete(boardId, sectionId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardSectionsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all board sections from a board owned by the \"operation user_account\" - or a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List board sections
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSectionsList(boardId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardSectionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSectionsList(boardId, adAccountId, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardSectionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the Pins on a board section of a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List Pins on board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSectionsListPins(boardId: string, sectionId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardsListPins200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSectionsListPins(boardId, sectionId, adAccountId, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardSectionsListPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Update board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {BoardSection} boardSection Update a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardSectionsUpdate(boardId: string, sectionId: string, boardSection: BoardSection, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardSection>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardSectionsUpdate(boardId, sectionId, boardSection, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardSectionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a board owned by the \"operation user_account\". Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Create board
         * @param {Board} board Create a board using a single board json object.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsCreate(board: Board, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsCreate(board, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a board owned by the \"operation user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Delete board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsDelete(boardId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsDelete(boardId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a board owned by the operation user_account - or a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Get board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsGet(boardId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsGet(boardId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the boards owned by the \"operation user_account\" + group boards where this account is a collaborator Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". Optional: Specify a privacy type (public, protected, or secret) to indicate which boards to return. - If no privacy is specified, all boards that can be returned (based on the scopes of the token and ad_account role if applicable) will be returned.
         * @summary List boards
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {BoardsListPrivacyEnum} [privacy] Privacy setting for a board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsList(adAccountId?: string, bookmark?: string, pageSize?: number, privacy?: BoardsListPrivacyEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsList(adAccountId, bookmark, pageSize, privacy, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the Pins on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List Pins on board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {Array<BoardsListPinsCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsListPins(boardId: string, bookmark?: string, pageSize?: number, creativeTypes?: Array<BoardsListPinsCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardsListPins200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsListPins(boardId, bookmark, pageSize, creativeTypes, adAccountId, pinMetrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardsListPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a board owned by the \"operating user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Update board
         * @param {string} boardId Unique identifier of a board.
         * @param {BoardUpdate} boardUpdate Update a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsUpdate(boardId: string, boardUpdate: BoardUpdate, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Board>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsUpdate(boardId, boardUpdate, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BoardsApi.boardsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BoardsApi - factory interface
 * @export
 */
export const BoardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BoardsApiFp(configuration)
    return {
        /**
         * Create a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Create board section
         * @param {string} boardId Unique identifier of a board.
         * @param {BoardSection} boardSection Create a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsCreate(boardId: string, boardSection: BoardSection, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<BoardSection> {
            return localVarFp.boardSectionsCreate(boardId, boardSection, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Delete board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsDelete(boardId: string, sectionId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.boardSectionsDelete(boardId, sectionId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all board sections from a board owned by the \"operation user_account\" - or a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List board sections
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsList(boardId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<BoardSectionsList200Response> {
            return localVarFp.boardSectionsList(boardId, adAccountId, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the Pins on a board section of a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List Pins on board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsListPins(boardId: string, sectionId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<BoardsListPins200Response> {
            return localVarFp.boardSectionsListPins(boardId, sectionId, adAccountId, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Update board section
         * @param {string} boardId Unique identifier of a board.
         * @param {string} sectionId Unique identifier of a board section.
         * @param {BoardSection} boardSection Update a board section.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardSectionsUpdate(boardId: string, sectionId: string, boardSection: BoardSection, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<BoardSection> {
            return localVarFp.boardSectionsUpdate(boardId, sectionId, boardSection, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a board owned by the \"operation user_account\". Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Create board
         * @param {Board} board Create a board using a single board json object.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsCreate(board: Board, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Board> {
            return localVarFp.boardsCreate(board, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a board owned by the \"operation user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Delete board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsDelete(boardId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.boardsDelete(boardId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a board owned by the operation user_account - or a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Get board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsGet(boardId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Board> {
            return localVarFp.boardsGet(boardId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the boards owned by the \"operation user_account\" + group boards where this account is a collaborator Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". Optional: Specify a privacy type (public, protected, or secret) to indicate which boards to return. - If no privacy is specified, all boards that can be returned (based on the scopes of the token and ad_account role if applicable) will be returned.
         * @summary List boards
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {BoardsListPrivacyEnum} [privacy] Privacy setting for a board.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsList(adAccountId?: string, bookmark?: string, pageSize?: number, privacy?: BoardsListPrivacyEnum, options?: RawAxiosRequestConfig): AxiosPromise<BoardsList200Response> {
            return localVarFp.boardsList(adAccountId, bookmark, pageSize, privacy, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the Pins on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary List Pins on board
         * @param {string} boardId Unique identifier of a board.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {Array<BoardsListPinsCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsListPins(boardId: string, bookmark?: string, pageSize?: number, creativeTypes?: Array<BoardsListPinsCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BoardsListPins200Response> {
            return localVarFp.boardsListPins(boardId, bookmark, pageSize, creativeTypes, adAccountId, pinMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a board owned by the \"operating user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
         * @summary Update board
         * @param {string} boardId Unique identifier of a board.
         * @param {BoardUpdate} boardUpdate Update a board.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsUpdate(boardId: string, boardUpdate: BoardUpdate, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Board> {
            return localVarFp.boardsUpdate(boardId, boardUpdate, adAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BoardsApi - object-oriented interface
 * @export
 * @class BoardsApi
 * @extends {BaseAPI}
 */
export class BoardsApi extends BaseAPI {
    /**
     * Create a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Create board section
     * @param {string} boardId Unique identifier of a board.
     * @param {BoardSection} boardSection Create a board section.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardSectionsCreate(boardId: string, boardSection: BoardSection, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardSectionsCreate(boardId, boardSection, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Delete board section
     * @param {string} boardId Unique identifier of a board.
     * @param {string} sectionId Unique identifier of a board section.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardSectionsDelete(boardId: string, sectionId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardSectionsDelete(boardId, sectionId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all board sections from a board owned by the \"operation user_account\" - or a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary List board sections
     * @param {string} boardId Unique identifier of a board.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardSectionsList(boardId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardSectionsList(boardId, adAccountId, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the Pins on a board section of a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary List Pins on board section
     * @param {string} boardId Unique identifier of a board.
     * @param {string} sectionId Unique identifier of a board section.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardSectionsListPins(boardId: string, sectionId: string, adAccountId?: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardSectionsListPins(boardId, sectionId, adAccountId, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a board section on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Update board section
     * @param {string} boardId Unique identifier of a board.
     * @param {string} sectionId Unique identifier of a board section.
     * @param {BoardSection} boardSection Update a board section.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardSectionsUpdate(boardId: string, sectionId: string, boardSection: BoardSection, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardSectionsUpdate(boardId, sectionId, boardSection, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a board owned by the \"operation user_account\". Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Create board
     * @param {Board} board Create a board using a single board json object.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardsCreate(board: Board, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardsCreate(board, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a board owned by the \"operation user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Delete board
     * @param {string} boardId Unique identifier of a board.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardsDelete(boardId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardsDelete(boardId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a board owned by the operation user_account - or a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Get board
     * @param {string} boardId Unique identifier of a board.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardsGet(boardId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardsGet(boardId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the boards owned by the \"operation user_account\" + group boards where this account is a collaborator Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". Optional: Specify a privacy type (public, protected, or secret) to indicate which boards to return. - If no privacy is specified, all boards that can be returned (based on the scopes of the token and ad_account role if applicable) will be returned.
     * @summary List boards
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {BoardsListPrivacyEnum} [privacy] Privacy setting for a board.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardsList(adAccountId?: string, bookmark?: string, pageSize?: number, privacy?: BoardsListPrivacyEnum, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardsList(adAccountId, bookmark, pageSize, privacy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the Pins on a board owned by the \"operation user_account\" - or on a group board that has been shared with this account. - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary List Pins on board
     * @param {string} boardId Unique identifier of a board.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {Array<BoardsListPinsCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardsListPins(boardId: string, bookmark?: string, pageSize?: number, creativeTypes?: Array<BoardsListPinsCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardsListPins(boardId, bookmark, pageSize, creativeTypes, adAccountId, pinMetrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a board owned by the \"operating user_account\". - Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.
     * @summary Update board
     * @param {string} boardId Unique identifier of a board.
     * @param {BoardUpdate} boardUpdate Update a board.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BoardsApi
     */
    public boardsUpdate(boardId: string, boardUpdate: BoardUpdate, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return BoardsApiFp(this.configuration).boardsUpdate(boardId, boardUpdate, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BoardsListPrivacyEnum = {
    All: 'ALL',
    Protected: 'PROTECTED',
    Public: 'PUBLIC',
    Secret: 'SECRET',
    PublicAndSecret: 'PUBLIC_AND_SECRET'
} as const;
export type BoardsListPrivacyEnum = typeof BoardsListPrivacyEnum[keyof typeof BoardsListPrivacyEnum];
/**
 * @export
 */
export const BoardsListPinsCreativeTypesEnum = {
    Regular: 'REGULAR',
    Video: 'VIDEO',
    Shopping: 'SHOPPING',
    Carousel: 'CAROUSEL',
    MaxVideo: 'MAX_VIDEO',
    ShopThePin: 'SHOP_THE_PIN',
    Collection: 'COLLECTION',
    Idea: 'IDEA'
} as const;
export type BoardsListPinsCreativeTypesEnum = typeof BoardsListPinsCreativeTypesEnum[keyof typeof BoardsListPinsCreativeTypesEnum];


/**
 * BulkApi - axios parameter creator
 * @export
 */
export const BulkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create an asynchronous report that may include information on campaigns, ad groups, product groups, ads, and/or keywords; can filter by campaigns. Though the entities may be active, archived, or paused, only active entities will return data.
         * @summary Get advertiser entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BulkDownloadRequest} bulkDownloadRequest Parameters to get ad entities in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownloadCreate: async (adAccountId: string, bulkDownloadRequest: BulkDownloadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('bulkDownloadCreate', 'adAccountId', adAccountId)
            // verify required parameter 'bulkDownloadRequest' is not null or undefined
            assertParamExists('bulkDownloadCreate', 'bulkDownloadRequest', bulkDownloadRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/bulk/download`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkDownloadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the status of a bulk request by <code>request_id</code>, along with a download URL that will allow you to download the new or updated entity data (campaigns, ad groups, product groups, ads, or keywords).
         * @summary Download advertiser entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} bulkRequestId Unique identifier of a bulk upsert request.
         * @param {boolean} [includeDetails] if set to True then attach the errors/details to all the requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRequestGet: async (adAccountId: string, bulkRequestId: string, includeDetails?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('bulkRequestGet', 'adAccountId', adAccountId)
            // verify required parameter 'bulkRequestId' is not null or undefined
            assertParamExists('bulkRequestGet', 'bulkRequestId', bulkRequestId)
            const localVarPath = `/ad_accounts/{ad_account_id}/bulk/{bulk_request_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"bulk_request_id"}}`, encodeURIComponent(String(bulkRequestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (includeDetails !== undefined) {
                localVarQueryParameter['include_details'] = includeDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Either create or update any combination of campaigns, ad groups, product groups, ads, or keywords. Note that this request will be processed asynchronously; the response will include a <code>request_id</code> that can be used to obtain the status of the request.
         * @summary Create/update ad entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BulkUpsertRequest} bulkUpsertRequest Parameters to get create/update ad entities in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpsertCreate: async (adAccountId: string, bulkUpsertRequest: BulkUpsertRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('bulkUpsertCreate', 'adAccountId', adAccountId)
            // verify required parameter 'bulkUpsertRequest' is not null or undefined
            assertParamExists('bulkUpsertCreate', 'bulkUpsertRequest', bulkUpsertRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/bulk/upsert`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bulkUpsertRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BulkApi - functional programming interface
 * @export
 */
export const BulkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BulkApiAxiosParamCreator(configuration)
    return {
        /**
         * Create an asynchronous report that may include information on campaigns, ad groups, product groups, ads, and/or keywords; can filter by campaigns. Though the entities may be active, archived, or paused, only active entities will return data.
         * @summary Get advertiser entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BulkDownloadRequest} bulkDownloadRequest Parameters to get ad entities in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDownloadCreate(adAccountId: string, bulkDownloadRequest: BulkDownloadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkDownloadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDownloadCreate(adAccountId, bulkDownloadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkApi.bulkDownloadCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the status of a bulk request by <code>request_id</code>, along with a download URL that will allow you to download the new or updated entity data (campaigns, ad groups, product groups, ads, or keywords).
         * @summary Download advertiser entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} bulkRequestId Unique identifier of a bulk upsert request.
         * @param {boolean} [includeDetails] if set to True then attach the errors/details to all the requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkRequestGet(adAccountId: string, bulkRequestId: string, includeDetails?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkUpsertStatusResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkRequestGet(adAccountId, bulkRequestId, includeDetails, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkApi.bulkRequestGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Either create or update any combination of campaigns, ad groups, product groups, ads, or keywords. Note that this request will be processed asynchronously; the response will include a <code>request_id</code> that can be used to obtain the status of the request.
         * @summary Create/update ad entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BulkUpsertRequest} bulkUpsertRequest Parameters to get create/update ad entities in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpsertCreate(adAccountId: string, bulkUpsertRequest: BulkUpsertRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BulkUpsertResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpsertCreate(adAccountId, bulkUpsertRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BulkApi.bulkUpsertCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BulkApi - factory interface
 * @export
 */
export const BulkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BulkApiFp(configuration)
    return {
        /**
         * Create an asynchronous report that may include information on campaigns, ad groups, product groups, ads, and/or keywords; can filter by campaigns. Though the entities may be active, archived, or paused, only active entities will return data.
         * @summary Get advertiser entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BulkDownloadRequest} bulkDownloadRequest Parameters to get ad entities in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDownloadCreate(adAccountId: string, bulkDownloadRequest: BulkDownloadRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkDownloadResponse> {
            return localVarFp.bulkDownloadCreate(adAccountId, bulkDownloadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the status of a bulk request by <code>request_id</code>, along with a download URL that will allow you to download the new or updated entity data (campaigns, ad groups, product groups, ads, or keywords).
         * @summary Download advertiser entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} bulkRequestId Unique identifier of a bulk upsert request.
         * @param {boolean} [includeDetails] if set to True then attach the errors/details to all the requests
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkRequestGet(adAccountId: string, bulkRequestId: string, includeDetails?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<BulkUpsertStatusResponse> {
            return localVarFp.bulkRequestGet(adAccountId, bulkRequestId, includeDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * Either create or update any combination of campaigns, ad groups, product groups, ads, or keywords. Note that this request will be processed asynchronously; the response will include a <code>request_id</code> that can be used to obtain the status of the request.
         * @summary Create/update ad entities in bulk
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {BulkUpsertRequest} bulkUpsertRequest Parameters to get create/update ad entities in bulk
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpsertCreate(adAccountId: string, bulkUpsertRequest: BulkUpsertRequest, options?: RawAxiosRequestConfig): AxiosPromise<BulkUpsertResponse> {
            return localVarFp.bulkUpsertCreate(adAccountId, bulkUpsertRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BulkApi - object-oriented interface
 * @export
 * @class BulkApi
 * @extends {BaseAPI}
 */
export class BulkApi extends BaseAPI {
    /**
     * Create an asynchronous report that may include information on campaigns, ad groups, product groups, ads, and/or keywords; can filter by campaigns. Though the entities may be active, archived, or paused, only active entities will return data.
     * @summary Get advertiser entities in bulk
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {BulkDownloadRequest} bulkDownloadRequest Parameters to get ad entities in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkApi
     */
    public bulkDownloadCreate(adAccountId: string, bulkDownloadRequest: BulkDownloadRequest, options?: RawAxiosRequestConfig) {
        return BulkApiFp(this.configuration).bulkDownloadCreate(adAccountId, bulkDownloadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the status of a bulk request by <code>request_id</code>, along with a download URL that will allow you to download the new or updated entity data (campaigns, ad groups, product groups, ads, or keywords).
     * @summary Download advertiser entities in bulk
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} bulkRequestId Unique identifier of a bulk upsert request.
     * @param {boolean} [includeDetails] if set to True then attach the errors/details to all the requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkApi
     */
    public bulkRequestGet(adAccountId: string, bulkRequestId: string, includeDetails?: boolean, options?: RawAxiosRequestConfig) {
        return BulkApiFp(this.configuration).bulkRequestGet(adAccountId, bulkRequestId, includeDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Either create or update any combination of campaigns, ad groups, product groups, ads, or keywords. Note that this request will be processed asynchronously; the response will include a <code>request_id</code> that can be used to obtain the status of the request.
     * @summary Create/update ad entities in bulk
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {BulkUpsertRequest} bulkUpsertRequest Parameters to get create/update ad entities in bulk
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BulkApi
     */
    public bulkUpsertCreate(adAccountId: string, bulkUpsertRequest: BulkUpsertRequest, options?: RawAxiosRequestConfig) {
        return BulkApiFp(this.configuration).bulkUpsertCreate(adAccountId, bulkUpsertRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * BusinessAccessAssetsApi - axios parameter creator
 * @export
 */
export const BusinessAccessAssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new asset group with the specified parameters. - An <a href=\"https://help.pinterest.com/en/business/article/asset-groups\">asset group</a> is a custom group of assets based on how youd like to manage your accounts.
         * @summary Create a new asset group.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetGroupBody} createAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGroupCreate: async (businessId: string, createAssetGroupBody: CreateAssetGroupBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('assetGroupCreate', 'businessId', businessId)
            // verify required parameter 'createAssetGroupBody' is not null or undefined
            assertParamExists('assetGroupCreate', 'createAssetGroupBody', createAssetGroupBody)
            const localVarPath = `/businesses/{business_id}/asset_groups`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetGroupBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a batch of asset groups.
         * @summary Delete asset groups.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeleteAssetGroupBody} deleteAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGroupDelete: async (businessId: string, deleteAssetGroupBody: DeleteAssetGroupBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('assetGroupDelete', 'businessId', businessId)
            // verify required parameter 'deleteAssetGroupBody' is not null or undefined
            assertParamExists('assetGroupDelete', 'deleteAssetGroupBody', deleteAssetGroupBody)
            const localVarPath = `/businesses/{business_id}/asset_groups`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteAssetGroupBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a batch of asset groups with the specified parameters.
         * @summary Update asset groups.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdateAssetGroupBody} updateAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGroupUpdate: async (businessId: string, updateAssetGroupBody: UpdateAssetGroupBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('assetGroupUpdate', 'businessId', businessId)
            // verify required parameter 'updateAssetGroupBody' is not null or undefined
            assertParamExists('assetGroupUpdate', 'updateAssetGroupBody', updateAssetGroupBody)
            const localVarPath = `/businesses/{business_id}/asset_groups`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAssetGroupBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the members the requesting business has granted access to on the given asset.
         * @summary Get members with access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} assetId Unique identifier of a business asset.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAssetMembersGet: async (businessId: string, assetId: string, bookmark?: string, pageSize?: number, startIndex?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessAssetMembersGet', 'businessId', businessId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('businessAssetMembersGet', 'assetId', assetId)
            const localVarPath = `/businesses/{business_id}/assets/{asset_id}/members`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the partners the requesting business has granted access to on the given asset. Note: If the asset has been shared with you, an empty array will be returned. This is because an asset shared with you cannot be shared with a different partner.
         * @summary Get partners with access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} assetId Unique identifier of a business asset.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAssetPartnersGet: async (businessId: string, assetId: string, startIndex?: number, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessAssetPartnersGet', 'businessId', businessId)
            // verify required parameter 'assetId' is not null or undefined
            assertParamExists('businessAssetPartnersGet', 'assetId', assetId)
            const localVarPath = `/businesses/{business_id}/assets/{asset_id}/partners`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"asset_id"}}`, encodeURIComponent(String(assetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all the assets the requesting business has access to. This includes assets the business owns and assets the business has access to through partnerships.
         * @summary List business assets
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {Array<PermissionsWithOwner>} [permissions] A list of asset permissions used to filter the assets. Only assets where the requesting business has at least one of the specified permissions will be returned.
         * @param {string} [childAssetId] A child asset unique identifier. Used to fetch asset groups that contain the asset id as a child.
         * @param {string} [assetGroupId] An asset group unique identifier. Used to fetch assets contained within the specified asset group.
         * @param {BusinessAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAssetsGet: async (businessId: string, permissions?: Array<PermissionsWithOwner>, childAssetId?: string, assetGroupId?: string, assetType?: BusinessAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessAssetsGet', 'businessId', businessId)
            const localVarPath = `/businesses/{business_id}/assets`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (permissions) {
                localVarQueryParameter['permissions'] = permissions;
            }

            if (childAssetId !== undefined) {
                localVarQueryParameter['child_asset_id'] = childAssetId;
            }

            if (assetGroupId !== undefined) {
                localVarQueryParameter['asset_group_id'] = assetGroupId;
            }

            if (assetType !== undefined) {
                localVarQueryParameter['asset_type'] = assetType;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get assets on which you assigned asset permissions to the given member. Can be used to: - get all assets, regardless of asset type or - get assets of one asset type by using the asset_type query. The return response will include the permissions the member has to that asset and the asset type.
         * @summary Get assets assigned to a member
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} memberId The member id to fetch assets for.
         * @param {BusinessMemberAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessMemberAssetsGet: async (businessId: string, memberId: string, assetType?: BusinessMemberAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessMemberAssetsGet', 'businessId', businessId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('businessMemberAssetsGet', 'memberId', memberId)
            const localVarPath = `/businesses/{business_id}/members/{member_id}/assets`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"member_id"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (assetType !== undefined) {
                localVarQueryParameter['asset_type'] = assetType;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminate multiple members\' access to an asset.
         * @summary Delete member access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {BusinessMembersAssetAccessDeleteRequest} businessMembersAssetAccessDeleteRequest List member assset permissions to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessMembersAssetAccessDelete: async (businessId: string, businessMembersAssetAccessDeleteRequest: BusinessMembersAssetAccessDeleteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessMembersAssetAccessDelete', 'businessId', businessId)
            // verify required parameter 'businessMembersAssetAccessDeleteRequest' is not null or undefined
            assertParamExists('businessMembersAssetAccessDelete', 'businessMembersAssetAccessDeleteRequest', businessMembersAssetAccessDeleteRequest)
            const localVarPath = `/businesses/{business_id}/members/assets/access`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(businessMembersAssetAccessDeleteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant multiple members access to assets and/or update multiple member\'s exisiting permissions to an asset. Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE. 
         * @summary Assign/Update member asset permissions
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdateMemberAssetAccessBody} updateMemberAssetAccessBody List of member asset permissions to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessMembersAssetAccessUpdate: async (businessId: string, updateMemberAssetAccessBody: UpdateMemberAssetAccessBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessMembersAssetAccessUpdate', 'businessId', businessId)
            // verify required parameter 'updateMemberAssetAccessBody' is not null or undefined
            assertParamExists('businessMembersAssetAccessUpdate', 'updateMemberAssetAccessBody', updateMemberAssetAccessBody)
            const localVarPath = `/businesses/{business_id}/members/assets/access`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberAssetAccessBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Can be used to get the business assets your partner has granted you access to or the business assets you have granted your partner access to. If you specify: - partner_type=INTERNAL, you will retrieve your business assets that the partner has access to. - partner_type=EXTERNAL, you will retrieve the partner\'s business assets that the partner has granted you access to.
         * @summary Get assets assigned to a partner or assets assigned by a partner
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} partnerId The partner id to be bound to the Business
         * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
         * @param {BusinessPartnerAssetAccessGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessPartnerAssetAccessGet: async (businessId: string, partnerId: string, partnerType?: PartnerType, assetType?: BusinessPartnerAssetAccessGetAssetTypeEnum, startIndex?: number, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('businessPartnerAssetAccessGet', 'businessId', businessId)
            // verify required parameter 'partnerId' is not null or undefined
            assertParamExists('businessPartnerAssetAccessGet', 'partnerId', partnerId)
            const localVarPath = `/businesses/{business_id}/partners/{partner_id}/assets`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)))
                .replace(`{${"partner_id"}}`, encodeURIComponent(String(partnerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (partnerType !== undefined) {
                for (const [key, value] of Object.entries(partnerType)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (assetType !== undefined) {
                localVarQueryParameter['asset_type'] = assetType;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminate multiple partners\' access to an asset. If - partner_type=INTERNAL: You will terminate a partner\'s asset access to your business assets. - partner_type=EXTERNAL: You will terminate your own access to your partner\'s business assets.
         * @summary Delete partner access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeletePartnerAssetAccessBody} deletePartnerAssetAccessBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartnerAssetAccessHandlerImpl: async (businessId: string, deletePartnerAssetAccessBody: DeletePartnerAssetAccessBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('deletePartnerAssetAccessHandlerImpl', 'businessId', businessId)
            // verify required parameter 'deletePartnerAssetAccessBody' is not null or undefined
            assertParamExists('deletePartnerAssetAccessHandlerImpl', 'deletePartnerAssetAccessBody', deletePartnerAssetAccessBody)
            const localVarPath = `/businesses/{business_id}/partners/assets`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePartnerAssetAccessBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant multiple partners access to assets and/or update multiple partner\'s exisiting permissions to an asset. If your partner already had permissions on the asset, they will be overriden with the new permissions you assign to them. To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview  Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE.
         * @summary Assign/Update partner asset permissions
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdatePartnerAssetAccessBody} updatePartnerAssetAccessBody A list of assets and permissions to assign to your partners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartnerAssetAccessHandlerImpl: async (businessId: string, updatePartnerAssetAccessBody: UpdatePartnerAssetAccessBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updatePartnerAssetAccessHandlerImpl', 'businessId', businessId)
            // verify required parameter 'updatePartnerAssetAccessBody' is not null or undefined
            assertParamExists('updatePartnerAssetAccessHandlerImpl', 'updatePartnerAssetAccessBody', updatePartnerAssetAccessBody)
            const localVarPath = `/businesses/{business_id}/partners/assets`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePartnerAssetAccessBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessAccessAssetsApi - functional programming interface
 * @export
 */
export const BusinessAccessAssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessAccessAssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new asset group with the specified parameters. - An <a href=\"https://help.pinterest.com/en/business/article/asset-groups\">asset group</a> is a custom group of assets based on how youd like to manage your accounts.
         * @summary Create a new asset group.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetGroupBody} createAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetGroupCreate(businessId: string, createAssetGroupBody: CreateAssetGroupBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetGroupCreate(businessId, createAssetGroupBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.assetGroupCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a batch of asset groups.
         * @summary Delete asset groups.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeleteAssetGroupBody} deleteAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetGroupDelete(businessId: string, deleteAssetGroupBody: DeleteAssetGroupBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAssetGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetGroupDelete(businessId, deleteAssetGroupBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.assetGroupDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a batch of asset groups with the specified parameters.
         * @summary Update asset groups.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdateAssetGroupBody} updateAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetGroupUpdate(businessId: string, updateAssetGroupBody: UpdateAssetGroupBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAssetGroupResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetGroupUpdate(businessId, updateAssetGroupBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.assetGroupUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all the members the requesting business has granted access to on the given asset.
         * @summary Get members with access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} assetId Unique identifier of a business asset.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessAssetMembersGet(businessId: string, assetId: string, bookmark?: string, pageSize?: number, startIndex?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessAssetMembersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessAssetMembersGet(businessId, assetId, bookmark, pageSize, startIndex, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessAssetMembersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all the partners the requesting business has granted access to on the given asset. Note: If the asset has been shared with you, an empty array will be returned. This is because an asset shared with you cannot be shared with a different partner.
         * @summary Get partners with access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} assetId Unique identifier of a business asset.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessAssetPartnersGet(businessId: string, assetId: string, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessAssetPartnersGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessAssetPartnersGet(businessId, assetId, startIndex, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessAssetPartnersGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all the assets the requesting business has access to. This includes assets the business owns and assets the business has access to through partnerships.
         * @summary List business assets
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {Array<PermissionsWithOwner>} [permissions] A list of asset permissions used to filter the assets. Only assets where the requesting business has at least one of the specified permissions will be returned.
         * @param {string} [childAssetId] A child asset unique identifier. Used to fetch asset groups that contain the asset id as a child.
         * @param {string} [assetGroupId] An asset group unique identifier. Used to fetch assets contained within the specified asset group.
         * @param {BusinessAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessAssetsGet(businessId: string, permissions?: Array<PermissionsWithOwner>, childAssetId?: string, assetGroupId?: string, assetType?: BusinessAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessAssetsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessAssetsGet(businessId, permissions, childAssetId, assetGroupId, assetType, startIndex, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessAssetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get assets on which you assigned asset permissions to the given member. Can be used to: - get all assets, regardless of asset type or - get assets of one asset type by using the asset_type query. The return response will include the permissions the member has to that asset and the asset type.
         * @summary Get assets assigned to a member
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} memberId The member id to fetch assets for.
         * @param {BusinessMemberAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessMemberAssetsGet(businessId: string, memberId: string, assetType?: BusinessMemberAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessMemberAssetsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessMemberAssetsGet(businessId, memberId, assetType, startIndex, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessMemberAssetsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminate multiple members\' access to an asset.
         * @summary Delete member access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {BusinessMembersAssetAccessDeleteRequest} businessMembersAssetAccessDeleteRequest List member assset permissions to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessMembersAssetAccessDelete(businessId: string, businessMembersAssetAccessDeleteRequest: BusinessMembersAssetAccessDeleteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteMemberAccessResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessMembersAssetAccessDelete(businessId, businessMembersAssetAccessDeleteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessMembersAssetAccessDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grant multiple members access to assets and/or update multiple member\'s exisiting permissions to an asset. Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE. 
         * @summary Assign/Update member asset permissions
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdateMemberAssetAccessBody} updateMemberAssetAccessBody List of member asset permissions to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessMembersAssetAccessUpdate(businessId: string, updateMemberAssetAccessBody: UpdateMemberAssetAccessBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMemberAssetsResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessMembersAssetAccessUpdate(businessId, updateMemberAssetAccessBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessMembersAssetAccessUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Can be used to get the business assets your partner has granted you access to or the business assets you have granted your partner access to. If you specify: - partner_type=INTERNAL, you will retrieve your business assets that the partner has access to. - partner_type=EXTERNAL, you will retrieve the partner\'s business assets that the partner has granted you access to.
         * @summary Get assets assigned to a partner or assets assigned by a partner
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} partnerId The partner id to be bound to the Business
         * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
         * @param {BusinessPartnerAssetAccessGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async businessPartnerAssetAccessGet(businessId: string, partnerId: string, partnerType?: PartnerType, assetType?: BusinessPartnerAssetAccessGetAssetTypeEnum, startIndex?: number, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BusinessPartnerAssetAccessGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.businessPartnerAssetAccessGet(businessId, partnerId, partnerType, assetType, startIndex, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.businessPartnerAssetAccessGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminate multiple partners\' access to an asset. If - partner_type=INTERNAL: You will terminate a partner\'s asset access to your business assets. - partner_type=EXTERNAL: You will terminate your own access to your partner\'s business assets.
         * @summary Delete partner access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeletePartnerAssetAccessBody} deletePartnerAssetAccessBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePartnerAssetAccessHandlerImpl(businessId: string, deletePartnerAssetAccessBody: DeletePartnerAssetAccessBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePartnerAssetsResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePartnerAssetAccessHandlerImpl(businessId, deletePartnerAssetAccessBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.deletePartnerAssetAccessHandlerImpl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Grant multiple partners access to assets and/or update multiple partner\'s exisiting permissions to an asset. If your partner already had permissions on the asset, they will be overriden with the new permissions you assign to them. To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview  Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE.
         * @summary Assign/Update partner asset permissions
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdatePartnerAssetAccessBody} updatePartnerAssetAccessBody A list of assets and permissions to assign to your partners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePartnerAssetAccessHandlerImpl(businessId: string, updatePartnerAssetAccessBody: UpdatePartnerAssetAccessBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdatePartnerAssetsResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePartnerAssetAccessHandlerImpl(businessId, updatePartnerAssetAccessBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessAssetsApi.updatePartnerAssetAccessHandlerImpl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessAccessAssetsApi - factory interface
 * @export
 */
export const BusinessAccessAssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessAccessAssetsApiFp(configuration)
    return {
        /**
         * Create a new asset group with the specified parameters. - An <a href=\"https://help.pinterest.com/en/business/article/asset-groups\">asset group</a> is a custom group of assets based on how youd like to manage your accounts.
         * @summary Create a new asset group.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetGroupBody} createAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGroupCreate(businessId: string, createAssetGroupBody: CreateAssetGroupBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetGroupResponse> {
            return localVarFp.assetGroupCreate(businessId, createAssetGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a batch of asset groups.
         * @summary Delete asset groups.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeleteAssetGroupBody} deleteAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGroupDelete(businessId: string, deleteAssetGroupBody: DeleteAssetGroupBody, options?: RawAxiosRequestConfig): AxiosPromise<DeleteAssetGroupResponse> {
            return localVarFp.assetGroupDelete(businessId, deleteAssetGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a batch of asset groups with the specified parameters.
         * @summary Update asset groups.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdateAssetGroupBody} updateAssetGroupBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGroupUpdate(businessId: string, updateAssetGroupBody: UpdateAssetGroupBody, options?: RawAxiosRequestConfig): AxiosPromise<UpdateAssetGroupResponse> {
            return localVarFp.assetGroupUpdate(businessId, updateAssetGroupBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the members the requesting business has granted access to on the given asset.
         * @summary Get members with access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} assetId Unique identifier of a business asset.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAssetMembersGet(businessId: string, assetId: string, bookmark?: string, pageSize?: number, startIndex?: number, options?: RawAxiosRequestConfig): AxiosPromise<BusinessAssetMembersGet200Response> {
            return localVarFp.businessAssetMembersGet(businessId, assetId, bookmark, pageSize, startIndex, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the partners the requesting business has granted access to on the given asset. Note: If the asset has been shared with you, an empty array will be returned. This is because an asset shared with you cannot be shared with a different partner.
         * @summary Get partners with access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} assetId Unique identifier of a business asset.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAssetPartnersGet(businessId: string, assetId: string, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<BusinessAssetPartnersGet200Response> {
            return localVarFp.businessAssetPartnersGet(businessId, assetId, startIndex, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all the assets the requesting business has access to. This includes assets the business owns and assets the business has access to through partnerships.
         * @summary List business assets
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {Array<PermissionsWithOwner>} [permissions] A list of asset permissions used to filter the assets. Only assets where the requesting business has at least one of the specified permissions will be returned.
         * @param {string} [childAssetId] A child asset unique identifier. Used to fetch asset groups that contain the asset id as a child.
         * @param {string} [assetGroupId] An asset group unique identifier. Used to fetch assets contained within the specified asset group.
         * @param {BusinessAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessAssetsGet(businessId: string, permissions?: Array<PermissionsWithOwner>, childAssetId?: string, assetGroupId?: string, assetType?: BusinessAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<BusinessAssetsGet200Response> {
            return localVarFp.businessAssetsGet(businessId, permissions, childAssetId, assetGroupId, assetType, startIndex, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get assets on which you assigned asset permissions to the given member. Can be used to: - get all assets, regardless of asset type or - get assets of one asset type by using the asset_type query. The return response will include the permissions the member has to that asset and the asset type.
         * @summary Get assets assigned to a member
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} memberId The member id to fetch assets for.
         * @param {BusinessMemberAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessMemberAssetsGet(businessId: string, memberId: string, assetType?: BusinessMemberAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<BusinessMemberAssetsGet200Response> {
            return localVarFp.businessMemberAssetsGet(businessId, memberId, assetType, startIndex, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminate multiple members\' access to an asset.
         * @summary Delete member access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {BusinessMembersAssetAccessDeleteRequest} businessMembersAssetAccessDeleteRequest List member assset permissions to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessMembersAssetAccessDelete(businessId: string, businessMembersAssetAccessDeleteRequest: BusinessMembersAssetAccessDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeleteMemberAccessResultsResponseArray> {
            return localVarFp.businessMembersAssetAccessDelete(businessId, businessMembersAssetAccessDeleteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant multiple members access to assets and/or update multiple member\'s exisiting permissions to an asset. Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE. 
         * @summary Assign/Update member asset permissions
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdateMemberAssetAccessBody} updateMemberAssetAccessBody List of member asset permissions to create or update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessMembersAssetAccessUpdate(businessId: string, updateMemberAssetAccessBody: UpdateMemberAssetAccessBody, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMemberAssetsResultsResponseArray> {
            return localVarFp.businessMembersAssetAccessUpdate(businessId, updateMemberAssetAccessBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Can be used to get the business assets your partner has granted you access to or the business assets you have granted your partner access to. If you specify: - partner_type=INTERNAL, you will retrieve your business assets that the partner has access to. - partner_type=EXTERNAL, you will retrieve the partner\'s business assets that the partner has granted you access to.
         * @summary Get assets assigned to a partner or assets assigned by a partner
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {string} partnerId The partner id to be bound to the Business
         * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
         * @param {BusinessPartnerAssetAccessGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        businessPartnerAssetAccessGet(businessId: string, partnerId: string, partnerType?: PartnerType, assetType?: BusinessPartnerAssetAccessGetAssetTypeEnum, startIndex?: number, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<BusinessPartnerAssetAccessGet200Response> {
            return localVarFp.businessPartnerAssetAccessGet(businessId, partnerId, partnerType, assetType, startIndex, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminate multiple partners\' access to an asset. If - partner_type=INTERNAL: You will terminate a partner\'s asset access to your business assets. - partner_type=EXTERNAL: You will terminate your own access to your partner\'s business assets.
         * @summary Delete partner access to asset
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeletePartnerAssetAccessBody} deletePartnerAssetAccessBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartnerAssetAccessHandlerImpl(businessId: string, deletePartnerAssetAccessBody: DeletePartnerAssetAccessBody, options?: RawAxiosRequestConfig): AxiosPromise<DeletePartnerAssetsResultsResponseArray> {
            return localVarFp.deletePartnerAssetAccessHandlerImpl(businessId, deletePartnerAssetAccessBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant multiple partners access to assets and/or update multiple partner\'s exisiting permissions to an asset. If your partner already had permissions on the asset, they will be overriden with the new permissions you assign to them. To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview  Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE.
         * @summary Assign/Update partner asset permissions
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {UpdatePartnerAssetAccessBody} updatePartnerAssetAccessBody A list of assets and permissions to assign to your partners.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartnerAssetAccessHandlerImpl(businessId: string, updatePartnerAssetAccessBody: UpdatePartnerAssetAccessBody, options?: RawAxiosRequestConfig): AxiosPromise<UpdatePartnerAssetsResultsResponseArray> {
            return localVarFp.updatePartnerAssetAccessHandlerImpl(businessId, updatePartnerAssetAccessBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessAccessAssetsApi - object-oriented interface
 * @export
 * @class BusinessAccessAssetsApi
 * @extends {BaseAPI}
 */
export class BusinessAccessAssetsApi extends BaseAPI {
    /**
     * Create a new asset group with the specified parameters. - An <a href=\"https://help.pinterest.com/en/business/article/asset-groups\">asset group</a> is a custom group of assets based on how youd like to manage your accounts.
     * @summary Create a new asset group.
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {CreateAssetGroupBody} createAssetGroupBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public assetGroupCreate(businessId: string, createAssetGroupBody: CreateAssetGroupBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).assetGroupCreate(businessId, createAssetGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a batch of asset groups.
     * @summary Delete asset groups.
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {DeleteAssetGroupBody} deleteAssetGroupBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public assetGroupDelete(businessId: string, deleteAssetGroupBody: DeleteAssetGroupBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).assetGroupDelete(businessId, deleteAssetGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a batch of asset groups with the specified parameters.
     * @summary Update asset groups.
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {UpdateAssetGroupBody} updateAssetGroupBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public assetGroupUpdate(businessId: string, updateAssetGroupBody: UpdateAssetGroupBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).assetGroupUpdate(businessId, updateAssetGroupBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the members the requesting business has granted access to on the given asset.
     * @summary Get members with access to asset
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {string} assetId Unique identifier of a business asset.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessAssetMembersGet(businessId: string, assetId: string, bookmark?: string, pageSize?: number, startIndex?: number, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessAssetMembersGet(businessId, assetId, bookmark, pageSize, startIndex, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the partners the requesting business has granted access to on the given asset. Note: If the asset has been shared with you, an empty array will be returned. This is because an asset shared with you cannot be shared with a different partner.
     * @summary Get partners with access to asset
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {string} assetId Unique identifier of a business asset.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessAssetPartnersGet(businessId: string, assetId: string, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessAssetPartnersGet(businessId, assetId, startIndex, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all the assets the requesting business has access to. This includes assets the business owns and assets the business has access to through partnerships.
     * @summary List business assets
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {Array<PermissionsWithOwner>} [permissions] A list of asset permissions used to filter the assets. Only assets where the requesting business has at least one of the specified permissions will be returned.
     * @param {string} [childAssetId] A child asset unique identifier. Used to fetch asset groups that contain the asset id as a child.
     * @param {string} [assetGroupId] An asset group unique identifier. Used to fetch assets contained within the specified asset group.
     * @param {BusinessAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessAssetsGet(businessId: string, permissions?: Array<PermissionsWithOwner>, childAssetId?: string, assetGroupId?: string, assetType?: BusinessAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessAssetsGet(businessId, permissions, childAssetId, assetGroupId, assetType, startIndex, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get assets on which you assigned asset permissions to the given member. Can be used to: - get all assets, regardless of asset type or - get assets of one asset type by using the asset_type query. The return response will include the permissions the member has to that asset and the asset type.
     * @summary Get assets assigned to a member
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {string} memberId The member id to fetch assets for.
     * @param {BusinessMemberAssetsGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessMemberAssetsGet(businessId: string, memberId: string, assetType?: BusinessMemberAssetsGetAssetTypeEnum, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessMemberAssetsGet(businessId, memberId, assetType, startIndex, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminate multiple members\' access to an asset.
     * @summary Delete member access to asset
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {BusinessMembersAssetAccessDeleteRequest} businessMembersAssetAccessDeleteRequest List member assset permissions to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessMembersAssetAccessDelete(businessId: string, businessMembersAssetAccessDeleteRequest: BusinessMembersAssetAccessDeleteRequest, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessMembersAssetAccessDelete(businessId, businessMembersAssetAccessDeleteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant multiple members access to assets and/or update multiple member\'s exisiting permissions to an asset. Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE. 
     * @summary Assign/Update member asset permissions
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {UpdateMemberAssetAccessBody} updateMemberAssetAccessBody List of member asset permissions to create or update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessMembersAssetAccessUpdate(businessId: string, updateMemberAssetAccessBody: UpdateMemberAssetAccessBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessMembersAssetAccessUpdate(businessId, updateMemberAssetAccessBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Can be used to get the business assets your partner has granted you access to or the business assets you have granted your partner access to. If you specify: - partner_type=INTERNAL, you will retrieve your business assets that the partner has access to. - partner_type=EXTERNAL, you will retrieve the partner\'s business assets that the partner has granted you access to.
     * @summary Get assets assigned to a partner or assets assigned by a partner
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {string} partnerId The partner id to be bound to the Business
     * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
     * @param {BusinessPartnerAssetAccessGetAssetTypeEnum} [assetType] A resource type to filter the assets by. Only assets of the specified type will be returned.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public businessPartnerAssetAccessGet(businessId: string, partnerId: string, partnerType?: PartnerType, assetType?: BusinessPartnerAssetAccessGetAssetTypeEnum, startIndex?: number, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).businessPartnerAssetAccessGet(businessId, partnerId, partnerType, assetType, startIndex, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminate multiple partners\' access to an asset. If - partner_type=INTERNAL: You will terminate a partner\'s asset access to your business assets. - partner_type=EXTERNAL: You will terminate your own access to your partner\'s business assets.
     * @summary Delete partner access to asset
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {DeletePartnerAssetAccessBody} deletePartnerAssetAccessBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public deletePartnerAssetAccessHandlerImpl(businessId: string, deletePartnerAssetAccessBody: DeletePartnerAssetAccessBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).deletePartnerAssetAccessHandlerImpl(businessId, deletePartnerAssetAccessBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant multiple partners access to assets and/or update multiple partner\'s exisiting permissions to an asset. If your partner already had permissions on the asset, they will be overriden with the new permissions you assign to them. To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview  Note: Not all listed permissions are applicable to each asset type. For example, PROFILE_PUBLISHER would not be applicable to an asset of type AD_ACCOUNT. The permission level PROFILE_PUBLISHER is only available to an asset of the type PROFILE.
     * @summary Assign/Update partner asset permissions
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {UpdatePartnerAssetAccessBody} updatePartnerAssetAccessBody A list of assets and permissions to assign to your partners.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessAssetsApi
     */
    public updatePartnerAssetAccessHandlerImpl(businessId: string, updatePartnerAssetAccessBody: UpdatePartnerAssetAccessBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessAssetsApiFp(this.configuration).updatePartnerAssetAccessHandlerImpl(businessId, updatePartnerAssetAccessBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const BusinessAssetsGetAssetTypeEnum = {
    AdAccount: 'AD_ACCOUNT',
    Profile: 'PROFILE',
    AssetGroup: 'ASSET_GROUP'
} as const;
export type BusinessAssetsGetAssetTypeEnum = typeof BusinessAssetsGetAssetTypeEnum[keyof typeof BusinessAssetsGetAssetTypeEnum];
/**
 * @export
 */
export const BusinessMemberAssetsGetAssetTypeEnum = {
    AdAccount: 'AD_ACCOUNT',
    Profile: 'PROFILE',
    AssetGroup: 'ASSET_GROUP'
} as const;
export type BusinessMemberAssetsGetAssetTypeEnum = typeof BusinessMemberAssetsGetAssetTypeEnum[keyof typeof BusinessMemberAssetsGetAssetTypeEnum];
/**
 * @export
 */
export const BusinessPartnerAssetAccessGetAssetTypeEnum = {
    AdAccount: 'AD_ACCOUNT',
    Profile: 'PROFILE',
    AssetGroup: 'ASSET_GROUP'
} as const;
export type BusinessPartnerAssetAccessGetAssetTypeEnum = typeof BusinessPartnerAssetAccessGetAssetTypeEnum[keyof typeof BusinessPartnerAssetAccessGetAssetTypeEnum];


/**
 * BusinessAccessInviteApi - axios parameter creator
 * @export
 */
export const BusinessAccessInviteApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a request to access an existing partner\'s assets with the specified permissions. The request will be sent to the partner for approval. The assets that can be requested are ad accounts and profiles.
         * @summary Create a request to access an existing partner\'s assets.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetAccessRequestBody} createAssetAccessRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetAccessRequestsCreate: async (businessId: string, createAssetAccessRequestBody: CreateAssetAccessRequestBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('assetAccessRequestsCreate', 'businessId', businessId)
            // verify required parameter 'createAssetAccessRequestBody' is not null or undefined
            assertParamExists('assetAccessRequestsCreate', 'createAssetAccessRequestBody', createAssetAccessRequestBody)
            const localVarPath = `/businesses/{business_id}/requests/assets/access`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetAccessRequestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel membership/partnership invites and/or requests.
         * @summary Cancel invites/requests
         * @param {string} businessId Business id
         * @param {CancelInvitesBody} cancelInvitesBody A list with invite ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvitesOrRequests: async (businessId: string, cancelInvitesBody: CancelInvitesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('cancelInvitesOrRequests', 'businessId', businessId)
            // verify required parameter 'cancelInvitesBody' is not null or undefined
            assertParamExists('cancelInvitesOrRequests', 'cancelInvitesBody', cancelInvitesBody)
            const localVarPath = `/businesses/{business_id}/invites`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelInvitesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Assign asset permissions information to an existing invite/request. Can be used to: - Request access to a partner\'s asset. Note: This is only for when no existing partnership exists. If an existing   partnership exists, use \"Create a request to access an existing partner\'s assets\" to request access to your   partner\'s assets.     - invite_type=\"PARTNER_REQUEST\" - Invite a partner to access your business assets. Note: This is only for when there is no existing partnership.   If there is an existing partnership, use \"Assign/Update partner asset permissions\" to assign a partner access to   new assets.     - invite_type=\"PARTNER_INVITE\" - Invite a member to access your business assets. Note: This is only for when there is no existing membership.   If there is an existing membership, use \"Assign/Update member asset permissions\" to assign a member access to new   assets.     - invite_type=\"MEMBER_INVITE\"  To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview.
         * @summary Update invite/request with an asset permission
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetInvitesRequest} createAssetInvitesRequest A list of invites/requests together with the asset permissions to be assigned to the invite/request. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetInvites: async (businessId: string, createAssetInvitesRequest: CreateAssetInvitesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createAssetInvites', 'businessId', businessId)
            // verify required parameter 'createAssetInvitesRequest' is not null or undefined
            assertParamExists('createAssetInvites', 'createAssetInvitesRequest', createAssetInvitesRequest)
            const localVarPath = `/businesses/{business_id}/invites/assets/access`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAssetInvitesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create batch invites or requests. Can create batch invites or requests as described below. - Invite members to join the business. This would required specifying the following:     - invite_type=\"MEMBER_INVITE\"     - business_role=\"EMPLOYEE\" OR business_role=\"BIZ_ADMIN\" (To learn more about business roles, visit     https://help.pinterest.com/en/business/article/profile-permissions-in-business-access.)     - members - Invite partners to access your business assets. This would require specifying the following:     - invite_type=\"PARTNER_INVITE\"     - business_role=\"PARTNER\"     - partners - Request to be a partner so you can access their assets. This would require specifying the following:     - invite_type=\"PARTNER_REQUEST\"     - business_role=\"PARTNER\"     - partners
         * @summary Create invites or requests
         * @param {string} businessId Business id
         * @param {CreateMembershipOrPartnershipInvitesBody} createMembershipOrPartnershipInvitesBody An object with the properties: invite_type, partners, members, business_role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMembershipOrPartnershipInvites: async (businessId: string, createMembershipOrPartnershipInvitesBody: CreateMembershipOrPartnershipInvitesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('createMembershipOrPartnershipInvites', 'businessId', businessId)
            // verify required parameter 'createMembershipOrPartnershipInvitesBody' is not null or undefined
            assertParamExists('createMembershipOrPartnershipInvites', 'createMembershipOrPartnershipInvitesBody', createMembershipOrPartnershipInvitesBody)
            const localVarPath = `/businesses/{business_id}/invites`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createMembershipOrPartnershipInvitesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the membership/partnership invites and/or requests for the authorized user.
         * @summary Get invites/requests
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [isMember] A boolean field to indicate whether the invite is to create a partnership or a membership.
         * @param {Array<GetInvitesInviteStatusEnum>} [inviteStatus] A list of invite statuses to filter invites by. Only invites whose status is in the provided statuses will be returned.
         * @param {InviteType} [inviteType] Invite type to filter invites by. Only invites of the specified type will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites: async (businessId: string, isMember?: boolean, inviteStatus?: Array<GetInvitesInviteStatusEnum>, inviteType?: InviteType, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getInvites', 'businessId', businessId)
            const localVarPath = `/businesses/{business_id}/invites`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (isMember !== undefined) {
                localVarQueryParameter['is_member'] = isMember;
            }

            if (inviteStatus) {
                localVarQueryParameter['invite_status'] = inviteStatus;
            }

            if (inviteType !== undefined) {
                localVarQueryParameter['invite_type'] = inviteType;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Accept or decline invites or requests.
         * @summary Accept or decline an invite/request
         * @param {AuthRespondInvitesBody} authRespondInvitesBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondBusinessAccessInvites: async (authRespondInvitesBody: AuthRespondInvitesBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authRespondInvitesBody' is not null or undefined
            assertParamExists('respondBusinessAccessInvites', 'authRespondInvitesBody', authRespondInvitesBody)
            const localVarPath = `/businesses/invites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRespondInvitesBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessAccessInviteApi - functional programming interface
 * @export
 */
export const BusinessAccessInviteApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessAccessInviteApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a request to access an existing partner\'s assets with the specified permissions. The request will be sent to the partner for approval. The assets that can be requested are ad accounts and profiles.
         * @summary Create a request to access an existing partner\'s assets.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetAccessRequestBody} createAssetAccessRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assetAccessRequestsCreate(businessId: string, createAssetAccessRequestBody: CreateAssetAccessRequestBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAssetAccessRequestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assetAccessRequestsCreate(businessId, createAssetAccessRequestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessInviteApi.assetAccessRequestsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel membership/partnership invites and/or requests.
         * @summary Cancel invites/requests
         * @param {string} businessId Business id
         * @param {CancelInvitesBody} cancelInvitesBody A list with invite ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelInvitesOrRequests(businessId: string, cancelInvitesBody: CancelInvitesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteInvitesResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelInvitesOrRequests(businessId, cancelInvitesBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessInviteApi.cancelInvitesOrRequests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Assign asset permissions information to an existing invite/request. Can be used to: - Request access to a partner\'s asset. Note: This is only for when no existing partnership exists. If an existing   partnership exists, use \"Create a request to access an existing partner\'s assets\" to request access to your   partner\'s assets.     - invite_type=\"PARTNER_REQUEST\" - Invite a partner to access your business assets. Note: This is only for when there is no existing partnership.   If there is an existing partnership, use \"Assign/Update partner asset permissions\" to assign a partner access to   new assets.     - invite_type=\"PARTNER_INVITE\" - Invite a member to access your business assets. Note: This is only for when there is no existing membership.   If there is an existing membership, use \"Assign/Update member asset permissions\" to assign a member access to new   assets.     - invite_type=\"MEMBER_INVITE\"  To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview.
         * @summary Update invite/request with an asset permission
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetInvitesRequest} createAssetInvitesRequest A list of invites/requests together with the asset permissions to be assigned to the invite/request. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAssetInvites(businessId: string, createAssetInvitesRequest: CreateAssetInvitesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateInvitesResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAssetInvites(businessId, createAssetInvitesRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessInviteApi.createAssetInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create batch invites or requests. Can create batch invites or requests as described below. - Invite members to join the business. This would required specifying the following:     - invite_type=\"MEMBER_INVITE\"     - business_role=\"EMPLOYEE\" OR business_role=\"BIZ_ADMIN\" (To learn more about business roles, visit     https://help.pinterest.com/en/business/article/profile-permissions-in-business-access.)     - members - Invite partners to access your business assets. This would require specifying the following:     - invite_type=\"PARTNER_INVITE\"     - business_role=\"PARTNER\"     - partners - Request to be a partner so you can access their assets. This would require specifying the following:     - invite_type=\"PARTNER_REQUEST\"     - business_role=\"PARTNER\"     - partners
         * @summary Create invites or requests
         * @param {string} businessId Business id
         * @param {CreateMembershipOrPartnershipInvitesBody} createMembershipOrPartnershipInvitesBody An object with the properties: invite_type, partners, members, business_role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMembershipOrPartnershipInvites(businessId: string, createMembershipOrPartnershipInvitesBody: CreateMembershipOrPartnershipInvitesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateInvitesResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMembershipOrPartnershipInvites(businessId, createMembershipOrPartnershipInvitesBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessInviteApi.createMembershipOrPartnershipInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the membership/partnership invites and/or requests for the authorized user.
         * @summary Get invites/requests
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [isMember] A boolean field to indicate whether the invite is to create a partnership or a membership.
         * @param {Array<GetInvitesInviteStatusEnum>} [inviteStatus] A list of invite statuses to filter invites by. Only invites whose status is in the provided statuses will be returned.
         * @param {InviteType} [inviteType] Invite type to filter invites by. Only invites of the specified type will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInvites(businessId: string, isMember?: boolean, inviteStatus?: Array<GetInvitesInviteStatusEnum>, inviteType?: InviteType, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetInvites200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInvites(businessId, isMember, inviteStatus, inviteType, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessInviteApi.getInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Accept or decline invites or requests.
         * @summary Accept or decline an invite/request
         * @param {AuthRespondInvitesBody} authRespondInvitesBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async respondBusinessAccessInvites(authRespondInvitesBody: AuthRespondInvitesBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RespondToInvitesResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.respondBusinessAccessInvites(authRespondInvitesBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessInviteApi.respondBusinessAccessInvites']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessAccessInviteApi - factory interface
 * @export
 */
export const BusinessAccessInviteApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessAccessInviteApiFp(configuration)
    return {
        /**
         * Create a request to access an existing partner\'s assets with the specified permissions. The request will be sent to the partner for approval. The assets that can be requested are ad accounts and profiles.
         * @summary Create a request to access an existing partner\'s assets.
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetAccessRequestBody} createAssetAccessRequestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetAccessRequestsCreate(businessId: string, createAssetAccessRequestBody: CreateAssetAccessRequestBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateAssetAccessRequestResponse> {
            return localVarFp.assetAccessRequestsCreate(businessId, createAssetAccessRequestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel membership/partnership invites and/or requests.
         * @summary Cancel invites/requests
         * @param {string} businessId Business id
         * @param {CancelInvitesBody} cancelInvitesBody A list with invite ids
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvitesOrRequests(businessId: string, cancelInvitesBody: CancelInvitesBody, options?: RawAxiosRequestConfig): AxiosPromise<DeleteInvitesResultsResponseArray> {
            return localVarFp.cancelInvitesOrRequests(businessId, cancelInvitesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Assign asset permissions information to an existing invite/request. Can be used to: - Request access to a partner\'s asset. Note: This is only for when no existing partnership exists. If an existing   partnership exists, use \"Create a request to access an existing partner\'s assets\" to request access to your   partner\'s assets.     - invite_type=\"PARTNER_REQUEST\" - Invite a partner to access your business assets. Note: This is only for when there is no existing partnership.   If there is an existing partnership, use \"Assign/Update partner asset permissions\" to assign a partner access to   new assets.     - invite_type=\"PARTNER_INVITE\" - Invite a member to access your business assets. Note: This is only for when there is no existing membership.   If there is an existing membership, use \"Assign/Update member asset permissions\" to assign a member access to new   assets.     - invite_type=\"MEMBER_INVITE\"  To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview.
         * @summary Update invite/request with an asset permission
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {CreateAssetInvitesRequest} createAssetInvitesRequest A list of invites/requests together with the asset permissions to be assigned to the invite/request. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAssetInvites(businessId: string, createAssetInvitesRequest: CreateAssetInvitesRequest, options?: RawAxiosRequestConfig): AxiosPromise<UpdateInvitesResultsResponseArray> {
            return localVarFp.createAssetInvites(businessId, createAssetInvitesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create batch invites or requests. Can create batch invites or requests as described below. - Invite members to join the business. This would required specifying the following:     - invite_type=\"MEMBER_INVITE\"     - business_role=\"EMPLOYEE\" OR business_role=\"BIZ_ADMIN\" (To learn more about business roles, visit     https://help.pinterest.com/en/business/article/profile-permissions-in-business-access.)     - members - Invite partners to access your business assets. This would require specifying the following:     - invite_type=\"PARTNER_INVITE\"     - business_role=\"PARTNER\"     - partners - Request to be a partner so you can access their assets. This would require specifying the following:     - invite_type=\"PARTNER_REQUEST\"     - business_role=\"PARTNER\"     - partners
         * @summary Create invites or requests
         * @param {string} businessId Business id
         * @param {CreateMembershipOrPartnershipInvitesBody} createMembershipOrPartnershipInvitesBody An object with the properties: invite_type, partners, members, business_role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMembershipOrPartnershipInvites(businessId: string, createMembershipOrPartnershipInvitesBody: CreateMembershipOrPartnershipInvitesBody, options?: RawAxiosRequestConfig): AxiosPromise<CreateInvitesResultsResponseArray> {
            return localVarFp.createMembershipOrPartnershipInvites(businessId, createMembershipOrPartnershipInvitesBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the membership/partnership invites and/or requests for the authorized user.
         * @summary Get invites/requests
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [isMember] A boolean field to indicate whether the invite is to create a partnership or a membership.
         * @param {Array<GetInvitesInviteStatusEnum>} [inviteStatus] A list of invite statuses to filter invites by. Only invites whose status is in the provided statuses will be returned.
         * @param {InviteType} [inviteType] Invite type to filter invites by. Only invites of the specified type will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvites(businessId: string, isMember?: boolean, inviteStatus?: Array<GetInvitesInviteStatusEnum>, inviteType?: InviteType, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetInvites200Response> {
            return localVarFp.getInvites(businessId, isMember, inviteStatus, inviteType, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Accept or decline invites or requests.
         * @summary Accept or decline an invite/request
         * @param {AuthRespondInvitesBody} authRespondInvitesBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        respondBusinessAccessInvites(authRespondInvitesBody: AuthRespondInvitesBody, options?: RawAxiosRequestConfig): AxiosPromise<RespondToInvitesResponseArray> {
            return localVarFp.respondBusinessAccessInvites(authRespondInvitesBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessAccessInviteApi - object-oriented interface
 * @export
 * @class BusinessAccessInviteApi
 * @extends {BaseAPI}
 */
export class BusinessAccessInviteApi extends BaseAPI {
    /**
     * Create a request to access an existing partner\'s assets with the specified permissions. The request will be sent to the partner for approval. The assets that can be requested are ad accounts and profiles.
     * @summary Create a request to access an existing partner\'s assets.
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {CreateAssetAccessRequestBody} createAssetAccessRequestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessInviteApi
     */
    public assetAccessRequestsCreate(businessId: string, createAssetAccessRequestBody: CreateAssetAccessRequestBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessInviteApiFp(this.configuration).assetAccessRequestsCreate(businessId, createAssetAccessRequestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel membership/partnership invites and/or requests.
     * @summary Cancel invites/requests
     * @param {string} businessId Business id
     * @param {CancelInvitesBody} cancelInvitesBody A list with invite ids
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessInviteApi
     */
    public cancelInvitesOrRequests(businessId: string, cancelInvitesBody: CancelInvitesBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessInviteApiFp(this.configuration).cancelInvitesOrRequests(businessId, cancelInvitesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Assign asset permissions information to an existing invite/request. Can be used to: - Request access to a partner\'s asset. Note: This is only for when no existing partnership exists. If an existing   partnership exists, use \"Create a request to access an existing partner\'s assets\" to request access to your   partner\'s assets.     - invite_type=\"PARTNER_REQUEST\" - Invite a partner to access your business assets. Note: This is only for when there is no existing partnership.   If there is an existing partnership, use \"Assign/Update partner asset permissions\" to assign a partner access to   new assets.     - invite_type=\"PARTNER_INVITE\" - Invite a member to access your business assets. Note: This is only for when there is no existing membership.   If there is an existing membership, use \"Assign/Update member asset permissions\" to assign a member access to new   assets.     - invite_type=\"MEMBER_INVITE\"  To learn more about permission levels, visit https://help.pinterest.com/en/business/article/business-manager-overview.
     * @summary Update invite/request with an asset permission
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {CreateAssetInvitesRequest} createAssetInvitesRequest A list of invites/requests together with the asset permissions to be assigned to the invite/request. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessInviteApi
     */
    public createAssetInvites(businessId: string, createAssetInvitesRequest: CreateAssetInvitesRequest, options?: RawAxiosRequestConfig) {
        return BusinessAccessInviteApiFp(this.configuration).createAssetInvites(businessId, createAssetInvitesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create batch invites or requests. Can create batch invites or requests as described below. - Invite members to join the business. This would required specifying the following:     - invite_type=\"MEMBER_INVITE\"     - business_role=\"EMPLOYEE\" OR business_role=\"BIZ_ADMIN\" (To learn more about business roles, visit     https://help.pinterest.com/en/business/article/profile-permissions-in-business-access.)     - members - Invite partners to access your business assets. This would require specifying the following:     - invite_type=\"PARTNER_INVITE\"     - business_role=\"PARTNER\"     - partners - Request to be a partner so you can access their assets. This would require specifying the following:     - invite_type=\"PARTNER_REQUEST\"     - business_role=\"PARTNER\"     - partners
     * @summary Create invites or requests
     * @param {string} businessId Business id
     * @param {CreateMembershipOrPartnershipInvitesBody} createMembershipOrPartnershipInvitesBody An object with the properties: invite_type, partners, members, business_role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessInviteApi
     */
    public createMembershipOrPartnershipInvites(businessId: string, createMembershipOrPartnershipInvitesBody: CreateMembershipOrPartnershipInvitesBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessInviteApiFp(this.configuration).createMembershipOrPartnershipInvites(businessId, createMembershipOrPartnershipInvitesBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the membership/partnership invites and/or requests for the authorized user.
     * @summary Get invites/requests
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {boolean} [isMember] A boolean field to indicate whether the invite is to create a partnership or a membership.
     * @param {Array<GetInvitesInviteStatusEnum>} [inviteStatus] A list of invite statuses to filter invites by. Only invites whose status is in the provided statuses will be returned.
     * @param {InviteType} [inviteType] Invite type to filter invites by. Only invites of the specified type will be returned.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessInviteApi
     */
    public getInvites(businessId: string, isMember?: boolean, inviteStatus?: Array<GetInvitesInviteStatusEnum>, inviteType?: InviteType, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BusinessAccessInviteApiFp(this.configuration).getInvites(businessId, isMember, inviteStatus, inviteType, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Accept or decline invites or requests.
     * @summary Accept or decline an invite/request
     * @param {AuthRespondInvitesBody} authRespondInvitesBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessInviteApi
     */
    public respondBusinessAccessInvites(authRespondInvitesBody: AuthRespondInvitesBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessInviteApiFp(this.configuration).respondBusinessAccessInvites(authRespondInvitesBody, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetInvitesInviteStatusEnum = {
    Pending: 'PENDING',
    Expired: 'EXPIRED'
} as const;
export type GetInvitesInviteStatusEnum = typeof GetInvitesInviteStatusEnum[keyof typeof GetInvitesInviteStatusEnum];


/**
 * BusinessAccessRelationshipsApi - axios parameter creator
 * @export
 */
export const BusinessAccessRelationshipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Terminate memberships between the specified members and your business.
         * @summary Terminate business memberships
         * @param {string} businessId Business id
         * @param {MembersToDeleteBody} membersToDeleteBody List of members with role to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessMembership: async (businessId: string, membersToDeleteBody: MembersToDeleteBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('deleteBusinessMembership', 'businessId', businessId)
            // verify required parameter 'membersToDeleteBody' is not null or undefined
            assertParamExists('deleteBusinessMembership', 'membersToDeleteBody', membersToDeleteBody)
            const localVarPath = `/businesses/{business_id}/members`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read", "biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(membersToDeleteBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Terminate partnerships between the specified partners and your business. Note: You may only batch terminate partners of the same partner type.
         * @summary Terminate business partnerships
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeletePartnersRequest} deletePartnersRequest An object containing a \&quot;partner_ids\&quot; property composed of a list of partner IDs and a \&quot;partners_type\&quot; property specifying the type of partners to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPartners: async (businessId: string, deletePartnersRequest: DeletePartnersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('deleteBusinessPartners', 'businessId', businessId)
            // verify required parameter 'deletePartnersRequest' is not null or undefined
            assertParamExists('deleteBusinessPartners', 'deletePartnersRequest', deletePartnersRequest)
            const localVarPath = `/businesses/{business_id}/partners`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePartnersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all of the viewing user\'s business employers.
         * @summary List business employers for user
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessEmployers: async (pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/businesses/employers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all members of the specified business. The return response will include the member\'s business_role and assets they have access to if assets_summary=TRUE
         * @summary Get business members
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
         * @param {Array<MemberBusinessRole>} [businessRoles] A list of business roles to filter the members by. Only members whose roles are in the specified roles will be returned.
         * @param {string} [memberIds] A list of business members ids separated by comma.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMembers: async (businessId: string, assetsSummary?: boolean, businessRoles?: Array<MemberBusinessRole>, memberIds?: string, startIndex?: number, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessMembers', 'businessId', businessId)
            const localVarPath = `/businesses/{business_id}/members`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (assetsSummary !== undefined) {
                localVarQueryParameter['assets_summary'] = assetsSummary;
            }

            if (businessRoles) {
                localVarQueryParameter['business_roles'] = businessRoles;
            }

            if (memberIds !== undefined) {
                localVarQueryParameter['member_ids'] = memberIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all partners of the specified business.  If the assets_summary=TRUE and: - partner_type=INTERNAL, the business assets returned are your business assets the partner has access to. - partner_type=EXTERNAL, the business assets returned are your partner\'s business assets the partner has granted you   access to.
         * @summary Get business partners
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
         * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
         * @param {string} [partnerIds] A list of business partner ids separated by commas used to filter the results. Only partners with the specified ids will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPartners: async (businessId: string, assetsSummary?: boolean, partnerType?: PartnerType, partnerIds?: string, startIndex?: number, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('getBusinessPartners', 'businessId', businessId)
            const localVarPath = `/businesses/{business_id}/partners`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:read"], configuration)

            if (assetsSummary !== undefined) {
                localVarQueryParameter['assets_summary'] = assetsSummary;
            }

            if (partnerType !== undefined) {
                localVarQueryParameter['partner_type'] = partnerType;
            }

            if (partnerIds !== undefined) {
                localVarQueryParameter['partner_ids'] = partnerIds;
            }

            if (startIndex !== undefined) {
                localVarQueryParameter['start_index'] = startIndex;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a member\'s business role within the business.
         * @summary Update member\'s business role
         * @param {string} businessId Business id
         * @param {Array<UpdateMemberBusinessRoleBody>} updateMemberBusinessRoleBody List of objects with the member id and the business_role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessMemberships: async (businessId: string, updateMemberBusinessRoleBody: Array<UpdateMemberBusinessRoleBody>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'businessId' is not null or undefined
            assertParamExists('updateBusinessMemberships', 'businessId', businessId)
            // verify required parameter 'updateMemberBusinessRoleBody' is not null or undefined
            assertParamExists('updateBusinessMemberships', 'updateMemberBusinessRoleBody', updateMemberBusinessRoleBody)
            const localVarPath = `/businesses/{business_id}/members`
                .replace(`{${"business_id"}}`, encodeURIComponent(String(businessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["biz_access:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateMemberBusinessRoleBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BusinessAccessRelationshipsApi - functional programming interface
 * @export
 */
export const BusinessAccessRelationshipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BusinessAccessRelationshipsApiAxiosParamCreator(configuration)
    return {
        /**
         * Terminate memberships between the specified members and your business.
         * @summary Terminate business memberships
         * @param {string} businessId Business id
         * @param {MembersToDeleteBody} membersToDeleteBody List of members with role to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBusinessMembership(businessId: string, membersToDeleteBody: MembersToDeleteBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletedMembersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBusinessMembership(businessId, membersToDeleteBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessRelationshipsApi.deleteBusinessMembership']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Terminate partnerships between the specified partners and your business. Note: You may only batch terminate partners of the same partner type.
         * @summary Terminate business partnerships
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeletePartnersRequest} deletePartnersRequest An object containing a \&quot;partner_ids\&quot; property composed of a list of partner IDs and a \&quot;partners_type\&quot; property specifying the type of partners to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBusinessPartners(businessId: string, deletePartnersRequest: DeletePartnersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePartnersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBusinessPartners(businessId, deletePartnersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessRelationshipsApi.deleteBusinessPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all of the viewing user\'s business employers.
         * @summary List business employers for user
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessEmployers(pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessEmployers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessEmployers(pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessRelationshipsApi.getBusinessEmployers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all members of the specified business. The return response will include the member\'s business_role and assets they have access to if assets_summary=TRUE
         * @summary Get business members
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
         * @param {Array<MemberBusinessRole>} [businessRoles] A list of business roles to filter the members by. Only members whose roles are in the specified roles will be returned.
         * @param {string} [memberIds] A list of business members ids separated by comma.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessMembers(businessId: string, assetsSummary?: boolean, businessRoles?: Array<MemberBusinessRole>, memberIds?: string, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessMembers200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessMembers(businessId, assetsSummary, businessRoles, memberIds, startIndex, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessRelationshipsApi.getBusinessMembers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all partners of the specified business.  If the assets_summary=TRUE and: - partner_type=INTERNAL, the business assets returned are your business assets the partner has access to. - partner_type=EXTERNAL, the business assets returned are your partner\'s business assets the partner has granted you   access to.
         * @summary Get business partners
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
         * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
         * @param {string} [partnerIds] A list of business partner ids separated by commas used to filter the results. Only partners with the specified ids will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBusinessPartners(businessId: string, assetsSummary?: boolean, partnerType?: PartnerType, partnerIds?: string, startIndex?: number, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBusinessPartners200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBusinessPartners(businessId, assetsSummary, partnerType, partnerIds, startIndex, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessRelationshipsApi.getBusinessPartners']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a member\'s business role within the business.
         * @summary Update member\'s business role
         * @param {string} businessId Business id
         * @param {Array<UpdateMemberBusinessRoleBody>} updateMemberBusinessRoleBody List of objects with the member id and the business_role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBusinessMemberships(businessId: string, updateMemberBusinessRoleBody: Array<UpdateMemberBusinessRoleBody>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateMemberResultsResponseArray>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBusinessMemberships(businessId, updateMemberBusinessRoleBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['BusinessAccessRelationshipsApi.updateBusinessMemberships']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * BusinessAccessRelationshipsApi - factory interface
 * @export
 */
export const BusinessAccessRelationshipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BusinessAccessRelationshipsApiFp(configuration)
    return {
        /**
         * Terminate memberships between the specified members and your business.
         * @summary Terminate business memberships
         * @param {string} businessId Business id
         * @param {MembersToDeleteBody} membersToDeleteBody List of members with role to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessMembership(businessId: string, membersToDeleteBody: MembersToDeleteBody, options?: RawAxiosRequestConfig): AxiosPromise<DeletedMembersResponse> {
            return localVarFp.deleteBusinessMembership(businessId, membersToDeleteBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Terminate partnerships between the specified partners and your business. Note: You may only batch terminate partners of the same partner type.
         * @summary Terminate business partnerships
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {DeletePartnersRequest} deletePartnersRequest An object containing a \&quot;partner_ids\&quot; property composed of a list of partner IDs and a \&quot;partners_type\&quot; property specifying the type of partners to delete. 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBusinessPartners(businessId: string, deletePartnersRequest: DeletePartnersRequest, options?: RawAxiosRequestConfig): AxiosPromise<DeletePartnersResponse> {
            return localVarFp.deleteBusinessPartners(businessId, deletePartnersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all of the viewing user\'s business employers.
         * @summary List business employers for user
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessEmployers(pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBusinessEmployers200Response> {
            return localVarFp.getBusinessEmployers(pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all members of the specified business. The return response will include the member\'s business_role and assets they have access to if assets_summary=TRUE
         * @summary Get business members
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
         * @param {Array<MemberBusinessRole>} [businessRoles] A list of business roles to filter the members by. Only members whose roles are in the specified roles will be returned.
         * @param {string} [memberIds] A list of business members ids separated by comma.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessMembers(businessId: string, assetsSummary?: boolean, businessRoles?: Array<MemberBusinessRole>, memberIds?: string, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetBusinessMembers200Response> {
            return localVarFp.getBusinessMembers(businessId, assetsSummary, businessRoles, memberIds, startIndex, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all partners of the specified business.  If the assets_summary=TRUE and: - partner_type=INTERNAL, the business assets returned are your business assets the partner has access to. - partner_type=EXTERNAL, the business assets returned are your partner\'s business assets the partner has granted you   access to.
         * @summary Get business partners
         * @param {string} businessId Unique identifier of the requesting business.
         * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
         * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
         * @param {string} [partnerIds] A list of business partner ids separated by commas used to filter the results. Only partners with the specified ids will be returned.
         * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBusinessPartners(businessId: string, assetsSummary?: boolean, partnerType?: PartnerType, partnerIds?: string, startIndex?: number, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetBusinessPartners200Response> {
            return localVarFp.getBusinessPartners(businessId, assetsSummary, partnerType, partnerIds, startIndex, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a member\'s business role within the business.
         * @summary Update member\'s business role
         * @param {string} businessId Business id
         * @param {Array<UpdateMemberBusinessRoleBody>} updateMemberBusinessRoleBody List of objects with the member id and the business_role.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBusinessMemberships(businessId: string, updateMemberBusinessRoleBody: Array<UpdateMemberBusinessRoleBody>, options?: RawAxiosRequestConfig): AxiosPromise<UpdateMemberResultsResponseArray> {
            return localVarFp.updateBusinessMemberships(businessId, updateMemberBusinessRoleBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BusinessAccessRelationshipsApi - object-oriented interface
 * @export
 * @class BusinessAccessRelationshipsApi
 * @extends {BaseAPI}
 */
export class BusinessAccessRelationshipsApi extends BaseAPI {
    /**
     * Terminate memberships between the specified members and your business.
     * @summary Terminate business memberships
     * @param {string} businessId Business id
     * @param {MembersToDeleteBody} membersToDeleteBody List of members with role to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessRelationshipsApi
     */
    public deleteBusinessMembership(businessId: string, membersToDeleteBody: MembersToDeleteBody, options?: RawAxiosRequestConfig) {
        return BusinessAccessRelationshipsApiFp(this.configuration).deleteBusinessMembership(businessId, membersToDeleteBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Terminate partnerships between the specified partners and your business. Note: You may only batch terminate partners of the same partner type.
     * @summary Terminate business partnerships
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {DeletePartnersRequest} deletePartnersRequest An object containing a \&quot;partner_ids\&quot; property composed of a list of partner IDs and a \&quot;partners_type\&quot; property specifying the type of partners to delete. 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessRelationshipsApi
     */
    public deleteBusinessPartners(businessId: string, deletePartnersRequest: DeletePartnersRequest, options?: RawAxiosRequestConfig) {
        return BusinessAccessRelationshipsApiFp(this.configuration).deleteBusinessPartners(businessId, deletePartnersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all of the viewing user\'s business employers.
     * @summary List business employers for user
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessRelationshipsApi
     */
    public getBusinessEmployers(pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return BusinessAccessRelationshipsApiFp(this.configuration).getBusinessEmployers(pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all members of the specified business. The return response will include the member\'s business_role and assets they have access to if assets_summary=TRUE
     * @summary Get business members
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
     * @param {Array<MemberBusinessRole>} [businessRoles] A list of business roles to filter the members by. Only members whose roles are in the specified roles will be returned.
     * @param {string} [memberIds] A list of business members ids separated by comma.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessRelationshipsApi
     */
    public getBusinessMembers(businessId: string, assetsSummary?: boolean, businessRoles?: Array<MemberBusinessRole>, memberIds?: string, startIndex?: number, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return BusinessAccessRelationshipsApiFp(this.configuration).getBusinessMembers(businessId, assetsSummary, businessRoles, memberIds, startIndex, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all partners of the specified business.  If the assets_summary=TRUE and: - partner_type=INTERNAL, the business assets returned are your business assets the partner has access to. - partner_type=EXTERNAL, the business assets returned are your partner\'s business assets the partner has granted you   access to.
     * @summary Get business partners
     * @param {string} businessId Unique identifier of the requesting business.
     * @param {boolean} [assetsSummary] Include assets summary in the response if this is true.  The assets summary returns a dictionary representing a summary of the assets for the business user ID, with information like the ad accounts and profiles the user has permissions for and what those permissions are
     * @param {PartnerType} [partnerType] Specifies whether to fetch internal or external (shared) partners. If partner_type&#x3D;INTERNAL, the asset being queried is for accesses the partner has to your business assets.&lt;br&gt; If partner_type&#x3D;EXTERNAL, the asset being queried is for the accesses you have to the partner\&#39;s business asset.
     * @param {string} [partnerIds] A list of business partner ids separated by commas used to filter the results. Only partners with the specified ids will be returned.
     * @param {number} [startIndex] An index to start fetching the results from. Only the results starting from this index will be returned.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessRelationshipsApi
     */
    public getBusinessPartners(businessId: string, assetsSummary?: boolean, partnerType?: PartnerType, partnerIds?: string, startIndex?: number, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return BusinessAccessRelationshipsApiFp(this.configuration).getBusinessPartners(businessId, assetsSummary, partnerType, partnerIds, startIndex, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a member\'s business role within the business.
     * @summary Update member\'s business role
     * @param {string} businessId Business id
     * @param {Array<UpdateMemberBusinessRoleBody>} updateMemberBusinessRoleBody List of objects with the member id and the business_role.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BusinessAccessRelationshipsApi
     */
    public updateBusinessMemberships(businessId: string, updateMemberBusinessRoleBody: Array<UpdateMemberBusinessRoleBody>, options?: RawAxiosRequestConfig) {
        return BusinessAccessRelationshipsApiFp(this.configuration).updateBusinessMemberships(businessId, updateMemberBusinessRoleBody, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CampaignsApi - axios parameter creator
 * @export
 */
export const CampaignsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get targeting analytics for one or more campaigns. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsCampaignTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<CampaignTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {CampaignTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {CampaignTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignTargetingAnalyticsGet: async (adAccountId: string, campaignIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsCampaignTargetingType>, columns: Array<CampaignTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: CampaignTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: CampaignTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: CampaignTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'adAccountId', adAccountId)
            // verify required parameter 'campaignIds' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'campaignIds', campaignIds)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'endDate', endDate)
            // verify required parameter 'targetingTypes' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'targetingTypes', targetingTypes)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('campaignTargetingAnalyticsGet', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/campaigns/targeting_analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (campaignIds) {
                localVarQueryParameter['campaign_ids'] = campaignIds;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (targetingTypes) {
                localVarQueryParameter['targeting_types'] = targetingTypes.join(COLLECTION_FORMATS.csv);
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }

            if (attributionTypes !== undefined) {
                localVarQueryParameter['attribution_types'] = attributionTypes;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics for the specified campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get campaign analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
         * @param {Array<CampaignsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {CampaignsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {CampaignsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsAnalytics: async (adAccountId: string, startDate: string, endDate: string, campaignIds: Array<string>, columns: Array<CampaignsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignsAnalyticsClickWindowDaysEnum, engagementWindowDays?: CampaignsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: CampaignsAnalyticsViewWindowDaysEnum, conversionReportTime?: CampaignsAnalyticsConversionReportTimeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('campaignsAnalytics', 'adAccountId', adAccountId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('campaignsAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('campaignsAnalytics', 'endDate', endDate)
            // verify required parameter 'campaignIds' is not null or undefined
            assertParamExists('campaignsAnalytics', 'campaignIds', campaignIds)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('campaignsAnalytics', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('campaignsAnalytics', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/campaigns/analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (campaignIds) {
                localVarQueryParameter['campaign_ids'] = campaignIds;
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create multiple new campaigns. Every campaign has its own campaign_id and houses one or more ad groups, which contain one or more ads. For more, see <a href=\"https://help.pinterest.com/en/business/article/set-up-your-campaign/\">Set up your campaign</a>. <p/> <strong>Note:</strong> - The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
         * @summary Create campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<CampaignCreateRequest>} campaignCreateRequest Array of campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsCreate: async (adAccountId: string, campaignCreateRequest: Array<CampaignCreateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('campaignsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'campaignCreateRequest' is not null or undefined
            assertParamExists('campaignsCreate', 'campaignCreateRequest', campaignCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/campaigns`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific campaign given the campaign ID.
         * @summary Get campaign
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} campaignId Campaign ID, must be associated with the ad account ID provided in the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsGet: async (adAccountId: string, campaignId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('campaignsGet', 'adAccountId', adAccountId)
            // verify required parameter 'campaignId' is not null or undefined
            assertParamExists('campaignsGet', 'campaignId', campaignId)
            const localVarPath = `/ad_accounts/{ad_account_id}/campaigns/{campaign_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"campaign_id"}}`, encodeURIComponent(String(campaignId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
         * @summary List campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<CampaignsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {CampaignsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList: async (adAccountId: string, campaignIds?: Array<string>, entityStatuses?: Array<CampaignsListEntityStatusesEnum>, pageSize?: number, order?: CampaignsListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('campaignsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/campaigns`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (campaignIds) {
                localVarQueryParameter['campaign_ids'] = campaignIds;
            }

            if (entityStatuses) {
                localVarQueryParameter['entity_statuses'] = entityStatuses;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple ad campaigns based on campaign_ids. <p/> <strong>Note:</strong><p/>  - <p>The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
         * @summary Update campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<CampaignUpdateRequest>} campaignUpdateRequest Array of campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsUpdate: async (adAccountId: string, campaignUpdateRequest: Array<CampaignUpdateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('campaignsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'campaignUpdateRequest' is not null or undefined
            assertParamExists('campaignsUpdate', 'campaignUpdateRequest', campaignUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/campaigns`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(campaignUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CampaignsApi - functional programming interface
 * @export
 */
export const CampaignsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CampaignsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get targeting analytics for one or more campaigns. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsCampaignTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<CampaignTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {CampaignTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {CampaignTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignTargetingAnalyticsGet(adAccountId: string, campaignIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsCampaignTargetingType>, columns: Array<CampaignTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: CampaignTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: CampaignTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: CampaignTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignTargetingAnalyticsGet(adAccountId, campaignIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignTargetingAnalyticsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics for the specified campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get campaign analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
         * @param {Array<CampaignsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {CampaignsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {CampaignsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsAnalytics(adAccountId: string, startDate: string, endDate: string, campaignIds: Array<string>, columns: Array<CampaignsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignsAnalyticsClickWindowDaysEnum, engagementWindowDays?: CampaignsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: CampaignsAnalyticsViewWindowDaysEnum, conversionReportTime?: CampaignsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignsAnalyticsResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsAnalytics(adAccountId, startDate, endDate, campaignIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create multiple new campaigns. Every campaign has its own campaign_id and houses one or more ad groups, which contain one or more ads. For more, see <a href=\"https://help.pinterest.com/en/business/article/set-up-your-campaign/\">Set up your campaign</a>. <p/> <strong>Note:</strong> - The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
         * @summary Create campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<CampaignCreateRequest>} campaignCreateRequest Array of campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsCreate(adAccountId: string, campaignCreateRequest: Array<CampaignCreateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsCreate(adAccountId, campaignCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific campaign given the campaign ID.
         * @summary Get campaign
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} campaignId Campaign ID, must be associated with the ad account ID provided in the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsGet(adAccountId: string, campaignId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsGet(adAccountId, campaignId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
         * @summary List campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<CampaignsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {CampaignsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsList(adAccountId: string, campaignIds?: Array<string>, entityStatuses?: Array<CampaignsListEntityStatusesEnum>, pageSize?: number, order?: CampaignsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsList(adAccountId, campaignIds, entityStatuses, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple ad campaigns based on campaign_ids. <p/> <strong>Note:</strong><p/>  - <p>The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
         * @summary Update campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<CampaignUpdateRequest>} campaignUpdateRequest Array of campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async campaignsUpdate(adAccountId: string, campaignUpdateRequest: Array<CampaignUpdateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CampaignUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.campaignsUpdate(adAccountId, campaignUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CampaignsApi.campaignsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CampaignsApi - factory interface
 * @export
 */
export const CampaignsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CampaignsApiFp(configuration)
    return {
        /**
         * Get targeting analytics for one or more campaigns. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get targeting analytics for campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<AdsAnalyticsCampaignTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
         * @param {Array<CampaignTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {CampaignTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {CampaignTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignTargetingAnalyticsGet(adAccountId: string, campaignIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsCampaignTargetingType>, columns: Array<CampaignTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: CampaignTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: CampaignTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: CampaignTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig): AxiosPromise<MetricsResponse> {
            return localVarFp.campaignTargetingAnalyticsGet(adAccountId, campaignIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics for the specified campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get campaign analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
         * @param {Array<CampaignsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {CampaignsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {CampaignsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {CampaignsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsAnalytics(adAccountId: string, startDate: string, endDate: string, campaignIds: Array<string>, columns: Array<CampaignsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignsAnalyticsClickWindowDaysEnum, engagementWindowDays?: CampaignsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: CampaignsAnalyticsViewWindowDaysEnum, conversionReportTime?: CampaignsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignsAnalyticsResponseInner>> {
            return localVarFp.campaignsAnalytics(adAccountId, startDate, endDate, campaignIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(axios, basePath));
        },
        /**
         * Create multiple new campaigns. Every campaign has its own campaign_id and houses one or more ad groups, which contain one or more ads. For more, see <a href=\"https://help.pinterest.com/en/business/article/set-up-your-campaign/\">Set up your campaign</a>. <p/> <strong>Note:</strong> - The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
         * @summary Create campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<CampaignCreateRequest>} campaignCreateRequest Array of campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsCreate(adAccountId: string, campaignCreateRequest: Array<CampaignCreateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<CampaignCreateResponse> {
            return localVarFp.campaignsCreate(adAccountId, campaignCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific campaign given the campaign ID.
         * @summary Get campaign
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} campaignId Campaign ID, must be associated with the ad account ID provided in the path.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsGet(adAccountId: string, campaignId: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignResponse> {
            return localVarFp.campaignsGet(adAccountId, campaignId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
         * @summary List campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
         * @param {Array<CampaignsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {CampaignsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsList(adAccountId: string, campaignIds?: Array<string>, entityStatuses?: Array<CampaignsListEntityStatusesEnum>, pageSize?: number, order?: CampaignsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<CampaignsList200Response> {
            return localVarFp.campaignsList(adAccountId, campaignIds, entityStatuses, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple ad campaigns based on campaign_ids. <p/> <strong>Note:</strong><p/>  - <p>The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
         * @summary Update campaigns
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<CampaignUpdateRequest>} campaignUpdateRequest Array of campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        campaignsUpdate(adAccountId: string, campaignUpdateRequest: Array<CampaignUpdateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<CampaignUpdateResponse> {
            return localVarFp.campaignsUpdate(adAccountId, campaignUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CampaignsApi - object-oriented interface
 * @export
 * @class CampaignsApi
 * @extends {BaseAPI}
 */
export class CampaignsApi extends BaseAPI {
    /**
     * Get targeting analytics for one or more campaigns. For the requested account and metrics, the response will include the requested metric information (e.g. SPEND_IN_DOLLAR) for the requested target type (e.g. \"age_bucket\") for applicable values (e.g. \"45-49\"). <p/> - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get targeting analytics for campaigns
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<AdsAnalyticsCampaignTargetingType>} targetingTypes Targeting type breakdowns for the report. The reporting per targeting type &lt;br&gt; is independent from each other. [\&quot;AGE_BUCKET_AND_GENDER\&quot;] is in BETA and not yet available to all users.
     * @param {Array<CampaignTargetingAnalyticsGetColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {CampaignTargetingAnalyticsGetClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {CampaignTargetingAnalyticsGetEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {CampaignTargetingAnalyticsGetViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {CampaignTargetingAnalyticsGetConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {ConversionReportAttributionType} [attributionTypes] List of types of attribution for the conversion report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignTargetingAnalyticsGet(adAccountId: string, campaignIds: Array<string>, startDate: string, endDate: string, targetingTypes: Array<AdsAnalyticsCampaignTargetingType>, columns: Array<CampaignTargetingAnalyticsGetColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignTargetingAnalyticsGetClickWindowDaysEnum, engagementWindowDays?: CampaignTargetingAnalyticsGetEngagementWindowDaysEnum, viewWindowDays?: CampaignTargetingAnalyticsGetViewWindowDaysEnum, conversionReportTime?: CampaignTargetingAnalyticsGetConversionReportTimeEnum, attributionTypes?: ConversionReportAttributionType, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignTargetingAnalyticsGet(adAccountId, campaignIds, startDate, endDate, targetingTypes, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, attributionTypes, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics for the specified campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get campaign analytics
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<string>} campaignIds List of Campaign Ids to use to filter the results.
     * @param {Array<CampaignsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {CampaignsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {CampaignsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {CampaignsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {CampaignsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsAnalytics(adAccountId: string, startDate: string, endDate: string, campaignIds: Array<string>, columns: Array<CampaignsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: CampaignsAnalyticsClickWindowDaysEnum, engagementWindowDays?: CampaignsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: CampaignsAnalyticsViewWindowDaysEnum, conversionReportTime?: CampaignsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsAnalytics(adAccountId, startDate, endDate, campaignIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create multiple new campaigns. Every campaign has its own campaign_id and houses one or more ad groups, which contain one or more ads. For more, see <a href=\"https://help.pinterest.com/en/business/article/set-up-your-campaign/\">Set up your campaign</a>. <p/> <strong>Note:</strong> - The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertisers profile.</p>  <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
     * @summary Create campaigns
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<CampaignCreateRequest>} campaignCreateRequest Array of campaigns.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsCreate(adAccountId: string, campaignCreateRequest: Array<CampaignCreateRequest>, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsCreate(adAccountId, campaignCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific campaign given the campaign ID.
     * @summary Get campaign
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} campaignId Campaign ID, must be associated with the ad account ID provided in the path.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsGet(adAccountId: string, campaignId: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsGet(adAccountId, campaignId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the campaigns in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager.
     * @summary List campaigns
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} [campaignIds] List of Campaign Ids to use to filter the results.
     * @param {Array<CampaignsListEntityStatusesEnum>} [entityStatuses] Entity status
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {CampaignsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsList(adAccountId: string, campaignIds?: Array<string>, entityStatuses?: Array<CampaignsListEntityStatusesEnum>, pageSize?: number, order?: CampaignsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsList(adAccountId, campaignIds, entityStatuses, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple ad campaigns based on campaign_ids. <p/> <strong>Note:</strong><p/>  - <p>The values for \'lifetime_spend_cap\' and \'daily_spend_cap\' are microcurrency amounts based on the currency field set in the advertiser\'s profile. (e.g. USD) <p/> <p>Microcurrency is used to track very small transactions, based on the currency set in the advertisers profile.</p> <p>A microcurrency unit is 10^(-6) of the standard unit of currency selected in the advertiser s profile.</p> <p><strong>Equivalency equations</strong>, using dollars as an example currency:</p> <ul>   <li>$1 = 1,000,000 microdollars</li>   <li>1 microdollar = $0.000001 </li> </ul> <p><strong>To convert between currency and microcurrency</strong>, using dollars as an example currency:</p> <ul>   <li>To convert dollars to microdollars, mutiply dollars by 1,000,000</li>   <li>To convert microdollars to dollars, divide microdollars by 1,000,000</li> </ul>
     * @summary Update campaigns
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<CampaignUpdateRequest>} campaignUpdateRequest Array of campaigns.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CampaignsApi
     */
    public campaignsUpdate(adAccountId: string, campaignUpdateRequest: Array<CampaignUpdateRequest>, options?: RawAxiosRequestConfig) {
        return CampaignsApiFp(this.configuration).campaignsUpdate(adAccountId, campaignUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CampaignTargetingAnalyticsGetColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type CampaignTargetingAnalyticsGetColumnsEnum = typeof CampaignTargetingAnalyticsGetColumnsEnum[keyof typeof CampaignTargetingAnalyticsGetColumnsEnum];
/**
 * @export
 */
export const CampaignTargetingAnalyticsGetClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type CampaignTargetingAnalyticsGetClickWindowDaysEnum = typeof CampaignTargetingAnalyticsGetClickWindowDaysEnum[keyof typeof CampaignTargetingAnalyticsGetClickWindowDaysEnum];
/**
 * @export
 */
export const CampaignTargetingAnalyticsGetEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type CampaignTargetingAnalyticsGetEngagementWindowDaysEnum = typeof CampaignTargetingAnalyticsGetEngagementWindowDaysEnum[keyof typeof CampaignTargetingAnalyticsGetEngagementWindowDaysEnum];
/**
 * @export
 */
export const CampaignTargetingAnalyticsGetViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type CampaignTargetingAnalyticsGetViewWindowDaysEnum = typeof CampaignTargetingAnalyticsGetViewWindowDaysEnum[keyof typeof CampaignTargetingAnalyticsGetViewWindowDaysEnum];
/**
 * @export
 */
export const CampaignTargetingAnalyticsGetConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type CampaignTargetingAnalyticsGetConversionReportTimeEnum = typeof CampaignTargetingAnalyticsGetConversionReportTimeEnum[keyof typeof CampaignTargetingAnalyticsGetConversionReportTimeEnum];
/**
 * @export
 */
export const CampaignsAnalyticsColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type CampaignsAnalyticsColumnsEnum = typeof CampaignsAnalyticsColumnsEnum[keyof typeof CampaignsAnalyticsColumnsEnum];
/**
 * @export
 */
export const CampaignsAnalyticsClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type CampaignsAnalyticsClickWindowDaysEnum = typeof CampaignsAnalyticsClickWindowDaysEnum[keyof typeof CampaignsAnalyticsClickWindowDaysEnum];
/**
 * @export
 */
export const CampaignsAnalyticsEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type CampaignsAnalyticsEngagementWindowDaysEnum = typeof CampaignsAnalyticsEngagementWindowDaysEnum[keyof typeof CampaignsAnalyticsEngagementWindowDaysEnum];
/**
 * @export
 */
export const CampaignsAnalyticsViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type CampaignsAnalyticsViewWindowDaysEnum = typeof CampaignsAnalyticsViewWindowDaysEnum[keyof typeof CampaignsAnalyticsViewWindowDaysEnum];
/**
 * @export
 */
export const CampaignsAnalyticsConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type CampaignsAnalyticsConversionReportTimeEnum = typeof CampaignsAnalyticsConversionReportTimeEnum[keyof typeof CampaignsAnalyticsConversionReportTimeEnum];
/**
 * @export
 */
export const CampaignsListEntityStatusesEnum = {
    Active: 'ACTIVE',
    Paused: 'PAUSED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;
export type CampaignsListEntityStatusesEnum = typeof CampaignsListEntityStatusesEnum[keyof typeof CampaignsListEntityStatusesEnum];
/**
 * @export
 */
export const CampaignsListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type CampaignsListOrderEnum = typeof CampaignsListOrderEnum[keyof typeof CampaignsListOrderEnum];


/**
 * CatalogsApi - axios parameter creator
 * @export
 */
export const CatalogsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: this API only supports the catalog type of HOTEL for now.
         * @summary Create catalog
         * @param {CatalogsCreateRequest} catalogsCreateRequest Request object used to created a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsCreate: async (catalogsCreateRequest: CatalogsCreateRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogsCreateRequest' is not null or undefined
            assertParamExists('catalogsCreate', 'catalogsCreateRequest', catalogsCreateRequest)
            const localVarPath = `/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalogsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List catalogs
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsList: async (bookmark?: string, pageSize?: number, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalogs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of product pins for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List products by product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupPinsList: async (productGroupId: string, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroupId' is not null or undefined
            assertParamExists('catalogsProductGroupPinsList', 'productGroupId', productGroupId)
            const localVarPath = `/catalogs/product_groups/{product_group_id}/products`
                .replace(`{${"product_group_id"}}`, encodeURIComponent(String(productGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "catalogs:read", "pins:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (pinMetrics !== undefined) {
                localVarQueryParameter['pin_metrics'] = pinMetrics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create product group
         * @param {MultipleProductGroupsInner} multipleProductGroupsInner Request object used to create a single catalogs product groups.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsCreate: async (multipleProductGroupsInner: MultipleProductGroupsInner, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'multipleProductGroupsInner' is not null or undefined
            assertParamExists('catalogsProductGroupsCreate', 'multipleProductGroupsInner', multipleProductGroupsInner)
            const localVarPath = `/catalogs/product_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multipleProductGroupsInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create product groups
         * @param {Array<MultipleProductGroupsInner>} multipleProductGroupsInner Request object used to create one or more catalogs product groups.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsCreateMany: async (multipleProductGroupsInner: Array<MultipleProductGroupsInner>, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'multipleProductGroupsInner' is not null or undefined
            assertParamExists('catalogsProductGroupsCreateMany', 'multipleProductGroupsInner', multipleProductGroupsInner)
            const localVarPath = `/catalogs/product_groups/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(multipleProductGroupsInner, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a product group owned by the \"operation user_account\" from being in use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Delete product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsDelete: async (productGroupId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroupId' is not null or undefined
            assertParamExists('catalogsProductGroupsDelete', 'productGroupId', productGroupId)
            const localVarPath = `/catalogs/product_groups/{product_group_id}`
                .replace(`{${"product_group_id"}}`, encodeURIComponent(String(productGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete product groups owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Delete product groups
         * @param {Array<number>} id Comma-separated list of product group ids
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsDeleteMany: async (id: Array<number>, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('catalogsProductGroupsDeleteMany', 'id', id)
            const localVarPath = `/catalogs/product_groups/multiple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a singe product group for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Get product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsGet: async (productGroupId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroupId' is not null or undefined
            assertParamExists('catalogsProductGroupsGet', 'productGroupId', productGroupId)
            const localVarPath = `/catalogs/product_groups/{product_group_id}`
                .replace(`{${"product_group_id"}}`, encodeURIComponent(String(productGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of product groups for a given Catalogs Feed Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List product groups
         * @param {Array<number>} [id] Comma-separated list of product group ids
         * @param {string} [feedId] Filter entities for a given feed_id. If not given, all feeds are considered.
         * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsList: async (id?: Array<number>, feedId?: string, catalogId?: string, bookmark?: string, pageSize?: number, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalogs/product_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }

            if (feedId !== undefined) {
                localVarQueryParameter['feed_id'] = feedId;
            }

            if (catalogId !== undefined) {
                localVarQueryParameter['catalog_id'] = catalogId;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a product counts for a given Catalogs Product Group owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Get product counts
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsProductCountsGet: async (productGroupId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroupId' is not null or undefined
            assertParamExists('catalogsProductGroupsProductCountsGet', 'productGroupId', productGroupId)
            const localVarPath = `/catalogs/product_groups/{product_group_id}/product_counts`
                .replace(`{${"product_group_id"}}`, encodeURIComponent(String(productGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update product group owned by the \"operation user_account\" to use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Update single product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {CatalogsProductGroupsUpdateRequest} catalogsProductGroupsUpdateRequest Request object used to Update a catalogs product group.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsUpdate: async (productGroupId: string, catalogsProductGroupsUpdateRequest: CatalogsProductGroupsUpdateRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productGroupId' is not null or undefined
            assertParamExists('catalogsProductGroupsUpdate', 'productGroupId', productGroupId)
            // verify required parameter 'catalogsProductGroupsUpdateRequest' is not null or undefined
            assertParamExists('catalogsProductGroupsUpdate', 'catalogsProductGroupsUpdateRequest', catalogsProductGroupsUpdateRequest)
            const localVarPath = `/catalogs/product_groups/{product_group_id}`
                .replace(`{${"product_group_id"}}`, encodeURIComponent(String(productGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalogsProductGroupsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a feed processing results owned by the \"operation user_account\". Please note that for now the bookmark parameter is not functional and only the first page will be available until it is implemented in some release in the near future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List feed processing results
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedProcessingResultsList: async (feedId: string, bookmark?: string, pageSize?: number, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('feedProcessingResultsList', 'feedId', feedId)
            const localVarPath = `/catalogs/feeds/{feed_id}/processing_results`
                .replace(`{${"feed_id"}}`, encodeURIComponent(String(feedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create feed
         * @param {FeedsCreateRequest} feedsCreateRequest Request object used to created a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsCreate: async (feedsCreateRequest: FeedsCreateRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedsCreateRequest' is not null or undefined
            assertParamExists('feedsCreate', 'feedsCreateRequest', feedsCreateRequest)
            const localVarPath = `/catalogs/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read", "catalogs:write"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read", "catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a feed owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary Delete feed
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsDelete: async (feedId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('feedsDelete', 'feedId', feedId)
            const localVarPath = `/catalogs/feeds/{feed_id}`
                .replace(`{${"feed_id"}}`, encodeURIComponent(String(feedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read", "catalogs:write"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read", "catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary Get feed
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsGet: async (feedId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('feedsGet', 'feedId', feedId)
            const localVarPath = `/catalogs/feeds/{feed_id}`
                .replace(`{${"feed_id"}}`, encodeURIComponent(String(feedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Ingest items for a given feed owned by the \"operation user_account\".  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: This endpoint is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Ingest feed items
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsIngest: async (feedId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('feedsIngest', 'feedId', feedId)
            const localVarPath = `/catalogs/feeds/{feed_id}/ingest`
                .replace(`{${"feed_id"}}`, encodeURIComponent(String(feedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch feeds owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary List feeds
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsList: async (bookmark?: string, pageSize?: number, catalogId?: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/catalogs/feeds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (catalogId !== undefined) {
                localVarQueryParameter['catalog_id'] = catalogId;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Update feed
         * @param {string} feedId Unique identifier of a feed
         * @param {FeedsUpdateRequest} feedsUpdateRequest Request object used to update a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsUpdate: async (feedId: string, feedsUpdateRequest: FeedsUpdateRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'feedId' is not null or undefined
            assertParamExists('feedsUpdate', 'feedId', feedId)
            // verify required parameter 'feedsUpdateRequest' is not null or undefined
            assertParamExists('feedsUpdate', 'feedsUpdateRequest', feedsUpdateRequest)
            const localVarPath = `/catalogs/feeds/{feed_id}`
                .replace(`{${"feed_id"}}`, encodeURIComponent(String(feedId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read", "catalogs:write"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read", "catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(feedsUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a single catalogs items batch owned by the \"operating user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Get item batch status
         * @param {string} batchId Id of a catalogs items batch to fetch
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsBatchGet: async (batchId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'batchId' is not null or undefined
            assertParamExists('itemsBatchGet', 'batchId', batchId)
            const localVarPath = `/catalogs/items/batch/{batch_id}`
                .replace(`{${"batch_id"}}`, encodeURIComponent(String(batchId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint supports multiple operations on a set of one or more catalog items owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: - Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager. - The item UPSERT operation is restricted to users without a feed data source. If you plan to migrate item ingestion from feeds to the API, please reach out to your partner manager to get assistance.
         * @summary Operate on item batch
         * @param {ItemsBatchPostRequest} itemsBatchPostRequest Request object used to create catalogs items in a batch
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsBatchPost: async (itemsBatchPostRequest: ItemsBatchPostRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemsBatchPostRequest' is not null or undefined
            assertParamExists('itemsBatchPost', 'itemsBatchPostRequest', itemsBatchPostRequest)
            const localVarPath = `/catalogs/items/batch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read", "catalogs:write"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["catalogs:read", "catalogs:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(itemsBatchPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: this endpoint is deprecated and will be deleted soon. Please use <a href=\'/docs/api/v5/#operation/items/post\'>Get catalogs items (POST)</a> instead.
         * @summary Get catalogs items
         * @param {string} country Country for the Catalogs Items
         * @param {string} language Language for the Catalogs Items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {Array<string>} [itemIds] This parameter is deprecated. Use filters instead.
         * @param {CatalogsItemsFilters} [filters] Identifies items to be retrieved. This is a required parameter.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        itemsGet: async (country: string, language: string, adAccountId?: string, itemIds?: Array<string>, filters?: CatalogsItemsFilters, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'country' is not null or undefined
            assertParamExists('itemsGet', 'country', country)
            // verify required parameter 'language' is not null or undefined
            assertParamExists('itemsGet', 'language', language)
            const localVarPath = `/catalogs/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (country !== undefined) {
                localVarQueryParameter['country'] = country;
            }

            if (language !== undefined) {
                localVarQueryParameter['language'] = language;
            }

            if (itemIds) {
                localVarQueryParameter['item_ids'] = itemIds;
            }

            if (filters !== undefined) {
                localVarQueryParameter['filters'] = filters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List item validation issues for a given feed processing result owned by the \"operation user_account\". Up to 20 random samples of affected items are returned for each error and warning code. Please note that for now query parameters \'item_numbers\' and \'item_validation_issue\' cannot be used simultaneously until it is implemented in some release in the future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: To get a list of all affected items instead of sampled issues, please refer to <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a> and <a href=\'/docs/api/v5/#operation/reports/get\'>Get catalogs report</a> endpoints. Moreover, they support multiple types of catalogs.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List item issues
         * @param {string} processingResultId Unique identifier of a feed processing result. It can be acquired from the \&quot;id\&quot; field of the \&quot;items\&quot; array within the response of the [List processing results for a given feed](/docs/api/v5/#operation/feed_processing_results/list).
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {Array<number>} [itemNumbers] Item number based on order of appearance in the Catalogs Feed. For example, \&#39;0\&#39; refers to first item found in a feed that was downloaded from a \&#39;location\&#39; specified during feed creation.
         * @param {CatalogsItemValidationIssue} [itemValidationIssue] Filter item validation issues that have a given type of item validation issue.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsIssuesList: async (processingResultId: string, bookmark?: string, pageSize?: number, itemNumbers?: Array<number>, itemValidationIssue?: CatalogsItemValidationIssue, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'processingResultId' is not null or undefined
            assertParamExists('itemsIssuesList', 'processingResultId', processingResultId)
            const localVarPath = `/catalogs/processing_results/{processing_result_id}/item_issues`
                .replace(`{${"processing_result_id"}}`, encodeURIComponent(String(processingResultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (itemNumbers) {
                localVarQueryParameter['item_numbers'] = itemNumbers;
            }

            if (itemValidationIssue !== undefined) {
                localVarQueryParameter['item_validation_issue'] = itemValidationIssue;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Get catalogs items (POST)
         * @param {CatalogsItemsRequest} catalogsItemsRequest Request object used to get catalogs items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsPost: async (catalogsItemsRequest: CatalogsItemsRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogsItemsRequest' is not null or undefined
            assertParamExists('itemsPost', 'catalogsItemsRequest', catalogsItemsRequest)
            const localVarPath = `/catalogs/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalogsItemsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List products Pins owned by the \"operation user_account\" that meet the criteria specified in the Catalogs Product Group Filter given in the request. - This endpoint has been implemented in POST to allow for complex filters. This specific POST endpoint is designed to be idempotent. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: This endpoint only supports RETAIL catalog at the moment.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List products by filter
         * @param {CatalogsListProductsByFilterRequest} catalogsListProductsByFilterRequest Object holding a group of filters for a catalog product group
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsByProductGroupFilterList: async (catalogsListProductsByFilterRequest: CatalogsListProductsByFilterRequest, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogsListProductsByFilterRequest' is not null or undefined
            assertParamExists('productsByProductGroupFilterList', 'catalogsListProductsByFilterRequest', catalogsListProductsByFilterRequest)
            const localVarPath = `/catalogs/products/get_by_product_group_filters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "catalogs:read", "pins:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (pinMetrics !== undefined) {
                localVarQueryParameter['pin_metrics'] = pinMetrics;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalogsListProductsByFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Async request to create a report of the catalog owned by the \"operation user_account\". This endpoint generates a report upon receiving the first approved request of the day. Any following requests with identical parameters will yield the same report even if data has changed. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Build catalogs report
         * @param {CatalogsReportParameters} catalogsReportParameters Request object to asynchronously create a report.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsCreate: async (catalogsReportParameters: CatalogsReportParameters, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'catalogsReportParameters' is not null or undefined
            assertParamExists('reportsCreate', 'catalogsReportParameters', catalogsReportParameters)
            const localVarPath = `/catalogs/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(catalogsReportParameters, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This returns a URL to a report given a token returned from <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a>. You can use the URL to download the report. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Get catalogs report
         * @param {string} token Token returned from async build report call
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGet: async (token: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('reportsGet', 'token', token)
            const localVarPath = `/catalogs/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List aggregated numbers of issues for a catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary List report stats
         * @param {CatalogsReportParameters} parameters Contains the parameters for report identification.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsStats: async (parameters: CatalogsReportParameters, adAccountId?: string, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('reportsStats', 'parameters', parameters)
            const localVarPath = `/catalogs/reports/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["catalogs:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (parameters !== undefined) {
                localVarQueryParameter['parameters'] = parameters;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CatalogsApi - functional programming interface
 * @export
 */
export const CatalogsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CatalogsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: this API only supports the catalog type of HOTEL for now.
         * @summary Create catalog
         * @param {CatalogsCreateRequest} catalogsCreateRequest Request object used to created a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsCreate(catalogsCreateRequest: CatalogsCreateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Catalog>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsCreate(catalogsCreateRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List catalogs
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsList(bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsList(bookmark, pageSize, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of product pins for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List products by product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupPinsList(productGroupId: string, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsProductGroupPinsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupPinsList(productGroupId, bookmark, pageSize, adAccountId, pinMetrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupPinsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create product group
         * @param {MultipleProductGroupsInner} multipleProductGroupsInner Request object used to create a single catalogs product groups.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsCreate(multipleProductGroupsInner: MultipleProductGroupsInner, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsVerticalProductGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsCreate(multipleProductGroupsInner, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create product groups
         * @param {Array<MultipleProductGroupsInner>} multipleProductGroupsInner Request object used to create one or more catalogs product groups.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsCreateMany(multipleProductGroupsInner: Array<MultipleProductGroupsInner>, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsCreateMany(multipleProductGroupsInner, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsCreateMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a product group owned by the \"operation user_account\" from being in use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Delete product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsDelete(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsDelete(productGroupId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete product groups owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Delete product groups
         * @param {Array<number>} id Comma-separated list of product group ids
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsDeleteMany(id: Array<number>, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsDeleteMany(id, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsDeleteMany']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a singe product group for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Get product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsGet(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsVerticalProductGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsGet(productGroupId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of product groups for a given Catalogs Feed Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List product groups
         * @param {Array<number>} [id] Comma-separated list of product group ids
         * @param {string} [feedId] Filter entities for a given feed_id. If not given, all feeds are considered.
         * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsList(id?: Array<number>, feedId?: string, catalogId?: string, bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsProductGroupsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsList(id, feedId, catalogId, bookmark, pageSize, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a product counts for a given Catalogs Product Group owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Get product counts
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsProductCountsGet(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsProductGroupProductCountsVertical>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsProductCountsGet(productGroupId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsProductCountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update product group owned by the \"operation user_account\" to use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Update single product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {CatalogsProductGroupsUpdateRequest} catalogsProductGroupsUpdateRequest Request object used to Update a catalogs product group.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async catalogsProductGroupsUpdate(productGroupId: string, catalogsProductGroupsUpdateRequest: CatalogsProductGroupsUpdateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsVerticalProductGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.catalogsProductGroupsUpdate(productGroupId, catalogsProductGroupsUpdateRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.catalogsProductGroupsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch a feed processing results owned by the \"operation user_account\". Please note that for now the bookmark parameter is not functional and only the first page will be available until it is implemented in some release in the near future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List feed processing results
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedProcessingResultsList(feedId: string, bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedProcessingResultsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedProcessingResultsList(feedId, bookmark, pageSize, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedProcessingResultsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create feed
         * @param {FeedsCreateRequest} feedsCreateRequest Request object used to created a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedsCreate(feedsCreateRequest: FeedsCreateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedsCreate(feedsCreateRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a feed owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary Delete feed
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedsDelete(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedsDelete(feedId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary Get feed
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedsGet(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedsGet(feedId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Ingest items for a given feed owned by the \"operation user_account\".  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: This endpoint is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Ingest feed items
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedsIngest(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsFeedIngestion>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedsIngest(feedId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedsIngest']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetch feeds owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary List feeds
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedsList(bookmark?: string, pageSize?: number, catalogId?: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FeedsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedsList(bookmark, pageSize, catalogId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Update feed
         * @param {string} feedId Unique identifier of a feed
         * @param {FeedsUpdateRequest} feedsUpdateRequest Request object used to update a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedsUpdate(feedId: string, feedsUpdateRequest: FeedsUpdateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsFeed>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedsUpdate(feedId, feedsUpdateRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.feedsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a single catalogs items batch owned by the \"operating user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Get item batch status
         * @param {string} batchId Id of a catalogs items batch to fetch
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsBatchGet(batchId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsItemsBatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsBatchGet(batchId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.itemsBatchGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint supports multiple operations on a set of one or more catalog items owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: - Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager. - The item UPSERT operation is restricted to users without a feed data source. If you plan to migrate item ingestion from feeds to the API, please reach out to your partner manager to get assistance.
         * @summary Operate on item batch
         * @param {ItemsBatchPostRequest} itemsBatchPostRequest Request object used to create catalogs items in a batch
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsBatchPost(itemsBatchPostRequest: ItemsBatchPostRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsItemsBatch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsBatchPost(itemsBatchPostRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.itemsBatchPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: this endpoint is deprecated and will be deleted soon. Please use <a href=\'/docs/api/v5/#operation/items/post\'>Get catalogs items (POST)</a> instead.
         * @summary Get catalogs items
         * @param {string} country Country for the Catalogs Items
         * @param {string} language Language for the Catalogs Items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {Array<string>} [itemIds] This parameter is deprecated. Use filters instead.
         * @param {CatalogsItemsFilters} [filters] Identifies items to be retrieved. This is a required parameter.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async itemsGet(country: string, language: string, adAccountId?: string, itemIds?: Array<string>, filters?: CatalogsItemsFilters, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsGet(country, language, adAccountId, itemIds, filters, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.itemsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List item validation issues for a given feed processing result owned by the \"operation user_account\". Up to 20 random samples of affected items are returned for each error and warning code. Please note that for now query parameters \'item_numbers\' and \'item_validation_issue\' cannot be used simultaneously until it is implemented in some release in the future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: To get a list of all affected items instead of sampled issues, please refer to <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a> and <a href=\'/docs/api/v5/#operation/reports/get\'>Get catalogs report</a> endpoints. Moreover, they support multiple types of catalogs.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List item issues
         * @param {string} processingResultId Unique identifier of a feed processing result. It can be acquired from the \&quot;id\&quot; field of the \&quot;items\&quot; array within the response of the [List processing results for a given feed](/docs/api/v5/#operation/feed_processing_results/list).
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {Array<number>} [itemNumbers] Item number based on order of appearance in the Catalogs Feed. For example, \&#39;0\&#39; refers to first item found in a feed that was downloaded from a \&#39;location\&#39; specified during feed creation.
         * @param {CatalogsItemValidationIssue} [itemValidationIssue] Filter item validation issues that have a given type of item validation issue.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsIssuesList(processingResultId: string, bookmark?: string, pageSize?: number, itemNumbers?: Array<number>, itemValidationIssue?: CatalogsItemValidationIssue, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ItemsIssuesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsIssuesList(processingResultId, bookmark, pageSize, itemNumbers, itemValidationIssue, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.itemsIssuesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Get catalogs items (POST)
         * @param {CatalogsItemsRequest} catalogsItemsRequest Request object used to get catalogs items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async itemsPost(catalogsItemsRequest: CatalogsItemsRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsItems>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.itemsPost(catalogsItemsRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.itemsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List products Pins owned by the \"operation user_account\" that meet the criteria specified in the Catalogs Product Group Filter given in the request. - This endpoint has been implemented in POST to allow for complex filters. This specific POST endpoint is designed to be idempotent. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: This endpoint only supports RETAIL catalog at the moment.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List products by filter
         * @param {CatalogsListProductsByFilterRequest} catalogsListProductsByFilterRequest Object holding a group of filters for a catalog product group
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productsByProductGroupFilterList(catalogsListProductsByFilterRequest: CatalogsListProductsByFilterRequest, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsProductGroupPinsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productsByProductGroupFilterList(catalogsListProductsByFilterRequest, bookmark, pageSize, adAccountId, pinMetrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.productsByProductGroupFilterList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Async request to create a report of the catalog owned by the \"operation user_account\". This endpoint generates a report upon receiving the first approved request of the day. Any following requests with identical parameters will yield the same report even if data has changed. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Build catalogs report
         * @param {CatalogsReportParameters} catalogsReportParameters Request object to asynchronously create a report.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsCreate(catalogsReportParameters: CatalogsReportParameters, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsCreateReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsCreate(catalogsReportParameters, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.reportsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This returns a URL to a report given a token returned from <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a>. You can use the URL to download the report. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Get catalogs report
         * @param {string} token Token returned from async build report call
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsGet(token: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CatalogsReport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsGet(token, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.reportsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List aggregated numbers of issues for a catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary List report stats
         * @param {CatalogsReportParameters} parameters Contains the parameters for report identification.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportsStats(parameters: CatalogsReportParameters, adAccountId?: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReportsStats200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportsStats(parameters, adAccountId, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CatalogsApi.reportsStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CatalogsApi - factory interface
 * @export
 */
export const CatalogsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CatalogsApiFp(configuration)
    return {
        /**
         * Create a new catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: this API only supports the catalog type of HOTEL for now.
         * @summary Create catalog
         * @param {CatalogsCreateRequest} catalogsCreateRequest Request object used to created a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsCreate(catalogsCreateRequest: CatalogsCreateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Catalog> {
            return localVarFp.catalogsCreate(catalogsCreateRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List catalogs
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsList(bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsList200Response> {
            return localVarFp.catalogsList(bookmark, pageSize, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of product pins for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List products by product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupPinsList(productGroupId: string, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsProductGroupPinsList200Response> {
            return localVarFp.catalogsProductGroupPinsList(productGroupId, bookmark, pageSize, adAccountId, pinMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create product group
         * @param {MultipleProductGroupsInner} multipleProductGroupsInner Request object used to create a single catalogs product groups.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsCreate(multipleProductGroupsInner: MultipleProductGroupsInner, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsVerticalProductGroup> {
            return localVarFp.catalogsProductGroupsCreate(multipleProductGroupsInner, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create product groups
         * @param {Array<MultipleProductGroupsInner>} multipleProductGroupsInner Request object used to create one or more catalogs product groups.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsCreateMany(multipleProductGroupsInner: Array<MultipleProductGroupsInner>, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.catalogsProductGroupsCreateMany(multipleProductGroupsInner, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a product group owned by the \"operation user_account\" from being in use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Delete product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsDelete(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.catalogsProductGroupsDelete(productGroupId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete product groups owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Delete product groups
         * @param {Array<number>} id Comma-separated list of product group ids
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsDeleteMany(id: Array<number>, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.catalogsProductGroupsDeleteMany(id, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a singe product group for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Get product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsGet(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsVerticalProductGroup> {
            return localVarFp.catalogsProductGroupsGet(productGroupId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of product groups for a given Catalogs Feed Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List product groups
         * @param {Array<number>} [id] Comma-separated list of product group ids
         * @param {string} [feedId] Filter entities for a given feed_id. If not given, all feeds are considered.
         * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsList(id?: Array<number>, feedId?: string, catalogId?: string, bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsProductGroupsList200Response> {
            return localVarFp.catalogsProductGroupsList(id, feedId, catalogId, bookmark, pageSize, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a product counts for a given Catalogs Product Group owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary Get product counts
         * @param {string} productGroupId Unique identifier of a product group
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsProductCountsGet(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsProductGroupProductCountsVertical> {
            return localVarFp.catalogsProductGroupsProductCountsGet(productGroupId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update product group owned by the \"operation user_account\" to use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Update single product group
         * @param {string} productGroupId Unique identifier of a product group
         * @param {CatalogsProductGroupsUpdateRequest} catalogsProductGroupsUpdateRequest Request object used to Update a catalogs product group.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        catalogsProductGroupsUpdate(productGroupId: string, catalogsProductGroupsUpdateRequest: CatalogsProductGroupsUpdateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsVerticalProductGroup> {
            return localVarFp.catalogsProductGroupsUpdate(productGroupId, catalogsProductGroupsUpdateRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch a feed processing results owned by the \"operation user_account\". Please note that for now the bookmark parameter is not functional and only the first page will be available until it is implemented in some release in the near future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List feed processing results
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedProcessingResultsList(feedId: string, bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FeedProcessingResultsList200Response> {
            return localVarFp.feedProcessingResultsList(feedId, bookmark, pageSize, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Create feed
         * @param {FeedsCreateRequest} feedsCreateRequest Request object used to created a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsCreate(feedsCreateRequest: FeedsCreateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsFeed> {
            return localVarFp.feedsCreate(feedsCreateRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a feed owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary Delete feed
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsDelete(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.feedsDelete(feedId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary Get feed
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsGet(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsFeed> {
            return localVarFp.feedsGet(feedId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Ingest items for a given feed owned by the \"operation user_account\".  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: This endpoint is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Ingest feed items
         * @param {string} feedId Unique identifier of a feed
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsIngest(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsFeedIngestion> {
            return localVarFp.feedsIngest(feedId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch feeds owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
         * @summary List feeds
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsList(bookmark?: string, pageSize?: number, catalogId?: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<FeedsList200Response> {
            return localVarFp.feedsList(bookmark, pageSize, catalogId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Update feed
         * @param {string} feedId Unique identifier of a feed
         * @param {FeedsUpdateRequest} feedsUpdateRequest Request object used to update a feed.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedsUpdate(feedId: string, feedsUpdateRequest: FeedsUpdateRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsFeed> {
            return localVarFp.feedsUpdate(feedId, feedsUpdateRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a single catalogs items batch owned by the \"operating user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Get item batch status
         * @param {string} batchId Id of a catalogs items batch to fetch
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsBatchGet(batchId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsItemsBatch> {
            return localVarFp.itemsBatchGet(batchId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint supports multiple operations on a set of one or more catalog items owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: - Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager. - The item UPSERT operation is restricted to users without a feed data source. If you plan to migrate item ingestion from feeds to the API, please reach out to your partner manager to get assistance.
         * @summary Operate on item batch
         * @param {ItemsBatchPostRequest} itemsBatchPostRequest Request object used to create catalogs items in a batch
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsBatchPost(itemsBatchPostRequest: ItemsBatchPostRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsItemsBatch> {
            return localVarFp.itemsBatchPost(itemsBatchPostRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: this endpoint is deprecated and will be deleted soon. Please use <a href=\'/docs/api/v5/#operation/items/post\'>Get catalogs items (POST)</a> instead.
         * @summary Get catalogs items
         * @param {string} country Country for the Catalogs Items
         * @param {string} language Language for the Catalogs Items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {Array<string>} [itemIds] This parameter is deprecated. Use filters instead.
         * @param {CatalogsItemsFilters} [filters] Identifies items to be retrieved. This is a required parameter.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        itemsGet(country: string, language: string, adAccountId?: string, itemIds?: Array<string>, filters?: CatalogsItemsFilters, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsItems> {
            return localVarFp.itemsGet(country, language, adAccountId, itemIds, filters, options).then((request) => request(axios, basePath));
        },
        /**
         * List item validation issues for a given feed processing result owned by the \"operation user_account\". Up to 20 random samples of affected items are returned for each error and warning code. Please note that for now query parameters \'item_numbers\' and \'item_validation_issue\' cannot be used simultaneously until it is implemented in some release in the future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: To get a list of all affected items instead of sampled issues, please refer to <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a> and <a href=\'/docs/api/v5/#operation/reports/get\'>Get catalogs report</a> endpoints. Moreover, they support multiple types of catalogs.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List item issues
         * @param {string} processingResultId Unique identifier of a feed processing result. It can be acquired from the \&quot;id\&quot; field of the \&quot;items\&quot; array within the response of the [List processing results for a given feed](/docs/api/v5/#operation/feed_processing_results/list).
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {Array<number>} [itemNumbers] Item number based on order of appearance in the Catalogs Feed. For example, \&#39;0\&#39; refers to first item found in a feed that was downloaded from a \&#39;location\&#39; specified during feed creation.
         * @param {CatalogsItemValidationIssue} [itemValidationIssue] Filter item validation issues that have a given type of item validation issue.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsIssuesList(processingResultId: string, bookmark?: string, pageSize?: number, itemNumbers?: Array<number>, itemValidationIssue?: CatalogsItemValidationIssue, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<ItemsIssuesList200Response> {
            return localVarFp.itemsIssuesList(processingResultId, bookmark, pageSize, itemNumbers, itemValidationIssue, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
         * @summary Get catalogs items (POST)
         * @param {CatalogsItemsRequest} catalogsItemsRequest Request object used to get catalogs items
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        itemsPost(catalogsItemsRequest: CatalogsItemsRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsItems> {
            return localVarFp.itemsPost(catalogsItemsRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * List products Pins owned by the \"operation user_account\" that meet the criteria specified in the Catalogs Product Group Filter given in the request. - This endpoint has been implemented in POST to allow for complex filters. This specific POST endpoint is designed to be idempotent. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: This endpoint only supports RETAIL catalog at the moment.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
         * @summary List products by filter
         * @param {CatalogsListProductsByFilterRequest} catalogsListProductsByFilterRequest Object holding a group of filters for a catalog product group
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsByProductGroupFilterList(catalogsListProductsByFilterRequest: CatalogsListProductsByFilterRequest, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsProductGroupPinsList200Response> {
            return localVarFp.productsByProductGroupFilterList(catalogsListProductsByFilterRequest, bookmark, pageSize, adAccountId, pinMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Async request to create a report of the catalog owned by the \"operation user_account\". This endpoint generates a report upon receiving the first approved request of the day. Any following requests with identical parameters will yield the same report even if data has changed. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Build catalogs report
         * @param {CatalogsReportParameters} catalogsReportParameters Request object to asynchronously create a report.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsCreate(catalogsReportParameters: CatalogsReportParameters, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsCreateReportResponse> {
            return localVarFp.reportsCreate(catalogsReportParameters, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * This returns a URL to a report given a token returned from <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a>. You can use the URL to download the report. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary Get catalogs report
         * @param {string} token Token returned from async build report call
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsGet(token: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<CatalogsReport> {
            return localVarFp.reportsGet(token, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * List aggregated numbers of issues for a catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
         * @summary List report stats
         * @param {CatalogsReportParameters} parameters Contains the parameters for report identification.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportsStats(parameters: CatalogsReportParameters, adAccountId?: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<ReportsStats200Response> {
            return localVarFp.reportsStats(parameters, adAccountId, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CatalogsApi - object-oriented interface
 * @export
 * @class CatalogsApi
 * @extends {BaseAPI}
 */
export class CatalogsApi extends BaseAPI {
    /**
     * Create a new catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: this API only supports the catalog type of HOTEL for now.
     * @summary Create catalog
     * @param {CatalogsCreateRequest} catalogsCreateRequest Request object used to created a feed.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsCreate(catalogsCreateRequest: CatalogsCreateRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsCreate(catalogsCreateRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary List catalogs
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsList(bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsList(bookmark, pageSize, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of product pins for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary List products by product group
     * @param {string} productGroupId Unique identifier of a product group
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupPinsList(productGroupId: string, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupPinsList(productGroupId, bookmark, pageSize, adAccountId, pinMetrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Create product group
     * @param {MultipleProductGroupsInner} multipleProductGroupsInner Request object used to create a single catalogs product groups.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsCreate(multipleProductGroupsInner: MultipleProductGroupsInner, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsCreate(multipleProductGroupsInner, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create product group to use in Catalogs owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Create product groups
     * @param {Array<MultipleProductGroupsInner>} multipleProductGroupsInner Request object used to create one or more catalogs product groups.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsCreateMany(multipleProductGroupsInner: Array<MultipleProductGroupsInner>, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsCreateMany(multipleProductGroupsInner, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a product group owned by the \"operation user_account\" from being in use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary Delete product group
     * @param {string} productGroupId Unique identifier of a product group
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsDelete(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsDelete(productGroupId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete product groups owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary Delete product groups
     * @param {Array<number>} id Comma-separated list of product group ids
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsDeleteMany(id: Array<number>, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsDeleteMany(id, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a singe product group for a given Catalogs Product Group Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary Get product group
     * @param {string} productGroupId Unique identifier of a product group
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsGet(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsGet(productGroupId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of product groups for a given Catalogs Feed Id owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary List product groups
     * @param {Array<number>} [id] Comma-separated list of product group ids
     * @param {string} [feedId] Filter entities for a given feed_id. If not given, all feeds are considered.
     * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsList(id?: Array<number>, feedId?: string, catalogId?: string, bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsList(id, feedId, catalogId, bookmark, pageSize, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a product counts for a given Catalogs Product Group owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary Get product counts
     * @param {string} productGroupId Unique identifier of a product group
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsProductCountsGet(productGroupId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsProductCountsGet(productGroupId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update product group owned by the \"operation user_account\" to use in Catalogs. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Update single product group
     * @param {string} productGroupId Unique identifier of a product group
     * @param {CatalogsProductGroupsUpdateRequest} catalogsProductGroupsUpdateRequest Request object used to Update a catalogs product group.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public catalogsProductGroupsUpdate(productGroupId: string, catalogsProductGroupsUpdateRequest: CatalogsProductGroupsUpdateRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).catalogsProductGroupsUpdate(productGroupId, catalogsProductGroupsUpdateRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch a feed processing results owned by the \"operation user_account\". Please note that for now the bookmark parameter is not functional and only the first page will be available until it is implemented in some release in the near future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary List feed processing results
     * @param {string} feedId Unique identifier of a feed
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedProcessingResultsList(feedId: string, bookmark?: string, pageSize?: number, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedProcessingResultsList(feedId, bookmark, pageSize, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Please, be aware that \"default_country\" and \"default_locale\" are not required in the spec for forward compatibility but for now the API will not accept requests without those fields.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Create feed
     * @param {FeedsCreateRequest} feedsCreateRequest Request object used to created a feed.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedsCreate(feedsCreateRequest: FeedsCreateRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedsCreate(feedsCreateRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a feed owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
     * @summary Delete feed
     * @param {string} feedId Unique identifier of a feed
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedsDelete(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedsDelete(feedId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
     * @summary Get feed
     * @param {string} feedId Unique identifier of a feed
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedsGet(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedsGet(feedId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Ingest items for a given feed owned by the \"operation user_account\".  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>  Note: This endpoint is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Ingest feed items
     * @param {string} feedId Unique identifier of a feed
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedsIngest(feedId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedsIngest(feedId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetch feeds owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.
     * @summary List feeds
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [catalogId] Filter entities for a given catalog_id. If not given, all catalogs are considered.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedsList(bookmark?: string, pageSize?: number, catalogId?: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedsList(bookmark, pageSize, catalogId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a feed owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  For Retail partners, refer to <a href=\'https://help.pinterest.com/en/business/article/before-you-get-started-with-catalogs\'>Before you get started with Catalogs</a>. For Hotel parterns, refer to <a href=\'/docs/api-features/shopping-overview/\'>Pinterest API for shopping</a>.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Update feed
     * @param {string} feedId Unique identifier of a feed
     * @param {FeedsUpdateRequest} feedsUpdateRequest Request object used to update a feed.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public feedsUpdate(feedId: string, feedsUpdateRequest: FeedsUpdateRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).feedsUpdate(feedId, feedsUpdateRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a single catalogs items batch owned by the \"operating user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
     * @summary Get item batch status
     * @param {string} batchId Id of a catalogs items batch to fetch
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public itemsBatchGet(batchId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).itemsBatchGet(batchId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint supports multiple operations on a set of one or more catalog items owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: - Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager. - The item UPSERT operation is restricted to users without a feed data source. If you plan to migrate item ingestion from feeds to the API, please reach out to your partner manager to get assistance.
     * @summary Operate on item batch
     * @param {ItemsBatchPostRequest} itemsBatchPostRequest Request object used to create catalogs items in a batch
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public itemsBatchPost(itemsBatchPostRequest: ItemsBatchPostRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).itemsBatchPost(itemsBatchPostRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: this endpoint is deprecated and will be deleted soon. Please use <a href=\'/docs/api/v5/#operation/items/post\'>Get catalogs items (POST)</a> instead.
     * @summary Get catalogs items
     * @param {string} country Country for the Catalogs Items
     * @param {string} language Language for the Catalogs Items
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {Array<string>} [itemIds] This parameter is deprecated. Use filters instead.
     * @param {CatalogsItemsFilters} [filters] Identifies items to be retrieved. This is a required parameter.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public itemsGet(country: string, language: string, adAccountId?: string, itemIds?: Array<string>, filters?: CatalogsItemsFilters, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).itemsGet(country, language, adAccountId, itemIds, filters, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List item validation issues for a given feed processing result owned by the \"operation user_account\". Up to 20 random samples of affected items are returned for each error and warning code. Please note that for now query parameters \'item_numbers\' and \'item_validation_issue\' cannot be used simultaneously until it is implemented in some release in the future. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: To get a list of all affected items instead of sampled issues, please refer to <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a> and <a href=\'/docs/api/v5/#operation/reports/get\'>Get catalogs report</a> endpoints. Moreover, they support multiple types of catalogs.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary List item issues
     * @param {string} processingResultId Unique identifier of a feed processing result. It can be acquired from the \&quot;id\&quot; field of the \&quot;items\&quot; array within the response of the [List processing results for a given feed](/docs/api/v5/#operation/feed_processing_results/list).
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {Array<number>} [itemNumbers] Item number based on order of appearance in the Catalogs Feed. For example, \&#39;0\&#39; refers to first item found in a feed that was downloaded from a \&#39;location\&#39; specified during feed creation.
     * @param {CatalogsItemValidationIssue} [itemValidationIssue] Filter item validation issues that have a given type of item validation issue.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public itemsIssuesList(processingResultId: string, bookmark?: string, pageSize?: number, itemNumbers?: Array<number>, itemValidationIssue?: CatalogsItemValidationIssue, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).itemsIssuesList(processingResultId, bookmark, pageSize, itemNumbers, itemValidationIssue, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the items of the catalog owned by the \"operation user_account\". <a href=\"/docs/api-features/shopping-overview/#Update%20items%20in%20batch\" target=\"_blank\">See detailed documentation here.</a> - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: Access to the Creative Assets catalog type is restricted to a specific group of users. If you require access, please reach out to your partner manager.
     * @summary Get catalogs items (POST)
     * @param {CatalogsItemsRequest} catalogsItemsRequest Request object used to get catalogs items
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public itemsPost(catalogsItemsRequest: CatalogsItemsRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).itemsPost(catalogsItemsRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List products Pins owned by the \"operation user_account\" that meet the criteria specified in the Catalogs Product Group Filter given in the request. - This endpoint has been implemented in POST to allow for complex filters. This specific POST endpoint is designed to be idempotent. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.  Note: This endpoint only supports RETAIL catalog at the moment.  <a href=\'/docs/api-features/shopping-overview/\'>Learn more</a>
     * @summary List products by filter
     * @param {CatalogsListProductsByFilterRequest} catalogsListProductsByFilterRequest Object holding a group of filters for a catalog product group
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public productsByProductGroupFilterList(catalogsListProductsByFilterRequest: CatalogsListProductsByFilterRequest, bookmark?: string, pageSize?: number, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).productsByProductGroupFilterList(catalogsListProductsByFilterRequest, bookmark, pageSize, adAccountId, pinMetrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Async request to create a report of the catalog owned by the \"operation user_account\". This endpoint generates a report upon receiving the first approved request of the day. Any following requests with identical parameters will yield the same report even if data has changed. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
     * @summary Build catalogs report
     * @param {CatalogsReportParameters} catalogsReportParameters Request object to asynchronously create a report.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public reportsCreate(catalogsReportParameters: CatalogsReportParameters, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).reportsCreate(catalogsReportParameters, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This returns a URL to a report given a token returned from <a href=\'/docs/api/v5/#operation/reports/create\'>Build catalogs report</a>. You can use the URL to download the report. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
     * @summary Get catalogs report
     * @param {string} token Token returned from async build report call
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public reportsGet(token: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).reportsGet(token, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List aggregated numbers of issues for a catalog owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account: Owner, Admin, Catalogs Manager.
     * @summary List report stats
     * @param {CatalogsReportParameters} parameters Contains the parameters for report identification.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogsApi
     */
    public reportsStats(parameters: CatalogsReportParameters, adAccountId?: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return CatalogsApiFp(this.configuration).reportsStats(parameters, adAccountId, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConversionEventsApi - axios parameter creator
 * @export
 */
export const ConversionEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The Pinterest API offers advertisers a way to send Pinterest their conversion information (including web conversions, in-app conversions, or even offline conversions) based on their <code>ad_account_id</code>. The request body should be a JSON object. - This endpoint requires an <code>access_token</code> be generated through Ads Manager. Review the <a href=\"/docs/api-features/conversion-overview/\">Conversions Guide</a> for more details. (Note that the authorization header required is <code>Authorization: Bearer &lt;access_token&gt;</code>). - The token\'s <code>user_account</code> must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Audience, Campaign. (Note that the token can be used across multiple ad accounts under an user ID.) - This endpoint has a rate limit of 5,000 calls per minute per ad account. - If the merchant is submitting this information using both Pinterest conversion tags and the Pinterest API, Pinterest will remove duplicate information before reporting. (Note that events that took place offline cannot be deduplicated.)
         * @summary Send conversions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ConversionEvents} conversionEvents Conversion events.
         * @param {boolean} [test] Include query param ?test&#x3D;true to mark the request as a test request. The events will not be recorded but the API will still return the same response messages. Use this mode to verify your requests are working and your events are constructed correctly. Warning: If you use this query parameter, be certain that it is off (set to false or deleted) before sending a legitimate (non-testing) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate: async (adAccountId: string, conversionEvents: ConversionEvents, test?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('eventsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'conversionEvents' is not null or undefined
            assertParamExists('eventsCreate', 'conversionEvents', conversionEvents)
            const localVarPath = `/ad_accounts/{ad_account_id}/events`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)

            // authentication conversion_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (test !== undefined) {
                localVarQueryParameter['test'] = test;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversionEvents, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversionEventsApi - functional programming interface
 * @export
 */
export const ConversionEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversionEventsApiAxiosParamCreator(configuration)
    return {
        /**
         * The Pinterest API offers advertisers a way to send Pinterest their conversion information (including web conversions, in-app conversions, or even offline conversions) based on their <code>ad_account_id</code>. The request body should be a JSON object. - This endpoint requires an <code>access_token</code> be generated through Ads Manager. Review the <a href=\"/docs/api-features/conversion-overview/\">Conversions Guide</a> for more details. (Note that the authorization header required is <code>Authorization: Bearer &lt;access_token&gt;</code>). - The token\'s <code>user_account</code> must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Audience, Campaign. (Note that the token can be used across multiple ad accounts under an user ID.) - This endpoint has a rate limit of 5,000 calls per minute per ad account. - If the merchant is submitting this information using both Pinterest conversion tags and the Pinterest API, Pinterest will remove duplicate information before reporting. (Note that events that took place offline cannot be deduplicated.)
         * @summary Send conversions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ConversionEvents} conversionEvents Conversion events.
         * @param {boolean} [test] Include query param ?test&#x3D;true to mark the request as a test request. The events will not be recorded but the API will still return the same response messages. Use this mode to verify your requests are working and your events are constructed correctly. Warning: If you use this query parameter, be certain that it is off (set to false or deleted) before sending a legitimate (non-testing) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsCreate(adAccountId: string, conversionEvents: ConversionEvents, test?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.eventsCreate(adAccountId, conversionEvents, test, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversionEventsApi.eventsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversionEventsApi - factory interface
 * @export
 */
export const ConversionEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversionEventsApiFp(configuration)
    return {
        /**
         * The Pinterest API offers advertisers a way to send Pinterest their conversion information (including web conversions, in-app conversions, or even offline conversions) based on their <code>ad_account_id</code>. The request body should be a JSON object. - This endpoint requires an <code>access_token</code> be generated through Ads Manager. Review the <a href=\"/docs/api-features/conversion-overview/\">Conversions Guide</a> for more details. (Note that the authorization header required is <code>Authorization: Bearer &lt;access_token&gt;</code>). - The token\'s <code>user_account</code> must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Audience, Campaign. (Note that the token can be used across multiple ad accounts under an user ID.) - This endpoint has a rate limit of 5,000 calls per minute per ad account. - If the merchant is submitting this information using both Pinterest conversion tags and the Pinterest API, Pinterest will remove duplicate information before reporting. (Note that events that took place offline cannot be deduplicated.)
         * @summary Send conversions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ConversionEvents} conversionEvents Conversion events.
         * @param {boolean} [test] Include query param ?test&#x3D;true to mark the request as a test request. The events will not be recorded but the API will still return the same response messages. Use this mode to verify your requests are working and your events are constructed correctly. Warning: If you use this query parameter, be certain that it is off (set to false or deleted) before sending a legitimate (non-testing) request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsCreate(adAccountId: string, conversionEvents: ConversionEvents, test?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConversionApiResponse> {
            return localVarFp.eventsCreate(adAccountId, conversionEvents, test, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversionEventsApi - object-oriented interface
 * @export
 * @class ConversionEventsApi
 * @extends {BaseAPI}
 */
export class ConversionEventsApi extends BaseAPI {
    /**
     * The Pinterest API offers advertisers a way to send Pinterest their conversion information (including web conversions, in-app conversions, or even offline conversions) based on their <code>ad_account_id</code>. The request body should be a JSON object. - This endpoint requires an <code>access_token</code> be generated through Ads Manager. Review the <a href=\"/docs/api-features/conversion-overview/\">Conversions Guide</a> for more details. (Note that the authorization header required is <code>Authorization: Bearer &lt;access_token&gt;</code>). - The token\'s <code>user_account</code> must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Audience, Campaign. (Note that the token can be used across multiple ad accounts under an user ID.) - This endpoint has a rate limit of 5,000 calls per minute per ad account. - If the merchant is submitting this information using both Pinterest conversion tags and the Pinterest API, Pinterest will remove duplicate information before reporting. (Note that events that took place offline cannot be deduplicated.)
     * @summary Send conversions
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {ConversionEvents} conversionEvents Conversion events.
     * @param {boolean} [test] Include query param ?test&#x3D;true to mark the request as a test request. The events will not be recorded but the API will still return the same response messages. Use this mode to verify your requests are working and your events are constructed correctly. Warning: If you use this query parameter, be certain that it is off (set to false or deleted) before sending a legitimate (non-testing) request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionEventsApi
     */
    public eventsCreate(adAccountId: string, conversionEvents: ConversionEvents, test?: boolean, options?: RawAxiosRequestConfig) {
        return ConversionEventsApiFp(this.configuration).eventsCreate(adAccountId, conversionEvents, test, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ConversionTagsApi - axios parameter creator
 * @export
 */
export const ConversionTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a conversion tag, also known as <a href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\" target=\"_blank\">Pinterest tag</a>, with the option to enable enhanced match.<p/> The Pinterest Tag tracks actions people take on the ad account s website after they view the ad account\'s ad on Pinterest. The advertiser needs to customize this tag to track conversions.<p/> For more information, see:<p/> <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\">Set up the Pinterest tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/\">Pinterest Tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/#enhanced-match\">Enhanced match</a>
         * @summary Create conversion tag
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ConversionTagCreate} conversionTagCreate Conversion Tag to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversionTagsCreate: async (adAccountId: string, conversionTagCreate: ConversionTagCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('conversionTagsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'conversionTagCreate' is not null or undefined
            assertParamExists('conversionTagsCreate', 'conversionTagCreate', conversionTagCreate)
            const localVarPath = `/ad_accounts/{ad_account_id}/conversion_tags`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversionTagCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about an existing conversion tag.
         * @summary Get conversion tag
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} conversionTagId Id of the conversion tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversionTagsGet: async (adAccountId: string, conversionTagId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('conversionTagsGet', 'adAccountId', adAccountId)
            // verify required parameter 'conversionTagId' is not null or undefined
            assertParamExists('conversionTagsGet', 'conversionTagId', conversionTagId)
            const localVarPath = `/ad_accounts/{ad_account_id}/conversion_tags/{conversion_tag_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"conversion_tag_id"}}`, encodeURIComponent(String(conversionTagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List conversion tags associated with an ad account.
         * @summary Get conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} [filterDeleted] Filter out deleted tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversionTagsList: async (adAccountId: string, filterDeleted?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('conversionTagsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/conversion_tags`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (filterDeleted !== undefined) {
                localVarQueryParameter['filter_deleted'] = filterDeleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get Ocpm eligible conversion tag events for an ad account.
         * @summary Get Ocpm eligible conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ocpmEligibleConversionTagsGet: async (adAccountId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('ocpmEligibleConversionTagsGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/conversion_tags/ocpm_eligible`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all page visit conversion tag events for an ad account.
         * @summary Get page visit conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {PageVisitConversionTagsGetOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageVisitConversionTagsGet: async (adAccountId: string, pageSize?: number, order?: PageVisitConversionTagsGetOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('pageVisitConversionTagsGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/conversion_tags/page_visit`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConversionTagsApi - functional programming interface
 * @export
 */
export const ConversionTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ConversionTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a conversion tag, also known as <a href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\" target=\"_blank\">Pinterest tag</a>, with the option to enable enhanced match.<p/> The Pinterest Tag tracks actions people take on the ad account s website after they view the ad account\'s ad on Pinterest. The advertiser needs to customize this tag to track conversions.<p/> For more information, see:<p/> <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\">Set up the Pinterest tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/\">Pinterest Tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/#enhanced-match\">Enhanced match</a>
         * @summary Create conversion tag
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ConversionTagCreate} conversionTagCreate Conversion Tag to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversionTagsCreate(adAccountId: string, conversionTagCreate: ConversionTagCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversionTagsCreate(adAccountId, conversionTagCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversionTagsApi.conversionTagsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get information about an existing conversion tag.
         * @summary Get conversion tag
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} conversionTagId Id of the conversion tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversionTagsGet(adAccountId: string, conversionTagId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionTagResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversionTagsGet(adAccountId, conversionTagId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversionTagsApi.conversionTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List conversion tags associated with an ad account.
         * @summary Get conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} [filterDeleted] Filter out deleted tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversionTagsList(adAccountId: string, filterDeleted?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversionTagListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversionTagsList(adAccountId, filterDeleted, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversionTagsApi.conversionTagsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get Ocpm eligible conversion tag events for an ad account.
         * @summary Get Ocpm eligible conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ocpmEligibleConversionTagsGet(adAccountId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: Array<ConversionEventResponse>; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ocpmEligibleConversionTagsGet(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversionTagsApi.ocpmEligibleConversionTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all page visit conversion tag events for an ad account.
         * @summary Get page visit conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {PageVisitConversionTagsGetOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pageVisitConversionTagsGet(adAccountId: string, pageSize?: number, order?: PageVisitConversionTagsGetOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageVisitConversionTagsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pageVisitConversionTagsGet(adAccountId, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ConversionTagsApi.pageVisitConversionTagsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ConversionTagsApi - factory interface
 * @export
 */
export const ConversionTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ConversionTagsApiFp(configuration)
    return {
        /**
         * Create a conversion tag, also known as <a href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\" target=\"_blank\">Pinterest tag</a>, with the option to enable enhanced match.<p/> The Pinterest Tag tracks actions people take on the ad account s website after they view the ad account\'s ad on Pinterest. The advertiser needs to customize this tag to track conversions.<p/> For more information, see:<p/> <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\">Set up the Pinterest tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/\">Pinterest Tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/#enhanced-match\">Enhanced match</a>
         * @summary Create conversion tag
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ConversionTagCreate} conversionTagCreate Conversion Tag to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversionTagsCreate(adAccountId: string, conversionTagCreate: ConversionTagCreate, options?: RawAxiosRequestConfig): AxiosPromise<ConversionTagResponse> {
            return localVarFp.conversionTagsCreate(adAccountId, conversionTagCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about an existing conversion tag.
         * @summary Get conversion tag
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} conversionTagId Id of the conversion tag.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversionTagsGet(adAccountId: string, conversionTagId: string, options?: RawAxiosRequestConfig): AxiosPromise<ConversionTagResponse> {
            return localVarFp.conversionTagsGet(adAccountId, conversionTagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List conversion tags associated with an ad account.
         * @summary Get conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} [filterDeleted] Filter out deleted tags.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversionTagsList(adAccountId: string, filterDeleted?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<ConversionTagListResponse> {
            return localVarFp.conversionTagsList(adAccountId, filterDeleted, options).then((request) => request(axios, basePath));
        },
        /**
         * Get Ocpm eligible conversion tag events for an ad account.
         * @summary Get Ocpm eligible conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ocpmEligibleConversionTagsGet(adAccountId: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: Array<ConversionEventResponse>; }> {
            return localVarFp.ocpmEligibleConversionTagsGet(adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all page visit conversion tag events for an ad account.
         * @summary Get page visit conversion tags
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {PageVisitConversionTagsGetOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pageVisitConversionTagsGet(adAccountId: string, pageSize?: number, order?: PageVisitConversionTagsGetOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<PageVisitConversionTagsGet200Response> {
            return localVarFp.pageVisitConversionTagsGet(adAccountId, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConversionTagsApi - object-oriented interface
 * @export
 * @class ConversionTagsApi
 * @extends {BaseAPI}
 */
export class ConversionTagsApi extends BaseAPI {
    /**
     * Create a conversion tag, also known as <a href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\" target=\"_blank\">Pinterest tag</a>, with the option to enable enhanced match.<p/> The Pinterest Tag tracks actions people take on the ad account s website after they view the ad account\'s ad on Pinterest. The advertiser needs to customize this tag to track conversions.<p/> For more information, see:<p/> <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/set-up-the-pinterest-tag\">Set up the Pinterest tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/\">Pinterest Tag</a><p/> <a class=\"reference external\" href=\"/docs/api-features/pinterest-tag/#enhanced-match\">Enhanced match</a>
     * @summary Create conversion tag
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {ConversionTagCreate} conversionTagCreate Conversion Tag to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionTagsApi
     */
    public conversionTagsCreate(adAccountId: string, conversionTagCreate: ConversionTagCreate, options?: RawAxiosRequestConfig) {
        return ConversionTagsApiFp(this.configuration).conversionTagsCreate(adAccountId, conversionTagCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information about an existing conversion tag.
     * @summary Get conversion tag
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} conversionTagId Id of the conversion tag.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionTagsApi
     */
    public conversionTagsGet(adAccountId: string, conversionTagId: string, options?: RawAxiosRequestConfig) {
        return ConversionTagsApiFp(this.configuration).conversionTagsGet(adAccountId, conversionTagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List conversion tags associated with an ad account.
     * @summary Get conversion tags
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {boolean} [filterDeleted] Filter out deleted tags.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionTagsApi
     */
    public conversionTagsList(adAccountId: string, filterDeleted?: boolean, options?: RawAxiosRequestConfig) {
        return ConversionTagsApiFp(this.configuration).conversionTagsList(adAccountId, filterDeleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get Ocpm eligible conversion tag events for an ad account.
     * @summary Get Ocpm eligible conversion tags
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionTagsApi
     */
    public ocpmEligibleConversionTagsGet(adAccountId: string, options?: RawAxiosRequestConfig) {
        return ConversionTagsApiFp(this.configuration).ocpmEligibleConversionTagsGet(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all page visit conversion tag events for an ad account.
     * @summary Get page visit conversion tags
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {PageVisitConversionTagsGetOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConversionTagsApi
     */
    public pageVisitConversionTagsGet(adAccountId: string, pageSize?: number, order?: PageVisitConversionTagsGetOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return ConversionTagsApiFp(this.configuration).pageVisitConversionTagsGet(adAccountId, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PageVisitConversionTagsGetOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type PageVisitConversionTagsGetOrderEnum = typeof PageVisitConversionTagsGetOrderEnum[keyof typeof PageVisitConversionTagsGetOrderEnum];


/**
 * CustomerListsApi - axios parameter creator
 * @export
 */
export const CustomerListsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Create a customer list from your records(hashed or plain-text email addresses, or hashed MAIDs or IDFAs).</p> <p>A customer list is one of the four types of Pinterest audiences: for more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.<p/>  <p><b>Please review our <u><a href=\"https://help.pinterest.com/en/business/article/audience-targeting#section-13341\" target=\"_blank\">requirements</a></u> for what type of information is allowed when uploading a customer list.</b></p> <p>When you create a customer list, the system scans the list for existing Pinterest accounts; the list must include at least 100 Pinterest accounts. Your original list will be deleted when the matching process is complete. The filtered list  containing only the Pinterest accounts that were included in your starting list  is what will be used to create the audience.</p> <p>Note that once you have created your customer list, you must convert it into an audience (of the  CUSTOMER_LIST type) using the <a href=\"#operation/create_audience_handler\">create audience endpoint</a> before it can be used.</p>
         * @summary Create customer lists
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {CustomerListRequest} customerListRequest Parameters to get Customer lists info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsCreate: async (adAccountId: string, customerListRequest: CustomerListRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('customerListsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'customerListRequest' is not null or undefined
            assertParamExists('customerListsCreate', 'customerListRequest', customerListRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/customer_lists`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerListRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a specific customer list given the customer list ID.
         * @summary Get customer list
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} customerListId Unique identifier of a customer list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsGet: async (adAccountId: string, customerListId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('customerListsGet', 'adAccountId', adAccountId)
            // verify required parameter 'customerListId' is not null or undefined
            assertParamExists('customerListsGet', 'customerListId', customerListId)
            const localVarPath = `/ad_accounts/{ad_account_id}/customer_lists/{customer_list_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"customer_list_id"}}`, encodeURIComponent(String(customerListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Get a set of customer lists including id and name based on the filters provided.</p> <p>(Customer lists are a type of audience.) For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>  or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
         * @summary Get customer lists
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {CustomerListsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsList: async (adAccountId: string, pageSize?: number, order?: CustomerListsListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('customerListsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/customer_lists`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Append or remove records to/from an existing customer list. (A customer list is one of the four types of Pinterest audiences.)</p> <p>When you add records to an existing customer list, the system scans the additions for existing Pinterest accounts; those are the records that will be added to your CUSTOMER_LIST audience. Your original list of records  to add will be deleted when the matching process is complete.</p> <p>For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
         * @summary Update customer list
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} customerListId Unique identifier of a customer list
         * @param {CustomerListUpdateRequest} customerListUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsUpdate: async (adAccountId: string, customerListId: string, customerListUpdateRequest: CustomerListUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('customerListsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'customerListId' is not null or undefined
            assertParamExists('customerListsUpdate', 'customerListId', customerListId)
            // verify required parameter 'customerListUpdateRequest' is not null or undefined
            assertParamExists('customerListsUpdate', 'customerListUpdateRequest', customerListUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/customer_lists/{customer_list_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"customer_list_id"}}`, encodeURIComponent(String(customerListId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customerListUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomerListsApi - functional programming interface
 * @export
 */
export const CustomerListsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomerListsApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Create a customer list from your records(hashed or plain-text email addresses, or hashed MAIDs or IDFAs).</p> <p>A customer list is one of the four types of Pinterest audiences: for more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.<p/>  <p><b>Please review our <u><a href=\"https://help.pinterest.com/en/business/article/audience-targeting#section-13341\" target=\"_blank\">requirements</a></u> for what type of information is allowed when uploading a customer list.</b></p> <p>When you create a customer list, the system scans the list for existing Pinterest accounts; the list must include at least 100 Pinterest accounts. Your original list will be deleted when the matching process is complete. The filtered list  containing only the Pinterest accounts that were included in your starting list  is what will be used to create the audience.</p> <p>Note that once you have created your customer list, you must convert it into an audience (of the  CUSTOMER_LIST type) using the <a href=\"#operation/create_audience_handler\">create audience endpoint</a> before it can be used.</p>
         * @summary Create customer lists
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {CustomerListRequest} customerListRequest Parameters to get Customer lists info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerListsCreate(adAccountId: string, customerListRequest: CustomerListRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerListsCreate(adAccountId, customerListRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerListsApi.customerListsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets a specific customer list given the customer list ID.
         * @summary Get customer list
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} customerListId Unique identifier of a customer list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerListsGet(adAccountId: string, customerListId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerListsGet(adAccountId, customerListId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerListsApi.customerListsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Get a set of customer lists including id and name based on the filters provided.</p> <p>(Customer lists are a type of audience.) For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>  or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
         * @summary Get customer lists
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {CustomerListsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerListsList(adAccountId: string, pageSize?: number, order?: CustomerListsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerListsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerListsList(adAccountId, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerListsApi.customerListsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Append or remove records to/from an existing customer list. (A customer list is one of the four types of Pinterest audiences.)</p> <p>When you add records to an existing customer list, the system scans the additions for existing Pinterest accounts; those are the records that will be added to your CUSTOMER_LIST audience. Your original list of records  to add will be deleted when the matching process is complete.</p> <p>For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
         * @summary Update customer list
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} customerListId Unique identifier of a customer list
         * @param {CustomerListUpdateRequest} customerListUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerListsUpdate(adAccountId: string, customerListId: string, customerListUpdateRequest: CustomerListUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerList>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerListsUpdate(adAccountId, customerListId, customerListUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CustomerListsApi.customerListsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CustomerListsApi - factory interface
 * @export
 */
export const CustomerListsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomerListsApiFp(configuration)
    return {
        /**
         * <p>Create a customer list from your records(hashed or plain-text email addresses, or hashed MAIDs or IDFAs).</p> <p>A customer list is one of the four types of Pinterest audiences: for more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.<p/>  <p><b>Please review our <u><a href=\"https://help.pinterest.com/en/business/article/audience-targeting#section-13341\" target=\"_blank\">requirements</a></u> for what type of information is allowed when uploading a customer list.</b></p> <p>When you create a customer list, the system scans the list for existing Pinterest accounts; the list must include at least 100 Pinterest accounts. Your original list will be deleted when the matching process is complete. The filtered list  containing only the Pinterest accounts that were included in your starting list  is what will be used to create the audience.</p> <p>Note that once you have created your customer list, you must convert it into an audience (of the  CUSTOMER_LIST type) using the <a href=\"#operation/create_audience_handler\">create audience endpoint</a> before it can be used.</p>
         * @summary Create customer lists
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {CustomerListRequest} customerListRequest Parameters to get Customer lists info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsCreate(adAccountId: string, customerListRequest: CustomerListRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerList> {
            return localVarFp.customerListsCreate(adAccountId, customerListRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets a specific customer list given the customer list ID.
         * @summary Get customer list
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} customerListId Unique identifier of a customer list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsGet(adAccountId: string, customerListId: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerList> {
            return localVarFp.customerListsGet(adAccountId, customerListId, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Get a set of customer lists including id and name based on the filters provided.</p> <p>(Customer lists are a type of audience.) For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>  or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
         * @summary Get customer lists
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {CustomerListsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsList(adAccountId: string, pageSize?: number, order?: CustomerListsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<CustomerListsList200Response> {
            return localVarFp.customerListsList(adAccountId, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Append or remove records to/from an existing customer list. (A customer list is one of the four types of Pinterest audiences.)</p> <p>When you add records to an existing customer list, the system scans the additions for existing Pinterest accounts; those are the records that will be added to your CUSTOMER_LIST audience. Your original list of records  to add will be deleted when the matching process is complete.</p> <p>For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
         * @summary Update customer list
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} customerListId Unique identifier of a customer list
         * @param {CustomerListUpdateRequest} customerListUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerListsUpdate(adAccountId: string, customerListId: string, customerListUpdateRequest: CustomerListUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<CustomerList> {
            return localVarFp.customerListsUpdate(adAccountId, customerListId, customerListUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomerListsApi - object-oriented interface
 * @export
 * @class CustomerListsApi
 * @extends {BaseAPI}
 */
export class CustomerListsApi extends BaseAPI {
    /**
     * <p>Create a customer list from your records(hashed or plain-text email addresses, or hashed MAIDs or IDFAs).</p> <p>A customer list is one of the four types of Pinterest audiences: for more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.<p/>  <p><b>Please review our <u><a href=\"https://help.pinterest.com/en/business/article/audience-targeting#section-13341\" target=\"_blank\">requirements</a></u> for what type of information is allowed when uploading a customer list.</b></p> <p>When you create a customer list, the system scans the list for existing Pinterest accounts; the list must include at least 100 Pinterest accounts. Your original list will be deleted when the matching process is complete. The filtered list  containing only the Pinterest accounts that were included in your starting list  is what will be used to create the audience.</p> <p>Note that once you have created your customer list, you must convert it into an audience (of the  CUSTOMER_LIST type) using the <a href=\"#operation/create_audience_handler\">create audience endpoint</a> before it can be used.</p>
     * @summary Create customer lists
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {CustomerListRequest} customerListRequest Parameters to get Customer lists info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerListsApi
     */
    public customerListsCreate(adAccountId: string, customerListRequest: CustomerListRequest, options?: RawAxiosRequestConfig) {
        return CustomerListsApiFp(this.configuration).customerListsCreate(adAccountId, customerListRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets a specific customer list given the customer list ID.
     * @summary Get customer list
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} customerListId Unique identifier of a customer list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerListsApi
     */
    public customerListsGet(adAccountId: string, customerListId: string, options?: RawAxiosRequestConfig) {
        return CustomerListsApiFp(this.configuration).customerListsGet(adAccountId, customerListId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Get a set of customer lists including id and name based on the filters provided.</p> <p>(Customer lists are a type of audience.) For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>  or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
     * @summary Get customer lists
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {CustomerListsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerListsApi
     */
    public customerListsList(adAccountId: string, pageSize?: number, order?: CustomerListsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return CustomerListsApiFp(this.configuration).customerListsList(adAccountId, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Append or remove records to/from an existing customer list. (A customer list is one of the four types of Pinterest audiences.)</p> <p>When you add records to an existing customer list, the system scans the additions for existing Pinterest accounts; those are the records that will be added to your CUSTOMER_LIST audience. Your original list of records  to add will be deleted when the matching process is complete.</p> <p>For more information, see <a href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a> or the <a href=\"/docs/api-features/targeting-overview/\" target=\"_blank\">Audiences</a> section of the ads management guide.</p>
     * @summary Update customer list
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} customerListId Unique identifier of a customer list
     * @param {CustomerListUpdateRequest} customerListUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomerListsApi
     */
    public customerListsUpdate(adAccountId: string, customerListId: string, customerListUpdateRequest: CustomerListUpdateRequest, options?: RawAxiosRequestConfig) {
        return CustomerListsApiFp(this.configuration).customerListsUpdate(adAccountId, customerListId, customerListUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const CustomerListsListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type CustomerListsListOrderEnum = typeof CustomerListsListOrderEnum[keyof typeof CustomerListsListOrderEnum];


/**
 * IntegrationsApi - axios parameter creator
 * @export
 */
export const IntegrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Delete commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommerceDel: async (externalBusinessId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalBusinessId' is not null or undefined
            assertParamExists('integrationsCommerceDel', 'externalBusinessId', externalBusinessId)
            const localVarPath = `/integrations/commerce/{external_business_id}`
                .replace(`{${"external_business_id"}}`, encodeURIComponent(String(externalBusinessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get commerce integration metadata associated with the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommerceGet: async (externalBusinessId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalBusinessId' is not null or undefined
            assertParamExists('integrationsCommerceGet', 'externalBusinessId', externalBusinessId)
            const localVarPath = `/integrations/commerce/{external_business_id}`
                .replace(`{${"external_business_id"}}`, encodeURIComponent(String(externalBusinessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Update commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {IntegrationRequestPatch} [integrationRequestPatch] Parameters to get create/update the Integration Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommercePatch: async (externalBusinessId: string, integrationRequestPatch?: IntegrationRequestPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'externalBusinessId' is not null or undefined
            assertParamExists('integrationsCommercePatch', 'externalBusinessId', externalBusinessId)
            const localVarPath = `/integrations/commerce/{external_business_id}`
                .replace(`{${"external_business_id"}}`, encodeURIComponent(String(externalBusinessId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationRequestPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create commerce integration metadata to link an external business ID with a Pinterest merchant & ad account. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Create commerce integration
         * @param {IntegrationRequest} [integrationRequest] Parameters to get create/update the Integration Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommercePost: async (integrationRequest?: IntegrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations/commerce`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get integration metadata by ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get integration metadata
         * @param {string} id Integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsGetById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('integrationsGetById', 'id', id)
            const localVarPath = `/integrations/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get integration metadata list. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get integration metadata list
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsGetList: async (bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/integrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint receives batched logs from integration applications on partner platforms. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Receives batched logs from integration applications.
         * @param {IntegrationLogsRequest} integrationLogsRequest Ingest log information from external integration application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsLogsPost: async (integrationLogsRequest: IntegrationLogsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'integrationLogsRequest' is not null or undefined
            assertParamExists('integrationsLogsPost', 'integrationLogsRequest', integrationLogsRequest)
            const localVarPath = `/integrations/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(integrationLogsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IntegrationsApi - functional programming interface
 * @export
 */
export const IntegrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IntegrationsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Delete commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsCommerceDel(externalBusinessId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsCommerceDel(externalBusinessId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsCommerceDel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get commerce integration metadata associated with the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsCommerceGet(externalBusinessId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsCommerceGet(externalBusinessId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsCommerceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Update commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {IntegrationRequestPatch} [integrationRequestPatch] Parameters to get create/update the Integration Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsCommercePatch(externalBusinessId: string, integrationRequestPatch?: IntegrationRequestPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsCommercePatch(externalBusinessId, integrationRequestPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsCommercePatch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create commerce integration metadata to link an external business ID with a Pinterest merchant & ad account. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Create commerce integration
         * @param {IntegrationRequest} [integrationRequest] Parameters to get create/update the Integration Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsCommercePost(integrationRequest?: IntegrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsCommercePost(integrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsCommercePost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get integration metadata by ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get integration metadata
         * @param {string} id Integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsGetById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsGetById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get integration metadata list. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get integration metadata list
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsGetList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationsGetList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsGetList(bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsGetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * This endpoint receives batched logs from integration applications on partner platforms. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Receives batched logs from integration applications.
         * @param {IntegrationLogsRequest} integrationLogsRequest Ingest log information from external integration application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async integrationsLogsPost(integrationLogsRequest: IntegrationLogsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IntegrationLogsSuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.integrationsLogsPost(integrationLogsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['IntegrationsApi.integrationsLogsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * IntegrationsApi - factory interface
 * @export
 */
export const IntegrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IntegrationsApiFp(configuration)
    return {
        /**
         * Delete commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Delete commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommerceDel(externalBusinessId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.integrationsCommerceDel(externalBusinessId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get commerce integration metadata associated with the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommerceGet(externalBusinessId: string, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationMetadata> {
            return localVarFp.integrationsCommerceGet(externalBusinessId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Update commerce integration
         * @param {string} externalBusinessId External business ID for the integration.
         * @param {IntegrationRequestPatch} [integrationRequestPatch] Parameters to get create/update the Integration Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommercePatch(externalBusinessId: string, integrationRequestPatch?: IntegrationRequestPatch, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationMetadata> {
            return localVarFp.integrationsCommercePatch(externalBusinessId, integrationRequestPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Create commerce integration metadata to link an external business ID with a Pinterest merchant & ad account. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Create commerce integration
         * @param {IntegrationRequest} [integrationRequest] Parameters to get create/update the Integration Metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsCommercePost(integrationRequest?: IntegrationRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationMetadata> {
            return localVarFp.integrationsCommercePost(integrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get integration metadata by ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get integration metadata
         * @param {string} id Integration ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsGetById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationRecord> {
            return localVarFp.integrationsGetById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get integration metadata list. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Get integration metadata list
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsGetList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationsGetList200Response> {
            return localVarFp.integrationsGetList(bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint receives batched logs from integration applications on partner platforms. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
         * @summary Receives batched logs from integration applications.
         * @param {IntegrationLogsRequest} integrationLogsRequest Ingest log information from external integration application.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        integrationsLogsPost(integrationLogsRequest: IntegrationLogsRequest, options?: RawAxiosRequestConfig): AxiosPromise<IntegrationLogsSuccessResponse> {
            return localVarFp.integrationsLogsPost(integrationLogsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IntegrationsApi - object-oriented interface
 * @export
 * @class IntegrationsApi
 * @extends {BaseAPI}
 */
export class IntegrationsApi extends BaseAPI {
    /**
     * Delete commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Delete commerce integration
     * @param {string} externalBusinessId External business ID for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsCommerceDel(externalBusinessId: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsCommerceDel(externalBusinessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get commerce integration metadata associated with the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Get commerce integration
     * @param {string} externalBusinessId External business ID for the integration.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsCommerceGet(externalBusinessId: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsCommerceGet(externalBusinessId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update commerce integration metadata for the given external business ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Update commerce integration
     * @param {string} externalBusinessId External business ID for the integration.
     * @param {IntegrationRequestPatch} [integrationRequestPatch] Parameters to get create/update the Integration Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsCommercePatch(externalBusinessId: string, integrationRequestPatch?: IntegrationRequestPatch, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsCommercePatch(externalBusinessId, integrationRequestPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create commerce integration metadata to link an external business ID with a Pinterest merchant & ad account. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Create commerce integration
     * @param {IntegrationRequest} [integrationRequest] Parameters to get create/update the Integration Metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsCommercePost(integrationRequest?: IntegrationRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsCommercePost(integrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get integration metadata by ID. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Get integration metadata
     * @param {string} id Integration ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsGetById(id: string, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsGetById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get integration metadata list. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Get integration metadata list
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsGetList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsGetList(bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint receives batched logs from integration applications on partner platforms. Note: If you\'re interested in joining the beta, please reach out to your Pinterest account manager.
     * @summary Receives batched logs from integration applications.
     * @param {IntegrationLogsRequest} integrationLogsRequest Ingest log information from external integration application.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationsApi
     */
    public integrationsLogsPost(integrationLogsRequest: IntegrationLogsRequest, options?: RawAxiosRequestConfig) {
        return IntegrationsApiFp(this.configuration).integrationsLogsPost(integrationLogsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KeywordsApi - axios parameter creator
 * @export
 */
export const KeywordsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
         * @summary Get country\'s keyword metrics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
         * @param {Array<string>} keywords Comma-separated keywords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryKeywordsMetricsGet: async (adAccountId: string, countryCode: string, keywords: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('countryKeywordsMetricsGet', 'adAccountId', adAccountId)
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('countryKeywordsMetricsGet', 'countryCode', countryCode)
            // verify required parameter 'keywords' is not null or undefined
            assertParamExists('countryKeywordsMetricsGet', 'keywords', keywords)
            const localVarPath = `/ad_accounts/{ad_account_id}/keywords/metrics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (keywords) {
                localVarQueryParameter['keywords'] = keywords.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
         * @summary Create keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {KeywordsRequest} keywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keywordsCreate: async (adAccountId: string, keywordsRequest: KeywordsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('keywordsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'keywordsRequest' is not null or undefined
            assertParamExists('keywordsCreate', 'keywordsRequest', keywordsRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/keywords`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
         * @summary Get keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [campaignId] Campaign Id to use to filter the results.
         * @param {string} [adGroupId] Ad group Id.
         * @param {Array<MatchType>} [matchTypes] Keyword &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;/docs/api-features/targeting-overview/\&quot;&gt;match type&lt;/a&gt;
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keywordsGet: async (adAccountId: string, campaignId?: string, adGroupId?: string, matchTypes?: Array<MatchType>, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('keywordsGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/keywords`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (campaignId !== undefined) {
                localVarQueryParameter['campaign_id'] = campaignId;
            }

            if (adGroupId !== undefined) {
                localVarQueryParameter['ad_group_id'] = adGroupId;
            }

            if (matchTypes) {
                localVarQueryParameter['match_types'] = matchTypes;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
         * @summary Update keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {KeywordUpdateBody} keywordUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keywordsUpdate: async (adAccountId: string, keywordUpdateBody: KeywordUpdateBody, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('keywordsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'keywordUpdateBody' is not null or undefined
            assertParamExists('keywordsUpdate', 'keywordUpdateBody', keywordUpdateBody)
            const localVarPath = `/ad_accounts/{ad_account_id}/keywords`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(keywordUpdateBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
         * @summary List trending keywords
         * @param {TrendsSupportedRegion} region The geographic region of interest. Only top trends within the specified region will be returned.&lt;br /&gt; The &#x60;region&#x60; parameter is formatted as ISO 3166-2 country codes delimited by &#x60;+&#x60;, corresponding to the following geographic areas: - &#x60;US&#x60; - United States - &#x60;CA&#x60; - Canada - &#x60;DE&#x60; - Germany - &#x60;FR&#x60; - France - &#x60;ES&#x60; - Spain - &#x60;IT&#x60; - Italy - &#x60;DE+AT+CH&#x60; - Germanic countries - &#x60;GB+IE&#x60; - Great Britain &amp; Ireland - &#x60;IT+ES+PT+GR+MT&#x60; - Southern Europe - &#x60;PL+RO+HU+SK+CZ&#x60; - Eastern Europe - &#x60;SE+DK+FI+NO&#x60; - Nordic countries - &#x60;NL+BE+LU&#x60; - Benelux - &#x60;AR&#x60; - Argentina - &#x60;BR&#x60; - Brazil - &#x60;CO&#x60; - Colombia - &#x60;MX&#x60; - Mexico - &#x60;MX+AR+CO+CL&#x60; - Hispanic LatAm - &#x60;AU+NZ&#x60; - Australasia
         * @param {TrendType} trendType The methodology used to rank how trendy a keyword is. - &#x60;growing&#x60; trends have high upward growth in search volume over the last quarter - &#x60;monthly&#x60; trends have high search volume in the last month - &#x60;yearly&#x60; trends have high search volume in the last year - &#x60;seasonal&#x60; trends have high upward growth in search volume over the last month and exhibit a seasonal recurring pattern (typically annual)
         * @param {Array<TrendingKeywordsListInterestsEnum>} [interests] If set, filters the results to trends associated with the specified interests.&lt;br /&gt; If unset, trends for all interests will be returned.&lt;br /&gt; The list of supported interests is: - &#x60;animals&#x60; - Animals - &#x60;architecture&#x60; - Architecture - &#x60;art&#x60; - Art - &#x60;beauty&#x60; - Beauty - &#x60;childrens_fashion&#x60; - Children\&#39;s Fashion - &#x60;design&#x60; - Design - &#x60;diy_and_crafts&#x60; - DIY &amp; Crafts - &#x60;education&#x60; - Education - &#x60;electronics&#x60; - Electronics - &#x60;entertainment&#x60; - Entertainment - &#x60;event_planning&#x60; - Event Planning - &#x60;finance&#x60; - Finance - &#x60;food_and_drinks&#x60; - Food &amp; Drink - &#x60;gardening&#x60; - Gardening - &#x60;health&#x60; - Health - &#x60;home_decor&#x60; - Home Decor - &#x60;mens_fashion&#x60; - Men\&#39;s Fashion - &#x60;parenting&#x60; - Parenting - &#x60;quotes&#x60; - Quotes - &#x60;sport&#x60; - Sports - &#x60;travel&#x60; - Travel - &#x60;vehicles&#x60; - Vehicles - &#x60;wedding&#x60; - Wedding - &#x60;womens_fashion&#x60; - Women\&#39;s Fashion
         * @param {Array<TrendingKeywordsListGendersEnum>} [genders] If set, filters the results to trends among users who identify with the specified gender(s).&lt;br /&gt; If unset, trends among all genders will be returned.&lt;br /&gt; The &#x60;unknown&#x60; group includes users with unspecified or customized gender profile settings.
         * @param {Array<TrendingKeywordsListAgesEnum>} [ages] If set, filters the results to trends among users in the specified age range(s).&lt;br /&gt; If unset, trends among all age groups will be returned.
         * @param {Array<string>} [includeKeywords] If set, filters the results to top trends which include at least one of the specified keywords.&lt;br /&gt; If unset, no keyword filtering logic is applied.
         * @param {boolean} [normalizeAgainstGroup] Governs how the resulting time series data will be normalized to a [0-100] scale.&lt;br /&gt; By default (&#x60;false&#x60;), the data will be normalized independently for each keyword.  The peak search volume observation in *each* keyword\&#39;s time series will be represented by the value 100.  This is ideal for analyzing when an individual keyword is expected to peak in interest.&lt;br /&gt; If set to &#x60;true&#x60;, the data will be normalized as a group.  The peak search volume observation across *all* keywords in the response will be represented by the value 100, and all other values scaled accordingly.  Use this option when you wish to compare relative search volume between multiple keywords.
         * @param {number} [limit] The maximum number of trending keywords that will be returned. Keywords are returned in trend-ranked order, so a &#x60;limit&#x60; of 50 will return the top 50 trends.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingKeywordsList: async (region: TrendsSupportedRegion, trendType: TrendType, interests?: Array<TrendingKeywordsListInterestsEnum>, genders?: Array<TrendingKeywordsListGendersEnum>, ages?: Array<TrendingKeywordsListAgesEnum>, includeKeywords?: Array<string>, normalizeAgainstGroup?: boolean, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'region' is not null or undefined
            assertParamExists('trendingKeywordsList', 'region', region)
            // verify required parameter 'trendType' is not null or undefined
            assertParamExists('trendingKeywordsList', 'trendType', trendType)
            const localVarPath = `/trends/keywords/{region}/top/{trend_type}`
                .replace(`{${"region"}}`, encodeURIComponent(String(region)))
                .replace(`{${"trend_type"}}`, encodeURIComponent(String(trendType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            if (interests) {
                localVarQueryParameter['interests'] = interests;
            }

            if (genders) {
                localVarQueryParameter['genders'] = genders;
            }

            if (ages) {
                localVarQueryParameter['ages'] = ages;
            }

            if (includeKeywords) {
                localVarQueryParameter['include_keywords'] = includeKeywords;
            }

            if (normalizeAgainstGroup !== undefined) {
                localVarQueryParameter['normalize_against_group'] = normalizeAgainstGroup;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeywordsApi - functional programming interface
 * @export
 */
export const KeywordsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeywordsApiAxiosParamCreator(configuration)
    return {
        /**
         * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
         * @summary Get country\'s keyword metrics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
         * @param {Array<string>} keywords Comma-separated keywords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countryKeywordsMetricsGet(adAccountId: string, countryCode: string, keywords: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordsMetricsArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countryKeywordsMetricsGet(adAccountId, countryCode, keywords, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.countryKeywordsMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
         * @summary Create keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {KeywordsRequest} keywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keywordsCreate(adAccountId: string, keywordsRequest: KeywordsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keywordsCreate(adAccountId, keywordsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.keywordsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
         * @summary Get keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [campaignId] Campaign Id to use to filter the results.
         * @param {string} [adGroupId] Ad group Id.
         * @param {Array<MatchType>} [matchTypes] Keyword &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;/docs/api-features/targeting-overview/\&quot;&gt;match type&lt;/a&gt;
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keywordsGet(adAccountId: string, campaignId?: string, adGroupId?: string, matchTypes?: Array<MatchType>, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keywordsGet(adAccountId, campaignId, adGroupId, matchTypes, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.keywordsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
         * @summary Update keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {KeywordUpdateBody} keywordUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async keywordsUpdate(adAccountId: string, keywordUpdateBody: KeywordUpdateBody, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KeywordsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.keywordsUpdate(adAccountId, keywordUpdateBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.keywordsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
         * @summary List trending keywords
         * @param {TrendsSupportedRegion} region The geographic region of interest. Only top trends within the specified region will be returned.&lt;br /&gt; The &#x60;region&#x60; parameter is formatted as ISO 3166-2 country codes delimited by &#x60;+&#x60;, corresponding to the following geographic areas: - &#x60;US&#x60; - United States - &#x60;CA&#x60; - Canada - &#x60;DE&#x60; - Germany - &#x60;FR&#x60; - France - &#x60;ES&#x60; - Spain - &#x60;IT&#x60; - Italy - &#x60;DE+AT+CH&#x60; - Germanic countries - &#x60;GB+IE&#x60; - Great Britain &amp; Ireland - &#x60;IT+ES+PT+GR+MT&#x60; - Southern Europe - &#x60;PL+RO+HU+SK+CZ&#x60; - Eastern Europe - &#x60;SE+DK+FI+NO&#x60; - Nordic countries - &#x60;NL+BE+LU&#x60; - Benelux - &#x60;AR&#x60; - Argentina - &#x60;BR&#x60; - Brazil - &#x60;CO&#x60; - Colombia - &#x60;MX&#x60; - Mexico - &#x60;MX+AR+CO+CL&#x60; - Hispanic LatAm - &#x60;AU+NZ&#x60; - Australasia
         * @param {TrendType} trendType The methodology used to rank how trendy a keyword is. - &#x60;growing&#x60; trends have high upward growth in search volume over the last quarter - &#x60;monthly&#x60; trends have high search volume in the last month - &#x60;yearly&#x60; trends have high search volume in the last year - &#x60;seasonal&#x60; trends have high upward growth in search volume over the last month and exhibit a seasonal recurring pattern (typically annual)
         * @param {Array<TrendingKeywordsListInterestsEnum>} [interests] If set, filters the results to trends associated with the specified interests.&lt;br /&gt; If unset, trends for all interests will be returned.&lt;br /&gt; The list of supported interests is: - &#x60;animals&#x60; - Animals - &#x60;architecture&#x60; - Architecture - &#x60;art&#x60; - Art - &#x60;beauty&#x60; - Beauty - &#x60;childrens_fashion&#x60; - Children\&#39;s Fashion - &#x60;design&#x60; - Design - &#x60;diy_and_crafts&#x60; - DIY &amp; Crafts - &#x60;education&#x60; - Education - &#x60;electronics&#x60; - Electronics - &#x60;entertainment&#x60; - Entertainment - &#x60;event_planning&#x60; - Event Planning - &#x60;finance&#x60; - Finance - &#x60;food_and_drinks&#x60; - Food &amp; Drink - &#x60;gardening&#x60; - Gardening - &#x60;health&#x60; - Health - &#x60;home_decor&#x60; - Home Decor - &#x60;mens_fashion&#x60; - Men\&#39;s Fashion - &#x60;parenting&#x60; - Parenting - &#x60;quotes&#x60; - Quotes - &#x60;sport&#x60; - Sports - &#x60;travel&#x60; - Travel - &#x60;vehicles&#x60; - Vehicles - &#x60;wedding&#x60; - Wedding - &#x60;womens_fashion&#x60; - Women\&#39;s Fashion
         * @param {Array<TrendingKeywordsListGendersEnum>} [genders] If set, filters the results to trends among users who identify with the specified gender(s).&lt;br /&gt; If unset, trends among all genders will be returned.&lt;br /&gt; The &#x60;unknown&#x60; group includes users with unspecified or customized gender profile settings.
         * @param {Array<TrendingKeywordsListAgesEnum>} [ages] If set, filters the results to trends among users in the specified age range(s).&lt;br /&gt; If unset, trends among all age groups will be returned.
         * @param {Array<string>} [includeKeywords] If set, filters the results to top trends which include at least one of the specified keywords.&lt;br /&gt; If unset, no keyword filtering logic is applied.
         * @param {boolean} [normalizeAgainstGroup] Governs how the resulting time series data will be normalized to a [0-100] scale.&lt;br /&gt; By default (&#x60;false&#x60;), the data will be normalized independently for each keyword.  The peak search volume observation in *each* keyword\&#39;s time series will be represented by the value 100.  This is ideal for analyzing when an individual keyword is expected to peak in interest.&lt;br /&gt; If set to &#x60;true&#x60;, the data will be normalized as a group.  The peak search volume observation across *all* keywords in the response will be represented by the value 100, and all other values scaled accordingly.  Use this option when you wish to compare relative search volume between multiple keywords.
         * @param {number} [limit] The maximum number of trending keywords that will be returned. Keywords are returned in trend-ranked order, so a &#x60;limit&#x60; of 50 will return the top 50 trends.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trendingKeywordsList(region: TrendsSupportedRegion, trendType: TrendType, interests?: Array<TrendingKeywordsListInterestsEnum>, genders?: Array<TrendingKeywordsListGendersEnum>, ages?: Array<TrendingKeywordsListAgesEnum>, includeKeywords?: Array<string>, normalizeAgainstGroup?: boolean, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrendingKeywordsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trendingKeywordsList(region, trendType, interests, genders, ages, includeKeywords, normalizeAgainstGroup, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KeywordsApi.trendingKeywordsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KeywordsApi - factory interface
 * @export
 */
export const KeywordsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeywordsApiFp(configuration)
    return {
        /**
         * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
         * @summary Get country\'s keyword metrics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
         * @param {Array<string>} keywords Comma-separated keywords
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countryKeywordsMetricsGet(adAccountId: string, countryCode: string, keywords: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<KeywordsMetricsArrayResponse> {
            return localVarFp.countryKeywordsMetricsGet(adAccountId, countryCode, keywords, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
         * @summary Create keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {KeywordsRequest} keywordsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keywordsCreate(adAccountId: string, keywordsRequest: KeywordsRequest, options?: RawAxiosRequestConfig): AxiosPromise<KeywordsResponse> {
            return localVarFp.keywordsCreate(adAccountId, keywordsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
         * @summary Get keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} [campaignId] Campaign Id to use to filter the results.
         * @param {string} [adGroupId] Ad group Id.
         * @param {Array<MatchType>} [matchTypes] Keyword &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;/docs/api-features/targeting-overview/\&quot;&gt;match type&lt;/a&gt;
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keywordsGet(adAccountId: string, campaignId?: string, adGroupId?: string, matchTypes?: Array<MatchType>, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<KeywordsGet200Response> {
            return localVarFp.keywordsGet(adAccountId, campaignId, adGroupId, matchTypes, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
         * @summary Update keywords
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {KeywordUpdateBody} keywordUpdateBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        keywordsUpdate(adAccountId: string, keywordUpdateBody: KeywordUpdateBody, options?: RawAxiosRequestConfig): AxiosPromise<KeywordsResponse> {
            return localVarFp.keywordsUpdate(adAccountId, keywordUpdateBody, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
         * @summary List trending keywords
         * @param {TrendsSupportedRegion} region The geographic region of interest. Only top trends within the specified region will be returned.&lt;br /&gt; The &#x60;region&#x60; parameter is formatted as ISO 3166-2 country codes delimited by &#x60;+&#x60;, corresponding to the following geographic areas: - &#x60;US&#x60; - United States - &#x60;CA&#x60; - Canada - &#x60;DE&#x60; - Germany - &#x60;FR&#x60; - France - &#x60;ES&#x60; - Spain - &#x60;IT&#x60; - Italy - &#x60;DE+AT+CH&#x60; - Germanic countries - &#x60;GB+IE&#x60; - Great Britain &amp; Ireland - &#x60;IT+ES+PT+GR+MT&#x60; - Southern Europe - &#x60;PL+RO+HU+SK+CZ&#x60; - Eastern Europe - &#x60;SE+DK+FI+NO&#x60; - Nordic countries - &#x60;NL+BE+LU&#x60; - Benelux - &#x60;AR&#x60; - Argentina - &#x60;BR&#x60; - Brazil - &#x60;CO&#x60; - Colombia - &#x60;MX&#x60; - Mexico - &#x60;MX+AR+CO+CL&#x60; - Hispanic LatAm - &#x60;AU+NZ&#x60; - Australasia
         * @param {TrendType} trendType The methodology used to rank how trendy a keyword is. - &#x60;growing&#x60; trends have high upward growth in search volume over the last quarter - &#x60;monthly&#x60; trends have high search volume in the last month - &#x60;yearly&#x60; trends have high search volume in the last year - &#x60;seasonal&#x60; trends have high upward growth in search volume over the last month and exhibit a seasonal recurring pattern (typically annual)
         * @param {Array<TrendingKeywordsListInterestsEnum>} [interests] If set, filters the results to trends associated with the specified interests.&lt;br /&gt; If unset, trends for all interests will be returned.&lt;br /&gt; The list of supported interests is: - &#x60;animals&#x60; - Animals - &#x60;architecture&#x60; - Architecture - &#x60;art&#x60; - Art - &#x60;beauty&#x60; - Beauty - &#x60;childrens_fashion&#x60; - Children\&#39;s Fashion - &#x60;design&#x60; - Design - &#x60;diy_and_crafts&#x60; - DIY &amp; Crafts - &#x60;education&#x60; - Education - &#x60;electronics&#x60; - Electronics - &#x60;entertainment&#x60; - Entertainment - &#x60;event_planning&#x60; - Event Planning - &#x60;finance&#x60; - Finance - &#x60;food_and_drinks&#x60; - Food &amp; Drink - &#x60;gardening&#x60; - Gardening - &#x60;health&#x60; - Health - &#x60;home_decor&#x60; - Home Decor - &#x60;mens_fashion&#x60; - Men\&#39;s Fashion - &#x60;parenting&#x60; - Parenting - &#x60;quotes&#x60; - Quotes - &#x60;sport&#x60; - Sports - &#x60;travel&#x60; - Travel - &#x60;vehicles&#x60; - Vehicles - &#x60;wedding&#x60; - Wedding - &#x60;womens_fashion&#x60; - Women\&#39;s Fashion
         * @param {Array<TrendingKeywordsListGendersEnum>} [genders] If set, filters the results to trends among users who identify with the specified gender(s).&lt;br /&gt; If unset, trends among all genders will be returned.&lt;br /&gt; The &#x60;unknown&#x60; group includes users with unspecified or customized gender profile settings.
         * @param {Array<TrendingKeywordsListAgesEnum>} [ages] If set, filters the results to trends among users in the specified age range(s).&lt;br /&gt; If unset, trends among all age groups will be returned.
         * @param {Array<string>} [includeKeywords] If set, filters the results to top trends which include at least one of the specified keywords.&lt;br /&gt; If unset, no keyword filtering logic is applied.
         * @param {boolean} [normalizeAgainstGroup] Governs how the resulting time series data will be normalized to a [0-100] scale.&lt;br /&gt; By default (&#x60;false&#x60;), the data will be normalized independently for each keyword.  The peak search volume observation in *each* keyword\&#39;s time series will be represented by the value 100.  This is ideal for analyzing when an individual keyword is expected to peak in interest.&lt;br /&gt; If set to &#x60;true&#x60;, the data will be normalized as a group.  The peak search volume observation across *all* keywords in the response will be represented by the value 100, and all other values scaled accordingly.  Use this option when you wish to compare relative search volume between multiple keywords.
         * @param {number} [limit] The maximum number of trending keywords that will be returned. Keywords are returned in trend-ranked order, so a &#x60;limit&#x60; of 50 will return the top 50 trends.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trendingKeywordsList(region: TrendsSupportedRegion, trendType: TrendType, interests?: Array<TrendingKeywordsListInterestsEnum>, genders?: Array<TrendingKeywordsListGendersEnum>, ages?: Array<TrendingKeywordsListAgesEnum>, includeKeywords?: Array<string>, normalizeAgainstGroup?: boolean, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<TrendingKeywordsResponse> {
            return localVarFp.trendingKeywordsList(region, trendType, interests, genders, ages, includeKeywords, normalizeAgainstGroup, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeywordsApi - object-oriented interface
 * @export
 * @class KeywordsApi
 * @extends {BaseAPI}
 */
export class KeywordsApi extends BaseAPI {
    /**
     * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
     * @summary Get country\'s keyword metrics
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
     * @param {Array<string>} keywords Comma-separated keywords
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public countryKeywordsMetricsGet(adAccountId: string, countryCode: string, keywords: Array<string>, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).countryKeywordsMetricsGet(adAccountId, countryCode, keywords, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
     * @summary Create keywords
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {KeywordsRequest} keywordsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public keywordsCreate(adAccountId: string, keywordsRequest: KeywordsRequest, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).keywordsCreate(adAccountId, keywordsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
     * @summary Get keywords
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} [campaignId] Campaign Id to use to filter the results.
     * @param {string} [adGroupId] Ad group Id.
     * @param {Array<MatchType>} [matchTypes] Keyword &lt;a target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;/docs/api-features/targeting-overview/\&quot;&gt;match type&lt;/a&gt;
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public keywordsGet(adAccountId: string, campaignId?: string, adGroupId?: string, matchTypes?: Array<MatchType>, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).keywordsGet(adAccountId, campaignId, adGroupId, matchTypes, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
     * @summary Update keywords
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {KeywordUpdateBody} keywordUpdateBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public keywordsUpdate(adAccountId: string, keywordUpdateBody: KeywordUpdateBody, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).keywordsUpdate(adAccountId, keywordUpdateBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
     * @summary List trending keywords
     * @param {TrendsSupportedRegion} region The geographic region of interest. Only top trends within the specified region will be returned.&lt;br /&gt; The &#x60;region&#x60; parameter is formatted as ISO 3166-2 country codes delimited by &#x60;+&#x60;, corresponding to the following geographic areas: - &#x60;US&#x60; - United States - &#x60;CA&#x60; - Canada - &#x60;DE&#x60; - Germany - &#x60;FR&#x60; - France - &#x60;ES&#x60; - Spain - &#x60;IT&#x60; - Italy - &#x60;DE+AT+CH&#x60; - Germanic countries - &#x60;GB+IE&#x60; - Great Britain &amp; Ireland - &#x60;IT+ES+PT+GR+MT&#x60; - Southern Europe - &#x60;PL+RO+HU+SK+CZ&#x60; - Eastern Europe - &#x60;SE+DK+FI+NO&#x60; - Nordic countries - &#x60;NL+BE+LU&#x60; - Benelux - &#x60;AR&#x60; - Argentina - &#x60;BR&#x60; - Brazil - &#x60;CO&#x60; - Colombia - &#x60;MX&#x60; - Mexico - &#x60;MX+AR+CO+CL&#x60; - Hispanic LatAm - &#x60;AU+NZ&#x60; - Australasia
     * @param {TrendType} trendType The methodology used to rank how trendy a keyword is. - &#x60;growing&#x60; trends have high upward growth in search volume over the last quarter - &#x60;monthly&#x60; trends have high search volume in the last month - &#x60;yearly&#x60; trends have high search volume in the last year - &#x60;seasonal&#x60; trends have high upward growth in search volume over the last month and exhibit a seasonal recurring pattern (typically annual)
     * @param {Array<TrendingKeywordsListInterestsEnum>} [interests] If set, filters the results to trends associated with the specified interests.&lt;br /&gt; If unset, trends for all interests will be returned.&lt;br /&gt; The list of supported interests is: - &#x60;animals&#x60; - Animals - &#x60;architecture&#x60; - Architecture - &#x60;art&#x60; - Art - &#x60;beauty&#x60; - Beauty - &#x60;childrens_fashion&#x60; - Children\&#39;s Fashion - &#x60;design&#x60; - Design - &#x60;diy_and_crafts&#x60; - DIY &amp; Crafts - &#x60;education&#x60; - Education - &#x60;electronics&#x60; - Electronics - &#x60;entertainment&#x60; - Entertainment - &#x60;event_planning&#x60; - Event Planning - &#x60;finance&#x60; - Finance - &#x60;food_and_drinks&#x60; - Food &amp; Drink - &#x60;gardening&#x60; - Gardening - &#x60;health&#x60; - Health - &#x60;home_decor&#x60; - Home Decor - &#x60;mens_fashion&#x60; - Men\&#39;s Fashion - &#x60;parenting&#x60; - Parenting - &#x60;quotes&#x60; - Quotes - &#x60;sport&#x60; - Sports - &#x60;travel&#x60; - Travel - &#x60;vehicles&#x60; - Vehicles - &#x60;wedding&#x60; - Wedding - &#x60;womens_fashion&#x60; - Women\&#39;s Fashion
     * @param {Array<TrendingKeywordsListGendersEnum>} [genders] If set, filters the results to trends among users who identify with the specified gender(s).&lt;br /&gt; If unset, trends among all genders will be returned.&lt;br /&gt; The &#x60;unknown&#x60; group includes users with unspecified or customized gender profile settings.
     * @param {Array<TrendingKeywordsListAgesEnum>} [ages] If set, filters the results to trends among users in the specified age range(s).&lt;br /&gt; If unset, trends among all age groups will be returned.
     * @param {Array<string>} [includeKeywords] If set, filters the results to top trends which include at least one of the specified keywords.&lt;br /&gt; If unset, no keyword filtering logic is applied.
     * @param {boolean} [normalizeAgainstGroup] Governs how the resulting time series data will be normalized to a [0-100] scale.&lt;br /&gt; By default (&#x60;false&#x60;), the data will be normalized independently for each keyword.  The peak search volume observation in *each* keyword\&#39;s time series will be represented by the value 100.  This is ideal for analyzing when an individual keyword is expected to peak in interest.&lt;br /&gt; If set to &#x60;true&#x60;, the data will be normalized as a group.  The peak search volume observation across *all* keywords in the response will be represented by the value 100, and all other values scaled accordingly.  Use this option when you wish to compare relative search volume between multiple keywords.
     * @param {number} [limit] The maximum number of trending keywords that will be returned. Keywords are returned in trend-ranked order, so a &#x60;limit&#x60; of 50 will return the top 50 trends.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeywordsApi
     */
    public trendingKeywordsList(region: TrendsSupportedRegion, trendType: TrendType, interests?: Array<TrendingKeywordsListInterestsEnum>, genders?: Array<TrendingKeywordsListGendersEnum>, ages?: Array<TrendingKeywordsListAgesEnum>, includeKeywords?: Array<string>, normalizeAgainstGroup?: boolean, limit?: number, options?: RawAxiosRequestConfig) {
        return KeywordsApiFp(this.configuration).trendingKeywordsList(region, trendType, interests, genders, ages, includeKeywords, normalizeAgainstGroup, limit, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TrendingKeywordsListInterestsEnum = {
    Animals: 'animals',
    Architecture: 'architecture',
    Art: 'art',
    Beauty: 'beauty',
    ChildrensFashion: 'childrens_fashion',
    Design: 'design',
    DiyAndCrafts: 'diy_and_crafts',
    Education: 'education',
    Electronics: 'electronics',
    Entertainment: 'entertainment',
    EventPlanning: 'event_planning',
    Finance: 'finance',
    FoodAndDrinks: 'food_and_drinks',
    Gardening: 'gardening',
    Health: 'health',
    HomeDecor: 'home_decor',
    MensFashion: 'mens_fashion',
    Parenting: 'parenting',
    Quotes: 'quotes',
    Sport: 'sport',
    Travel: 'travel',
    Vehicles: 'vehicles',
    Wedding: 'wedding',
    WomensFashion: 'womens_fashion'
} as const;
export type TrendingKeywordsListInterestsEnum = typeof TrendingKeywordsListInterestsEnum[keyof typeof TrendingKeywordsListInterestsEnum];
/**
 * @export
 */
export const TrendingKeywordsListGendersEnum = {
    Female: 'female',
    Male: 'male',
    Unknown: 'unknown'
} as const;
export type TrendingKeywordsListGendersEnum = typeof TrendingKeywordsListGendersEnum[keyof typeof TrendingKeywordsListGendersEnum];
/**
 * @export
 */
export const TrendingKeywordsListAgesEnum = {
    _1824: '18-24',
    _2534: '25-34',
    _3544: '35-44',
    _4549: '45-49',
    _5054: '50-54',
    _5564: '55-64',
    _65: '65+'
} as const;
export type TrendingKeywordsListAgesEnum = typeof TrendingKeywordsListAgesEnum[keyof typeof TrendingKeywordsListAgesEnum];


/**
 * LeadAdsApi - axios parameter creator
 * @export
 */
export const LeadAdsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete an existing lead ads webhook subscription by ID. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Delete lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} subscriptionId Unique identifier of a subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsDelById: async (adAccountId: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountsSubscriptionsDelById', 'adAccountId', adAccountId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('adAccountsSubscriptionsDelById', 'subscriptionId', subscriptionId)
            const localVarPath = `/ad_accounts/{ad_account_id}/leads/subscriptions/{subscription_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific lead ads subscription record. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} subscriptionId Unique identifier of a subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsGetById: async (adAccountId: string, subscriptionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountsSubscriptionsGetById', 'adAccountId', adAccountId)
            // verify required parameter 'subscriptionId' is not null or undefined
            assertParamExists('adAccountsSubscriptionsGetById', 'subscriptionId', subscriptionId)
            const localVarPath = `/ad_accounts/{ad_account_id}/leads/subscriptions/{subscription_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"subscription_id"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the advertiser\'s list of lead ads subscriptions. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead ads subscriptions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsGetList: async (adAccountId: string, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountsSubscriptionsGetList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/leads/subscriptions`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a lead ads webhook subscription. Subscriptions allow Pinterest to deliver lead data from Ads Manager directly to the subscriber. Subscriptions can exist for a specific lead form or at ad account level. - Only requests for the OWNER or ADMIN of the ad_account will be allowed. - Advertisers can set up multiple integrations using ad_account_id + lead_form_id but only one integration per unique records. - For data security, egress lead data is encrypted with AES-256-GCM.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Create lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdAccountCreateSubscriptionRequest} adAccountCreateSubscriptionRequest Subscription to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsPost: async (adAccountId: string, adAccountCreateSubscriptionRequest: AdAccountCreateSubscriptionRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('adAccountsSubscriptionsPost', 'adAccountId', adAccountId)
            // verify required parameter 'adAccountCreateSubscriptionRequest' is not null or undefined
            assertParamExists('adAccountsSubscriptionsPost', 'adAccountCreateSubscriptionRequest', adAccountCreateSubscriptionRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/leads/subscriptions`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adAccountCreateSubscriptionRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadAdsApi - functional programming interface
 * @export
 */
export const LeadAdsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeadAdsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete an existing lead ads webhook subscription by ID. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Delete lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} subscriptionId Unique identifier of a subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsSubscriptionsDelById(adAccountId: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsSubscriptionsDelById(adAccountId, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadAdsApi.adAccountsSubscriptionsDelById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a specific lead ads subscription record. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} subscriptionId Unique identifier of a subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsSubscriptionsGetById(adAccountId: string, subscriptionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountGetSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsSubscriptionsGetById(adAccountId, subscriptionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadAdsApi.adAccountsSubscriptionsGetById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the advertiser\'s list of lead ads subscriptions. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead ads subscriptions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsSubscriptionsGetList(adAccountId: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountsSubscriptionsGetList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsSubscriptionsGetList(adAccountId, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadAdsApi.adAccountsSubscriptionsGetList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a lead ads webhook subscription. Subscriptions allow Pinterest to deliver lead data from Ads Manager directly to the subscriber. Subscriptions can exist for a specific lead form or at ad account level. - Only requests for the OWNER or ADMIN of the ad_account will be allowed. - Advertisers can set up multiple integrations using ad_account_id + lead_form_id but only one integration per unique records. - For data security, egress lead data is encrypted with AES-256-GCM.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Create lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdAccountCreateSubscriptionRequest} adAccountCreateSubscriptionRequest Subscription to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountsSubscriptionsPost(adAccountId: string, adAccountCreateSubscriptionRequest: AdAccountCreateSubscriptionRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountCreateSubscriptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountsSubscriptionsPost(adAccountId, adAccountCreateSubscriptionRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadAdsApi.adAccountsSubscriptionsPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeadAdsApi - factory interface
 * @export
 */
export const LeadAdsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadAdsApiFp(configuration)
    return {
        /**
         * Delete an existing lead ads webhook subscription by ID. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Delete lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} subscriptionId Unique identifier of a subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsDelById(adAccountId: string, subscriptionId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.adAccountsSubscriptionsDelById(adAccountId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific lead ads subscription record. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} subscriptionId Unique identifier of a subscription.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsGetById(adAccountId: string, subscriptionId: string, options?: RawAxiosRequestConfig): AxiosPromise<AdAccountGetSubscriptionResponse> {
            return localVarFp.adAccountsSubscriptionsGetById(adAccountId, subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the advertiser\'s list of lead ads subscriptions. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead ads subscriptions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsGetList(adAccountId: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<AdAccountsSubscriptionsGetList200Response> {
            return localVarFp.adAccountsSubscriptionsGetList(adAccountId, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a lead ads webhook subscription. Subscriptions allow Pinterest to deliver lead data from Ads Manager directly to the subscriber. Subscriptions can exist for a specific lead form or at ad account level. - Only requests for the OWNER or ADMIN of the ad_account will be allowed. - Advertisers can set up multiple integrations using ad_account_id + lead_form_id but only one integration per unique records. - For data security, egress lead data is encrypted with AES-256-GCM.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Create lead ads subscription
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {AdAccountCreateSubscriptionRequest} adAccountCreateSubscriptionRequest Subscription to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountsSubscriptionsPost(adAccountId: string, adAccountCreateSubscriptionRequest: AdAccountCreateSubscriptionRequest, options?: RawAxiosRequestConfig): AxiosPromise<AdAccountCreateSubscriptionResponse> {
            return localVarFp.adAccountsSubscriptionsPost(adAccountId, adAccountCreateSubscriptionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeadAdsApi - object-oriented interface
 * @export
 * @class LeadAdsApi
 * @extends {BaseAPI}
 */
export class LeadAdsApi extends BaseAPI {
    /**
     * Delete an existing lead ads webhook subscription by ID. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Delete lead ads subscription
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} subscriptionId Unique identifier of a subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadAdsApi
     */
    public adAccountsSubscriptionsDelById(adAccountId: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return LeadAdsApiFp(this.configuration).adAccountsSubscriptionsDelById(adAccountId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific lead ads subscription record. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Get lead ads subscription
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} subscriptionId Unique identifier of a subscription.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadAdsApi
     */
    public adAccountsSubscriptionsGetById(adAccountId: string, subscriptionId: string, options?: RawAxiosRequestConfig) {
        return LeadAdsApiFp(this.configuration).adAccountsSubscriptionsGetById(adAccountId, subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the advertiser\'s list of lead ads subscriptions. - Only requests for the OWNER or ADMIN of the ad_account will be allowed.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Get lead ads subscriptions
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadAdsApi
     */
    public adAccountsSubscriptionsGetList(adAccountId: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return LeadAdsApiFp(this.configuration).adAccountsSubscriptionsGetList(adAccountId, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a lead ads webhook subscription. Subscriptions allow Pinterest to deliver lead data from Ads Manager directly to the subscriber. Subscriptions can exist for a specific lead form or at ad account level. - Only requests for the OWNER or ADMIN of the ad_account will be allowed. - Advertisers can set up multiple integrations using ad_account_id + lead_form_id but only one integration per unique records. - For data security, egress lead data is encrypted with AES-256-GCM.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Create lead ads subscription
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {AdAccountCreateSubscriptionRequest} adAccountCreateSubscriptionRequest Subscription to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadAdsApi
     */
    public adAccountsSubscriptionsPost(adAccountId: string, adAccountCreateSubscriptionRequest: AdAccountCreateSubscriptionRequest, options?: RawAxiosRequestConfig) {
        return LeadAdsApiFp(this.configuration).adAccountsSubscriptionsPost(adAccountId, adAccountCreateSubscriptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LeadFormsApi - axios parameter creator
 * @export
 */
export const LeadFormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Gets a lead form given it\'s ID. It must also be associated with the provided ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Get lead form by id
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadFormId Unique identifier of a lead form.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormGet: async (adAccountId: string, leadFormId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadFormGet', 'adAccountId', adAccountId)
            // verify required parameter 'leadFormId' is not null or undefined
            assertParamExists('leadFormGet', 'leadFormId', leadFormId)
            const localVarPath = `/ad_accounts/{ad_account_id}/lead_forms/{lead_form_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"lead_form_id"}}`, encodeURIComponent(String(leadFormId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create lead form test data based on the list of answers provided as part of the body. - List of answers should follow the questions creation order.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Create lead form test data
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadFormId Unique identifier of a lead form.
         * @param {LeadFormTestRequest} leadFormTestRequest Subscription to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormTestCreate: async (adAccountId: string, leadFormId: string, leadFormTestRequest: LeadFormTestRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadFormTestCreate', 'adAccountId', adAccountId)
            // verify required parameter 'leadFormId' is not null or undefined
            assertParamExists('leadFormTestCreate', 'leadFormId', leadFormId)
            // verify required parameter 'leadFormTestRequest' is not null or undefined
            assertParamExists('leadFormTestCreate', 'leadFormTestRequest', leadFormTestRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/lead_forms/{lead_form_id}/test`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"lead_form_id"}}`, encodeURIComponent(String(leadFormId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leadFormTestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create lead forms. Lead forms are used in lead ads and allow you to control what text appears on the lead form s description, questions and confirmation sections.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Create lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<LeadFormCreateRequest>} leadFormCreateRequest List of lead forms to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormsCreate: async (adAccountId: string, leadFormCreateRequest: Array<LeadFormCreateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadFormsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'leadFormCreateRequest' is not null or undefined
            assertParamExists('leadFormsCreate', 'leadFormCreateRequest', leadFormCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/lead_forms`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leadFormCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  List lead forms associated with an ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary List lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {LeadFormsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormsList: async (adAccountId: string, pageSize?: number, order?: LeadFormsListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadFormsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/lead_forms`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Update lead forms. Lead ads help you reach people who are actively looking for, and interested in, your goods and services. The lead form can be associated with an ad to allow people to fill out the form.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Update lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<LeadFormUpdateRequest>} leadFormUpdateRequest List of lead forms to update, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormsUpdate: async (adAccountId: string, leadFormUpdateRequest: Array<LeadFormUpdateRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadFormsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'leadFormUpdateRequest' is not null or undefined
            assertParamExists('leadFormsUpdate', 'leadFormUpdateRequest', leadFormUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/lead_forms`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leadFormUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadFormsApi - functional programming interface
 * @export
 */
export const LeadFormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeadFormsApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Gets a lead form given it\'s ID. It must also be associated with the provided ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Get lead form by id
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadFormId Unique identifier of a lead form.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadFormGet(adAccountId: string, leadFormId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadFormResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadFormGet(adAccountId, leadFormId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadFormsApi.leadFormGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create lead form test data based on the list of answers provided as part of the body. - List of answers should follow the questions creation order.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Create lead form test data
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadFormId Unique identifier of a lead form.
         * @param {LeadFormTestRequest} leadFormTestRequest Subscription to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadFormTestCreate(adAccountId: string, leadFormId: string, leadFormTestRequest: LeadFormTestRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadFormTestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadFormTestCreate(adAccountId, leadFormId, leadFormTestRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadFormsApi.leadFormTestCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create lead forms. Lead forms are used in lead ads and allow you to control what text appears on the lead form s description, questions and confirmation sections.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Create lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<LeadFormCreateRequest>} leadFormCreateRequest List of lead forms to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadFormsCreate(adAccountId: string, leadFormCreateRequest: Array<LeadFormCreateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadFormArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadFormsCreate(adAccountId, leadFormCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadFormsApi.leadFormsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  List lead forms associated with an ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary List lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {LeadFormsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadFormsList(adAccountId: string, pageSize?: number, order?: LeadFormsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadFormsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadFormsList(adAccountId, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadFormsApi.leadFormsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Update lead forms. Lead ads help you reach people who are actively looking for, and interested in, your goods and services. The lead form can be associated with an ad to allow people to fill out the form.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Update lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<LeadFormUpdateRequest>} leadFormUpdateRequest List of lead forms to update, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadFormsUpdate(adAccountId: string, leadFormUpdateRequest: Array<LeadFormUpdateRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadFormArrayResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadFormsUpdate(adAccountId, leadFormUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadFormsApi.leadFormsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeadFormsApi - factory interface
 * @export
 */
export const LeadFormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadFormsApiFp(configuration)
    return {
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Gets a lead form given it\'s ID. It must also be associated with the provided ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Get lead form by id
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadFormId Unique identifier of a lead form.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormGet(adAccountId: string, leadFormId: string, options?: RawAxiosRequestConfig): AxiosPromise<LeadFormResponse> {
            return localVarFp.leadFormGet(adAccountId, leadFormId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create lead form test data based on the list of answers provided as part of the body. - List of answers should follow the questions creation order.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Create lead form test data
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadFormId Unique identifier of a lead form.
         * @param {LeadFormTestRequest} leadFormTestRequest Subscription to create.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormTestCreate(adAccountId: string, leadFormId: string, leadFormTestRequest: LeadFormTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<LeadFormTestResponse> {
            return localVarFp.leadFormTestCreate(adAccountId, leadFormId, leadFormTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create lead forms. Lead forms are used in lead ads and allow you to control what text appears on the lead form s description, questions and confirmation sections.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Create lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<LeadFormCreateRequest>} leadFormCreateRequest List of lead forms to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormsCreate(adAccountId: string, leadFormCreateRequest: Array<LeadFormCreateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<LeadFormArrayResponse> {
            return localVarFp.leadFormsCreate(adAccountId, leadFormCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  List lead forms associated with an ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary List lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {LeadFormsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormsList(adAccountId: string, pageSize?: number, order?: LeadFormsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<LeadFormsList200Response> {
            return localVarFp.leadFormsList(adAccountId, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Update lead forms. Lead ads help you reach people who are actively looking for, and interested in, your goods and services. The lead form can be associated with an ad to allow people to fill out the form.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Update lead forms
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<LeadFormUpdateRequest>} leadFormUpdateRequest List of lead forms to update, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormsUpdate(adAccountId: string, leadFormUpdateRequest: Array<LeadFormUpdateRequest>, options?: RawAxiosRequestConfig): AxiosPromise<LeadFormArrayResponse> {
            return localVarFp.leadFormsUpdate(adAccountId, leadFormUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeadFormsApi - object-oriented interface
 * @export
 * @class LeadFormsApi
 * @extends {BaseAPI}
 */
export class LeadFormsApi extends BaseAPI {
    /**
     * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Gets a lead form given it\'s ID. It must also be associated with the provided ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
     * @summary Get lead form by id
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} leadFormId Unique identifier of a lead form.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadFormsApi
     */
    public leadFormGet(adAccountId: string, leadFormId: string, options?: RawAxiosRequestConfig) {
        return LeadFormsApiFp(this.configuration).leadFormGet(adAccountId, leadFormId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create lead form test data based on the list of answers provided as part of the body. - List of answers should follow the questions creation order.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Create lead form test data
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} leadFormId Unique identifier of a lead form.
     * @param {LeadFormTestRequest} leadFormTestRequest Subscription to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadFormsApi
     */
    public leadFormTestCreate(adAccountId: string, leadFormId: string, leadFormTestRequest: LeadFormTestRequest, options?: RawAxiosRequestConfig) {
        return LeadFormsApiFp(this.configuration).leadFormTestCreate(adAccountId, leadFormId, leadFormTestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create lead forms. Lead forms are used in lead ads and allow you to control what text appears on the lead form s description, questions and confirmation sections.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
     * @summary Create lead forms
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<LeadFormCreateRequest>} leadFormCreateRequest List of lead forms to create, size limit [1, 30].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadFormsApi
     */
    public leadFormsCreate(adAccountId: string, leadFormCreateRequest: Array<LeadFormCreateRequest>, options?: RawAxiosRequestConfig) {
        return LeadFormsApiFp(this.configuration).leadFormsCreate(adAccountId, leadFormCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  List lead forms associated with an ad account ID.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
     * @summary List lead forms
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {LeadFormsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadFormsApi
     */
    public leadFormsList(adAccountId: string, pageSize?: number, order?: LeadFormsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return LeadFormsApiFp(this.configuration).leadFormsList(adAccountId, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Update lead forms. Lead ads help you reach people who are actively looking for, and interested in, your goods and services. The lead form can be associated with an ad to allow people to fill out the form.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
     * @summary Update lead forms
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<LeadFormUpdateRequest>} leadFormUpdateRequest List of lead forms to update, size limit [1, 30].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadFormsApi
     */
    public leadFormsUpdate(adAccountId: string, leadFormUpdateRequest: Array<LeadFormUpdateRequest>, options?: RawAxiosRequestConfig) {
        return LeadFormsApiFp(this.configuration).leadFormsUpdate(adAccountId, leadFormUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const LeadFormsListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type LeadFormsListOrderEnum = typeof LeadFormsListOrderEnum[keyof typeof LeadFormsListOrderEnum];


/**
 * LeadsExportApi - axios parameter creator
 * @export
 */
export const LeadsExportApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create an export of leads collected from a lead ad. This returns a lead_export_id  token that you can use to download the export when it is ready.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Create a request to export leads collected from a lead ad
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {LeadsExportCreateRequest} leadsExportCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadsExportCreate: async (adAccountId: string, leadsExportCreateRequest: LeadsExportCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadsExportCreate', 'adAccountId', adAccountId)
            // verify required parameter 'leadsExportCreateRequest' is not null or undefined
            assertParamExists('leadsExportCreate', 'leadsExportCreateRequest', leadsExportCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/leads_export`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(leadsExportCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Get the export of leads collected from a lead ad. This returns a URL to a list of lead export given a lead_export_id token returned from the create a lead export call. You can use the URL to download the report.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Get the lead export from the lead export create call
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadsExportId lead_export_id token returned from the create a lead export endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadsExportGet: async (adAccountId: string, leadsExportId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('leadsExportGet', 'adAccountId', adAccountId)
            // verify required parameter 'leadsExportId' is not null or undefined
            assertParamExists('leadsExportGet', 'leadsExportId', leadsExportId)
            const localVarPath = `/ad_accounts/{ad_account_id}/leads_export/{leads_export_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"leads_export_id"}}`, encodeURIComponent(String(leadsExportId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LeadsExportApi - functional programming interface
 * @export
 */
export const LeadsExportApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LeadsExportApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create an export of leads collected from a lead ad. This returns a lead_export_id  token that you can use to download the export when it is ready.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Create a request to export leads collected from a lead ad
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {LeadsExportCreateRequest} leadsExportCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadsExportCreate(adAccountId: string, leadsExportCreateRequest: LeadsExportCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadsExportCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadsExportCreate(adAccountId, leadsExportCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadsExportApi.leadsExportCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Get the export of leads collected from a lead ad. This returns a URL to a list of lead export given a lead_export_id token returned from the create a lead export call. You can use the URL to download the report.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Get the lead export from the lead export create call
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadsExportId lead_export_id token returned from the create a lead export endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadsExportGet(adAccountId: string, leadsExportId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LeadsExportResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadsExportGet(adAccountId, leadsExportId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LeadsExportApi.leadsExportGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LeadsExportApi - factory interface
 * @export
 */
export const LeadsExportApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LeadsExportApiFp(configuration)
    return {
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create an export of leads collected from a lead ad. This returns a lead_export_id  token that you can use to download the export when it is ready.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Create a request to export leads collected from a lead ad
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {LeadsExportCreateRequest} leadsExportCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadsExportCreate(adAccountId: string, leadsExportCreateRequest: LeadsExportCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<LeadsExportCreateResponse> {
            return localVarFp.leadsExportCreate(adAccountId, leadsExportCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Get the export of leads collected from a lead ad. This returns a URL to a list of lead export given a lead_export_id token returned from the create a lead export call. You can use the URL to download the report.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
         * @summary Get the lead export from the lead export create call
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} leadsExportId lead_export_id token returned from the create a lead export endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadsExportGet(adAccountId: string, leadsExportId: string, options?: RawAxiosRequestConfig): AxiosPromise<LeadsExportResponseData> {
            return localVarFp.leadsExportGet(adAccountId, leadsExportId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LeadsExportApi - object-oriented interface
 * @export
 * @class LeadsExportApi
 * @extends {BaseAPI}
 */
export class LeadsExportApi extends BaseAPI {
    /**
     * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Create an export of leads collected from a lead ad. This returns a lead_export_id  token that you can use to download the export when it is ready.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
     * @summary Create a request to export leads collected from a lead ad
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {LeadsExportCreateRequest} leadsExportCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsExportApi
     */
    public leadsExportCreate(adAccountId: string, leadsExportCreateRequest: LeadsExportCreateRequest, options?: RawAxiosRequestConfig) {
        return LeadsExportApiFp(this.configuration).leadsExportCreate(adAccountId, leadsExportCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>This feature is currently in beta and not available to all apps, if you\'re interested in joining the beta, please reach out to your Pinterest account manager.</strong>  Get the export of leads collected from a lead ad. This returns a URL to a list of lead export given a lead_export_id token returned from the create a lead export call. You can use the URL to download the report.  Note: Lead ad data will be available up to 30 days after the lead has been submitted.  For more, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/lead-ads\">Lead ads</a>.
     * @summary Get the lead export from the lead export create call
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} leadsExportId lead_export_id token returned from the create a lead export endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LeadsExportApi
     */
    public leadsExportGet(adAccountId: string, leadsExportId: string, options?: RawAxiosRequestConfig) {
        return LeadsExportApiFp(this.configuration).leadsExportGet(adAccountId, leadsExportId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MediaApi - axios parameter creator
 * @export
 */
export const MediaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Register your intent to upload media  The response includes all of the information needed to upload the media to Pinterest.  To upload the media, make an HTTP POST request (using <tt>curl</tt>, for example) to <tt>upload_url</tt> using the <tt>Content-Type</tt> header value. Send the media file\'s contents as the request\'s <tt>file</tt> parameter and also include all of the parameters from <tt>upload_parameters</tt>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Register media upload
         * @param {MediaUploadRequest} mediaUploadRequest Create a media upload request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaCreate: async (mediaUploadRequest: MediaUploadRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaUploadRequest' is not null or undefined
            assertParamExists('mediaCreate', 'mediaUploadRequest', mediaUploadRequest)
            const localVarPath = `/media`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["pins:read", "pins:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mediaUploadRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details for a registered media upload, including its current status.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Get media upload details
         * @param {string} mediaId Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaGet: async (mediaId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mediaId' is not null or undefined
            assertParamExists('mediaGet', 'mediaId', mediaId)
            const localVarPath = `/media/{media_id}`
                .replace(`{${"media_id"}}`, encodeURIComponent(String(mediaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["pins:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List media uploads filtered by given parameters.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary List media uploads
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaList: async (bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/media`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["pins:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MediaApi - functional programming interface
 * @export
 */
export const MediaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MediaApiAxiosParamCreator(configuration)
    return {
        /**
         * Register your intent to upload media  The response includes all of the information needed to upload the media to Pinterest.  To upload the media, make an HTTP POST request (using <tt>curl</tt>, for example) to <tt>upload_url</tt> using the <tt>Content-Type</tt> header value. Send the media file\'s contents as the request\'s <tt>file</tt> parameter and also include all of the parameters from <tt>upload_parameters</tt>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Register media upload
         * @param {MediaUploadRequest} mediaUploadRequest Create a media upload request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaCreate(mediaUploadRequest: MediaUploadRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaUpload>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaCreate(mediaUploadRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get details for a registered media upload, including its current status.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Get media upload details
         * @param {string} mediaId Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaGet(mediaId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaUploadDetails>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaGet(mediaId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List media uploads filtered by given parameters.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary List media uploads
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mediaList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MediaList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mediaList(bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MediaApi.mediaList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MediaApi - factory interface
 * @export
 */
export const MediaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MediaApiFp(configuration)
    return {
        /**
         * Register your intent to upload media  The response includes all of the information needed to upload the media to Pinterest.  To upload the media, make an HTTP POST request (using <tt>curl</tt>, for example) to <tt>upload_url</tt> using the <tt>Content-Type</tt> header value. Send the media file\'s contents as the request\'s <tt>file</tt> parameter and also include all of the parameters from <tt>upload_parameters</tt>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Register media upload
         * @param {MediaUploadRequest} mediaUploadRequest Create a media upload request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaCreate(mediaUploadRequest: MediaUploadRequest, options?: RawAxiosRequestConfig): AxiosPromise<MediaUpload> {
            return localVarFp.mediaCreate(mediaUploadRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details for a registered media upload, including its current status.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Get media upload details
         * @param {string} mediaId Media identifier
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaGet(mediaId: string, options?: RawAxiosRequestConfig): AxiosPromise<MediaUploadDetails> {
            return localVarFp.mediaGet(mediaId, options).then((request) => request(axios, basePath));
        },
        /**
         * List media uploads filtered by given parameters.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary List media uploads
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mediaList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<MediaList200Response> {
            return localVarFp.mediaList(bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MediaApi - object-oriented interface
 * @export
 * @class MediaApi
 * @extends {BaseAPI}
 */
export class MediaApi extends BaseAPI {
    /**
     * Register your intent to upload media  The response includes all of the information needed to upload the media to Pinterest.  To upload the media, make an HTTP POST request (using <tt>curl</tt>, for example) to <tt>upload_url</tt> using the <tt>Content-Type</tt> header value. Send the media file\'s contents as the request\'s <tt>file</tt> parameter and also include all of the parameters from <tt>upload_parameters</tt>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
     * @summary Register media upload
     * @param {MediaUploadRequest} mediaUploadRequest Create a media upload request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaCreate(mediaUploadRequest: MediaUploadRequest, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaCreate(mediaUploadRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details for a registered media upload, including its current status.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
     * @summary Get media upload details
     * @param {string} mediaId Media identifier
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaGet(mediaId: string, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaGet(mediaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List media uploads filtered by given parameters.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
     * @summary List media uploads
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MediaApi
     */
    public mediaList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return MediaApiFp(this.configuration).mediaList(bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OauthApi - axios parameter creator
 * @export
 */
export const OauthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Generate an OAuth access token by using an authorization code or a refresh token.  IMPORTANT: You need to start the OAuth flow via www.pinterest.com/oauth before calling this endpoint (or have an existing refresh token).  See <a href=\'/docs/getting-started/authentication-and-scopes/\'>Authentication</a> for more.  <strong>Parameter <i>refresh_on</i> and its corresponding response type <i>everlasting_refresh</i> are now available to all apps! Later this year, continuous refresh will become the default behavior (ie you will no longer need to send this parameter). <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  <strong>Grant type <i>client_credentials</i> and its corresponding response type are not fully available. You will likely get a default error if you attempt to use this grant_type.</strong>
         * @summary Generate OAuth access token
         * @param {OauthTokenGrantTypeEnum} grantType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthToken: async (grantType: OauthTokenGrantTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('oauthToken', 'grantType', grantType)
            const localVarPath = `/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication basic required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OauthApi - functional programming interface
 * @export
 */
export const OauthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OauthApiAxiosParamCreator(configuration)
    return {
        /**
         * Generate an OAuth access token by using an authorization code or a refresh token.  IMPORTANT: You need to start the OAuth flow via www.pinterest.com/oauth before calling this endpoint (or have an existing refresh token).  See <a href=\'/docs/getting-started/authentication-and-scopes/\'>Authentication</a> for more.  <strong>Parameter <i>refresh_on</i> and its corresponding response type <i>everlasting_refresh</i> are now available to all apps! Later this year, continuous refresh will become the default behavior (ie you will no longer need to send this parameter). <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  <strong>Grant type <i>client_credentials</i> and its corresponding response type are not fully available. You will likely get a default error if you attempt to use this grant_type.</strong>
         * @summary Generate OAuth access token
         * @param {OauthTokenGrantTypeEnum} grantType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oauthToken(grantType: OauthTokenGrantTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OauthAccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oauthToken(grantType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OauthApi.oauthToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OauthApi - factory interface
 * @export
 */
export const OauthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OauthApiFp(configuration)
    return {
        /**
         * Generate an OAuth access token by using an authorization code or a refresh token.  IMPORTANT: You need to start the OAuth flow via www.pinterest.com/oauth before calling this endpoint (or have an existing refresh token).  See <a href=\'/docs/getting-started/authentication-and-scopes/\'>Authentication</a> for more.  <strong>Parameter <i>refresh_on</i> and its corresponding response type <i>everlasting_refresh</i> are now available to all apps! Later this year, continuous refresh will become the default behavior (ie you will no longer need to send this parameter). <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  <strong>Grant type <i>client_credentials</i> and its corresponding response type are not fully available. You will likely get a default error if you attempt to use this grant_type.</strong>
         * @summary Generate OAuth access token
         * @param {OauthTokenGrantTypeEnum} grantType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oauthToken(grantType: OauthTokenGrantTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<OauthAccessTokenResponse> {
            return localVarFp.oauthToken(grantType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OauthApi - object-oriented interface
 * @export
 * @class OauthApi
 * @extends {BaseAPI}
 */
export class OauthApi extends BaseAPI {
    /**
     * Generate an OAuth access token by using an authorization code or a refresh token.  IMPORTANT: You need to start the OAuth flow via www.pinterest.com/oauth before calling this endpoint (or have an existing refresh token).  See <a href=\'/docs/getting-started/authentication-and-scopes/\'>Authentication</a> for more.  <strong>Parameter <i>refresh_on</i> and its corresponding response type <i>everlasting_refresh</i> are now available to all apps! Later this year, continuous refresh will become the default behavior (ie you will no longer need to send this parameter). <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  <strong>Grant type <i>client_credentials</i> and its corresponding response type are not fully available. You will likely get a default error if you attempt to use this grant_type.</strong>
     * @summary Generate OAuth access token
     * @param {OauthTokenGrantTypeEnum} grantType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OauthApi
     */
    public oauthToken(grantType: OauthTokenGrantTypeEnum, options?: RawAxiosRequestConfig) {
        return OauthApiFp(this.configuration).oauthToken(grantType, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OauthTokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code',
    RefreshToken: 'refresh_token',
    ClientCredentials: 'client_credentials'
} as const;
export type OauthTokenGrantTypeEnum = typeof OauthTokenGrantTypeEnum[keyof typeof OauthTokenGrantTypeEnum];


/**
 * OrderLinesApi - axios parameter creator
 * @export
 */
export const OrderLinesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a specific existing order line associated with an ad account.
         * @summary Get order line
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} orderLineId Unique identifier of an order line.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderLinesGet: async (adAccountId: string, orderLineId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('orderLinesGet', 'adAccountId', adAccountId)
            // verify required parameter 'orderLineId' is not null or undefined
            assertParamExists('orderLinesGet', 'orderLineId', orderLineId)
            const localVarPath = `/ad_accounts/{ad_account_id}/order_lines/{order_line_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"order_line_id"}}`, encodeURIComponent(String(orderLineId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing order lines associated with an ad account.
         * @summary Get order lines
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {OrderLinesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderLinesList: async (adAccountId: string, pageSize?: number, order?: OrderLinesListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('orderLinesList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/order_lines`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderLinesApi - functional programming interface
 * @export
 */
export const OrderLinesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderLinesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a specific existing order line associated with an ad account.
         * @summary Get order line
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} orderLineId Unique identifier of an order line.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderLinesGet(adAccountId: string, orderLineId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLine>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderLinesGet(adAccountId, orderLineId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderLinesApi.orderLinesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing order lines associated with an ad account.
         * @summary Get order lines
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {OrderLinesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderLinesList(adAccountId: string, pageSize?: number, order?: OrderLinesListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderLinesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderLinesList(adAccountId, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderLinesApi.orderLinesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderLinesApi - factory interface
 * @export
 */
export const OrderLinesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderLinesApiFp(configuration)
    return {
        /**
         * Get a specific existing order line associated with an ad account.
         * @summary Get order line
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} orderLineId Unique identifier of an order line.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderLinesGet(adAccountId: string, orderLineId: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderLine> {
            return localVarFp.orderLinesGet(adAccountId, orderLineId, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing order lines associated with an ad account.
         * @summary Get order lines
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {OrderLinesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderLinesList(adAccountId: string, pageSize?: number, order?: OrderLinesListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<OrderLinesList200Response> {
            return localVarFp.orderLinesList(adAccountId, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderLinesApi - object-oriented interface
 * @export
 * @class OrderLinesApi
 * @extends {BaseAPI}
 */
export class OrderLinesApi extends BaseAPI {
    /**
     * Get a specific existing order line associated with an ad account.
     * @summary Get order line
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} orderLineId Unique identifier of an order line.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderLinesApi
     */
    public orderLinesGet(adAccountId: string, orderLineId: string, options?: RawAxiosRequestConfig) {
        return OrderLinesApiFp(this.configuration).orderLinesGet(adAccountId, orderLineId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing order lines associated with an ad account.
     * @summary Get order lines
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {OrderLinesListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderLinesApi
     */
    public orderLinesList(adAccountId: string, pageSize?: number, order?: OrderLinesListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return OrderLinesApiFp(this.configuration).orderLinesList(adAccountId, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OrderLinesListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type OrderLinesListOrderEnum = typeof OrderLinesListOrderEnum[keyof typeof OrderLinesListOrderEnum];


/**
 * PinsApi - axios parameter creator
 * @export
 */
export const PinsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get analytics for multiple pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - The maximum number of pins supported in a single request is 100. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @summary Get multiple Pin analytics
         * @param {Array<string>} pinIds List of Pin IDs.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for.
         * @param {MultiPinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiPinsAnalytics: async (pinIds: Array<string>, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: MultiPinsAnalyticsAppTypesEnum, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinIds' is not null or undefined
            assertParamExists('multiPinsAnalytics', 'pinIds', pinIds)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('multiPinsAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('multiPinsAnalytics', 'endDate', endDate)
            // verify required parameter 'metricTypes' is not null or undefined
            assertParamExists('multiPinsAnalytics', 'metricTypes', metricTypes)
            const localVarPath = `/pins/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "pins:read"], configuration)

            if (pinIds) {
                localVarQueryParameter['pin_ids'] = pinIds;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (appTypes !== undefined) {
                localVarQueryParameter['app_types'] = appTypes;
            }

            if (metricTypes) {
                localVarQueryParameter['metric_types'] = metricTypes.join(COLLECTION_FORMATS.csv);
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics for a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @summary Get Pin analytics
         * @param {string} pinId Unique identifier of a Pin.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for. VIDEO_MRC_VIEW are Video views, VIDEO_V50_WATCH_TIME is Total play time. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt;, Profile visits and Follows will only be available for Idea Pins. These metrics are available for all Pin formats since then. Keep in mind this cannot have ALL if split_field is set to any value other than &lt;code&gt;NO_SPLIT&lt;/code&gt;.
         * @param {PinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {PinsAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsAnalytics: async (pinId: string, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: PinsAnalyticsAppTypesEnum, splitField?: PinsAnalyticsSplitFieldEnum, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinId' is not null or undefined
            assertParamExists('pinsAnalytics', 'pinId', pinId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('pinsAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('pinsAnalytics', 'endDate', endDate)
            // verify required parameter 'metricTypes' is not null or undefined
            assertParamExists('pinsAnalytics', 'metricTypes', metricTypes)
            const localVarPath = `/pins/{pin_id}/analytics`
                .replace(`{${"pin_id"}}`, encodeURIComponent(String(pinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "pins:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (appTypes !== undefined) {
                localVarQueryParameter['app_types'] = appTypes;
            }

            if (metricTypes) {
                localVarQueryParameter['metric_types'] = metricTypes.join(COLLECTION_FORMATS.csv);
            }

            if (splitField !== undefined) {
                localVarQueryParameter['split_field'] = splitField;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a Pin on a board or board section owned by the \"operation user_account\".  Note: If the current \"operation user_account\" (defined by the access token) has access to another user\'s Ad Accounts via Pinterest Business Access, you can modify your request to make use of the current operation_user_account\'s permissions to those Ad Accounts by including the ad_account_id in the path parameters for the request (e.g. .../?ad_account_id=12345&...).  - This function is intended solely for publishing new content created by the user. If you are interested in saving content created by others to your Pinterest boards, sometimes called \'curated content\', please use our <a href=\'/docs/web-features/add-ons-overview/\'>Save button</a> instead. For more tips on creating fresh content for Pinterest, review our <a href=\'/docs/api-features/content-overview/\'>Content App Solutions Guide</a>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Create Pin
         * @param {PinCreate | null} pinCreate Create a new Pin.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsCreate: async (pinCreate: PinCreate | null, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinCreate' is not null or undefined
            assertParamExists('pinsCreate', 'pinCreate', pinCreate)
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write", "pins:read", "pins:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pinCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a Pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
         * @summary Delete Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsDelete: async (pinId: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinId' is not null or undefined
            assertParamExists('pinsDelete', 'pinId', pinId)
            const localVarPath = `/pins/{pin_id}`
                .replace(`{${"pin_id"}}`, encodeURIComponent(String(pinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write", "pins:read", "pins:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
         * @summary Get Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsGet: async (pinId: string, pinMetrics?: boolean, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinId' is not null or undefined
            assertParamExists('pinsGet', 'pinId', pinId)
            const localVarPath = `/pins/{pin_id}`
                .replace(`{${"pin_id"}}`, encodeURIComponent(String(pinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "pins:read"], configuration)

            if (pinMetrics !== undefined) {
                localVarQueryParameter['pin_metrics'] = pinMetrics;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the Pins owned by the \"operation user_account\".   - By default, the \"operation user_account\" is the token user_account.   - All Pins owned by the \"operation user_account\" are included, regardless of who owns the board they are on. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".  Disclaimer: there are known performance issues when filtering by field <code>creative_type</code> and including protected pins. If your request is timing out in this scenario we encourage you to use <a href=\'/docs/api/v5/#operation/boards/list_pins\'>GET List Pins on Board</a>.
         * @summary List Pins
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {PinsListPinFilterEnum} [pinFilter] Pin filter.
         * @param {boolean} [includeProtectedPins] Specify if return pins from protected boards
         * @param {PinsListPinTypeEnum} [pinType] The type of pins to return, currently only enabled for private pins
         * @param {Array<PinsListCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsList: async (bookmark?: string, pageSize?: number, pinFilter?: PinsListPinFilterEnum, includeProtectedPins?: boolean, pinType?: PinsListPinTypeEnum, creativeTypes?: Array<PinsListCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "pins:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (pinFilter !== undefined) {
                localVarQueryParameter['pin_filter'] = pinFilter;
            }

            if (includeProtectedPins !== undefined) {
                localVarQueryParameter['include_protected_pins'] = includeProtectedPins;
            }

            if (pinType !== undefined) {
                localVarQueryParameter['pin_type'] = pinType;
            }

            if (creativeTypes) {
                localVarQueryParameter['creative_types'] = creativeTypes;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (pinMetrics !== undefined) {
                localVarQueryParameter['pin_metrics'] = pinMetrics;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Save a Pin on a board or board section owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account. Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  - Any Pin type can be saved: image Pin, video Pin, Idea Pin, product Pin, etc. - Any public Pin can be saved given a pin ID.
         * @summary Save Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {PinsSaveRequest} pinsSaveRequest Request object used to save an existing pin
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsSave: async (pinId: string, pinsSaveRequest: PinsSaveRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinId' is not null or undefined
            assertParamExists('pinsSave', 'pinId', pinId)
            // verify required parameter 'pinsSaveRequest' is not null or undefined
            assertParamExists('pinsSave', 'pinsSaveRequest', pinsSaveRequest)
            const localVarPath = `/pins/{pin_id}/save`
                .replace(`{${"pin_id"}}`, encodeURIComponent(String(pinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write", "pins:read", "pins:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pinsSaveRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a pin owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Update Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {PinUpdate | null} pinUpdate 
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsUpdate: async (pinId: string, pinUpdate: PinUpdate | null, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pinId' is not null or undefined
            assertParamExists('pinsUpdate', 'pinId', pinId)
            // verify required parameter 'pinUpdate' is not null or undefined
            assertParamExists('pinsUpdate', 'pinUpdate', pinUpdate)
            const localVarPath = `/pins/{pin_id}`
                .replace(`{${"pin_id"}}`, encodeURIComponent(String(pinId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:write", "pins:read", "pins:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pinUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PinsApi - functional programming interface
 * @export
 */
export const PinsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PinsApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get analytics for multiple pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - The maximum number of pins supported in a single request is 100. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @summary Get multiple Pin analytics
         * @param {Array<string>} pinIds List of Pin IDs.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for.
         * @param {MultiPinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async multiPinsAnalytics(pinIds: Array<string>, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: MultiPinsAnalyticsAppTypesEnum, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: PinAnalyticsMetricsResponse; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.multiPinsAnalytics(pinIds, startDate, endDate, metricTypes, appTypes, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.multiPinsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics for a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @summary Get Pin analytics
         * @param {string} pinId Unique identifier of a Pin.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for. VIDEO_MRC_VIEW are Video views, VIDEO_V50_WATCH_TIME is Total play time. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt;, Profile visits and Follows will only be available for Idea Pins. These metrics are available for all Pin formats since then. Keep in mind this cannot have ALL if split_field is set to any value other than &lt;code&gt;NO_SPLIT&lt;/code&gt;.
         * @param {PinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {PinsAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsAnalytics(pinId: string, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: PinsAnalyticsAppTypesEnum, splitField?: PinsAnalyticsSplitFieldEnum, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: PinAnalyticsMetricsResponse; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsAnalytics(pinId, startDate, endDate, metricTypes, appTypes, splitField, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a Pin on a board or board section owned by the \"operation user_account\".  Note: If the current \"operation user_account\" (defined by the access token) has access to another user\'s Ad Accounts via Pinterest Business Access, you can modify your request to make use of the current operation_user_account\'s permissions to those Ad Accounts by including the ad_account_id in the path parameters for the request (e.g. .../?ad_account_id=12345&...).  - This function is intended solely for publishing new content created by the user. If you are interested in saving content created by others to your Pinterest boards, sometimes called \'curated content\', please use our <a href=\'/docs/web-features/add-ons-overview/\'>Save button</a> instead. For more tips on creating fresh content for Pinterest, review our <a href=\'/docs/api-features/content-overview/\'>Content App Solutions Guide</a>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Create Pin
         * @param {PinCreate | null} pinCreate Create a new Pin.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsCreate(pinCreate: PinCreate | null, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsCreate(pinCreate, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a Pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
         * @summary Delete Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsDelete(pinId: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsDelete(pinId, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
         * @summary Get Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsGet(pinId: string, pinMetrics?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsGet(pinId, pinMetrics, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the Pins owned by the \"operation user_account\".   - By default, the \"operation user_account\" is the token user_account.   - All Pins owned by the \"operation user_account\" are included, regardless of who owns the board they are on. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".  Disclaimer: there are known performance issues when filtering by field <code>creative_type</code> and including protected pins. If your request is timing out in this scenario we encourage you to use <a href=\'/docs/api/v5/#operation/boards/list_pins\'>GET List Pins on Board</a>.
         * @summary List Pins
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {PinsListPinFilterEnum} [pinFilter] Pin filter.
         * @param {boolean} [includeProtectedPins] Specify if return pins from protected boards
         * @param {PinsListPinTypeEnum} [pinType] The type of pins to return, currently only enabled for private pins
         * @param {Array<PinsListCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsList(bookmark?: string, pageSize?: number, pinFilter?: PinsListPinFilterEnum, includeProtectedPins?: boolean, pinType?: PinsListPinTypeEnum, creativeTypes?: Array<PinsListCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsList(bookmark, pageSize, pinFilter, includeProtectedPins, pinType, creativeTypes, adAccountId, pinMetrics, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Save a Pin on a board or board section owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account. Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  - Any Pin type can be saved: image Pin, video Pin, Idea Pin, product Pin, etc. - Any public Pin can be saved given a pin ID.
         * @summary Save Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {PinsSaveRequest} pinsSaveRequest Request object used to save an existing pin
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsSave(pinId: string, pinsSaveRequest: PinsSaveRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsSave(pinId, pinsSaveRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsSave']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a pin owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Update Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {PinUpdate | null} pinUpdate 
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pinsUpdate(pinId: string, pinUpdate: PinUpdate | null, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pin>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pinsUpdate(pinId, pinUpdate, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PinsApi.pinsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PinsApi - factory interface
 * @export
 */
export const PinsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PinsApiFp(configuration)
    return {
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get analytics for multiple pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - The maximum number of pins supported in a single request is 100. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @summary Get multiple Pin analytics
         * @param {Array<string>} pinIds List of Pin IDs.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for.
         * @param {MultiPinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        multiPinsAnalytics(pinIds: Array<string>, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: MultiPinsAnalyticsAppTypesEnum, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: { [key: string]: PinAnalyticsMetricsResponse; }; }> {
            return localVarFp.multiPinsAnalytics(pinIds, startDate, endDate, metricTypes, appTypes, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics for a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @summary Get Pin analytics
         * @param {string} pinId Unique identifier of a Pin.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for. VIDEO_MRC_VIEW are Video views, VIDEO_V50_WATCH_TIME is Total play time. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt;, Profile visits and Follows will only be available for Idea Pins. These metrics are available for all Pin formats since then. Keep in mind this cannot have ALL if split_field is set to any value other than &lt;code&gt;NO_SPLIT&lt;/code&gt;.
         * @param {PinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {PinsAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsAnalytics(pinId: string, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: PinsAnalyticsAppTypesEnum, splitField?: PinsAnalyticsSplitFieldEnum, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: PinAnalyticsMetricsResponse; }> {
            return localVarFp.pinsAnalytics(pinId, startDate, endDate, metricTypes, appTypes, splitField, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a Pin on a board or board section owned by the \"operation user_account\".  Note: If the current \"operation user_account\" (defined by the access token) has access to another user\'s Ad Accounts via Pinterest Business Access, you can modify your request to make use of the current operation_user_account\'s permissions to those Ad Accounts by including the ad_account_id in the path parameters for the request (e.g. .../?ad_account_id=12345&...).  - This function is intended solely for publishing new content created by the user. If you are interested in saving content created by others to your Pinterest boards, sometimes called \'curated content\', please use our <a href=\'/docs/web-features/add-ons-overview/\'>Save button</a> instead. For more tips on creating fresh content for Pinterest, review our <a href=\'/docs/api-features/content-overview/\'>Content App Solutions Guide</a>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
         * @summary Create Pin
         * @param {PinCreate | null} pinCreate Create a new Pin.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsCreate(pinCreate: PinCreate | null, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Pin> {
            return localVarFp.pinsCreate(pinCreate, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a Pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
         * @summary Delete Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsDelete(pinId: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.pinsDelete(pinId, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
         * @summary Get Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsGet(pinId: string, pinMetrics?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Pin> {
            return localVarFp.pinsGet(pinId, pinMetrics, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the Pins owned by the \"operation user_account\".   - By default, the \"operation user_account\" is the token user_account.   - All Pins owned by the \"operation user_account\" are included, regardless of who owns the board they are on. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".  Disclaimer: there are known performance issues when filtering by field <code>creative_type</code> and including protected pins. If your request is timing out in this scenario we encourage you to use <a href=\'/docs/api/v5/#operation/boards/list_pins\'>GET List Pins on Board</a>.
         * @summary List Pins
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {PinsListPinFilterEnum} [pinFilter] Pin filter.
         * @param {boolean} [includeProtectedPins] Specify if return pins from protected boards
         * @param {PinsListPinTypeEnum} [pinType] The type of pins to return, currently only enabled for private pins
         * @param {Array<PinsListCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsList(bookmark?: string, pageSize?: number, pinFilter?: PinsListPinFilterEnum, includeProtectedPins?: boolean, pinType?: PinsListPinTypeEnum, creativeTypes?: Array<PinsListCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<PinsList200Response> {
            return localVarFp.pinsList(bookmark, pageSize, pinFilter, includeProtectedPins, pinType, creativeTypes, adAccountId, pinMetrics, options).then((request) => request(axios, basePath));
        },
        /**
         * Save a Pin on a board or board section owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account. Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  - Any Pin type can be saved: image Pin, video Pin, Idea Pin, product Pin, etc. - Any public Pin can be saved given a pin ID.
         * @summary Save Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {PinsSaveRequest} pinsSaveRequest Request object used to save an existing pin
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsSave(pinId: string, pinsSaveRequest: PinsSaveRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Pin> {
            return localVarFp.pinsSave(pinId, pinsSaveRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a pin owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Update Pin
         * @param {string} pinId Unique identifier of a Pin.
         * @param {PinUpdate | null} pinUpdate 
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pinsUpdate(pinId: string, pinUpdate: PinUpdate | null, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Pin> {
            return localVarFp.pinsUpdate(pinId, pinUpdate, adAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PinsApi - object-oriented interface
 * @export
 * @class PinsApi
 * @extends {BaseAPI}
 */
export class PinsApi extends BaseAPI {
    /**
     * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get analytics for multiple pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - The maximum number of pins supported in a single request is 100. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @summary Get multiple Pin analytics
     * @param {Array<string>} pinIds List of Pin IDs.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for.
     * @param {MultiPinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public multiPinsAnalytics(pinIds: Array<string>, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: MultiPinsAnalyticsAppTypesEnum, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).multiPinsAnalytics(pinIds, startDate, endDate, metricTypes, appTypes, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics for a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\"/docs/api/v5/#operation/ad_accounts/list\">List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Admin, Analyst. - For Pins on secret boards: Admin.  If Pin was created before <code>2023-03-20</code> lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @summary Get Pin analytics
     * @param {string} pinId Unique identifier of a Pin.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<PinsAnalyticsMetricTypesParameterInner>} metricTypes Pin metric types to get data for. VIDEO_MRC_VIEW are Video views, VIDEO_V50_WATCH_TIME is Total play time. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt;, Profile visits and Follows will only be available for Idea Pins. These metrics are available for all Pin formats since then. Keep in mind this cannot have ALL if split_field is set to any value other than &lt;code&gt;NO_SPLIT&lt;/code&gt;.
     * @param {PinsAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
     * @param {PinsAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsAnalytics(pinId: string, startDate: string, endDate: string, metricTypes: Array<PinsAnalyticsMetricTypesParameterInner>, appTypes?: PinsAnalyticsAppTypesEnum, splitField?: PinsAnalyticsSplitFieldEnum, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsAnalytics(pinId, startDate, endDate, metricTypes, appTypes, splitField, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a Pin on a board or board section owned by the \"operation user_account\".  Note: If the current \"operation user_account\" (defined by the access token) has access to another user\'s Ad Accounts via Pinterest Business Access, you can modify your request to make use of the current operation_user_account\'s permissions to those Ad Accounts by including the ad_account_id in the path parameters for the request (e.g. .../?ad_account_id=12345&...).  - This function is intended solely for publishing new content created by the user. If you are interested in saving content created by others to your Pinterest boards, sometimes called \'curated content\', please use our <a href=\'/docs/web-features/add-ons-overview/\'>Save button</a> instead. For more tips on creating fresh content for Pinterest, review our <a href=\'/docs/api-features/content-overview/\'>Content App Solutions Guide</a>.  <strong><a href=\'/docs/api-features/creating-boards-and-pins/#creating-video-pins\'>Learn more</a></strong> about video Pin creation.
     * @summary Create Pin
     * @param {PinCreate | null} pinCreate Create a new Pin.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsCreate(pinCreate: PinCreate | null, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsCreate(pinCreate, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a Pins owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
     * @summary Delete Pin
     * @param {string} pinId Unique identifier of a Pin.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsDelete(pinId: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsDelete(pinId, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a Pin owned by the \"operation user_account\" - or on a group board that has been shared with this account. - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.
     * @summary Get Pin
     * @param {string} pinId Unique identifier of a Pin.
     * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsGet(pinId: string, pinMetrics?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsGet(pinId, pinMetrics, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the Pins owned by the \"operation user_account\".   - By default, the \"operation user_account\" is the token user_account.   - All Pins owned by the \"operation user_account\" are included, regardless of who owns the board they are on. Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".  Disclaimer: there are known performance issues when filtering by field <code>creative_type</code> and including protected pins. If your request is timing out in this scenario we encourage you to use <a href=\'/docs/api/v5/#operation/boards/list_pins\'>GET List Pins on Board</a>.
     * @summary List Pins
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {PinsListPinFilterEnum} [pinFilter] Pin filter.
     * @param {boolean} [includeProtectedPins] Specify if return pins from protected boards
     * @param {PinsListPinTypeEnum} [pinType] The type of pins to return, currently only enabled for private pins
     * @param {Array<PinsListCreativeTypesEnum>} [creativeTypes] Pin creative types filter. &lt;/p&gt;&lt;strong&gt;Note:&lt;/strong&gt; SHOP_THE_PIN has been deprecated. Please use COLLECTION instead.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {boolean} [pinMetrics] Specify whether to return 90d and lifetime Pin metrics. Total comments and total reactions are only available with lifetime Pin metrics. If Pin was created before &lt;code&gt;2023-03-20&lt;/code&gt; lifetime metrics will only be available for Video and Idea Pin formats. Lifetime metrics are available for all Pin formats since then.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsList(bookmark?: string, pageSize?: number, pinFilter?: PinsListPinFilterEnum, includeProtectedPins?: boolean, pinType?: PinsListPinTypeEnum, creativeTypes?: Array<PinsListCreativeTypesEnum>, adAccountId?: string, pinMetrics?: boolean, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsList(bookmark, pageSize, pinFilter, includeProtectedPins, pinType, creativeTypes, adAccountId, pinMetrics, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Save a Pin on a board or board section owned by the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account. Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  - Any Pin type can be saved: image Pin, video Pin, Idea Pin, product Pin, etc. - Any public Pin can be saved given a pin ID.
     * @summary Save Pin
     * @param {string} pinId Unique identifier of a Pin.
     * @param {PinsSaveRequest} pinsSaveRequest Request object used to save an existing pin
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsSave(pinId: string, pinsSaveRequest: PinsSaveRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsSave(pinId, pinsSaveRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a pin owned by the \"operating user_account\". - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an <code>ad_account_id</code> (obtained via <a href=\'/docs/api/v5/#operation/ad_accounts/list\'>List ad accounts</a>) to use the owner of that ad_account as the \"operation user_account\". In order to do this, the token user_account must have one of the following <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a> roles on the ad_account:  - For Pins on public or protected boards: Owner, Admin, Analyst, Campaign Manager. - For Pins on secret boards: Owner, Admin.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Update Pin
     * @param {string} pinId Unique identifier of a Pin.
     * @param {PinUpdate | null} pinUpdate 
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PinsApi
     */
    public pinsUpdate(pinId: string, pinUpdate: PinUpdate | null, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return PinsApiFp(this.configuration).pinsUpdate(pinId, pinUpdate, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MultiPinsAnalyticsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type MultiPinsAnalyticsAppTypesEnum = typeof MultiPinsAnalyticsAppTypesEnum[keyof typeof MultiPinsAnalyticsAppTypesEnum];
/**
 * @export
 */
export const PinsAnalyticsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type PinsAnalyticsAppTypesEnum = typeof PinsAnalyticsAppTypesEnum[keyof typeof PinsAnalyticsAppTypesEnum];
/**
 * @export
 */
export const PinsAnalyticsSplitFieldEnum = {
    NoSplit: 'NO_SPLIT',
    AppType: 'APP_TYPE'
} as const;
export type PinsAnalyticsSplitFieldEnum = typeof PinsAnalyticsSplitFieldEnum[keyof typeof PinsAnalyticsSplitFieldEnum];
/**
 * @export
 */
export const PinsListPinFilterEnum = {
    ExcludeNative: 'exclude_native',
    ExcludeRepins: 'exclude_repins',
    HasBeenPromoted: 'has_been_promoted'
} as const;
export type PinsListPinFilterEnum = typeof PinsListPinFilterEnum[keyof typeof PinsListPinFilterEnum];
/**
 * @export
 */
export const PinsListPinTypeEnum = {
    Private: 'PRIVATE'
} as const;
export type PinsListPinTypeEnum = typeof PinsListPinTypeEnum[keyof typeof PinsListPinTypeEnum];
/**
 * @export
 */
export const PinsListCreativeTypesEnum = {
    Regular: 'REGULAR',
    Video: 'VIDEO',
    Shopping: 'SHOPPING',
    Carousel: 'CAROUSEL',
    MaxVideo: 'MAX_VIDEO',
    ShopThePin: 'SHOP_THE_PIN',
    Collection: 'COLLECTION',
    Idea: 'IDEA'
} as const;
export type PinsListCreativeTypesEnum = typeof PinsListCreativeTypesEnum[keyof typeof PinsListCreativeTypesEnum];


/**
 * ProductGroupPromotionsApi - axios parameter creator
 * @export
 */
export const ProductGroupPromotionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add one or more product groups from your catalog to an existing ad group. (Product groups added to an ad group are a \'product group promotion.\')
         * @summary Create product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ProductGroupPromotionCreateRequest} productGroupPromotionCreateRequest List of Product Group Promotions to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsCreate: async (adAccountId: string, productGroupPromotionCreateRequest: ProductGroupPromotionCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('productGroupPromotionsCreate', 'adAccountId', adAccountId)
            // verify required parameter 'productGroupPromotionCreateRequest' is not null or undefined
            assertParamExists('productGroupPromotionsCreate', 'productGroupPromotionCreateRequest', productGroupPromotionCreateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/product_group_promotions`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productGroupPromotionCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a product group promotion by id
         * @summary Get a product group promotion by id
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} productGroupPromotionId Unique identifier of a product group promotion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsGet: async (adAccountId: string, productGroupPromotionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('productGroupPromotionsGet', 'adAccountId', adAccountId)
            // verify required parameter 'productGroupPromotionId' is not null or undefined
            assertParamExists('productGroupPromotionsGet', 'productGroupPromotionId', productGroupPromotionId)
            const localVarPath = `/ad_accounts/{ad_account_id}/product_group_promotions/{product_group_promotion_id}`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)))
                .replace(`{${"product_group_promotion_id"}}`, encodeURIComponent(String(productGroupPromotionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List existing product group promotions associated with an ad account.  Include either ad_group_id or product_group_promotion_ids in your request.  <b>Note:</b> ad_group_ids and product_group_promotion_ids are mutually exclusive parameters. Only provide one. If multiple options are provided, product_group_promotion_ids takes precedence over ad_group_ids. If none are provided, the endpoint returns an error.
         * @summary Get product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [productGroupPromotionIds] List of Product group promotion Ids.
         * @param {Array<ProductGroupPromotionsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {string} [adGroupId] Ad group Id.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {ProductGroupPromotionsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsList: async (adAccountId: string, productGroupPromotionIds?: Array<string>, entityStatuses?: Array<ProductGroupPromotionsListEntityStatusesEnum>, adGroupId?: string, pageSize?: number, order?: ProductGroupPromotionsListOrderEnum, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('productGroupPromotionsList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/product_group_promotions`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (productGroupPromotionIds) {
                localVarQueryParameter['product_group_promotion_ids'] = productGroupPromotionIds;
            }

            if (entityStatuses) {
                localVarQueryParameter['entity_statuses'] = entityStatuses;
            }

            if (adGroupId !== undefined) {
                localVarQueryParameter['ad_group_id'] = adGroupId;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update multiple existing Product Group Promotions (by product_group_id)
         * @summary Update product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ProductGroupPromotionUpdateRequest} productGroupPromotionUpdateRequest Parameters to update Product group promotions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsUpdate: async (adAccountId: string, productGroupPromotionUpdateRequest: ProductGroupPromotionUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('productGroupPromotionsUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'productGroupPromotionUpdateRequest' is not null or undefined
            assertParamExists('productGroupPromotionsUpdate', 'productGroupPromotionUpdateRequest', productGroupPromotionUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/product_group_promotions`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productGroupPromotionUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics for the specified product groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get product group analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} productGroupIds List of Product group Ids to use to filter the results.
         * @param {Array<ProductGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {ProductGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {ProductGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {ProductGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {ProductGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupsAnalytics: async (adAccountId: string, startDate: string, endDate: string, productGroupIds: Array<string>, columns: Array<ProductGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: ProductGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: ProductGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: ProductGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: ProductGroupsAnalyticsConversionReportTimeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('productGroupsAnalytics', 'adAccountId', adAccountId)
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('productGroupsAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('productGroupsAnalytics', 'endDate', endDate)
            // verify required parameter 'productGroupIds' is not null or undefined
            assertParamExists('productGroupsAnalytics', 'productGroupIds', productGroupIds)
            // verify required parameter 'columns' is not null or undefined
            assertParamExists('productGroupsAnalytics', 'columns', columns)
            // verify required parameter 'granularity' is not null or undefined
            assertParamExists('productGroupsAnalytics', 'granularity', granularity)
            const localVarPath = `/ad_accounts/{ad_account_id}/product_groups/analytics`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (productGroupIds) {
                localVarQueryParameter['product_group_ids'] = productGroupIds;
            }

            if (columns) {
                localVarQueryParameter['columns'] = columns.join(COLLECTION_FORMATS.csv);
            }

            if (granularity !== undefined) {
                localVarQueryParameter['granularity'] = granularity;
            }

            if (clickWindowDays !== undefined) {
                localVarQueryParameter['click_window_days'] = clickWindowDays;
            }

            if (engagementWindowDays !== undefined) {
                localVarQueryParameter['engagement_window_days'] = engagementWindowDays;
            }

            if (viewWindowDays !== undefined) {
                localVarQueryParameter['view_window_days'] = viewWindowDays;
            }

            if (conversionReportTime !== undefined) {
                localVarQueryParameter['conversion_report_time'] = conversionReportTime;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductGroupPromotionsApi - functional programming interface
 * @export
 */
export const ProductGroupPromotionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductGroupPromotionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Add one or more product groups from your catalog to an existing ad group. (Product groups added to an ad group are a \'product group promotion.\')
         * @summary Create product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ProductGroupPromotionCreateRequest} productGroupPromotionCreateRequest List of Product Group Promotions to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGroupPromotionsCreate(adAccountId: string, productGroupPromotionCreateRequest: ProductGroupPromotionCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductGroupPromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGroupPromotionsCreate(adAccountId, productGroupPromotionCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductGroupPromotionsApi.productGroupPromotionsCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a product group promotion by id
         * @summary Get a product group promotion by id
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} productGroupPromotionId Unique identifier of a product group promotion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGroupPromotionsGet(adAccountId: string, productGroupPromotionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductGroupPromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGroupPromotionsGet(adAccountId, productGroupPromotionId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductGroupPromotionsApi.productGroupPromotionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * List existing product group promotions associated with an ad account.  Include either ad_group_id or product_group_promotion_ids in your request.  <b>Note:</b> ad_group_ids and product_group_promotion_ids are mutually exclusive parameters. Only provide one. If multiple options are provided, product_group_promotion_ids takes precedence over ad_group_ids. If none are provided, the endpoint returns an error.
         * @summary Get product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [productGroupPromotionIds] List of Product group promotion Ids.
         * @param {Array<ProductGroupPromotionsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {string} [adGroupId] Ad group Id.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {ProductGroupPromotionsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGroupPromotionsList(adAccountId: string, productGroupPromotionIds?: Array<string>, entityStatuses?: Array<ProductGroupPromotionsListEntityStatusesEnum>, adGroupId?: string, pageSize?: number, order?: ProductGroupPromotionsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductGroupPromotionsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGroupPromotionsList(adAccountId, productGroupPromotionIds, entityStatuses, adGroupId, pageSize, order, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductGroupPromotionsApi.productGroupPromotionsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update multiple existing Product Group Promotions (by product_group_id)
         * @summary Update product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ProductGroupPromotionUpdateRequest} productGroupPromotionUpdateRequest Parameters to update Product group promotions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGroupPromotionsUpdate(adAccountId: string, productGroupPromotionUpdateRequest: ProductGroupPromotionUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductGroupPromotionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGroupPromotionsUpdate(adAccountId, productGroupPromotionUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductGroupPromotionsApi.productGroupPromotionsUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics for the specified product groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get product group analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} productGroupIds List of Product group Ids to use to filter the results.
         * @param {Array<ProductGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {ProductGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {ProductGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {ProductGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {ProductGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async productGroupsAnalytics(adAccountId: string, startDate: string, endDate: string, productGroupIds: Array<string>, columns: Array<ProductGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: ProductGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: ProductGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: ProductGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: ProductGroupsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductGroupAnalyticsResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.productGroupsAnalytics(adAccountId, startDate, endDate, productGroupIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductGroupPromotionsApi.productGroupsAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductGroupPromotionsApi - factory interface
 * @export
 */
export const ProductGroupPromotionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductGroupPromotionsApiFp(configuration)
    return {
        /**
         * Add one or more product groups from your catalog to an existing ad group. (Product groups added to an ad group are a \'product group promotion.\')
         * @summary Create product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ProductGroupPromotionCreateRequest} productGroupPromotionCreateRequest List of Product Group Promotions to create, size limit [1, 30].
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsCreate(adAccountId: string, productGroupPromotionCreateRequest: ProductGroupPromotionCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductGroupPromotionResponse> {
            return localVarFp.productGroupPromotionsCreate(adAccountId, productGroupPromotionCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a product group promotion by id
         * @summary Get a product group promotion by id
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} productGroupPromotionId Unique identifier of a product group promotion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsGet(adAccountId: string, productGroupPromotionId: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductGroupPromotionResponse> {
            return localVarFp.productGroupPromotionsGet(adAccountId, productGroupPromotionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List existing product group promotions associated with an ad account.  Include either ad_group_id or product_group_promotion_ids in your request.  <b>Note:</b> ad_group_ids and product_group_promotion_ids are mutually exclusive parameters. Only provide one. If multiple options are provided, product_group_promotion_ids takes precedence over ad_group_ids. If none are provided, the endpoint returns an error.
         * @summary Get product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {Array<string>} [productGroupPromotionIds] List of Product group promotion Ids.
         * @param {Array<ProductGroupPromotionsListEntityStatusesEnum>} [entityStatuses] Entity status
         * @param {string} [adGroupId] Ad group Id.
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {ProductGroupPromotionsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsList(adAccountId: string, productGroupPromotionIds?: Array<string>, entityStatuses?: Array<ProductGroupPromotionsListEntityStatusesEnum>, adGroupId?: string, pageSize?: number, order?: ProductGroupPromotionsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<ProductGroupPromotionsList200Response> {
            return localVarFp.productGroupPromotionsList(adAccountId, productGroupPromotionIds, entityStatuses, adGroupId, pageSize, order, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * Update multiple existing Product Group Promotions (by product_group_id)
         * @summary Update product group promotions
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {ProductGroupPromotionUpdateRequest} productGroupPromotionUpdateRequest Parameters to update Product group promotions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupPromotionsUpdate(adAccountId: string, productGroupPromotionUpdateRequest: ProductGroupPromotionUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductGroupPromotionResponse> {
            return localVarFp.productGroupPromotionsUpdate(adAccountId, productGroupPromotionUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics for the specified product groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
         * @summary Get product group analytics
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {Array<string>} productGroupIds List of Product group Ids to use to filter the results.
         * @param {Array<ProductGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
         * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
         * @param {ProductGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {ProductGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
         * @param {ProductGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
         * @param {ProductGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productGroupsAnalytics(adAccountId: string, startDate: string, endDate: string, productGroupIds: Array<string>, columns: Array<ProductGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: ProductGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: ProductGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: ProductGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: ProductGroupsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductGroupAnalyticsResponseInner>> {
            return localVarFp.productGroupsAnalytics(adAccountId, startDate, endDate, productGroupIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductGroupPromotionsApi - object-oriented interface
 * @export
 * @class ProductGroupPromotionsApi
 * @extends {BaseAPI}
 */
export class ProductGroupPromotionsApi extends BaseAPI {
    /**
     * Add one or more product groups from your catalog to an existing ad group. (Product groups added to an ad group are a \'product group promotion.\')
     * @summary Create product group promotions
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {ProductGroupPromotionCreateRequest} productGroupPromotionCreateRequest List of Product Group Promotions to create, size limit [1, 30].
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductGroupPromotionsApi
     */
    public productGroupPromotionsCreate(adAccountId: string, productGroupPromotionCreateRequest: ProductGroupPromotionCreateRequest, options?: RawAxiosRequestConfig) {
        return ProductGroupPromotionsApiFp(this.configuration).productGroupPromotionsCreate(adAccountId, productGroupPromotionCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a product group promotion by id
     * @summary Get a product group promotion by id
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} productGroupPromotionId Unique identifier of a product group promotion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductGroupPromotionsApi
     */
    public productGroupPromotionsGet(adAccountId: string, productGroupPromotionId: string, options?: RawAxiosRequestConfig) {
        return ProductGroupPromotionsApiFp(this.configuration).productGroupPromotionsGet(adAccountId, productGroupPromotionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List existing product group promotions associated with an ad account.  Include either ad_group_id or product_group_promotion_ids in your request.  <b>Note:</b> ad_group_ids and product_group_promotion_ids are mutually exclusive parameters. Only provide one. If multiple options are provided, product_group_promotion_ids takes precedence over ad_group_ids. If none are provided, the endpoint returns an error.
     * @summary Get product group promotions
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {Array<string>} [productGroupPromotionIds] List of Product group promotion Ids.
     * @param {Array<ProductGroupPromotionsListEntityStatusesEnum>} [entityStatuses] Entity status
     * @param {string} [adGroupId] Ad group Id.
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {ProductGroupPromotionsListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductGroupPromotionsApi
     */
    public productGroupPromotionsList(adAccountId: string, productGroupPromotionIds?: Array<string>, entityStatuses?: Array<ProductGroupPromotionsListEntityStatusesEnum>, adGroupId?: string, pageSize?: number, order?: ProductGroupPromotionsListOrderEnum, bookmark?: string, options?: RawAxiosRequestConfig) {
        return ProductGroupPromotionsApiFp(this.configuration).productGroupPromotionsList(adAccountId, productGroupPromotionIds, entityStatuses, adGroupId, pageSize, order, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update multiple existing Product Group Promotions (by product_group_id)
     * @summary Update product group promotions
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {ProductGroupPromotionUpdateRequest} productGroupPromotionUpdateRequest Parameters to update Product group promotions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductGroupPromotionsApi
     */
    public productGroupPromotionsUpdate(adAccountId: string, productGroupPromotionUpdateRequest: ProductGroupPromotionUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProductGroupPromotionsApiFp(this.configuration).productGroupPromotionsUpdate(adAccountId, productGroupPromotionUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics for the specified product groups in the specified <code>ad_account_id</code>, filtered by the specified options. - The token\'s user_account must either be the Owner of the specified ad account, or have one of the necessary roles granted to them via <a href=\"https://help.pinterest.com/en/business/article/share-and-manage-access-to-your-ad-accounts\">Business Access</a>: Admin, Analyst, Campaign Manager. - If granularity is not HOUR, the furthest back you can are allowed to pull data is 90 days before the current date in UTC time and the max time range supported is 90 days. - If granularity is HOUR, the furthest back you can are allowed to pull data is 8 days before the current date in UTC time and the max time range supported is 3 days.
     * @summary Get product group analytics
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {Array<string>} productGroupIds List of Product group Ids to use to filter the results.
     * @param {Array<ProductGroupsAnalyticsColumnsEnum>} columns Columns to retrieve, encoded as a comma-separated string. **NOTE**: Any metrics defined as MICRO_DOLLARS returns a value based on the advertiser profile\&#39;s currency field. For USD,($1/1,000,000, or $0.000001 - one one-ten-thousandth of a cent). it\&#39;s microdollars. Otherwise, it\&#39;s in microunits of the advertiser\&#39;s currency.&lt;br/&gt;For example, if the advertiser\&#39;s currency is GBP (British pound sterling), all MICRO_DOLLARS fields will be in GBP microunits (1/1,000,000 British pound).&lt;br/&gt;If a column has no value, it may not be returned
     * @param {Granularity} granularity TOTAL - metrics are aggregated over the specified date range.&lt;br&gt; DAY - metrics are broken down daily.&lt;br&gt; HOUR - metrics are broken down hourly.&lt;br&gt;WEEKLY - metrics are broken down weekly.&lt;br&gt;MONTHLY - metrics are broken down monthly
     * @param {ProductGroupsAnalyticsClickWindowDaysEnum} [clickWindowDays] Number of days to use as the conversion attribution window for a pin click action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {ProductGroupsAnalyticsEngagementWindowDaysEnum} [engagementWindowDays] Number of days to use as the conversion attribution window for an engagement action. Engagements include saves, closeups, link clicks, and carousel card swipes. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;30&#x60; days.
     * @param {ProductGroupsAnalyticsViewWindowDaysEnum} [viewWindowDays] Number of days to use as the conversion attribution window for a view action. Applies to Pinterest Tag conversion metrics. Prior conversion tags use their defined attribution windows. If not specified, defaults to &#x60;1&#x60; day.
     * @param {ProductGroupsAnalyticsConversionReportTimeEnum} [conversionReportTime] The date by which the conversion metrics returned from this endpoint will be reported. There are two dates associated with a conversion event: the date that the user interacted with the ad, and the date that the user completed a conversion event.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductGroupPromotionsApi
     */
    public productGroupsAnalytics(adAccountId: string, startDate: string, endDate: string, productGroupIds: Array<string>, columns: Array<ProductGroupsAnalyticsColumnsEnum>, granularity: Granularity, clickWindowDays?: ProductGroupsAnalyticsClickWindowDaysEnum, engagementWindowDays?: ProductGroupsAnalyticsEngagementWindowDaysEnum, viewWindowDays?: ProductGroupsAnalyticsViewWindowDaysEnum, conversionReportTime?: ProductGroupsAnalyticsConversionReportTimeEnum, options?: RawAxiosRequestConfig) {
        return ProductGroupPromotionsApiFp(this.configuration).productGroupsAnalytics(adAccountId, startDate, endDate, productGroupIds, columns, granularity, clickWindowDays, engagementWindowDays, viewWindowDays, conversionReportTime, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ProductGroupPromotionsListEntityStatusesEnum = {
    Active: 'ACTIVE',
    Paused: 'PAUSED',
    Archived: 'ARCHIVED',
    Draft: 'DRAFT',
    DeletedDraft: 'DELETED_DRAFT'
} as const;
export type ProductGroupPromotionsListEntityStatusesEnum = typeof ProductGroupPromotionsListEntityStatusesEnum[keyof typeof ProductGroupPromotionsListEntityStatusesEnum];
/**
 * @export
 */
export const ProductGroupPromotionsListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type ProductGroupPromotionsListOrderEnum = typeof ProductGroupPromotionsListOrderEnum[keyof typeof ProductGroupPromotionsListOrderEnum];
/**
 * @export
 */
export const ProductGroupsAnalyticsColumnsEnum = {
    SpendInMicroDollar: 'SPEND_IN_MICRO_DOLLAR',
    PaidImpression: 'PAID_IMPRESSION',
    SpendInDollar: 'SPEND_IN_DOLLAR',
    CpcInMicroDollar: 'CPC_IN_MICRO_DOLLAR',
    EcpcInMicroDollar: 'ECPC_IN_MICRO_DOLLAR',
    EcpcInDollar: 'ECPC_IN_DOLLAR',
    Ctr: 'CTR',
    Ectr: 'ECTR',
    CampaignName: 'CAMPAIGN_NAME',
    PinId: 'PIN_ID',
    TotalEngagement: 'TOTAL_ENGAGEMENT',
    Engagement1: 'ENGAGEMENT_1',
    Engagement2: 'ENGAGEMENT_2',
    EcpeInDollar: 'ECPE_IN_DOLLAR',
    EngagementRate: 'ENGAGEMENT_RATE',
    EengagementRate: 'EENGAGEMENT_RATE',
    EcpmInMicroDollar: 'ECPM_IN_MICRO_DOLLAR',
    RepinRate: 'REPIN_RATE',
    Ctr2: 'CTR_2',
    CampaignId: 'CAMPAIGN_ID',
    AdvertiserId: 'ADVERTISER_ID',
    AdAccountId: 'AD_ACCOUNT_ID',
    PinPromotionId: 'PIN_PROMOTION_ID',
    AdId: 'AD_ID',
    AdGroupId: 'AD_GROUP_ID',
    CampaignEntityStatus: 'CAMPAIGN_ENTITY_STATUS',
    CampaignObjectiveType: 'CAMPAIGN_OBJECTIVE_TYPE',
    CpmInMicroDollar: 'CPM_IN_MICRO_DOLLAR',
    CpmInDollar: 'CPM_IN_DOLLAR',
    AdGroupEntityStatus: 'AD_GROUP_ENTITY_STATUS',
    OrderLineId: 'ORDER_LINE_ID',
    OrderLineName: 'ORDER_LINE_NAME',
    Clickthrough1: 'CLICKTHROUGH_1',
    Repin1: 'REPIN_1',
    Impression1: 'IMPRESSION_1',
    Impression1Gross: 'IMPRESSION_1_GROSS',
    Clickthrough1Gross: 'CLICKTHROUGH_1_GROSS',
    OutboundClick1: 'OUTBOUND_CLICK_1',
    Clickthrough2: 'CLICKTHROUGH_2',
    Repin2: 'REPIN_2',
    Impression2: 'IMPRESSION_2',
    OutboundClick2: 'OUTBOUND_CLICK_2',
    TotalClickthrough: 'TOTAL_CLICKTHROUGH',
    TotalImpression: 'TOTAL_IMPRESSION',
    TotalImpressionUser: 'TOTAL_IMPRESSION_USER',
    TotalImpressionFrequency: 'TOTAL_IMPRESSION_FREQUENCY',
    CostPerOutboundClickInDollar: 'COST_PER_OUTBOUND_CLICK_IN_DOLLAR',
    TotalEngagementSignup: 'TOTAL_ENGAGEMENT_SIGNUP',
    TotalEngagementCheckout: 'TOTAL_ENGAGEMENT_CHECKOUT',
    TotalEngagementLead: 'TOTAL_ENGAGEMENT_LEAD',
    TotalClickSignup: 'TOTAL_CLICK_SIGNUP',
    TotalClickCheckout: 'TOTAL_CLICK_CHECKOUT',
    TotalClickAddToCart: 'TOTAL_CLICK_ADD_TO_CART',
    TotalClickLead: 'TOTAL_CLICK_LEAD',
    TotalViewSignup: 'TOTAL_VIEW_SIGNUP',
    TotalViewCheckout: 'TOTAL_VIEW_CHECKOUT',
    TotalViewAddToCart: 'TOTAL_VIEW_ADD_TO_CART',
    TotalViewLead: 'TOTAL_VIEW_LEAD',
    TotalConversions: 'TOTAL_CONVERSIONS',
    TotalEngagementSignupValueInMicroDollar: 'TOTAL_ENGAGEMENT_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalEngagementCheckoutValueInMicroDollar: 'TOTAL_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalClickSignupValueInMicroDollar: 'TOTAL_CLICK_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalClickCheckoutValueInMicroDollar: 'TOTAL_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalViewSignupValueInMicroDollar: 'TOTAL_VIEW_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalViewCheckoutValueInMicroDollar: 'TOTAL_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebSessions: 'TOTAL_WEB_SESSIONS',
    WebSessions1: 'WEB_SESSIONS_1',
    WebSessions2: 'WEB_SESSIONS_2',
    CampaignLifetimeSpendCap: 'CAMPAIGN_LIFETIME_SPEND_CAP',
    CampaignDailySpendCap: 'CAMPAIGN_DAILY_SPEND_CAP',
    TotalPageVisit: 'TOTAL_PAGE_VISIT',
    TotalSignup: 'TOTAL_SIGNUP',
    TotalCheckout: 'TOTAL_CHECKOUT',
    TotalCustom: 'TOTAL_CUSTOM',
    TotalLead: 'TOTAL_LEAD',
    TotalSignupValueInMicroDollar: 'TOTAL_SIGNUP_VALUE_IN_MICRO_DOLLAR',
    TotalCheckoutValueInMicroDollar: 'TOTAL_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalCustomValueInMicroDollar: 'TOTAL_CUSTOM_VALUE_IN_MICRO_DOLLAR',
    PageVisitCostPerAction: 'PAGE_VISIT_COST_PER_ACTION',
    PageVisitRoas: 'PAGE_VISIT_ROAS',
    CheckoutRoas: 'CHECKOUT_ROAS',
    CustomRoas: 'CUSTOM_ROAS',
    VideoMrcViews1: 'VIDEO_MRC_VIEWS_1',
    Video3SecViews2: 'VIDEO_3SEC_VIEWS_2',
    VideoP100Complete2: 'VIDEO_P100_COMPLETE_2',
    VideoP0Combined2: 'VIDEO_P0_COMBINED_2',
    VideoP25Combined2: 'VIDEO_P25_COMBINED_2',
    VideoP50Combined2: 'VIDEO_P50_COMBINED_2',
    VideoP75Combined2: 'VIDEO_P75_COMBINED_2',
    VideoP95Combined2: 'VIDEO_P95_COMBINED_2',
    VideoMrcViews2: 'VIDEO_MRC_VIEWS_2',
    PaidVideoViewableRate: 'PAID_VIDEO_VIEWABLE_RATE',
    VideoLength: 'VIDEO_LENGTH',
    EcpvInDollar: 'ECPV_IN_DOLLAR',
    EcpcvInDollar: 'ECPCV_IN_DOLLAR',
    EcpcvP95InDollar: 'ECPCV_P95_IN_DOLLAR',
    TotalVideo3SecViews: 'TOTAL_VIDEO_3SEC_VIEWS',
    TotalVideoP100Complete: 'TOTAL_VIDEO_P100_COMPLETE',
    TotalVideoP0Combined: 'TOTAL_VIDEO_P0_COMBINED',
    TotalVideoP25Combined: 'TOTAL_VIDEO_P25_COMBINED',
    TotalVideoP50Combined: 'TOTAL_VIDEO_P50_COMBINED',
    TotalVideoP75Combined: 'TOTAL_VIDEO_P75_COMBINED',
    TotalVideoP95Combined: 'TOTAL_VIDEO_P95_COMBINED',
    TotalVideoMrcViews: 'TOTAL_VIDEO_MRC_VIEWS',
    TotalVideoAvgWatchtimeInSecond: 'TOTAL_VIDEO_AVG_WATCHTIME_IN_SECOND',
    TotalRepinRate: 'TOTAL_REPIN_RATE',
    WebCheckoutCostPerAction: 'WEB_CHECKOUT_COST_PER_ACTION',
    WebCheckoutRoas: 'WEB_CHECKOUT_ROAS',
    TotalWebCheckout: 'TOTAL_WEB_CHECKOUT',
    TotalWebCheckoutValueInMicroDollar: 'TOTAL_WEB_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebClickCheckout: 'TOTAL_WEB_CLICK_CHECKOUT',
    TotalWebClickCheckoutValueInMicroDollar: 'TOTAL_WEB_CLICK_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebEngagementCheckout: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT',
    TotalWebEngagementCheckoutValueInMicroDollar: 'TOTAL_WEB_ENGAGEMENT_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    TotalWebViewCheckout: 'TOTAL_WEB_VIEW_CHECKOUT',
    TotalWebViewCheckoutValueInMicroDollar: 'TOTAL_WEB_VIEW_CHECKOUT_VALUE_IN_MICRO_DOLLAR',
    InappCheckoutCostPerAction: 'INAPP_CHECKOUT_COST_PER_ACTION',
    TotalOfflineCheckout: 'TOTAL_OFFLINE_CHECKOUT',
    IdeaPinProductTagVisit1: 'IDEA_PIN_PRODUCT_TAG_VISIT_1',
    IdeaPinProductTagVisit2: 'IDEA_PIN_PRODUCT_TAG_VISIT_2',
    TotalIdeaPinProductTagVisit: 'TOTAL_IDEA_PIN_PRODUCT_TAG_VISIT',
    Leads: 'LEADS',
    CostPerLead: 'COST_PER_LEAD',
    QuizCompleted: 'QUIZ_COMPLETED',
    QuizPinResultOpen: 'QUIZ_PIN_RESULT_OPEN',
    QuizCompletionRate: 'QUIZ_COMPLETION_RATE',
    ShowcasePinClickthrough: 'SHOWCASE_PIN_CLICKTHROUGH',
    ShowcaseSubpageClickthrough: 'SHOWCASE_SUBPAGE_CLICKTHROUGH',
    ShowcaseSubpinClickthrough: 'SHOWCASE_SUBPIN_CLICKTHROUGH',
    ShowcaseSubpageImpression: 'SHOWCASE_SUBPAGE_IMPRESSION',
    ShowcaseSubpinImpression: 'SHOWCASE_SUBPIN_IMPRESSION',
    ShowcaseSubpageSwipeLeft: 'SHOWCASE_SUBPAGE_SWIPE_LEFT',
    ShowcaseSubpageSwipeRight: 'SHOWCASE_SUBPAGE_SWIPE_RIGHT',
    ShowcaseSubpinSwipeLeft: 'SHOWCASE_SUBPIN_SWIPE_LEFT',
    ShowcaseSubpinSwipeRight: 'SHOWCASE_SUBPIN_SWIPE_RIGHT',
    ShowcaseSubpageRepin: 'SHOWCASE_SUBPAGE_REPIN',
    ShowcaseSubpinRepin: 'SHOWCASE_SUBPIN_REPIN',
    ShowcaseSubpageCloseup: 'SHOWCASE_SUBPAGE_CLOSEUP',
    ShowcaseCardThumbnailSwipeForward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_FORWARD',
    ShowcaseCardThumbnailSwipeBackward: 'SHOWCASE_CARD_THUMBNAIL_SWIPE_BACKWARD',
    ShowcaseAverageSubpageCloseupPerSession: 'SHOWCASE_AVERAGE_SUBPAGE_CLOSEUP_PER_SESSION',
    TotalCheckoutConversionRate: 'TOTAL_CHECKOUT_CONVERSION_RATE',
    TotalViewCategoryConversionRate: 'TOTAL_VIEW_CATEGORY_CONVERSION_RATE',
    TotalAddToCartConversionRate: 'TOTAL_ADD_TO_CART_CONVERSION_RATE',
    TotalSignupConversionRate: 'TOTAL_SIGNUP_CONVERSION_RATE',
    TotalPageVisitConversionRate: 'TOTAL_PAGE_VISIT_CONVERSION_RATE',
    TotalLeadConversionRate: 'TOTAL_LEAD_CONVERSION_RATE',
    TotalSearchConversionRate: 'TOTAL_SEARCH_CONVERSION_RATE',
    TotalWatchVideoConversionRate: 'TOTAL_WATCH_VIDEO_CONVERSION_RATE',
    TotalUnknownConversionRate: 'TOTAL_UNKNOWN_CONVERSION_RATE',
    TotalCustomConversionRate: 'TOTAL_CUSTOM_CONVERSION_RATE'
} as const;
export type ProductGroupsAnalyticsColumnsEnum = typeof ProductGroupsAnalyticsColumnsEnum[keyof typeof ProductGroupsAnalyticsColumnsEnum];
/**
 * @export
 */
export const ProductGroupsAnalyticsClickWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type ProductGroupsAnalyticsClickWindowDaysEnum = typeof ProductGroupsAnalyticsClickWindowDaysEnum[keyof typeof ProductGroupsAnalyticsClickWindowDaysEnum];
/**
 * @export
 */
export const ProductGroupsAnalyticsEngagementWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type ProductGroupsAnalyticsEngagementWindowDaysEnum = typeof ProductGroupsAnalyticsEngagementWindowDaysEnum[keyof typeof ProductGroupsAnalyticsEngagementWindowDaysEnum];
/**
 * @export
 */
export const ProductGroupsAnalyticsViewWindowDaysEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_7: 7,
    NUMBER_14: 14,
    NUMBER_30: 30,
    NUMBER_60: 60
} as const;
export type ProductGroupsAnalyticsViewWindowDaysEnum = typeof ProductGroupsAnalyticsViewWindowDaysEnum[keyof typeof ProductGroupsAnalyticsViewWindowDaysEnum];
/**
 * @export
 */
export const ProductGroupsAnalyticsConversionReportTimeEnum = {
    AdAction: 'TIME_OF_AD_ACTION',
    Conversion: 'TIME_OF_CONVERSION'
} as const;
export type ProductGroupsAnalyticsConversionReportTimeEnum = typeof ProductGroupsAnalyticsConversionReportTimeEnum[keyof typeof ProductGroupsAnalyticsConversionReportTimeEnum];


/**
 * ResourcesApi - axios parameter creator
 * @export
 */
export const ResourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get Ad Accounts countries
         * @summary Get ad accounts countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountCountriesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/ad_account_countries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the definitions for ads and organic metrics available across both synchronous and asynchronous report endpoints. The `display_name` attribute will match how the metric is named in our native tools like Ads Manager. See <a href=\'/docs/api-features/analytics-overview/\'>Organic Analytics</a> and <a href=\'/docs/api-features/ads-reporting/\'>Ads Analytics</a> for more information.
         * @summary Get available metrics\' definitions
         * @param {DeliveryMetricsGetReportTypeEnum} [reportType] Report type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryMetricsGet: async (reportType?: DeliveryMetricsGetReportTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/delivery_metrics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read", "pins:read", "user_accounts:read"], configuration)

            if (reportType !== undefined) {
                localVarQueryParameter['report_type'] = reportType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Get details of a specific interest given interest ID.</p> <p>Click <a href=\"https://docs.google.com/spreadsheets/d/1HxL-0Z3p2fgxis9YBP2HWC3tvPrs1hAuHDRtH-NJTIM/edit#gid=118370875\" target=\"_blank\">here</a> for a spreadsheet listing interests and their IDs.</p>
         * @summary Get interest details
         * @param {string} interestId Unique identifier of an interest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestTargetingOptionsGet: async (interestId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interestId' is not null or undefined
            assertParamExists('interestTargetingOptionsGet', 'interestId', interestId)
            const localVarPath = `/resources/targeting/interests/{interest_id}`
                .replace(`{${"interest_id"}}`, encodeURIComponent(String(interestId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of all lead form question type names. Some questions might not be used.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead form questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormQuestionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/resources/lead_form_questions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Learn whether conversion or non-conversion metrics are finalized and ready to query.
         * @summary Get metrics ready state
         * @param {string} date Analytics reports request date (UTC). Format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsReadyStateGet: async (date: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'date' is not null or undefined
            assertParamExists('metricsReadyStateGet', 'date', date)
            const localVarPath = `/resources/metrics_ready_state`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>You can use targeting values in ads placement to define your intended audience. </p> <p>Targeting metrics are organized around targeting specifications.</p> <p>For more information on ads targeting, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.</p> <p><b>Sample return:</b></p> <pre class=\"literal-block\"> [{&quot;36313&quot;: &quot;Australia: Moreton Bay - North&quot;, &quot;124735&quot;: &quot;Canada: North Battleford&quot;, &quot;36109&quot;: &quot;Australia: Murray&quot;, &quot;36108&quot;: &quot;Australia: Mid North Coast&quot;, &quot;36101&quot;: &quot;Australia: Capital Region&quot;, &quot;811&quot;: &quot;U.S.: Reno&quot;, &quot;36103&quot;: &quot;Australia: Central West&quot;, &quot;36102&quot;: &quot;Australia: Central Coast&quot;, &quot;36105&quot;: &quot;Australia: Far West and Orana&quot;, &quot;36104&quot;: &quot;Australia: Coffs Harbour - Grafton&quot;, &quot;36107&quot;: &quot;Australia: Illawarra&quot;, &quot;36106&quot;: &quot;Australia: Hunter Valley Exc Newcastle&quot;, &quot;554017&quot;: &quot;New Zealand: Wanganui&quot;, &quot;554016&quot;: &quot;New Zealand: Marlborough&quot;, &quot;554015&quot;: &quot;New Zealand: Gisborne&quot;, &quot;554014&quot;: &quot;New Zealand: Tararua&quot;, &quot;554013&quot;: &quot;New Zealand: Invercargill&quot;, &quot;GR&quot;: &quot;Greece&quot;, &quot;554011&quot;: &quot;New Zealand: Whangarei&quot;, &quot;554010&quot;: &quot;New Zealand: Far North&quot;, &quot;717&quot;: &quot;U.S.: Quincy-Hannibal-Keokuk&quot;, &quot;716&quot;: &quot;U.S.: Baton Rouge&quot;,...}] </pre>
         * @summary Get targeting options
         * @param {TargetingOptionsGetTargetingTypeEnum} targetingType Public targeting type.
         * @param {string} [clientId] Client ID.
         * @param {string} [oauthSignature] Oauth signature
         * @param {string} [timestamp] Timestamp
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingOptionsGet: async (targetingType: TargetingOptionsGetTargetingTypeEnum, clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'targetingType' is not null or undefined
            assertParamExists('targetingOptionsGet', 'targetingType', targetingType)
            const localVarPath = `/resources/targeting/{targeting_type}`
                .replace(`{${"targeting_type"}}`, encodeURIComponent(String(targetingType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (oauthSignature !== undefined) {
                localVarQueryParameter['oauth_signature'] = oauthSignature;
            }

            if (timestamp !== undefined) {
                localVarQueryParameter['timestamp'] = timestamp;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourcesApi - functional programming interface
 * @export
 */
export const ResourcesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourcesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get Ad Accounts countries
         * @summary Get ad accounts countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async adAccountCountriesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AdAccountsCountryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.adAccountCountriesGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.adAccountCountriesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the definitions for ads and organic metrics available across both synchronous and asynchronous report endpoints. The `display_name` attribute will match how the metric is named in our native tools like Ads Manager. See <a href=\'/docs/api-features/analytics-overview/\'>Organic Analytics</a> and <a href=\'/docs/api-features/ads-reporting/\'>Ads Analytics</a> for more information.
         * @summary Get available metrics\' definitions
         * @param {DeliveryMetricsGetReportTypeEnum} [reportType] Report type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deliveryMetricsGet(reportType?: DeliveryMetricsGetReportTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeliveryMetricsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deliveryMetricsGet(reportType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.deliveryMetricsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Get details of a specific interest given interest ID.</p> <p>Click <a href=\"https://docs.google.com/spreadsheets/d/1HxL-0Z3p2fgxis9YBP2HWC3tvPrs1hAuHDRtH-NJTIM/edit#gid=118370875\" target=\"_blank\">here</a> for a spreadsheet listing interests and their IDs.</p>
         * @summary Get interest details
         * @param {string} interestId Unique identifier of an interest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interestTargetingOptionsGet(interestId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SingleInterestTargetingOptionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interestTargetingOptionsGet(interestId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.interestTargetingOptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of all lead form question type names. Some questions might not be used.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead form questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async leadFormQuestionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.leadFormQuestionsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.leadFormQuestionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Learn whether conversion or non-conversion metrics are finalized and ready to query.
         * @summary Get metrics ready state
         * @param {string} date Analytics reports request date (UTC). Format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async metricsReadyStateGet(date: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BookClosedResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.metricsReadyStateGet(date, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.metricsReadyStateGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>You can use targeting values in ads placement to define your intended audience. </p> <p>Targeting metrics are organized around targeting specifications.</p> <p>For more information on ads targeting, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.</p> <p><b>Sample return:</b></p> <pre class=\"literal-block\"> [{&quot;36313&quot;: &quot;Australia: Moreton Bay - North&quot;, &quot;124735&quot;: &quot;Canada: North Battleford&quot;, &quot;36109&quot;: &quot;Australia: Murray&quot;, &quot;36108&quot;: &quot;Australia: Mid North Coast&quot;, &quot;36101&quot;: &quot;Australia: Capital Region&quot;, &quot;811&quot;: &quot;U.S.: Reno&quot;, &quot;36103&quot;: &quot;Australia: Central West&quot;, &quot;36102&quot;: &quot;Australia: Central Coast&quot;, &quot;36105&quot;: &quot;Australia: Far West and Orana&quot;, &quot;36104&quot;: &quot;Australia: Coffs Harbour - Grafton&quot;, &quot;36107&quot;: &quot;Australia: Illawarra&quot;, &quot;36106&quot;: &quot;Australia: Hunter Valley Exc Newcastle&quot;, &quot;554017&quot;: &quot;New Zealand: Wanganui&quot;, &quot;554016&quot;: &quot;New Zealand: Marlborough&quot;, &quot;554015&quot;: &quot;New Zealand: Gisborne&quot;, &quot;554014&quot;: &quot;New Zealand: Tararua&quot;, &quot;554013&quot;: &quot;New Zealand: Invercargill&quot;, &quot;GR&quot;: &quot;Greece&quot;, &quot;554011&quot;: &quot;New Zealand: Whangarei&quot;, &quot;554010&quot;: &quot;New Zealand: Far North&quot;, &quot;717&quot;: &quot;U.S.: Quincy-Hannibal-Keokuk&quot;, &quot;716&quot;: &quot;U.S.: Baton Rouge&quot;,...}] </pre>
         * @summary Get targeting options
         * @param {TargetingOptionsGetTargetingTypeEnum} targetingType Public targeting type.
         * @param {string} [clientId] Client ID.
         * @param {string} [oauthSignature] Oauth signature
         * @param {string} [timestamp] Timestamp
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async targetingOptionsGet(targetingType: TargetingOptionsGetTargetingTypeEnum, clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.targetingOptionsGet(targetingType, clientId, oauthSignature, timestamp, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourcesApi.targetingOptionsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourcesApi - factory interface
 * @export
 */
export const ResourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourcesApiFp(configuration)
    return {
        /**
         * Get Ad Accounts countries
         * @summary Get ad accounts countries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adAccountCountriesGet(options?: RawAxiosRequestConfig): AxiosPromise<AdAccountsCountryResponse> {
            return localVarFp.adAccountCountriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the definitions for ads and organic metrics available across both synchronous and asynchronous report endpoints. The `display_name` attribute will match how the metric is named in our native tools like Ads Manager. See <a href=\'/docs/api-features/analytics-overview/\'>Organic Analytics</a> and <a href=\'/docs/api-features/ads-reporting/\'>Ads Analytics</a> for more information.
         * @summary Get available metrics\' definitions
         * @param {DeliveryMetricsGetReportTypeEnum} [reportType] Report type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deliveryMetricsGet(reportType?: DeliveryMetricsGetReportTypeEnum, options?: RawAxiosRequestConfig): AxiosPromise<DeliveryMetricsResponse> {
            return localVarFp.deliveryMetricsGet(reportType, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Get details of a specific interest given interest ID.</p> <p>Click <a href=\"https://docs.google.com/spreadsheets/d/1HxL-0Z3p2fgxis9YBP2HWC3tvPrs1hAuHDRtH-NJTIM/edit#gid=118370875\" target=\"_blank\">here</a> for a spreadsheet listing interests and their IDs.</p>
         * @summary Get interest details
         * @param {string} interestId Unique identifier of an interest.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interestTargetingOptionsGet(interestId: string, options?: RawAxiosRequestConfig): AxiosPromise<SingleInterestTargetingOptionResponse> {
            return localVarFp.interestTargetingOptionsGet(interestId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of all lead form question type names. Some questions might not be used.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
         * @summary Get lead form questions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        leadFormQuestionsGet(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.leadFormQuestionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Learn whether conversion or non-conversion metrics are finalized and ready to query.
         * @summary Get metrics ready state
         * @param {string} date Analytics reports request date (UTC). Format: YYYY-MM-DD
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        metricsReadyStateGet(date: string, options?: RawAxiosRequestConfig): AxiosPromise<BookClosedResponse> {
            return localVarFp.metricsReadyStateGet(date, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>You can use targeting values in ads placement to define your intended audience. </p> <p>Targeting metrics are organized around targeting specifications.</p> <p>For more information on ads targeting, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.</p> <p><b>Sample return:</b></p> <pre class=\"literal-block\"> [{&quot;36313&quot;: &quot;Australia: Moreton Bay - North&quot;, &quot;124735&quot;: &quot;Canada: North Battleford&quot;, &quot;36109&quot;: &quot;Australia: Murray&quot;, &quot;36108&quot;: &quot;Australia: Mid North Coast&quot;, &quot;36101&quot;: &quot;Australia: Capital Region&quot;, &quot;811&quot;: &quot;U.S.: Reno&quot;, &quot;36103&quot;: &quot;Australia: Central West&quot;, &quot;36102&quot;: &quot;Australia: Central Coast&quot;, &quot;36105&quot;: &quot;Australia: Far West and Orana&quot;, &quot;36104&quot;: &quot;Australia: Coffs Harbour - Grafton&quot;, &quot;36107&quot;: &quot;Australia: Illawarra&quot;, &quot;36106&quot;: &quot;Australia: Hunter Valley Exc Newcastle&quot;, &quot;554017&quot;: &quot;New Zealand: Wanganui&quot;, &quot;554016&quot;: &quot;New Zealand: Marlborough&quot;, &quot;554015&quot;: &quot;New Zealand: Gisborne&quot;, &quot;554014&quot;: &quot;New Zealand: Tararua&quot;, &quot;554013&quot;: &quot;New Zealand: Invercargill&quot;, &quot;GR&quot;: &quot;Greece&quot;, &quot;554011&quot;: &quot;New Zealand: Whangarei&quot;, &quot;554010&quot;: &quot;New Zealand: Far North&quot;, &quot;717&quot;: &quot;U.S.: Quincy-Hannibal-Keokuk&quot;, &quot;716&quot;: &quot;U.S.: Baton Rouge&quot;,...}] </pre>
         * @summary Get targeting options
         * @param {TargetingOptionsGetTargetingTypeEnum} targetingType Public targeting type.
         * @param {string} [clientId] Client ID.
         * @param {string} [oauthSignature] Oauth signature
         * @param {string} [timestamp] Timestamp
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingOptionsGet(targetingType: TargetingOptionsGetTargetingTypeEnum, clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.targetingOptionsGet(targetingType, clientId, oauthSignature, timestamp, adAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourcesApi - object-oriented interface
 * @export
 * @class ResourcesApi
 * @extends {BaseAPI}
 */
export class ResourcesApi extends BaseAPI {
    /**
     * Get Ad Accounts countries
     * @summary Get ad accounts countries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public adAccountCountriesGet(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).adAccountCountriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the definitions for ads and organic metrics available across both synchronous and asynchronous report endpoints. The `display_name` attribute will match how the metric is named in our native tools like Ads Manager. See <a href=\'/docs/api-features/analytics-overview/\'>Organic Analytics</a> and <a href=\'/docs/api-features/ads-reporting/\'>Ads Analytics</a> for more information.
     * @summary Get available metrics\' definitions
     * @param {DeliveryMetricsGetReportTypeEnum} [reportType] Report type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public deliveryMetricsGet(reportType?: DeliveryMetricsGetReportTypeEnum, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).deliveryMetricsGet(reportType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Get details of a specific interest given interest ID.</p> <p>Click <a href=\"https://docs.google.com/spreadsheets/d/1HxL-0Z3p2fgxis9YBP2HWC3tvPrs1hAuHDRtH-NJTIM/edit#gid=118370875\" target=\"_blank\">here</a> for a spreadsheet listing interests and their IDs.</p>
     * @summary Get interest details
     * @param {string} interestId Unique identifier of an interest.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public interestTargetingOptionsGet(interestId: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).interestTargetingOptionsGet(interestId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of all lead form question type names. Some questions might not be used.  <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>
     * @summary Get lead form questions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public leadFormQuestionsGet(options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).leadFormQuestionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Learn whether conversion or non-conversion metrics are finalized and ready to query.
     * @summary Get metrics ready state
     * @param {string} date Analytics reports request date (UTC). Format: YYYY-MM-DD
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public metricsReadyStateGet(date: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).metricsReadyStateGet(date, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>You can use targeting values in ads placement to define your intended audience. </p> <p>Targeting metrics are organized around targeting specifications.</p> <p>For more information on ads targeting, see <a class=\"reference external\" href=\"https://help.pinterest.com/en/business/article/audience-targeting\" target=\"_blank\">Audience targeting</a>.</p> <p><b>Sample return:</b></p> <pre class=\"literal-block\"> [{&quot;36313&quot;: &quot;Australia: Moreton Bay - North&quot;, &quot;124735&quot;: &quot;Canada: North Battleford&quot;, &quot;36109&quot;: &quot;Australia: Murray&quot;, &quot;36108&quot;: &quot;Australia: Mid North Coast&quot;, &quot;36101&quot;: &quot;Australia: Capital Region&quot;, &quot;811&quot;: &quot;U.S.: Reno&quot;, &quot;36103&quot;: &quot;Australia: Central West&quot;, &quot;36102&quot;: &quot;Australia: Central Coast&quot;, &quot;36105&quot;: &quot;Australia: Far West and Orana&quot;, &quot;36104&quot;: &quot;Australia: Coffs Harbour - Grafton&quot;, &quot;36107&quot;: &quot;Australia: Illawarra&quot;, &quot;36106&quot;: &quot;Australia: Hunter Valley Exc Newcastle&quot;, &quot;554017&quot;: &quot;New Zealand: Wanganui&quot;, &quot;554016&quot;: &quot;New Zealand: Marlborough&quot;, &quot;554015&quot;: &quot;New Zealand: Gisborne&quot;, &quot;554014&quot;: &quot;New Zealand: Tararua&quot;, &quot;554013&quot;: &quot;New Zealand: Invercargill&quot;, &quot;GR&quot;: &quot;Greece&quot;, &quot;554011&quot;: &quot;New Zealand: Whangarei&quot;, &quot;554010&quot;: &quot;New Zealand: Far North&quot;, &quot;717&quot;: &quot;U.S.: Quincy-Hannibal-Keokuk&quot;, &quot;716&quot;: &quot;U.S.: Baton Rouge&quot;,...}] </pre>
     * @summary Get targeting options
     * @param {TargetingOptionsGetTargetingTypeEnum} targetingType Public targeting type.
     * @param {string} [clientId] Client ID.
     * @param {string} [oauthSignature] Oauth signature
     * @param {string} [timestamp] Timestamp
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourcesApi
     */
    public targetingOptionsGet(targetingType: TargetingOptionsGetTargetingTypeEnum, clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return ResourcesApiFp(this.configuration).targetingOptionsGet(targetingType, clientId, oauthSignature, timestamp, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DeliveryMetricsGetReportTypeEnum = {
    Sync: 'SYNC',
    Async: 'ASYNC'
} as const;
export type DeliveryMetricsGetReportTypeEnum = typeof DeliveryMetricsGetReportTypeEnum[keyof typeof DeliveryMetricsGetReportTypeEnum];
/**
 * @export
 */
export const TargetingOptionsGetTargetingTypeEnum = {
    Apptype: 'APPTYPE',
    Gender: 'GENDER',
    Locale: 'LOCALE',
    AgeBucket: 'AGE_BUCKET',
    Location: 'LOCATION',
    Geo: 'GEO',
    Interest: 'INTEREST',
    Keyword: 'KEYWORD',
    AudienceInclude: 'AUDIENCE_INCLUDE',
    AudienceExclude: 'AUDIENCE_EXCLUDE'
} as const;
export type TargetingOptionsGetTargetingTypeEnum = typeof TargetingOptionsGetTargetingTypeEnum[keyof typeof TargetingOptionsGetTargetingTypeEnum];


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get the top 10 Pins by a given search term.
         * @summary Search pins by a given search term
         * @param {string} term Search term to look up pins.
         * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {string} [locale] Search locale.
         * @param {number} [limit] Max search result size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPartnerPins: async (term: string, countryCode: string, bookmark?: string, locale?: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('searchPartnerPins', 'term', term)
            // verify required parameter 'countryCode' is not null or undefined
            assertParamExists('searchPartnerPins', 'countryCode', countryCode)
            const localVarPath = `/search/partner/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "pins:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (countryCode !== undefined) {
                localVarQueryParameter['country_code'] = countryCode;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (locale !== undefined) {
                localVarQueryParameter['locale'] = locale;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for boards for the \"operation user_account\". This includes boards of all board types. - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Search user\'s boards
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [query] Search query. Can contain pin description keywords or comma-separated pin IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserBoardsGet: async (adAccountId?: string, bookmark?: string, pageSize?: number, query?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/search/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:read_secret"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["boards:read", "boards:read_secret"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Search for pins for the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Search user\'s Pins
         * @param {string} query Search query. Can contain pin description keywords or comma-separated pin IDs.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserPinsList: async (query: string, adAccountId?: string, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchUserPinsList', 'query', query)
            const localVarPath = `/search/pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["boards:read", "boards:read_secret", "pins:read", "pins:read_secret"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SearchApiAxiosParamCreator(configuration)
    return {
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get the top 10 Pins by a given search term.
         * @summary Search pins by a given search term
         * @param {string} term Search term to look up pins.
         * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {string} [locale] Search locale.
         * @param {number} [limit] Max search result size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPartnerPins(term: string, countryCode: string, bookmark?: string, locale?: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPartnerPins200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPartnerPins(term, countryCode, bookmark, locale, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchPartnerPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for boards for the \"operation user_account\". This includes boards of all board types. - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Search user\'s boards
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [query] Search query. Can contain pin description keywords or comma-separated pin IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUserBoardsGet(adAccountId?: string, bookmark?: string, pageSize?: number, query?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchUserBoardsGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUserBoardsGet(adAccountId, bookmark, pageSize, query, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUserBoardsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Search for pins for the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Search user\'s Pins
         * @param {string} query Search query. Can contain pin description keywords or comma-separated pin IDs.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUserPinsList(query: string, adAccountId?: string, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PinsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUserPinsList(query, adAccountId, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['SearchApi.searchUserPinsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SearchApiFp(configuration)
    return {
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get the top 10 Pins by a given search term.
         * @summary Search pins by a given search term
         * @param {string} term Search term to look up pins.
         * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {string} [locale] Search locale.
         * @param {number} [limit] Max search result size
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPartnerPins(term: string, countryCode: string, bookmark?: string, locale?: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<SearchPartnerPins200Response> {
            return localVarFp.searchPartnerPins(term, countryCode, bookmark, locale, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for boards for the \"operation user_account\". This includes boards of all board types. - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Search user\'s boards
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [query] Search query. Can contain pin description keywords or comma-separated pin IDs.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserBoardsGet(adAccountId?: string, bookmark?: string, pageSize?: number, query?: string, options?: RawAxiosRequestConfig): AxiosPromise<SearchUserBoardsGet200Response> {
            return localVarFp.searchUserBoardsGet(adAccountId, bookmark, pageSize, query, options).then((request) => request(axios, basePath));
        },
        /**
         * Search for pins for the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Search user\'s Pins
         * @param {string} query Search query. Can contain pin description keywords or comma-separated pin IDs.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUserPinsList(query: string, adAccountId?: string, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<PinsList200Response> {
            return localVarFp.searchUserPinsList(query, adAccountId, bookmark, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Get the top 10 Pins by a given search term.
     * @summary Search pins by a given search term
     * @param {string} term Search term to look up pins.
     * @param {string} countryCode Two letter country code (ISO 3166-1 alpha-2)
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {string} [locale] Search locale.
     * @param {number} [limit] Max search result size
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchPartnerPins(term: string, countryCode: string, bookmark?: string, locale?: string, limit?: number, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchPartnerPins(term, countryCode, bookmark, locale, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for boards for the \"operation user_account\". This includes boards of all board types. - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
     * @summary Search user\'s boards
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [query] Search query. Can contain pin description keywords or comma-separated pin IDs.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUserBoardsGet(adAccountId?: string, bookmark?: string, pageSize?: number, query?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUserBoardsGet(adAccountId, bookmark, pageSize, query, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Search for pins for the \"operation user_account\". - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
     * @summary Search user\'s Pins
     * @param {string} query Search query. Can contain pin description keywords or comma-separated pin IDs.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchUserPinsList(query: string, adAccountId?: string, bookmark?: string, options?: RawAxiosRequestConfig) {
        return SearchApiFp(this.configuration).searchUserPinsList(query, adAccountId, bookmark, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TargetingTemplateApi - axios parameter creator
 * @export
 */
export const TargetingTemplateApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <p>Targeting templates allow advertisers to save a set of targeting details including audience lists,  keywords & interest, demographics, and placements to use more than once during the campaign creation process.</p>  <p>Templates can be used to build out basic targeting criteria that you plan to use across campaigns and to reuse   performance targeting from prior campaigns for new campaigns.</p>
         * @summary Create targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateCreate} targetingTemplateCreate targeting template creation entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingTemplateCreate: async (adAccountId: string, targetingTemplateCreate: TargetingTemplateCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('targetingTemplateCreate', 'adAccountId', adAccountId)
            // verify required parameter 'targetingTemplateCreate' is not null or undefined
            assertParamExists('targetingTemplateCreate', 'targetingTemplateCreate', targetingTemplateCreate)
            const localVarPath = `/ad_accounts/{ad_account_id}/targeting_templates`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetingTemplateCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of the targeting templates in the specified <code>ad_account_id</code>
         * @summary List targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {boolean} [includeSizing] Include audience sizing in result or not
         * @param {string} [searchQuery] Search keyword for targeting templates
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingTemplateList: async (adAccountId: string, order?: TargetingTemplateListOrderEnum, includeSizing?: boolean, searchQuery?: string, pageSize?: number, bookmark?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('targetingTemplateList', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/targeting_templates`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (includeSizing !== undefined) {
                localVarQueryParameter['include_sizing'] = includeSizing;
            }

            if (searchQuery !== undefined) {
                localVarQueryParameter['search_query'] = searchQuery;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <p>Update the targeting template given advertiser ID and targeting template ID</p>
         * @summary Update targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateUpdateRequest} targetingTemplateUpdateRequest Operation type and targeting template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingTemplateUpdate: async (adAccountId: string, targetingTemplateUpdateRequest: TargetingTemplateUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('targetingTemplateUpdate', 'adAccountId', adAccountId)
            // verify required parameter 'targetingTemplateUpdateRequest' is not null or undefined
            assertParamExists('targetingTemplateUpdate', 'targetingTemplateUpdateRequest', targetingTemplateUpdateRequest)
            const localVarPath = `/ad_accounts/{ad_account_id}/targeting_templates`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(targetingTemplateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TargetingTemplateApi - functional programming interface
 * @export
 */
export const TargetingTemplateApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TargetingTemplateApiAxiosParamCreator(configuration)
    return {
        /**
         * <p>Targeting templates allow advertisers to save a set of targeting details including audience lists,  keywords & interest, demographics, and placements to use more than once during the campaign creation process.</p>  <p>Templates can be used to build out basic targeting criteria that you plan to use across campaigns and to reuse   performance targeting from prior campaigns for new campaigns.</p>
         * @summary Create targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateCreate} targetingTemplateCreate targeting template creation entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async targetingTemplateCreate(adAccountId: string, targetingTemplateCreate: TargetingTemplateCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetingTemplateGetResponseData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.targetingTemplateCreate(adAccountId, targetingTemplateCreate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TargetingTemplateApi.targetingTemplateCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of the targeting templates in the specified <code>ad_account_id</code>
         * @summary List targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {boolean} [includeSizing] Include audience sizing in result or not
         * @param {string} [searchQuery] Search keyword for targeting templates
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async targetingTemplateList(adAccountId: string, order?: TargetingTemplateListOrderEnum, includeSizing?: boolean, searchQuery?: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TargetingTemplateList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.targetingTemplateList(adAccountId, order, includeSizing, searchQuery, pageSize, bookmark, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TargetingTemplateApi.targetingTemplateList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <p>Update the targeting template given advertiser ID and targeting template ID</p>
         * @summary Update targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateUpdateRequest} targetingTemplateUpdateRequest Operation type and targeting template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async targetingTemplateUpdate(adAccountId: string, targetingTemplateUpdateRequest: TargetingTemplateUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.targetingTemplateUpdate(adAccountId, targetingTemplateUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TargetingTemplateApi.targetingTemplateUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TargetingTemplateApi - factory interface
 * @export
 */
export const TargetingTemplateApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TargetingTemplateApiFp(configuration)
    return {
        /**
         * <p>Targeting templates allow advertisers to save a set of targeting details including audience lists,  keywords & interest, demographics, and placements to use more than once during the campaign creation process.</p>  <p>Templates can be used to build out basic targeting criteria that you plan to use across campaigns and to reuse   performance targeting from prior campaigns for new campaigns.</p>
         * @summary Create targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateCreate} targetingTemplateCreate targeting template creation entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingTemplateCreate(adAccountId: string, targetingTemplateCreate: TargetingTemplateCreate, options?: RawAxiosRequestConfig): AxiosPromise<TargetingTemplateGetResponseData> {
            return localVarFp.targetingTemplateCreate(adAccountId, targetingTemplateCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of the targeting templates in the specified <code>ad_account_id</code>
         * @summary List targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
         * @param {boolean} [includeSizing] Include audience sizing in result or not
         * @param {string} [searchQuery] Search keyword for targeting templates
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingTemplateList(adAccountId: string, order?: TargetingTemplateListOrderEnum, includeSizing?: boolean, searchQuery?: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig): AxiosPromise<TargetingTemplateList200Response> {
            return localVarFp.targetingTemplateList(adAccountId, order, includeSizing, searchQuery, pageSize, bookmark, options).then((request) => request(axios, basePath));
        },
        /**
         * <p>Update the targeting template given advertiser ID and targeting template ID</p>
         * @summary Update targeting templates
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {TargetingTemplateUpdateRequest} targetingTemplateUpdateRequest Operation type and targeting template ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        targetingTemplateUpdate(adAccountId: string, targetingTemplateUpdateRequest: TargetingTemplateUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.targetingTemplateUpdate(adAccountId, targetingTemplateUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TargetingTemplateApi - object-oriented interface
 * @export
 * @class TargetingTemplateApi
 * @extends {BaseAPI}
 */
export class TargetingTemplateApi extends BaseAPI {
    /**
     * <p>Targeting templates allow advertisers to save a set of targeting details including audience lists,  keywords & interest, demographics, and placements to use more than once during the campaign creation process.</p>  <p>Templates can be used to build out basic targeting criteria that you plan to use across campaigns and to reuse   performance targeting from prior campaigns for new campaigns.</p>
     * @summary Create targeting templates
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {TargetingTemplateCreate} targetingTemplateCreate targeting template creation entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TargetingTemplateApi
     */
    public targetingTemplateCreate(adAccountId: string, targetingTemplateCreate: TargetingTemplateCreate, options?: RawAxiosRequestConfig) {
        return TargetingTemplateApiFp(this.configuration).targetingTemplateCreate(adAccountId, targetingTemplateCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of the targeting templates in the specified <code>ad_account_id</code>
     * @summary List targeting templates
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {TargetingTemplateListOrderEnum} [order] The order in which to sort the items returned: ASCENDING or DESCENDING by ID. Note that higher-value IDs are associated with more-recently added items.
     * @param {boolean} [includeSizing] Include audience sizing in result or not
     * @param {string} [searchQuery] Search keyword for targeting templates
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TargetingTemplateApi
     */
    public targetingTemplateList(adAccountId: string, order?: TargetingTemplateListOrderEnum, includeSizing?: boolean, searchQuery?: string, pageSize?: number, bookmark?: string, options?: RawAxiosRequestConfig) {
        return TargetingTemplateApiFp(this.configuration).targetingTemplateList(adAccountId, order, includeSizing, searchQuery, pageSize, bookmark, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <p>Update the targeting template given advertiser ID and targeting template ID</p>
     * @summary Update targeting templates
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {TargetingTemplateUpdateRequest} targetingTemplateUpdateRequest Operation type and targeting template ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TargetingTemplateApi
     */
    public targetingTemplateUpdate(adAccountId: string, targetingTemplateUpdateRequest: TargetingTemplateUpdateRequest, options?: RawAxiosRequestConfig) {
        return TargetingTemplateApiFp(this.configuration).targetingTemplateUpdate(adAccountId, targetingTemplateUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TargetingTemplateListOrderEnum = {
    Ascending: 'ASCENDING',
    Descending: 'DESCENDING'
} as const;
export type TargetingTemplateListOrderEnum = typeof TargetingTemplateListOrderEnum[keyof typeof TargetingTemplateListOrderEnum];


/**
 * TermsApi - axios parameter creator
 * @export
 */
export const TermsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of terms logically related to each input term. <p/> Example: the term \'workout\' would list related terms like \'one song workout\', \'yoga workout\', \'workout motivation\', etc.
         * @summary List related terms
         * @param {Array<string>} terms List of input terms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termsRelatedList: async (terms: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'terms' is not null or undefined
            assertParamExists('termsRelatedList', 'terms', terms)
            const localVarPath = `/terms/related`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (terms) {
                localVarQueryParameter['terms'] = terms;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get popular search terms that begin with your input term. <p/> Example: \'sport\' would return popular terms like \'sports bar\' and \'sportswear\', but not \'motor sports\' since the phrase does not begin with the given term.
         * @summary List suggested terms
         * @param {string} term Input term.
         * @param {number} [limit] Max suggested terms to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termsSuggestedList: async (term: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('termsSuggestedList', 'term', term)
            const localVarPath = `/terms/suggested`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermsApi - functional programming interface
 * @export
 */
export const TermsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TermsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of terms logically related to each input term. <p/> Example: the term \'workout\' would list related terms like \'one song workout\', \'yoga workout\', \'workout motivation\', etc.
         * @summary List related terms
         * @param {Array<string>} terms List of input terms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async termsRelatedList(terms: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RelatedTerms>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.termsRelatedList(terms, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TermsApi.termsRelatedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get popular search terms that begin with your input term. <p/> Example: \'sport\' would return popular terms like \'sports bar\' and \'sportswear\', but not \'motor sports\' since the phrase does not begin with the given term.
         * @summary List suggested terms
         * @param {string} term Input term.
         * @param {number} [limit] Max suggested terms to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async termsSuggestedList(term: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.termsSuggestedList(term, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TermsApi.termsSuggestedList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TermsApi - factory interface
 * @export
 */
export const TermsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TermsApiFp(configuration)
    return {
        /**
         * Get a list of terms logically related to each input term. <p/> Example: the term \'workout\' would list related terms like \'one song workout\', \'yoga workout\', \'workout motivation\', etc.
         * @summary List related terms
         * @param {Array<string>} terms List of input terms.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termsRelatedList(terms: Array<string>, options?: RawAxiosRequestConfig): AxiosPromise<RelatedTerms> {
            return localVarFp.termsRelatedList(terms, options).then((request) => request(axios, basePath));
        },
        /**
         * Get popular search terms that begin with your input term. <p/> Example: \'sport\' would return popular terms like \'sports bar\' and \'sportswear\', but not \'motor sports\' since the phrase does not begin with the given term.
         * @summary List suggested terms
         * @param {string} term Input term.
         * @param {number} [limit] Max suggested terms to return.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termsSuggestedList(term: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.termsSuggestedList(term, limit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TermsApi - object-oriented interface
 * @export
 * @class TermsApi
 * @extends {BaseAPI}
 */
export class TermsApi extends BaseAPI {
    /**
     * Get a list of terms logically related to each input term. <p/> Example: the term \'workout\' would list related terms like \'one song workout\', \'yoga workout\', \'workout motivation\', etc.
     * @summary List related terms
     * @param {Array<string>} terms List of input terms.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public termsRelatedList(terms: Array<string>, options?: RawAxiosRequestConfig) {
        return TermsApiFp(this.configuration).termsRelatedList(terms, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get popular search terms that begin with your input term. <p/> Example: \'sport\' would return popular terms like \'sports bar\' and \'sportswear\', but not \'motor sports\' since the phrase does not begin with the given term.
     * @summary List suggested terms
     * @param {string} term Input term.
     * @param {number} [limit] Max suggested terms to return.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsApi
     */
    public termsSuggestedList(term: string, limit?: number, options?: RawAxiosRequestConfig) {
        return TermsApiFp(this.configuration).termsSuggestedList(term, limit, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TermsOfServiceApi - axios parameter creator
 * @export
 */
export const TermsOfServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the text of the terms of service and see whether the advertiser has accepted the terms of service.
         * @summary Get terms of service
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} [includeHtml] Return HTML in TOS text.
         * @param {string} [tosType] Request type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termsOfServiceGet: async (adAccountId: string, includeHtml?: boolean, tosType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adAccountId' is not null or undefined
            assertParamExists('termsOfServiceGet', 'adAccountId', adAccountId)
            const localVarPath = `/ad_accounts/{ad_account_id}/terms_of_service`
                .replace(`{${"ad_account_id"}}`, encodeURIComponent(String(adAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["ads:read"], configuration)

            if (includeHtml !== undefined) {
                localVarQueryParameter['include_html'] = includeHtml;
            }

            if (tosType !== undefined) {
                localVarQueryParameter['tos_type'] = tosType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TermsOfServiceApi - functional programming interface
 * @export
 */
export const TermsOfServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TermsOfServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the text of the terms of service and see whether the advertiser has accepted the terms of service.
         * @summary Get terms of service
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} [includeHtml] Return HTML in TOS text.
         * @param {string} [tosType] Request type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async termsOfServiceGet(adAccountId: string, includeHtml?: boolean, tosType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TermsOfService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.termsOfServiceGet(adAccountId, includeHtml, tosType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TermsOfServiceApi.termsOfServiceGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TermsOfServiceApi - factory interface
 * @export
 */
export const TermsOfServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TermsOfServiceApiFp(configuration)
    return {
        /**
         * Get the text of the terms of service and see whether the advertiser has accepted the terms of service.
         * @summary Get terms of service
         * @param {string} adAccountId Unique identifier of an ad account.
         * @param {boolean} [includeHtml] Return HTML in TOS text.
         * @param {string} [tosType] Request type.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        termsOfServiceGet(adAccountId: string, includeHtml?: boolean, tosType?: string, options?: RawAxiosRequestConfig): AxiosPromise<TermsOfService> {
            return localVarFp.termsOfServiceGet(adAccountId, includeHtml, tosType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TermsOfServiceApi - object-oriented interface
 * @export
 * @class TermsOfServiceApi
 * @extends {BaseAPI}
 */
export class TermsOfServiceApi extends BaseAPI {
    /**
     * Get the text of the terms of service and see whether the advertiser has accepted the terms of service.
     * @summary Get terms of service
     * @param {string} adAccountId Unique identifier of an ad account.
     * @param {boolean} [includeHtml] Return HTML in TOS text.
     * @param {string} [tosType] Request type.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TermsOfServiceApi
     */
    public termsOfServiceGet(adAccountId: string, includeHtml?: boolean, tosType?: string, options?: RawAxiosRequestConfig) {
        return TermsOfServiceApiFp(this.configuration).termsOfServiceGet(adAccountId, includeHtml, tosType, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserAccountApi - axios parameter creator
 * @export
 */
export const UserAccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a list of the boards a user follows. The request returns a board summary object array.
         * @summary List following boards
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsUserFollowsList: async (bookmark?: string, pageSize?: number, explicitFollowing?: boolean, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account/following/boards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (explicitFollowing !== undefined) {
                localVarQueryParameter['explicit_following'] = explicitFollowing;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
         * @summary Follow user
         * @param {string} username A valid username
         * @param {FollowUserRequest} followUserRequest Follow a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUserUpdate: async (username: string, followUserRequest: FollowUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('followUserUpdate', 'username', username)
            // verify required parameter 'followUserRequest' is not null or undefined
            assertParamExists('followUserUpdate', 'followUserRequest', followUserRequest)
            const localVarPath = `/user_account/following/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:write"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(followUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of your followers.
         * @summary List followers
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followersList: async (bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account/followers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of your linked business accounts.
         * @summary List linked businesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkedBusinessAccountsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account/businesses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Unverifu a website verified by the signed-in user.
         * @summary Unverify website
         * @param {string} website Website with path or domain only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unverifyWebsiteDelete: async (website: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'website' is not null or undefined
            assertParamExists('unverifyWebsiteDelete', 'website', website)
            const localVarPath = `/user_account/websites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:write"], configuration)

            if (website !== undefined) {
                localVarQueryParameter['website'] = website;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
         * @param {UserAccountAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountAnalytics: async (startDate: string, endDate: string, fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsPinFormatEnum, appTypes?: UserAccountAnalyticsAppTypesEnum, contentType?: UserAccountAnalyticsContentTypeEnum, source?: UserAccountAnalyticsSourceEnum, metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>, splitField?: UserAccountAnalyticsSplitFieldEnum, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('userAccountAnalytics', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('userAccountAnalytics', 'endDate', endDate)
            const localVarPath = `/user_account/analytics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (fromClaimedContent !== undefined) {
                localVarQueryParameter['from_claimed_content'] = fromClaimedContent;
            }

            if (pinFormat !== undefined) {
                localVarQueryParameter['pin_format'] = pinFormat;
            }

            if (appTypes !== undefined) {
                localVarQueryParameter['app_types'] = appTypes;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (metricTypes) {
                localVarQueryParameter['metric_types'] = metricTypes.join(COLLECTION_FORMATS.csv);
            }

            if (splitField !== undefined) {
                localVarQueryParameter['split_field'] = splitField;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account top pins analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsTopPinsSortByEnum} sortBy Specify sorting order for metrics
         * @param {UserAccountAnalyticsTopPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsTopPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsTopPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsTopPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsTopPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsTopPinsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
         * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
         * @param {UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountAnalyticsTopPins: async (startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopPinsContentTypeEnum, source?: UserAccountAnalyticsTopPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('userAccountAnalyticsTopPins', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('userAccountAnalyticsTopPins', 'endDate', endDate)
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('userAccountAnalyticsTopPins', 'sortBy', sortBy)
            const localVarPath = `/user_account/analytics/top_pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["pins:read", "user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["pins:read", "user_accounts:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (fromClaimedContent !== undefined) {
                localVarQueryParameter['from_claimed_content'] = fromClaimedContent;
            }

            if (pinFormat !== undefined) {
                localVarQueryParameter['pin_format'] = pinFormat;
            }

            if (appTypes !== undefined) {
                localVarQueryParameter['app_types'] = appTypes;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (metricTypes) {
                localVarQueryParameter['metric_types'] = metricTypes.join(COLLECTION_FORMATS.csv);
            }

            if (numOfPins !== undefined) {
                localVarQueryParameter['num_of_pins'] = numOfPins;
            }

            if (createdInLastNDays !== undefined) {
                localVarQueryParameter['created_in_last_n_days'] = createdInLastNDays;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account top video pins analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsTopVideoPinsSortByEnum} sortBy Specify sorting order for video metrics
         * @param {UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsTopVideoPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsTopVideoPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsTopVideoPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsTopVideoPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>} [metricTypes] Metric types to get video data for, default is all. 
         * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
         * @param {UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountAnalyticsTopVideoPins: async (startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum, source?: UserAccountAnalyticsTopVideoPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'startDate' is not null or undefined
            assertParamExists('userAccountAnalyticsTopVideoPins', 'startDate', startDate)
            // verify required parameter 'endDate' is not null or undefined
            assertParamExists('userAccountAnalyticsTopVideoPins', 'endDate', endDate)
            // verify required parameter 'sortBy' is not null or undefined
            assertParamExists('userAccountAnalyticsTopVideoPins', 'sortBy', sortBy)
            const localVarPath = `/user_account/analytics/top_video_pins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["pins:read", "user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["pins:read", "user_accounts:read"], configuration)

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substring(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substring(0,10) :
                    endDate;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sort_by'] = sortBy;
            }

            if (fromClaimedContent !== undefined) {
                localVarQueryParameter['from_claimed_content'] = fromClaimedContent;
            }

            if (pinFormat !== undefined) {
                localVarQueryParameter['pin_format'] = pinFormat;
            }

            if (appTypes !== undefined) {
                localVarQueryParameter['app_types'] = appTypes;
            }

            if (contentType !== undefined) {
                localVarQueryParameter['content_type'] = contentType;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (metricTypes) {
                localVarQueryParameter['metric_types'] = metricTypes.join(COLLECTION_FORMATS.csv);
            }

            if (numOfPins !== undefined) {
                localVarQueryParameter['num_of_pins'] = numOfPins;
            }

            if (createdInLastNDays !== undefined) {
                localVarQueryParameter['created_in_last_n_days'] = createdInLastNDays;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of a user\'s following interests in one place.
         * @summary List following interests
         * @param {string} username A valid username
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountFollowedInterests: async (username: string, bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('userAccountFollowedInterests', 'username', username)
            const localVarPath = `/users/{username}/interests/follow`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Get user account
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountGet: async (adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a list of who a certain user follows.
         * @summary List following
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {UserFollowingFeedType} [feedType] Thrift param specifying what type of followees will be kept. Default to include all followees.
         * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFollowingGet: async (bookmark?: string, pageSize?: number, feedType?: UserFollowingFeedType, explicitFollowing?: boolean, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account/following`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }

            if (feedType !== undefined) {
                localVarQueryParameter['feed_type'] = feedType;
            }

            if (explicitFollowing !== undefined) {
                localVarQueryParameter['explicit_following'] = explicitFollowing;
            }

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user websites, claimed or not
         * @summary Get user websites
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWebsitesGet: async (bookmark?: string, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account/websites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            if (bookmark !== undefined) {
                localVarQueryParameter['bookmark'] = bookmark;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['page_size'] = pageSize;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Verify a website as a signed-in user.
         * @summary Verify website
         * @param {UserWebsiteVerifyRequest} userWebsiteVerifyRequest Verify a website.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyWebsiteUpdate: async (userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userWebsiteVerifyRequest' is not null or undefined
            assertParamExists('verifyWebsiteUpdate', 'userWebsiteVerifyRequest', userWebsiteVerifyRequest)
            const localVarPath = `/user_account/websites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:write"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userWebsiteVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get verification code for user to install on the website to claim it.
         * @summary Get user verification code for website claiming
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteVerificationGet: async (adAccountId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user_account/websites/verification`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication pinterest_oauth2 required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "pinterest_oauth2", ["user_accounts:read"], configuration)

            // authentication client_credentials required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "client_credentials", ["user_accounts:read"], configuration)

            if (adAccountId !== undefined) {
                localVarQueryParameter['ad_account_id'] = adAccountId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAccountApi - functional programming interface
 * @export
 */
export const UserAccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAccountApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a list of the boards a user follows. The request returns a board summary object array.
         * @summary List following boards
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async boardsUserFollowsList(bookmark?: string, pageSize?: number, explicitFollowing?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BoardsUserFollowsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.boardsUserFollowsList(bookmark, pageSize, explicitFollowing, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.boardsUserFollowsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
         * @summary Follow user
         * @param {string} username A valid username
         * @param {FollowUserRequest} followUserRequest Follow a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followUserUpdate(username: string, followUserRequest: FollowUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followUserUpdate(username, followUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.followUserUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of your followers.
         * @summary List followers
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async followersList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FollowersList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.followersList(bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.followersList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of your linked business accounts.
         * @summary List linked businesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async linkedBusinessAccountsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LinkedBusiness>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.linkedBusinessAccountsGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.linkedBusinessAccountsGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Unverifu a website verified by the signed-in user.
         * @summary Unverify website
         * @param {string} website Website with path or domain only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unverifyWebsiteDelete(website: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unverifyWebsiteDelete(website, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.unverifyWebsiteDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
         * @param {UserAccountAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccountAnalytics(startDate: string, endDate: string, fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsPinFormatEnum, appTypes?: UserAccountAnalyticsAppTypesEnum, contentType?: UserAccountAnalyticsContentTypeEnum, source?: UserAccountAnalyticsSourceEnum, metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>, splitField?: UserAccountAnalyticsSplitFieldEnum, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: AnalyticsMetricsResponse; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccountAnalytics(startDate, endDate, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, splitField, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userAccountAnalytics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account top pins analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsTopPinsSortByEnum} sortBy Specify sorting order for metrics
         * @param {UserAccountAnalyticsTopPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsTopPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsTopPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsTopPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsTopPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsTopPinsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
         * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
         * @param {UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccountAnalyticsTopPins(startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopPinsContentTypeEnum, source?: UserAccountAnalyticsTopPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopPinsAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccountAnalyticsTopPins(startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userAccountAnalyticsTopPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account top video pins analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsTopVideoPinsSortByEnum} sortBy Specify sorting order for video metrics
         * @param {UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsTopVideoPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsTopVideoPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsTopVideoPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsTopVideoPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>} [metricTypes] Metric types to get video data for, default is all. 
         * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
         * @param {UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccountAnalyticsTopVideoPins(startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum, source?: UserAccountAnalyticsTopVideoPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TopVideoPinsAnalyticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccountAnalyticsTopVideoPins(startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userAccountAnalyticsTopVideoPins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of a user\'s following interests in one place.
         * @summary List following interests
         * @param {string} username A valid username
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccountFollowedInterests(username: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAccountFollowedInterests200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccountFollowedInterests(username, bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userAccountFollowedInterests']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Get user account
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userAccountGet(adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userAccountGet(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userAccountGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a list of who a certain user follows.
         * @summary List following
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {UserFollowingFeedType} [feedType] Thrift param specifying what type of followees will be kept. Default to include all followees.
         * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userFollowingGet(bookmark?: string, pageSize?: number, feedType?: UserFollowingFeedType, explicitFollowing?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserFollowingGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userFollowingGet(bookmark, pageSize, feedType, explicitFollowing, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userFollowingGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get user websites, claimed or not
         * @summary Get user websites
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userWebsitesGet(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWebsitesGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userWebsitesGet(bookmark, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.userWebsitesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Verify a website as a signed-in user.
         * @summary Verify website
         * @param {UserWebsiteVerifyRequest} userWebsiteVerifyRequest Verify a website.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyWebsiteUpdate(userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWebsiteSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyWebsiteUpdate(userWebsiteVerifyRequest, adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.verifyWebsiteUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get verification code for user to install on the website to claim it.
         * @summary Get user verification code for website claiming
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteVerificationGet(adAccountId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserWebsiteVerificationCode>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteVerificationGet(adAccountId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAccountApi.websiteVerificationGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAccountApi - factory interface
 * @export
 */
export const UserAccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAccountApiFp(configuration)
    return {
        /**
         * Get a list of the boards a user follows. The request returns a board summary object array.
         * @summary List following boards
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        boardsUserFollowsList(bookmark?: string, pageSize?: number, explicitFollowing?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<BoardsUserFollowsList200Response> {
            return localVarFp.boardsUserFollowsList(bookmark, pageSize, explicitFollowing, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
         * @summary Follow user
         * @param {string} username A valid username
         * @param {FollowUserRequest} followUserRequest Follow a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followUserUpdate(username: string, followUserRequest: FollowUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserSummary> {
            return localVarFp.followUserUpdate(username, followUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of your followers.
         * @summary List followers
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        followersList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<FollowersList200Response> {
            return localVarFp.followersList(bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of your linked business accounts.
         * @summary List linked businesses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkedBusinessAccountsGet(options?: RawAxiosRequestConfig): AxiosPromise<Array<LinkedBusiness>> {
            return localVarFp.linkedBusinessAccountsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Unverifu a website verified by the signed-in user.
         * @summary Unverify website
         * @param {string} website Website with path or domain only
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unverifyWebsiteDelete(website: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unverifyWebsiteDelete(website, options).then((request) => request(axios, basePath));
        },
        /**
         * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
         * @param {UserAccountAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountAnalytics(startDate: string, endDate: string, fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsPinFormatEnum, appTypes?: UserAccountAnalyticsAppTypesEnum, contentType?: UserAccountAnalyticsContentTypeEnum, source?: UserAccountAnalyticsSourceEnum, metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>, splitField?: UserAccountAnalyticsSplitFieldEnum, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: AnalyticsMetricsResponse; }> {
            return localVarFp.userAccountAnalytics(startDate, endDate, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, splitField, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account top pins analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsTopPinsSortByEnum} sortBy Specify sorting order for metrics
         * @param {UserAccountAnalyticsTopPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsTopPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsTopPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsTopPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsTopPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsTopPinsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
         * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
         * @param {UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountAnalyticsTopPins(startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopPinsContentTypeEnum, source?: UserAccountAnalyticsTopPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TopPinsAnalyticsResponse> {
            return localVarFp.userAccountAnalyticsTopPins(startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
         * @summary Get user account top video pins analytics
         * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
         * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
         * @param {UserAccountAnalyticsTopVideoPinsSortByEnum} sortBy Specify sorting order for video metrics
         * @param {UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
         * @param {UserAccountAnalyticsTopVideoPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
         * @param {UserAccountAnalyticsTopVideoPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
         * @param {UserAccountAnalyticsTopVideoPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
         * @param {UserAccountAnalyticsTopVideoPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
         * @param {Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>} [metricTypes] Metric types to get video data for, default is all. 
         * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
         * @param {UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountAnalyticsTopVideoPins(startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum, source?: UserAccountAnalyticsTopVideoPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<TopVideoPinsAnalyticsResponse> {
            return localVarFp.userAccountAnalyticsTopVideoPins(startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of a user\'s following interests in one place.
         * @summary List following interests
         * @param {string} username A valid username
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountFollowedInterests(username: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserAccountFollowedInterests200Response> {
            return localVarFp.userAccountFollowedInterests(username, bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
         * @summary Get user account
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userAccountGet(adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.userAccountGet(adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a list of who a certain user follows.
         * @summary List following
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {UserFollowingFeedType} [feedType] Thrift param specifying what type of followees will be kept. Default to include all followees.
         * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userFollowingGet(bookmark?: string, pageSize?: number, feedType?: UserFollowingFeedType, explicitFollowing?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserFollowingGet200Response> {
            return localVarFp.userFollowingGet(bookmark, pageSize, feedType, explicitFollowing, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user websites, claimed or not
         * @summary Get user websites
         * @param {string} [bookmark] Cursor used to fetch the next page of items
         * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userWebsitesGet(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<UserWebsitesGet200Response> {
            return localVarFp.userWebsitesGet(bookmark, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * Verify a website as a signed-in user.
         * @summary Verify website
         * @param {UserWebsiteVerifyRequest} userWebsiteVerifyRequest Verify a website.
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyWebsiteUpdate(userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserWebsiteSummary> {
            return localVarFp.verifyWebsiteUpdate(userWebsiteVerifyRequest, adAccountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get verification code for user to install on the website to claim it.
         * @summary Get user verification code for website claiming
         * @param {string} [adAccountId] Unique identifier of an ad account.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteVerificationGet(adAccountId?: string, options?: RawAxiosRequestConfig): AxiosPromise<UserWebsiteVerificationCode> {
            return localVarFp.websiteVerificationGet(adAccountId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAccountApi - object-oriented interface
 * @export
 * @class UserAccountApi
 * @extends {BaseAPI}
 */
export class UserAccountApi extends BaseAPI {
    /**
     * Get a list of the boards a user follows. The request returns a board summary object array.
     * @summary List following boards
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public boardsUserFollowsList(bookmark?: string, pageSize?: number, explicitFollowing?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).boardsUserFollowsList(bookmark, pageSize, explicitFollowing, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
     * @summary Follow user
     * @param {string} username A valid username
     * @param {FollowUserRequest} followUserRequest Follow a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public followUserUpdate(username: string, followUserRequest: FollowUserRequest, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).followUserUpdate(username, followUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of your followers.
     * @summary List followers
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public followersList(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).followersList(bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of your linked business accounts.
     * @summary List linked businesses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public linkedBusinessAccountsGet(options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).linkedBusinessAccountsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Unverifu a website verified by the signed-in user.
     * @summary Unverify website
     * @param {string} website Website with path or domain only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public unverifyWebsiteDelete(website: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).unverifyWebsiteDelete(website, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * @summary Get user account analytics
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {UserAccountAnalyticsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
     * @param {UserAccountAnalyticsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
     * @param {UserAccountAnalyticsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
     * @param {UserAccountAnalyticsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
     * @param {UserAccountAnalyticsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
     * @param {Array<UserAccountAnalyticsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
     * @param {UserAccountAnalyticsSplitFieldEnum} [splitField] How to split the data into groups. Not including this param means data won\&#39;t be split.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userAccountAnalytics(startDate: string, endDate: string, fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsPinFormatEnum, appTypes?: UserAccountAnalyticsAppTypesEnum, contentType?: UserAccountAnalyticsContentTypeEnum, source?: UserAccountAnalyticsSourceEnum, metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>, splitField?: UserAccountAnalyticsSplitFieldEnum, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userAccountAnalytics(startDate, endDate, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, splitField, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * @summary Get user account top pins analytics
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {UserAccountAnalyticsTopPinsSortByEnum} sortBy Specify sorting order for metrics
     * @param {UserAccountAnalyticsTopPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
     * @param {UserAccountAnalyticsTopPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
     * @param {UserAccountAnalyticsTopPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
     * @param {UserAccountAnalyticsTopPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
     * @param {UserAccountAnalyticsTopPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
     * @param {Array<UserAccountAnalyticsTopPinsMetricTypesEnum>} [metricTypes] Metric types to get data for, default is all. 
     * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
     * @param {UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userAccountAnalyticsTopPins(startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopPinsContentTypeEnum, source?: UserAccountAnalyticsTopPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userAccountAnalyticsTopPins(startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * @summary Get user account top video pins analytics
     * @param {string} startDate Metric report start date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days back from today.
     * @param {string} endDate Metric report end date (UTC). Format: YYYY-MM-DD. Cannot be more than 90 days past start_date.
     * @param {UserAccountAnalyticsTopVideoPinsSortByEnum} sortBy Specify sorting order for video metrics
     * @param {UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum} [fromClaimedContent] Filter on Pins that match your claimed domain.
     * @param {UserAccountAnalyticsTopVideoPinsPinFormatEnum} [pinFormat] Pin formats to get data for, default is all.
     * @param {UserAccountAnalyticsTopVideoPinsAppTypesEnum} [appTypes] Apps or devices to get data for, default is all.
     * @param {UserAccountAnalyticsTopVideoPinsContentTypeEnum} [contentType] Filter to paid or organic data. Default is all.
     * @param {UserAccountAnalyticsTopVideoPinsSourceEnum} [source] Filter to activity from Pins created and saved by your, or activity created and saved by others from your claimed accounts
     * @param {Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>} [metricTypes] Metric types to get video data for, default is all. 
     * @param {number} [numOfPins] Number of pins to include, default is 10. Max is 50.
     * @param {UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum} [createdInLastNDays] Get metrics for pins created in the last \&quot;n\&quot; days.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userAccountAnalyticsTopVideoPins(startDate: string, endDate: string, sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum, fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum, pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum, appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum, contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum, source?: UserAccountAnalyticsTopVideoPinsSourceEnum, metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>, numOfPins?: number, createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userAccountAnalyticsTopVideoPins(startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of a user\'s following interests in one place.
     * @summary List following interests
     * @param {string} username A valid username
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userAccountFollowedInterests(username: string, bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userAccountFollowedInterests(username, bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
     * @summary Get user account
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userAccountGet(adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userAccountGet(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a list of who a certain user follows.
     * @summary List following
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {UserFollowingFeedType} [feedType] Thrift param specifying what type of followees will be kept. Default to include all followees.
     * @param {boolean} [explicitFollowing] Whether or not to include implicit user follows, which means followees with board follows. When explicit_following is True, it means we only want explicit user follows.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userFollowingGet(bookmark?: string, pageSize?: number, feedType?: UserFollowingFeedType, explicitFollowing?: boolean, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userFollowingGet(bookmark, pageSize, feedType, explicitFollowing, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user websites, claimed or not
     * @summary Get user websites
     * @param {string} [bookmark] Cursor used to fetch the next page of items
     * @param {number} [pageSize] Maximum number of items to include in a single page of the response. See documentation on &lt;a href&#x3D;\&#39;/docs/reference/pagination/\&#39;&gt;Pagination&lt;/a&gt; for more information.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public userWebsitesGet(bookmark?: string, pageSize?: number, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).userWebsitesGet(bookmark, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Verify a website as a signed-in user.
     * @summary Verify website
     * @param {UserWebsiteVerifyRequest} userWebsiteVerifyRequest Verify a website.
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public verifyWebsiteUpdate(userWebsiteVerifyRequest: UserWebsiteVerifyRequest, adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).verifyWebsiteUpdate(userWebsiteVerifyRequest, adAccountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get verification code for user to install on the website to claim it.
     * @summary Get user verification code for website claiming
     * @param {string} [adAccountId] Unique identifier of an ad account.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAccountApi
     */
    public websiteVerificationGet(adAccountId?: string, options?: RawAxiosRequestConfig) {
        return UserAccountApiFp(this.configuration).websiteVerificationGet(adAccountId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const UserAccountAnalyticsFromClaimedContentEnum = {
    Other: 'OTHER',
    Claimed: 'CLAIMED',
    Both: 'BOTH'
} as const;
export type UserAccountAnalyticsFromClaimedContentEnum = typeof UserAccountAnalyticsFromClaimedContentEnum[keyof typeof UserAccountAnalyticsFromClaimedContentEnum];
/**
 * @export
 */
export const UserAccountAnalyticsPinFormatEnum = {
    All: 'ALL',
    OrganicImage: 'ORGANIC_IMAGE',
    OrganicProduct: 'ORGANIC_PRODUCT',
    OrganicVideo: 'ORGANIC_VIDEO',
    AdsStandard: 'ADS_STANDARD',
    AdsProduct: 'ADS_PRODUCT',
    AdsVideo: 'ADS_VIDEO',
    AdsIdea: 'ADS_IDEA'
} as const;
export type UserAccountAnalyticsPinFormatEnum = typeof UserAccountAnalyticsPinFormatEnum[keyof typeof UserAccountAnalyticsPinFormatEnum];
/**
 * @export
 */
export const UserAccountAnalyticsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type UserAccountAnalyticsAppTypesEnum = typeof UserAccountAnalyticsAppTypesEnum[keyof typeof UserAccountAnalyticsAppTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsContentTypeEnum = {
    All: 'ALL',
    Paid: 'PAID',
    Organic: 'ORGANIC'
} as const;
export type UserAccountAnalyticsContentTypeEnum = typeof UserAccountAnalyticsContentTypeEnum[keyof typeof UserAccountAnalyticsContentTypeEnum];
/**
 * @export
 */
export const UserAccountAnalyticsSourceEnum = {
    All: 'ALL',
    YourPins: 'YOUR_PINS',
    OtherPins: 'OTHER_PINS'
} as const;
export type UserAccountAnalyticsSourceEnum = typeof UserAccountAnalyticsSourceEnum[keyof typeof UserAccountAnalyticsSourceEnum];
/**
 * @export
 */
export const UserAccountAnalyticsMetricTypesEnum = {
    Engagement: 'ENGAGEMENT',
    EngagementRate: 'ENGAGEMENT_RATE',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    OutboundClickRate: 'OUTBOUND_CLICK_RATE',
    PinClick: 'PIN_CLICK',
    PinClickRate: 'PIN_CLICK_RATE',
    Save: 'SAVE',
    SaveRate: 'SAVE_RATE'
} as const;
export type UserAccountAnalyticsMetricTypesEnum = typeof UserAccountAnalyticsMetricTypesEnum[keyof typeof UserAccountAnalyticsMetricTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsSplitFieldEnum = {
    NoSplit: 'NO_SPLIT',
    AppType: 'APP_TYPE',
    OwnedContent: 'OWNED_CONTENT',
    Source: 'SOURCE',
    PinFormat: 'PIN_FORMAT'
} as const;
export type UserAccountAnalyticsSplitFieldEnum = typeof UserAccountAnalyticsSplitFieldEnum[keyof typeof UserAccountAnalyticsSplitFieldEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsSortByEnum = {
    Engagement: 'ENGAGEMENT',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    PinClick: 'PIN_CLICK',
    Save: 'SAVE'
} as const;
export type UserAccountAnalyticsTopPinsSortByEnum = typeof UserAccountAnalyticsTopPinsSortByEnum[keyof typeof UserAccountAnalyticsTopPinsSortByEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsFromClaimedContentEnum = {
    Other: 'OTHER',
    Claimed: 'CLAIMED',
    Both: 'BOTH'
} as const;
export type UserAccountAnalyticsTopPinsFromClaimedContentEnum = typeof UserAccountAnalyticsTopPinsFromClaimedContentEnum[keyof typeof UserAccountAnalyticsTopPinsFromClaimedContentEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsPinFormatEnum = {
    All: 'ALL',
    OrganicImage: 'ORGANIC_IMAGE',
    OrganicProduct: 'ORGANIC_PRODUCT',
    OrganicVideo: 'ORGANIC_VIDEO',
    AdsStandard: 'ADS_STANDARD',
    AdsProduct: 'ADS_PRODUCT',
    AdsVideo: 'ADS_VIDEO',
    AdsIdea: 'ADS_IDEA'
} as const;
export type UserAccountAnalyticsTopPinsPinFormatEnum = typeof UserAccountAnalyticsTopPinsPinFormatEnum[keyof typeof UserAccountAnalyticsTopPinsPinFormatEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type UserAccountAnalyticsTopPinsAppTypesEnum = typeof UserAccountAnalyticsTopPinsAppTypesEnum[keyof typeof UserAccountAnalyticsTopPinsAppTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsContentTypeEnum = {
    All: 'ALL',
    Paid: 'PAID',
    Organic: 'ORGANIC'
} as const;
export type UserAccountAnalyticsTopPinsContentTypeEnum = typeof UserAccountAnalyticsTopPinsContentTypeEnum[keyof typeof UserAccountAnalyticsTopPinsContentTypeEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsSourceEnum = {
    All: 'ALL',
    YourPins: 'YOUR_PINS',
    OtherPins: 'OTHER_PINS'
} as const;
export type UserAccountAnalyticsTopPinsSourceEnum = typeof UserAccountAnalyticsTopPinsSourceEnum[keyof typeof UserAccountAnalyticsTopPinsSourceEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsMetricTypesEnum = {
    Engagement: 'ENGAGEMENT',
    EngagementRate: 'ENGAGEMENT_RATE',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    OutboundClickRate: 'OUTBOUND_CLICK_RATE',
    PinClick: 'PIN_CLICK',
    PinClickRate: 'PIN_CLICK_RATE',
    Save: 'SAVE',
    SaveRate: 'SAVE_RATE'
} as const;
export type UserAccountAnalyticsTopPinsMetricTypesEnum = typeof UserAccountAnalyticsTopPinsMetricTypesEnum[keyof typeof UserAccountAnalyticsTopPinsMetricTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum = {
    NUMBER_30: 30
} as const;
export type UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum = typeof UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum[keyof typeof UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsSortByEnum = {
    Impression: 'IMPRESSION',
    Save: 'SAVE',
    OutboundClick: 'OUTBOUND_CLICK',
    VideoMrcView: 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime: 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime: 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView: 'QUARTILE_95_PERCENT_VIEW',
    Video10SView: 'VIDEO_10S_VIEW',
    VideoStart: 'VIDEO_START'
} as const;
export type UserAccountAnalyticsTopVideoPinsSortByEnum = typeof UserAccountAnalyticsTopVideoPinsSortByEnum[keyof typeof UserAccountAnalyticsTopVideoPinsSortByEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum = {
    Other: 'OTHER',
    Claimed: 'CLAIMED',
    Both: 'BOTH'
} as const;
export type UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum = typeof UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum[keyof typeof UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsPinFormatEnum = {
    All: 'ALL',
    OrganicImage: 'ORGANIC_IMAGE',
    OrganicProduct: 'ORGANIC_PRODUCT',
    OrganicVideo: 'ORGANIC_VIDEO',
    AdsStandard: 'ADS_STANDARD',
    AdsProduct: 'ADS_PRODUCT',
    AdsVideo: 'ADS_VIDEO',
    AdsIdea: 'ADS_IDEA'
} as const;
export type UserAccountAnalyticsTopVideoPinsPinFormatEnum = typeof UserAccountAnalyticsTopVideoPinsPinFormatEnum[keyof typeof UserAccountAnalyticsTopVideoPinsPinFormatEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type UserAccountAnalyticsTopVideoPinsAppTypesEnum = typeof UserAccountAnalyticsTopVideoPinsAppTypesEnum[keyof typeof UserAccountAnalyticsTopVideoPinsAppTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsContentTypeEnum = {
    All: 'ALL',
    Paid: 'PAID',
    Organic: 'ORGANIC'
} as const;
export type UserAccountAnalyticsTopVideoPinsContentTypeEnum = typeof UserAccountAnalyticsTopVideoPinsContentTypeEnum[keyof typeof UserAccountAnalyticsTopVideoPinsContentTypeEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsSourceEnum = {
    All: 'ALL',
    YourPins: 'YOUR_PINS',
    OtherPins: 'OTHER_PINS'
} as const;
export type UserAccountAnalyticsTopVideoPinsSourceEnum = typeof UserAccountAnalyticsTopVideoPinsSourceEnum[keyof typeof UserAccountAnalyticsTopVideoPinsSourceEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsMetricTypesEnum = {
    Impression: 'IMPRESSION',
    Save: 'SAVE',
    VideoMrcView: 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime: 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime: 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView: 'QUARTILE_95_PERCENT_VIEW',
    Video10SView: 'VIDEO_10S_VIEW',
    VideoStart: 'VIDEO_START',
    OutboundClick: 'OUTBOUND_CLICK'
} as const;
export type UserAccountAnalyticsTopVideoPinsMetricTypesEnum = typeof UserAccountAnalyticsTopVideoPinsMetricTypesEnum[keyof typeof UserAccountAnalyticsTopVideoPinsMetricTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum = {
    NUMBER_30: 30
} as const;
export type UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum = typeof UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum[keyof typeof UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum];


