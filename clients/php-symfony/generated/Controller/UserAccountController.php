<?php

/**
 * UserAccountController
 * PHP version 8.1.1
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */

/**
 * Pinterest REST API
 *
 * Pinterest's REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 *
 */

/**
 * NOTE: This class is auto generated by the openapi generator program.
 * https://github.com/openapitools/openapi-generator
 * Do not edit the class manually.
 */

namespace OpenAPI\Server\Controller;

use \Exception;
use JMS\Serializer\Exception\RuntimeException as SerializerRuntimeException;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpKernel\Exception\HttpException;
use Symfony\Component\Validator\Constraints as Assert;
use OpenAPI\Server\Api\UserAccountApiInterface;
use OpenAPI\Server\Model\Account;
use OpenAPI\Server\Model\AnalyticsMetricsResponse;
use OpenAPI\Server\Model\BoardsUserFollowsList200Response;
use OpenAPI\Server\Model\Date;
use OpenAPI\Server\Model\Error;
use OpenAPI\Server\Model\FollowUserRequest;
use OpenAPI\Server\Model\FollowersList200Response;
use OpenAPI\Server\Model\LinkedBusiness;
use OpenAPI\Server\Model\TopPinsAnalyticsResponse;
use OpenAPI\Server\Model\TopVideoPinsAnalyticsResponse;
use OpenAPI\Server\Model\UserAccountFollowedInterests200Response;
use OpenAPI\Server\Model\UserFollowingFeedType;
use OpenAPI\Server\Model\UserFollowingGet200Response;
use OpenAPI\Server\Model\UserSummary;
use OpenAPI\Server\Model\UserWebsiteSummary;
use OpenAPI\Server\Model\UserWebsiteVerificationCode;
use OpenAPI\Server\Model\UserWebsiteVerifyRequest;
use OpenAPI\Server\Model\UserWebsitesGet200Response;

/**
 * UserAccountController Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Server\Controller
 * @author   OpenAPI Generator team
 * @link     https://github.com/openapitools/openapi-generator
 */
class UserAccountController extends Controller
{

    /**
     * Operation boardsUserFollowsList
     *
     * List following boards
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function boardsUserFollowsListAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $bookmark = $request->query->get('bookmark');
        $pageSize = $request->query->get('pageSize', 25);
        $explicitFollowing = $request->query->get('explicitFollowing', false);
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $bookmark = $this->deserialize($bookmark, 'string', 'string');
            $pageSize = $this->deserialize($pageSize, 'int', 'string');
            $explicitFollowing = $this->deserialize($explicitFollowing, 'bool', 'string');
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bookmark, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(250);
        $response = $this->validate($pageSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($explicitFollowing, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->boardsUserFollowsList($bookmark, $pageSize, $explicitFollowing, $adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                400 => 'Invalid user id',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation followUserUpdate
     *
     * Follow user
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function followUserUpdateAction(Request $request, $username)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $followUserRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $username = $this->deserialize($username, 'string', 'string');
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $followUserRequest = $this->deserialize($followUserRequest, 'OpenAPI\Server\Model\FollowUserRequest', $inputFormat);
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Regex("/(?!^\\d+$)^.+$/");
        $response = $this->validate($username, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\FollowUserRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($followUserRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->followUserUpdate($username, $followUserRequest, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                404 => 'User not found',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation followersList
     *
     * List followers
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function followersListAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $bookmark = $request->query->get('bookmark');
        $pageSize = $request->query->get('pageSize', 25);

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $bookmark = $this->deserialize($bookmark, 'string', 'string');
            $pageSize = $this->deserialize($pageSize, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bookmark, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(250);
        $response = $this->validate($pageSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->followersList($bookmark, $pageSize, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                400 => 'Invalid user id',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation linkedBusinessAccountsGet
     *
     * List linked businesses
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function linkedBusinessAccountsGetAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables

        // Use the default value if no value was provided

        // Validate the input values


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->linkedBusinessAccountsGet($responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation unverifyWebsiteDelete
     *
     * Unverify website
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function unverifyWebsiteDeleteAction(Request $request)
    {
        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $website = $request->query->get('website');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $website = $this->deserialize($website, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($website, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);

            // Make the call to the business logic
            $responseCode = 204;
            $responseHeaders = [];

            $handler->unverifyWebsiteDelete($website, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                204 => 'Successfully unverified website',
                404 => 'Website not in user list.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                '',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userAccountAnalytics
     *
     * Get user account analytics
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userAccountAnalyticsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startDate = $request->query->get('startDate');
        $endDate = $request->query->get('endDate');
        $fromClaimedContent = $request->query->get('fromClaimedContent', 'BOTH');
        $pinFormat = $request->query->get('pinFormat', 'ALL');
        $appTypes = $request->query->get('appTypes', 'ALL');
        $contentType = $request->query->get('contentType', 'ALL');
        $source = $request->query->get('source', 'ALL');
        $metricTypes = $request->query->get('metricTypes');
        $splitField = $request->query->get('splitField', 'NO_SPLIT');
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startDate = $this->deserialize($startDate, '\DateTime', 'string');
            $endDate = $this->deserialize($endDate, '\DateTime', 'string');
            $fromClaimedContent = $this->deserialize($fromClaimedContent, 'string', 'string');
            $pinFormat = $this->deserialize($pinFormat, 'string', 'string');
            $appTypes = $this->deserialize($appTypes, 'string', 'string');
            $contentType = $this->deserialize($contentType, 'string', 'string');
            $source = $this->deserialize($source, 'string', 'string');
            $metricTypes = $this->deserialize($metricTypes, 'array<csv,string>', 'string');
            $splitField = $this->deserialize($splitField, 'string', 'string');
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Date();
        $response = $this->validate($startDate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Date();
        $response = $this->validate($endDate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "OTHER", "CLAIMED", "BOTH" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($fromClaimedContent, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "ORGANIC_IMAGE", "ORGANIC_PRODUCT", "ORGANIC_VIDEO", "ADS_STANDARD", "ADS_PRODUCT", "ADS_VIDEO", "ADS_IDEA" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($pinFormat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "MOBILE", "TABLET", "WEB" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($appTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "PAID", "ORGANIC" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($contentType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "YOUR_PINS", "OTHER_PINS" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($source, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ "ENGAGEMENT", "ENGAGEMENT_RATE", "IMPRESSION", "OUTBOUND_CLICK", "OUTBOUND_CLICK_RATE", "PIN_CLICK", "PIN_CLICK_RATE", "SAVE", "SAVE_RATE" ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($metricTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "NO_SPLIT", "APP_TYPE", "OWNED_CONTENT", "SOURCE", "PIN_FORMAT" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($splitField, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userAccountAnalytics($startDate, $endDate, $fromClaimedContent, $pinFormat, $appTypes, $contentType, $source, $metricTypes, $splitField, $adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                400 => 'Invalid user accounts analytics parameters.',
                403 => 'Not authorized to access the user account analytics.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userAccountAnalyticsTopPins
     *
     * Get user account top pins analytics
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userAccountAnalyticsTopPinsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startDate = $request->query->get('startDate');
        $endDate = $request->query->get('endDate');
        $sortBy = $request->query->get('sortBy');
        $fromClaimedContent = $request->query->get('fromClaimedContent', 'BOTH');
        $pinFormat = $request->query->get('pinFormat', 'ALL');
        $appTypes = $request->query->get('appTypes', 'ALL');
        $contentType = $request->query->get('contentType', 'ALL');
        $source = $request->query->get('source', 'ALL');
        $metricTypes = $request->query->get('metricTypes');
        $numOfPins = $request->query->get('numOfPins', 10);
        $createdInLastNDays = $request->query->get('createdInLastNDays');
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startDate = $this->deserialize($startDate, '\DateTime', 'string');
            $endDate = $this->deserialize($endDate, '\DateTime', 'string');
            $sortBy = $this->deserialize($sortBy, 'string', 'string');
            $fromClaimedContent = $this->deserialize($fromClaimedContent, 'string', 'string');
            $pinFormat = $this->deserialize($pinFormat, 'string', 'string');
            $appTypes = $this->deserialize($appTypes, 'string', 'string');
            $contentType = $this->deserialize($contentType, 'string', 'string');
            $source = $this->deserialize($source, 'string', 'string');
            $metricTypes = $this->deserialize($metricTypes, 'array<csv,string>', 'string');
            $numOfPins = $this->deserialize($numOfPins, 'int', 'string');
            $createdInLastNDays = $this->deserialize($createdInLastNDays, 'int', 'string');
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Date();
        $response = $this->validate($startDate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Date();
        $response = $this->validate($endDate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Choice([ "ENGAGEMENT", "IMPRESSION", "OUTBOUND_CLICK", "PIN_CLICK", "SAVE" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($sortBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "OTHER", "CLAIMED", "BOTH" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($fromClaimedContent, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "ORGANIC_IMAGE", "ORGANIC_PRODUCT", "ORGANIC_VIDEO", "ADS_STANDARD", "ADS_PRODUCT", "ADS_VIDEO", "ADS_IDEA" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($pinFormat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "MOBILE", "TABLET", "WEB" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($appTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "PAID", "ORGANIC" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($contentType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "YOUR_PINS", "OTHER_PINS" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($source, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ "ENGAGEMENT", "ENGAGEMENT_RATE", "IMPRESSION", "OUTBOUND_CLICK", "OUTBOUND_CLICK_RATE", "PIN_CLICK", "PIN_CLICK_RATE", "SAVE", "SAVE_RATE" ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($metricTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(50);
        $response = $this->validate($numOfPins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ 30 ]);
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($createdInLastNDays, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userAccountAnalyticsTopPins($startDate, $endDate, $sortBy, $fromClaimedContent, $pinFormat, $appTypes, $contentType, $source, $metricTypes, $numOfPins, $createdInLastNDays, $adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                403 => 'Not authorized to access the user account analytics.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userAccountAnalyticsTopVideoPins
     *
     * Get user account top video pins analytics
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userAccountAnalyticsTopVideoPinsAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $startDate = $request->query->get('startDate');
        $endDate = $request->query->get('endDate');
        $sortBy = $request->query->get('sortBy');
        $fromClaimedContent = $request->query->get('fromClaimedContent', 'BOTH');
        $pinFormat = $request->query->get('pinFormat', 'ALL');
        $appTypes = $request->query->get('appTypes', 'ALL');
        $contentType = $request->query->get('contentType', 'ALL');
        $source = $request->query->get('source', 'ALL');
        $metricTypes = $request->query->get('metricTypes');
        $numOfPins = $request->query->get('numOfPins', 10);
        $createdInLastNDays = $request->query->get('createdInLastNDays');
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $startDate = $this->deserialize($startDate, '\DateTime', 'string');
            $endDate = $this->deserialize($endDate, '\DateTime', 'string');
            $sortBy = $this->deserialize($sortBy, 'string', 'string');
            $fromClaimedContent = $this->deserialize($fromClaimedContent, 'string', 'string');
            $pinFormat = $this->deserialize($pinFormat, 'string', 'string');
            $appTypes = $this->deserialize($appTypes, 'string', 'string');
            $contentType = $this->deserialize($contentType, 'string', 'string');
            $source = $this->deserialize($source, 'string', 'string');
            $metricTypes = $this->deserialize($metricTypes, 'array<csv,string>', 'string');
            $numOfPins = $this->deserialize($numOfPins, 'int', 'string');
            $createdInLastNDays = $this->deserialize($createdInLastNDays, 'int', 'string');
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Date();
        $response = $this->validate($startDate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Date();
        $response = $this->validate($endDate, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Choice([ "IMPRESSION", "SAVE", "OUTBOUND_CLICK", "VIDEO_MRC_VIEW", "VIDEO_AVG_WATCH_TIME", "VIDEO_V50_WATCH_TIME", "QUARTILE_95_PERCENT_VIEW", "VIDEO_10S_VIEW", "VIDEO_START" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($sortBy, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "OTHER", "CLAIMED", "BOTH" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($fromClaimedContent, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "ORGANIC_IMAGE", "ORGANIC_PRODUCT", "ORGANIC_VIDEO", "ADS_STANDARD", "ADS_PRODUCT", "ADS_VIDEO", "ADS_IDEA" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($pinFormat, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "MOBILE", "TABLET", "WEB" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($appTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "PAID", "ORGANIC" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($contentType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ "ALL", "YOUR_PINS", "OTHER_PINS" ]);
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($source, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\All([
            new Assert\Choice([ "IMPRESSION", "SAVE", "VIDEO_MRC_VIEW", "VIDEO_AVG_WATCH_TIME", "VIDEO_V50_WATCH_TIME", "QUARTILE_95_PERCENT_VIEW", "VIDEO_10S_VIEW", "VIDEO_START", "OUTBOUND_CLICK" ])
        ]);
        $asserts[] = new Assert\All([
            new Assert\Type("string"),
        ]);
        $asserts[] = new Assert\Valid();
        $response = $this->validate($metricTypes, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(50);
        $response = $this->validate($numOfPins, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Choice([ 30 ]);
        $asserts[] = new Assert\Type("int");
        $response = $this->validate($createdInLastNDays, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userAccountAnalyticsTopVideoPins($startDate, $endDate, $sortBy, $fromClaimedContent, $pinFormat, $appTypes, $contentType, $source, $metricTypes, $numOfPins, $createdInLastNDays, $adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                403 => 'Not authorized to access the user account analytics.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userAccountFollowedInterests
     *
     * List following interests
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userAccountFollowedInterestsAction(Request $request, $username)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $bookmark = $request->query->get('bookmark');
        $pageSize = $request->query->get('pageSize', 25);

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $username = $this->deserialize($username, 'string', 'string');
            $bookmark = $this->deserialize($bookmark, 'string', 'string');
            $pageSize = $this->deserialize($pageSize, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Regex("/(?!^\\d+$)^.+$/");
        $response = $this->validate($username, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bookmark, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(250);
        $response = $this->validate($pageSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userAccountFollowedInterests($username, $bookmark, $pageSize, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                400 => 'Invalid parameters',
                401 => 'Authorization failed',
                404 => 'User not found',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userAccountGet
     *
     * Get user account
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userAccountGetAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userAccountGet($adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'response',
                403 => 'Not authorized to access the user account.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userFollowingGet
     *
     * List following
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userFollowingGetAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $bookmark = $request->query->get('bookmark');
        $pageSize = $request->query->get('pageSize', 25);
        $feedType = $request->query->get('feedType');
        $explicitFollowing = $request->query->get('explicitFollowing', false);
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $bookmark = $this->deserialize($bookmark, 'string', 'string');
            $pageSize = $this->deserialize($pageSize, 'int', 'string');
            $feedType = $this->deserialize($feedType, '\OpenAPI\Server\Model\OpenAPI\Server\Model\UserFollowingFeedType', 'string');
            $explicitFollowing = $this->deserialize($explicitFollowing, 'bool', 'string');
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bookmark, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(250);
        $response = $this->validate($pageSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("\OpenAPI\Server\Model\OpenAPI\Server\Model\UserFollowingFeedType");
        $response = $this->validate($feedType, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("bool");
        $response = $this->validate($explicitFollowing, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userFollowingGet($bookmark, $pageSize, $feedType, $explicitFollowing, $adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'response',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation userWebsitesGet
     *
     * Get user websites
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function userWebsitesGetAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $bookmark = $request->query->get('bookmark');
        $pageSize = $request->query->get('pageSize', 25);

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $bookmark = $this->deserialize($bookmark, 'string', 'string');
            $pageSize = $this->deserialize($pageSize, 'int', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $response = $this->validate($bookmark, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("int");
        $asserts[] = new Assert\GreaterThanOrEqual(1);
        $asserts[] = new Assert\LessThanOrEqual(250);
        $response = $this->validate($pageSize, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->userWebsitesGet($bookmark, $pageSize, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                403 => 'Not authorized to access the user website list.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation verifyWebsiteUpdate
     *
     * Verify website
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function verifyWebsiteUpdateAction(Request $request)
    {
        // Make sure that the client is providing something that we can consume
        $consumes = ['application/json'];
        if (!static::isContentTypeAllowed($request, $consumes)) {
            // We can't consume the content that the client is sending us
            return new Response('', 415);
        }

        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $adAccountId = $request->query->get('adAccountId');
        $userWebsiteVerifyRequest = $request->getContent();

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $inputFormat = $request->getMimeType($request->getContentTypeFormat());
            $userWebsiteVerifyRequest = $this->deserialize($userWebsiteVerifyRequest, 'OpenAPI\Server\Model\UserWebsiteVerifyRequest', $inputFormat);
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\NotNull();
        $asserts[] = new Assert\Type("OpenAPI\Server\Model\UserWebsiteVerifyRequest");
        $asserts[] = new Assert\Valid();
        $response = $this->validate($userWebsiteVerifyRequest, $asserts);
        if ($response instanceof Response) {
            return $response;
        }
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->verifyWebsiteUpdate($userWebsiteVerifyRequest, $adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Operation websiteVerificationGet
     *
     * Get user verification code for website claiming
     *
     * @param Request $request The Symfony request to handle.
     * @return Response The Symfony response.
     */
    public function websiteVerificationGetAction(Request $request)
    {
        // Figure out what data format to return to the client
        $produces = ['application/json'];
        // Figure out what the client accepts
        $clientAccepts = $request->headers->has('Accept')?$request->headers->get('Accept'):'*/*';
        $responseFormat = $this->getOutputFormat($clientAccepts, $produces);
        if ($responseFormat === null) {
            return new Response('', 406);
        }

        // Handle authentication
        // Authentication 'pinterest_oauth2' required
        // Oauth required
        $securitypinterest_oauth2 = $request->headers->get('authorization');
        // Authentication 'client_credentials' required
        // Oauth required
        $securityclient_credentials = $request->headers->get('authorization');

        // Read out all input parameter values into variables
        $adAccountId = $request->query->get('adAccountId');

        // Use the default value if no value was provided

        // Deserialize the input values that needs it
        try {
            $adAccountId = $this->deserialize($adAccountId, 'string', 'string');
        } catch (SerializerRuntimeException $exception) {
            return $this->createBadRequestResponse($exception->getMessage());
        }

        // Validate the input values
        $asserts = [];
        $asserts[] = new Assert\Type("string");
        $asserts[] = new Assert\Length([
            'max' => 18
        ]);
        $asserts[] = new Assert\Regex("/^\\d+$/");
        $response = $this->validate($adAccountId, $asserts);
        if ($response instanceof Response) {
            return $response;
        }


        try {
            $handler = $this->getApiHandler();

            // Set authentication method 'pinterest_oauth2'
            $handler->setpinterest_oauth2($securitypinterest_oauth2);
            // Set authentication method 'client_credentials'
            $handler->setclient_credentials($securityclient_credentials);

            // Make the call to the business logic
            $responseCode = 200;
            $responseHeaders = [];

            $result = $handler->websiteVerificationGet($adAccountId, $responseCode, $responseHeaders);

            $message = match($responseCode) {
                200 => 'Success',
                403 => 'Not authorized to access the user verification code for website claiming.',
                0 => 'Unexpected error',
                default => 'Unexpected error',
            };

            return new Response(
                $result !== null ?$this->serialize($result, $responseFormat):'',
                $responseCode,
                array_merge(
                    $responseHeaders,
                    [
                        'Content-Type' => $responseFormat,
                        'X-OpenAPI-Message' => $message
                    ]
                )
            );
        } catch (\Throwable $fallthrough) {
            return $this->createErrorResponse(new HttpException(500, 'An unsuspected error occurred.', $fallthrough));
        }
    }

    /**
     * Returns the handler for this API controller.
     * @return UserAccountApiInterface
     */
    public function getApiHandler()
    {
        return $this->apiServer->getApiHandler('userAccount');
    }
}
