/* tslint:disable */
/* eslint-disable */
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.12.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  KeywordUpdateBody,
  KeywordsGet200Response,
  KeywordsMetricsArrayResponse,
  KeywordsRequest,
  KeywordsResponse,
  MatchType,
  TrendType,
  TrendingKeywordsResponse,
  TrendsSupportedRegion,
} from '../models/index';
import {
    KeywordUpdateBodyFromJSON,
    KeywordUpdateBodyToJSON,
    KeywordsGet200ResponseFromJSON,
    KeywordsGet200ResponseToJSON,
    KeywordsMetricsArrayResponseFromJSON,
    KeywordsMetricsArrayResponseToJSON,
    KeywordsRequestFromJSON,
    KeywordsRequestToJSON,
    KeywordsResponseFromJSON,
    KeywordsResponseToJSON,
    MatchTypeFromJSON,
    MatchTypeToJSON,
    TrendTypeFromJSON,
    TrendTypeToJSON,
    TrendingKeywordsResponseFromJSON,
    TrendingKeywordsResponseToJSON,
    TrendsSupportedRegionFromJSON,
    TrendsSupportedRegionToJSON,
} from '../models/index';

export interface CountryKeywordsMetricsGetRequest {
    adAccountId: string;
    countryCode: string;
    keywords: Array<string>;
}

export interface KeywordsCreateRequest {
    adAccountId: string;
    keywordsRequest: KeywordsRequest;
}

export interface KeywordsGetRequest {
    adAccountId: string;
    campaignId?: string;
    adGroupId?: string;
    matchTypes?: Array<MatchType>;
    pageSize?: number;
    bookmark?: string;
}

export interface KeywordsUpdateRequest {
    adAccountId: string;
    keywordUpdateBody: KeywordUpdateBody;
}

export interface TrendingKeywordsListRequest {
    region: TrendsSupportedRegion;
    trendType: TrendType;
    interests?: Array<TrendingKeywordsListInterestsEnum>;
    genders?: Array<TrendingKeywordsListGendersEnum>;
    ages?: Array<TrendingKeywordsListAgesEnum>;
    normalizeAgainstGroup?: boolean;
    limit?: number;
}

/**
 * 
 */
export class KeywordsApi extends runtime.BaseAPI {

    /**
     * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
     * Get country\'s keyword metrics
     */
    async countryKeywordsMetricsGetRaw(requestParameters: CountryKeywordsMetricsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KeywordsMetricsArrayResponse>> {
        if (requestParameters['adAccountId'] == null) {
            throw new runtime.RequiredError(
                'adAccountId',
                'Required parameter "adAccountId" was null or undefined when calling countryKeywordsMetricsGet().'
            );
        }

        if (requestParameters['countryCode'] == null) {
            throw new runtime.RequiredError(
                'countryCode',
                'Required parameter "countryCode" was null or undefined when calling countryKeywordsMetricsGet().'
            );
        }

        if (requestParameters['keywords'] == null) {
            throw new runtime.RequiredError(
                'keywords',
                'Required parameter "keywords" was null or undefined when calling countryKeywordsMetricsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['countryCode'] != null) {
            queryParameters['country_code'] = requestParameters['countryCode'];
        }

        if (requestParameters['keywords'] != null) {
            queryParameters['keywords'] = requestParameters['keywords']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["ads:read"]);
        }

        const response = await this.request({
            path: `/ad_accounts/{ad_account_id}/keywords/metrics`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters['adAccountId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordsMetricsArrayResponseFromJSON(jsonValue));
    }

    /**
     * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
     * Get country\'s keyword metrics
     */
    async countryKeywordsMetricsGet(requestParameters: CountryKeywordsMetricsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KeywordsMetricsArrayResponse> {
        const response = await this.countryKeywordsMetricsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/ads/targeting/#Match%20type%20and%20targeting%20level\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/redoc/#tag/Rate-Limits\">WRITE</a>.</p>
     * Create keywords
     */
    async keywordsCreateRaw(requestParameters: KeywordsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KeywordsResponse>> {
        if (requestParameters['adAccountId'] == null) {
            throw new runtime.RequiredError(
                'adAccountId',
                'Required parameter "adAccountId" was null or undefined when calling keywordsCreate().'
            );
        }

        if (requestParameters['keywordsRequest'] == null) {
            throw new runtime.RequiredError(
                'keywordsRequest',
                'Required parameter "keywordsRequest" was null or undefined when calling keywordsCreate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["ads:write"]);
        }

        const response = await this.request({
            path: `/ad_accounts/{ad_account_id}/keywords`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters['adAccountId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordsRequestToJSON(requestParameters['keywordsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordsResponseFromJSON(jsonValue));
    }

    /**
     * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/ads/targeting/#Match%20type%20and%20targeting%20level\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/redoc/#tag/Rate-Limits\">WRITE</a>.</p>
     * Create keywords
     */
    async keywordsCreate(requestParameters: KeywordsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KeywordsResponse> {
        const response = await this.keywordsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/ads/targeting/#Match%20type%20and%20targeting%20level\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
     * Get keywords
     */
    async keywordsGetRaw(requestParameters: KeywordsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KeywordsGet200Response>> {
        if (requestParameters['adAccountId'] == null) {
            throw new runtime.RequiredError(
                'adAccountId',
                'Required parameter "adAccountId" was null or undefined when calling keywordsGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['campaignId'] != null) {
            queryParameters['campaign_id'] = requestParameters['campaignId'];
        }

        if (requestParameters['adGroupId'] != null) {
            queryParameters['ad_group_id'] = requestParameters['adGroupId'];
        }

        if (requestParameters['matchTypes'] != null) {
            queryParameters['match_types'] = requestParameters['matchTypes'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['bookmark'] != null) {
            queryParameters['bookmark'] = requestParameters['bookmark'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["ads:read"]);
        }

        const response = await this.request({
            path: `/ad_accounts/{ad_account_id}/keywords`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters['adAccountId']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordsGet200ResponseFromJSON(jsonValue));
    }

    /**
     * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/ads/targeting/#Match%20type%20and%20targeting%20level\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
     * Get keywords
     */
    async keywordsGet(requestParameters: KeywordsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KeywordsGet200Response> {
        const response = await this.keywordsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
     * Update keywords
     */
    async keywordsUpdateRaw(requestParameters: KeywordsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<KeywordsResponse>> {
        if (requestParameters['adAccountId'] == null) {
            throw new runtime.RequiredError(
                'adAccountId',
                'Required parameter "adAccountId" was null or undefined when calling keywordsUpdate().'
            );
        }

        if (requestParameters['keywordUpdateBody'] == null) {
            throw new runtime.RequiredError(
                'keywordUpdateBody',
                'Required parameter "keywordUpdateBody" was null or undefined when calling keywordsUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["ads:write"]);
        }

        const response = await this.request({
            path: `/ad_accounts/{ad_account_id}/keywords`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters['adAccountId']))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: KeywordUpdateBodyToJSON(requestParameters['keywordUpdateBody']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => KeywordsResponseFromJSON(jsonValue));
    }

    /**
     * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
     * Update keywords
     */
    async keywordsUpdate(requestParameters: KeywordsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<KeywordsResponse> {
        const response = await this.keywordsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>.
     * List trending keywords
     */
    async trendingKeywordsListRaw(requestParameters: TrendingKeywordsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TrendingKeywordsResponse>> {
        if (requestParameters['region'] == null) {
            throw new runtime.RequiredError(
                'region',
                'Required parameter "region" was null or undefined when calling trendingKeywordsList().'
            );
        }

        if (requestParameters['trendType'] == null) {
            throw new runtime.RequiredError(
                'trendType',
                'Required parameter "trendType" was null or undefined when calling trendingKeywordsList().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['interests'] != null) {
            queryParameters['interests'] = requestParameters['interests'];
        }

        if (requestParameters['genders'] != null) {
            queryParameters['genders'] = requestParameters['genders'];
        }

        if (requestParameters['ages'] != null) {
            queryParameters['ages'] = requestParameters['ages'];
        }

        if (requestParameters['normalizeAgainstGroup'] != null) {
            queryParameters['normalize_against_group'] = requestParameters['normalizeAgainstGroup'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/trends/keywords/{region}/top/{trend_type}`.replace(`{${"region"}}`, encodeURIComponent(String(requestParameters['region']))).replace(`{${"trend_type"}}`, encodeURIComponent(String(requestParameters['trendType']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TrendingKeywordsResponseFromJSON(jsonValue));
    }

    /**
     * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>.
     * List trending keywords
     */
    async trendingKeywordsList(requestParameters: TrendingKeywordsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TrendingKeywordsResponse> {
        const response = await this.trendingKeywordsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const TrendingKeywordsListInterestsEnum = {
    Animals: 'animals',
    Architecture: 'architecture',
    Art: 'art',
    Beauty: 'beauty',
    ChildrensFashion: 'childrens_fashion',
    Design: 'design',
    DiyAndCrafts: 'diy_and_crafts',
    Education: 'education',
    Electronics: 'electronics',
    Entertainment: 'entertainment',
    EventPlanning: 'event_planning',
    Finance: 'finance',
    FoodAndDrinks: 'food_and_drinks',
    Gardening: 'gardening',
    Health: 'health',
    HomeDecor: 'home_decor',
    MensFashion: 'mens_fashion',
    Parenting: 'parenting',
    Quotes: 'quotes',
    Sport: 'sport',
    Travel: 'travel',
    Vehicles: 'vehicles',
    Wedding: 'wedding',
    WomensFashion: 'womens_fashion'
} as const;
export type TrendingKeywordsListInterestsEnum = typeof TrendingKeywordsListInterestsEnum[keyof typeof TrendingKeywordsListInterestsEnum];
/**
 * @export
 */
export const TrendingKeywordsListGendersEnum = {
    Female: 'female',
    Male: 'male',
    Unknown: 'unknown'
} as const;
export type TrendingKeywordsListGendersEnum = typeof TrendingKeywordsListGendersEnum[keyof typeof TrendingKeywordsListGendersEnum];
/**
 * @export
 */
export const TrendingKeywordsListAgesEnum = {
    _1824: '18-24',
    _2534: '25-34',
    _3544: '35-44',
    _4549: '45-49',
    _5054: '50-54',
    _5564: '55-64',
    _65: '65+'
} as const;
export type TrendingKeywordsListAgesEnum = typeof TrendingKeywordsListAgesEnum[keyof typeof TrendingKeywordsListAgesEnum];
