/* tslint:disable */
/* eslint-disable */
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Account,
  AnalyticsMetricsResponse,
  BoardsUserFollowsList200Response,
  FollowUserRequest,
  FollowersList200Response,
  LinkedBusiness,
  TopPinsAnalyticsResponse,
  TopVideoPinsAnalyticsResponse,
  UserAccountFollowedInterests200Response,
  UserFollowingFeedType,
  UserFollowingGet200Response,
  UserSummary,
  UserWebsiteSummary,
  UserWebsiteVerificationCode,
  UserWebsiteVerifyRequest,
  UserWebsitesGet200Response,
} from '../models/index';
import {
    AccountFromJSON,
    AccountToJSON,
    AnalyticsMetricsResponseFromJSON,
    AnalyticsMetricsResponseToJSON,
    BoardsUserFollowsList200ResponseFromJSON,
    BoardsUserFollowsList200ResponseToJSON,
    FollowUserRequestFromJSON,
    FollowUserRequestToJSON,
    FollowersList200ResponseFromJSON,
    FollowersList200ResponseToJSON,
    LinkedBusinessFromJSON,
    LinkedBusinessToJSON,
    TopPinsAnalyticsResponseFromJSON,
    TopPinsAnalyticsResponseToJSON,
    TopVideoPinsAnalyticsResponseFromJSON,
    TopVideoPinsAnalyticsResponseToJSON,
    UserAccountFollowedInterests200ResponseFromJSON,
    UserAccountFollowedInterests200ResponseToJSON,
    UserFollowingFeedTypeFromJSON,
    UserFollowingFeedTypeToJSON,
    UserFollowingGet200ResponseFromJSON,
    UserFollowingGet200ResponseToJSON,
    UserSummaryFromJSON,
    UserSummaryToJSON,
    UserWebsiteSummaryFromJSON,
    UserWebsiteSummaryToJSON,
    UserWebsiteVerificationCodeFromJSON,
    UserWebsiteVerificationCodeToJSON,
    UserWebsiteVerifyRequestFromJSON,
    UserWebsiteVerifyRequestToJSON,
    UserWebsitesGet200ResponseFromJSON,
    UserWebsitesGet200ResponseToJSON,
} from '../models/index';

export interface BoardsUserFollowsListRequest {
    bookmark?: string;
    pageSize?: number;
    explicitFollowing?: boolean;
    adAccountId?: string;
}

export interface FollowUserUpdateRequest {
    username: string;
    followUserRequest: FollowUserRequest;
}

export interface FollowersListRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface UnverifyWebsiteDeleteRequest {
    website: string;
}

export interface UserAccountAnalyticsRequest {
    startDate: Date;
    endDate: Date;
    fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsPinFormatEnum;
    appTypes?: UserAccountAnalyticsAppTypesEnum;
    contentType?: UserAccountAnalyticsContentTypeEnum;
    source?: UserAccountAnalyticsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>;
    splitField?: UserAccountAnalyticsSplitFieldEnum;
    adAccountId?: string;
}

export interface UserAccountAnalyticsTopPinsRequest {
    startDate: Date;
    endDate: Date;
    sortBy: UserAccountAnalyticsTopPinsSortByEnum;
    fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum;
    appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum;
    contentType?: UserAccountAnalyticsTopPinsContentTypeEnum;
    source?: UserAccountAnalyticsTopPinsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>;
    numOfPins?: number;
    createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum;
    adAccountId?: string;
}

export interface UserAccountAnalyticsTopVideoPinsRequest {
    startDate: Date;
    endDate: Date;
    sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum;
    fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum;
    appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum;
    contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum;
    source?: UserAccountAnalyticsTopVideoPinsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>;
    numOfPins?: number;
    createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum;
    adAccountId?: string;
}

export interface UserAccountFollowedInterestsRequest {
    username: string;
    bookmark?: string;
    pageSize?: number;
}

export interface UserAccountGetRequest {
    adAccountId?: string;
}

export interface UserFollowingGetRequest {
    bookmark?: string;
    pageSize?: number;
    feedType?: UserFollowingFeedType;
    explicitFollowing?: boolean;
    adAccountId?: string;
}

export interface UserWebsitesGetRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface VerifyWebsiteUpdateRequest {
    userWebsiteVerifyRequest: UserWebsiteVerifyRequest;
    adAccountId?: string;
}

export interface WebsiteVerificationGetRequest {
    adAccountId?: string;
}

/**
 * 
 */
export class UserAccountApi extends runtime.BaseAPI {

    /**
     * Get a list of the boards a user follows. The request returns a board summary object array.
     * List following boards
     */
    async boardsUserFollowsListRaw(requestParameters: BoardsUserFollowsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BoardsUserFollowsList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['bookmark'] != null) {
            queryParameters['bookmark'] = requestParameters['bookmark'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['explicitFollowing'] != null) {
            queryParameters['explicit_following'] = requestParameters['explicitFollowing'];
        }

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/following/boards`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BoardsUserFollowsList200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of the boards a user follows. The request returns a board summary object array.
     * List following boards
     */
    async boardsUserFollowsList(requestParameters: BoardsUserFollowsListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BoardsUserFollowsList200Response> {
        const response = await this.boardsUserFollowsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
     * Follow user
     */
    async followUserUpdateRaw(requestParameters: FollowUserUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSummary>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling followUserUpdate().'
            );
        }

        if (requestParameters['followUserRequest'] == null) {
            throw new runtime.RequiredError(
                'followUserRequest',
                'Required parameter "followUserRequest" was null or undefined when calling followUserUpdate().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:write"]);
        }

        const response = await this.request({
            path: `/user_account/following/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FollowUserRequestToJSON(requestParameters['followUserRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSummaryFromJSON(jsonValue));
    }

    /**
     * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
     * Follow user
     */
    async followUserUpdate(requestParameters: FollowUserUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSummary> {
        const response = await this.followUserUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of your followers.
     * List followers
     */
    async followersListRaw(requestParameters: FollowersListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FollowersList200Response>> {
        const queryParameters: any = {};

        if (requestParameters['bookmark'] != null) {
            queryParameters['bookmark'] = requestParameters['bookmark'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/followers`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FollowersList200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of your followers.
     * List followers
     */
    async followersList(requestParameters: FollowersListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FollowersList200Response> {
        const response = await this.followersListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of your linked business accounts.
     * List linked businesses
     */
    async linkedBusinessAccountsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LinkedBusiness>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/businesses`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LinkedBusinessFromJSON));
    }

    /**
     * Get a list of your linked business accounts.
     * List linked businesses
     */
    async linkedBusinessAccountsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LinkedBusiness>> {
        const response = await this.linkedBusinessAccountsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Unverifu a website verified by the signed-in user.
     * Unverify website
     */
    async unverifyWebsiteDeleteRaw(requestParameters: UnverifyWebsiteDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters['website'] == null) {
            throw new runtime.RequiredError(
                'website',
                'Required parameter "website" was null or undefined when calling unverifyWebsiteDelete().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['website'] != null) {
            queryParameters['website'] = requestParameters['website'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:write"]);
        }

        const response = await this.request({
            path: `/user_account/websites`,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Unverifu a website verified by the signed-in user.
     * Unverify website
     */
    async unverifyWebsiteDelete(requestParameters: UnverifyWebsiteDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.unverifyWebsiteDeleteRaw(requestParameters, initOverrides);
    }

    /**
     * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account analytics
     */
    async userAccountAnalyticsRaw(requestParameters: UserAccountAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<{ [key: string]: AnalyticsMetricsResponse; }>> {
        if (requestParameters['startDate'] == null) {
            throw new runtime.RequiredError(
                'startDate',
                'Required parameter "startDate" was null or undefined when calling userAccountAnalytics().'
            );
        }

        if (requestParameters['endDate'] == null) {
            throw new runtime.RequiredError(
                'endDate',
                'Required parameter "endDate" was null or undefined when calling userAccountAnalytics().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = (requestParameters['startDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = (requestParameters['endDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['fromClaimedContent'] != null) {
            queryParameters['from_claimed_content'] = requestParameters['fromClaimedContent'];
        }

        if (requestParameters['pinFormat'] != null) {
            queryParameters['pin_format'] = requestParameters['pinFormat'];
        }

        if (requestParameters['appTypes'] != null) {
            queryParameters['app_types'] = requestParameters['appTypes'];
        }

        if (requestParameters['contentType'] != null) {
            queryParameters['content_type'] = requestParameters['contentType'];
        }

        if (requestParameters['source'] != null) {
            queryParameters['source'] = requestParameters['source'];
        }

        if (requestParameters['metricTypes'] != null) {
            queryParameters['metric_types'] = requestParameters['metricTypes']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['splitField'] != null) {
            queryParameters['split_field'] = requestParameters['splitField'];
        }

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/analytics`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => runtime.mapValues(jsonValue, AnalyticsMetricsResponseFromJSON));
    }

    /**
     * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account analytics
     */
    async userAccountAnalytics(requestParameters: UserAccountAnalyticsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<{ [key: string]: AnalyticsMetricsResponse; }> {
        const response = await this.userAccountAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account top pins analytics
     */
    async userAccountAnalyticsTopPinsRaw(requestParameters: UserAccountAnalyticsTopPinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopPinsAnalyticsResponse>> {
        if (requestParameters['startDate'] == null) {
            throw new runtime.RequiredError(
                'startDate',
                'Required parameter "startDate" was null or undefined when calling userAccountAnalyticsTopPins().'
            );
        }

        if (requestParameters['endDate'] == null) {
            throw new runtime.RequiredError(
                'endDate',
                'Required parameter "endDate" was null or undefined when calling userAccountAnalyticsTopPins().'
            );
        }

        if (requestParameters['sortBy'] == null) {
            throw new runtime.RequiredError(
                'sortBy',
                'Required parameter "sortBy" was null or undefined when calling userAccountAnalyticsTopPins().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = (requestParameters['startDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = (requestParameters['endDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['fromClaimedContent'] != null) {
            queryParameters['from_claimed_content'] = requestParameters['fromClaimedContent'];
        }

        if (requestParameters['pinFormat'] != null) {
            queryParameters['pin_format'] = requestParameters['pinFormat'];
        }

        if (requestParameters['appTypes'] != null) {
            queryParameters['app_types'] = requestParameters['appTypes'];
        }

        if (requestParameters['contentType'] != null) {
            queryParameters['content_type'] = requestParameters['contentType'];
        }

        if (requestParameters['source'] != null) {
            queryParameters['source'] = requestParameters['source'];
        }

        if (requestParameters['metricTypes'] != null) {
            queryParameters['metric_types'] = requestParameters['metricTypes']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['numOfPins'] != null) {
            queryParameters['num_of_pins'] = requestParameters['numOfPins'];
        }

        if (requestParameters['createdInLastNDays'] != null) {
            queryParameters['created_in_last_n_days'] = requestParameters['createdInLastNDays'];
        }

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["pins:read", "user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["pins:read", "user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/analytics/top_pins`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopPinsAnalyticsResponseFromJSON(jsonValue));
    }

    /**
     * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account top pins analytics
     */
    async userAccountAnalyticsTopPins(requestParameters: UserAccountAnalyticsTopPinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopPinsAnalyticsResponse> {
        const response = await this.userAccountAnalyticsTopPinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account top video pins analytics
     */
    async userAccountAnalyticsTopVideoPinsRaw(requestParameters: UserAccountAnalyticsTopVideoPinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TopVideoPinsAnalyticsResponse>> {
        if (requestParameters['startDate'] == null) {
            throw new runtime.RequiredError(
                'startDate',
                'Required parameter "startDate" was null or undefined when calling userAccountAnalyticsTopVideoPins().'
            );
        }

        if (requestParameters['endDate'] == null) {
            throw new runtime.RequiredError(
                'endDate',
                'Required parameter "endDate" was null or undefined when calling userAccountAnalyticsTopVideoPins().'
            );
        }

        if (requestParameters['sortBy'] == null) {
            throw new runtime.RequiredError(
                'sortBy',
                'Required parameter "sortBy" was null or undefined when calling userAccountAnalyticsTopVideoPins().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = (requestParameters['startDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = (requestParameters['endDate'] as any).toISOString().substring(0,10);
        }

        if (requestParameters['sortBy'] != null) {
            queryParameters['sort_by'] = requestParameters['sortBy'];
        }

        if (requestParameters['fromClaimedContent'] != null) {
            queryParameters['from_claimed_content'] = requestParameters['fromClaimedContent'];
        }

        if (requestParameters['pinFormat'] != null) {
            queryParameters['pin_format'] = requestParameters['pinFormat'];
        }

        if (requestParameters['appTypes'] != null) {
            queryParameters['app_types'] = requestParameters['appTypes'];
        }

        if (requestParameters['contentType'] != null) {
            queryParameters['content_type'] = requestParameters['contentType'];
        }

        if (requestParameters['source'] != null) {
            queryParameters['source'] = requestParameters['source'];
        }

        if (requestParameters['metricTypes'] != null) {
            queryParameters['metric_types'] = requestParameters['metricTypes']!.join(runtime.COLLECTION_FORMATS["csv"]);
        }

        if (requestParameters['numOfPins'] != null) {
            queryParameters['num_of_pins'] = requestParameters['numOfPins'];
        }

        if (requestParameters['createdInLastNDays'] != null) {
            queryParameters['created_in_last_n_days'] = requestParameters['createdInLastNDays'];
        }

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["pins:read", "user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["pins:read", "user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/analytics/top_video_pins`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TopVideoPinsAnalyticsResponseFromJSON(jsonValue));
    }

    /**
     * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account top video pins analytics
     */
    async userAccountAnalyticsTopVideoPins(requestParameters: UserAccountAnalyticsTopVideoPinsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TopVideoPinsAnalyticsResponse> {
        const response = await this.userAccountAnalyticsTopVideoPinsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of a user\'s following interests in one place.
     * List following interests
     */
    async userAccountFollowedInterestsRaw(requestParameters: UserAccountFollowedInterestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserAccountFollowedInterests200Response>> {
        if (requestParameters['username'] == null) {
            throw new runtime.RequiredError(
                'username',
                'Required parameter "username" was null or undefined when calling userAccountFollowedInterests().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bookmark'] != null) {
            queryParameters['bookmark'] = requestParameters['bookmark'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/users/{username}/interests/follow`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters['username']))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserAccountFollowedInterests200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of a user\'s following interests in one place.
     * List following interests
     */
    async userAccountFollowedInterests(requestParameters: UserAccountFollowedInterestsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserAccountFollowedInterests200Response> {
        const response = await this.userAccountFollowedInterestsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
     * Get user account
     */
    async userAccountGetRaw(requestParameters: UserAccountGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Account>> {
        const queryParameters: any = {};

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
    }

    /**
     * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
     * Get user account
     */
    async userAccountGet(requestParameters: UserAccountGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Account> {
        const response = await this.userAccountGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of who a certain user follows.
     * List following
     */
    async userFollowingGetRaw(requestParameters: UserFollowingGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserFollowingGet200Response>> {
        const queryParameters: any = {};

        if (requestParameters['bookmark'] != null) {
            queryParameters['bookmark'] = requestParameters['bookmark'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        if (requestParameters['feedType'] != null) {
            queryParameters['feed_type'] = requestParameters['feedType'];
        }

        if (requestParameters['explicitFollowing'] != null) {
            queryParameters['explicit_following'] = requestParameters['explicitFollowing'];
        }

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/following`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserFollowingGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get a list of who a certain user follows.
     * List following
     */
    async userFollowingGet(requestParameters: UserFollowingGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserFollowingGet200Response> {
        const response = await this.userFollowingGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user websites, claimed or not
     * Get user websites
     */
    async userWebsitesGetRaw(requestParameters: UserWebsitesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserWebsitesGet200Response>> {
        const queryParameters: any = {};

        if (requestParameters['bookmark'] != null) {
            queryParameters['bookmark'] = requestParameters['bookmark'];
        }

        if (requestParameters['pageSize'] != null) {
            queryParameters['page_size'] = requestParameters['pageSize'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/websites`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserWebsitesGet200ResponseFromJSON(jsonValue));
    }

    /**
     * Get user websites, claimed or not
     * Get user websites
     */
    async userWebsitesGet(requestParameters: UserWebsitesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserWebsitesGet200Response> {
        const response = await this.userWebsitesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Verify a website as a signed-in user.
     * Verify website
     */
    async verifyWebsiteUpdateRaw(requestParameters: VerifyWebsiteUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserWebsiteSummary>> {
        if (requestParameters['userWebsiteVerifyRequest'] == null) {
            throw new runtime.RequiredError(
                'userWebsiteVerifyRequest',
                'Required parameter "userWebsiteVerifyRequest" was null or undefined when calling verifyWebsiteUpdate().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:write"]);
        }

        const response = await this.request({
            path: `/user_account/websites`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserWebsiteVerifyRequestToJSON(requestParameters['userWebsiteVerifyRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserWebsiteSummaryFromJSON(jsonValue));
    }

    /**
     * Verify a website as a signed-in user.
     * Verify website
     */
    async verifyWebsiteUpdate(requestParameters: VerifyWebsiteUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserWebsiteSummary> {
        const response = await this.verifyWebsiteUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get verification code for user to install on the website to claim it.
     * Get user verification code for website claiming
     */
    async websiteVerificationGetRaw(requestParameters: WebsiteVerificationGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserWebsiteVerificationCode>> {
        const queryParameters: any = {};

        if (requestParameters['adAccountId'] != null) {
            queryParameters['ad_account_id'] = requestParameters['adAccountId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("pinterest_oauth2", ["user_accounts:read"]);
        }

        if (this.configuration && this.configuration.accessToken) {
            // oauth required
            headerParameters["Authorization"] = await this.configuration.accessToken("client_credentials", ["user_accounts:read"]);
        }

        const response = await this.request({
            path: `/user_account/websites/verification`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserWebsiteVerificationCodeFromJSON(jsonValue));
    }

    /**
     * Get verification code for user to install on the website to claim it.
     * Get user verification code for website claiming
     */
    async websiteVerificationGet(requestParameters: WebsiteVerificationGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserWebsiteVerificationCode> {
        const response = await this.websiteVerificationGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const UserAccountAnalyticsFromClaimedContentEnum = {
    Other: 'OTHER',
    Claimed: 'CLAIMED',
    Both: 'BOTH'
} as const;
export type UserAccountAnalyticsFromClaimedContentEnum = typeof UserAccountAnalyticsFromClaimedContentEnum[keyof typeof UserAccountAnalyticsFromClaimedContentEnum];
/**
 * @export
 */
export const UserAccountAnalyticsPinFormatEnum = {
    All: 'ALL',
    OrganicImage: 'ORGANIC_IMAGE',
    OrganicProduct: 'ORGANIC_PRODUCT',
    OrganicVideo: 'ORGANIC_VIDEO',
    AdsStandard: 'ADS_STANDARD',
    AdsProduct: 'ADS_PRODUCT',
    AdsVideo: 'ADS_VIDEO',
    AdsIdea: 'ADS_IDEA'
} as const;
export type UserAccountAnalyticsPinFormatEnum = typeof UserAccountAnalyticsPinFormatEnum[keyof typeof UserAccountAnalyticsPinFormatEnum];
/**
 * @export
 */
export const UserAccountAnalyticsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type UserAccountAnalyticsAppTypesEnum = typeof UserAccountAnalyticsAppTypesEnum[keyof typeof UserAccountAnalyticsAppTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsContentTypeEnum = {
    All: 'ALL',
    Paid: 'PAID',
    Organic: 'ORGANIC'
} as const;
export type UserAccountAnalyticsContentTypeEnum = typeof UserAccountAnalyticsContentTypeEnum[keyof typeof UserAccountAnalyticsContentTypeEnum];
/**
 * @export
 */
export const UserAccountAnalyticsSourceEnum = {
    All: 'ALL',
    YourPins: 'YOUR_PINS',
    OtherPins: 'OTHER_PINS'
} as const;
export type UserAccountAnalyticsSourceEnum = typeof UserAccountAnalyticsSourceEnum[keyof typeof UserAccountAnalyticsSourceEnum];
/**
 * @export
 */
export const UserAccountAnalyticsMetricTypesEnum = {
    Engagement: 'ENGAGEMENT',
    EngagementRate: 'ENGAGEMENT_RATE',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    OutboundClickRate: 'OUTBOUND_CLICK_RATE',
    PinClick: 'PIN_CLICK',
    PinClickRate: 'PIN_CLICK_RATE',
    Save: 'SAVE',
    SaveRate: 'SAVE_RATE'
} as const;
export type UserAccountAnalyticsMetricTypesEnum = typeof UserAccountAnalyticsMetricTypesEnum[keyof typeof UserAccountAnalyticsMetricTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsSplitFieldEnum = {
    NoSplit: 'NO_SPLIT',
    AppType: 'APP_TYPE',
    OwnedContent: 'OWNED_CONTENT',
    Source: 'SOURCE',
    PinFormat: 'PIN_FORMAT'
} as const;
export type UserAccountAnalyticsSplitFieldEnum = typeof UserAccountAnalyticsSplitFieldEnum[keyof typeof UserAccountAnalyticsSplitFieldEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsSortByEnum = {
    Engagement: 'ENGAGEMENT',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    PinClick: 'PIN_CLICK',
    Save: 'SAVE'
} as const;
export type UserAccountAnalyticsTopPinsSortByEnum = typeof UserAccountAnalyticsTopPinsSortByEnum[keyof typeof UserAccountAnalyticsTopPinsSortByEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsFromClaimedContentEnum = {
    Other: 'OTHER',
    Claimed: 'CLAIMED',
    Both: 'BOTH'
} as const;
export type UserAccountAnalyticsTopPinsFromClaimedContentEnum = typeof UserAccountAnalyticsTopPinsFromClaimedContentEnum[keyof typeof UserAccountAnalyticsTopPinsFromClaimedContentEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsPinFormatEnum = {
    All: 'ALL',
    OrganicImage: 'ORGANIC_IMAGE',
    OrganicProduct: 'ORGANIC_PRODUCT',
    OrganicVideo: 'ORGANIC_VIDEO',
    AdsStandard: 'ADS_STANDARD',
    AdsProduct: 'ADS_PRODUCT',
    AdsVideo: 'ADS_VIDEO',
    AdsIdea: 'ADS_IDEA'
} as const;
export type UserAccountAnalyticsTopPinsPinFormatEnum = typeof UserAccountAnalyticsTopPinsPinFormatEnum[keyof typeof UserAccountAnalyticsTopPinsPinFormatEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type UserAccountAnalyticsTopPinsAppTypesEnum = typeof UserAccountAnalyticsTopPinsAppTypesEnum[keyof typeof UserAccountAnalyticsTopPinsAppTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsContentTypeEnum = {
    All: 'ALL',
    Paid: 'PAID',
    Organic: 'ORGANIC'
} as const;
export type UserAccountAnalyticsTopPinsContentTypeEnum = typeof UserAccountAnalyticsTopPinsContentTypeEnum[keyof typeof UserAccountAnalyticsTopPinsContentTypeEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsSourceEnum = {
    All: 'ALL',
    YourPins: 'YOUR_PINS',
    OtherPins: 'OTHER_PINS'
} as const;
export type UserAccountAnalyticsTopPinsSourceEnum = typeof UserAccountAnalyticsTopPinsSourceEnum[keyof typeof UserAccountAnalyticsTopPinsSourceEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsMetricTypesEnum = {
    Engagement: 'ENGAGEMENT',
    EngagementRate: 'ENGAGEMENT_RATE',
    Impression: 'IMPRESSION',
    OutboundClick: 'OUTBOUND_CLICK',
    OutboundClickRate: 'OUTBOUND_CLICK_RATE',
    PinClick: 'PIN_CLICK',
    PinClickRate: 'PIN_CLICK_RATE',
    Save: 'SAVE',
    SaveRate: 'SAVE_RATE'
} as const;
export type UserAccountAnalyticsTopPinsMetricTypesEnum = typeof UserAccountAnalyticsTopPinsMetricTypesEnum[keyof typeof UserAccountAnalyticsTopPinsMetricTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum = {
    NUMBER_30: 30
} as const;
export type UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum = typeof UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum[keyof typeof UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsSortByEnum = {
    Impression: 'IMPRESSION',
    Save: 'SAVE',
    OutboundClick: 'OUTBOUND_CLICK',
    VideoMrcView: 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime: 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime: 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView: 'QUARTILE_95_PERCENT_VIEW',
    Video10SView: 'VIDEO_10S_VIEW',
    VideoStart: 'VIDEO_START'
} as const;
export type UserAccountAnalyticsTopVideoPinsSortByEnum = typeof UserAccountAnalyticsTopVideoPinsSortByEnum[keyof typeof UserAccountAnalyticsTopVideoPinsSortByEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum = {
    Other: 'OTHER',
    Claimed: 'CLAIMED',
    Both: 'BOTH'
} as const;
export type UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum = typeof UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum[keyof typeof UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsPinFormatEnum = {
    All: 'ALL',
    OrganicImage: 'ORGANIC_IMAGE',
    OrganicProduct: 'ORGANIC_PRODUCT',
    OrganicVideo: 'ORGANIC_VIDEO',
    AdsStandard: 'ADS_STANDARD',
    AdsProduct: 'ADS_PRODUCT',
    AdsVideo: 'ADS_VIDEO',
    AdsIdea: 'ADS_IDEA'
} as const;
export type UserAccountAnalyticsTopVideoPinsPinFormatEnum = typeof UserAccountAnalyticsTopVideoPinsPinFormatEnum[keyof typeof UserAccountAnalyticsTopVideoPinsPinFormatEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsAppTypesEnum = {
    All: 'ALL',
    Mobile: 'MOBILE',
    Tablet: 'TABLET',
    Web: 'WEB'
} as const;
export type UserAccountAnalyticsTopVideoPinsAppTypesEnum = typeof UserAccountAnalyticsTopVideoPinsAppTypesEnum[keyof typeof UserAccountAnalyticsTopVideoPinsAppTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsContentTypeEnum = {
    All: 'ALL',
    Paid: 'PAID',
    Organic: 'ORGANIC'
} as const;
export type UserAccountAnalyticsTopVideoPinsContentTypeEnum = typeof UserAccountAnalyticsTopVideoPinsContentTypeEnum[keyof typeof UserAccountAnalyticsTopVideoPinsContentTypeEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsSourceEnum = {
    All: 'ALL',
    YourPins: 'YOUR_PINS',
    OtherPins: 'OTHER_PINS'
} as const;
export type UserAccountAnalyticsTopVideoPinsSourceEnum = typeof UserAccountAnalyticsTopVideoPinsSourceEnum[keyof typeof UserAccountAnalyticsTopVideoPinsSourceEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsMetricTypesEnum = {
    Impression: 'IMPRESSION',
    Save: 'SAVE',
    VideoMrcView: 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime: 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime: 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView: 'QUARTILE_95_PERCENT_VIEW',
    Video10SView: 'VIDEO_10S_VIEW',
    VideoStart: 'VIDEO_START',
    OutboundClick: 'OUTBOUND_CLICK'
} as const;
export type UserAccountAnalyticsTopVideoPinsMetricTypesEnum = typeof UserAccountAnalyticsTopVideoPinsMetricTypesEnum[keyof typeof UserAccountAnalyticsTopVideoPinsMetricTypesEnum];
/**
 * @export
 */
export const UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum = {
    NUMBER_30: 30
} as const;
export type UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum = typeof UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum[keyof typeof UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum];
