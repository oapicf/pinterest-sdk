/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs/Observable';

import { map } from 'rxjs/operators';
import IHttpClient from '../IHttpClient';
import { inject, injectable } from 'inversify';
import { IAPIConfiguration } from '../IAPIConfiguration';
import { Headers } from '../Headers';
import HttpResponse from '../HttpResponse';

import { AdAccountsCountryResponse } from '../model/adAccountsCountryResponse';
import { BookClosedResponse } from '../model/bookClosedResponse';
import { DeliveryMetricsResponse } from '../model/deliveryMetricsResponse';
import { SingleInterestTargetingOptionResponse } from '../model/singleInterestTargetingOptionResponse';

import { COLLECTION_FORMATS }  from '../variables';



@injectable()
export class ResourcesService {
    private basePath: string = 'https://api.pinterest.com/v5';

    constructor(@inject('IApiHttpClient') private httpClient: IHttpClient,
        @inject('IAPIConfiguration') private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * Get ad accounts countries
     * Get Ad Accounts countries
     
     */
    public adAccountCountriesGet(observe?: 'body', headers?: Headers): Observable<AdAccountsCountryResponse>;
    public adAccountCountriesGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<AdAccountsCountryResponse>>;
    public adAccountCountriesGet(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (pinterest_oauth2) required
        if (this.APIConfiguration.accessToken) {
            let accessToken = typeof this.APIConfiguration.accessToken === 'function'
                ? this.APIConfiguration.accessToken()
                : this.APIConfiguration.accessToken;
            headers['Authorization'] = 'Bearer ' + accessToken;
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<AdAccountsCountryResponse>> = this.httpClient.get(`${this.basePath}/resources/ad_account_countries`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <AdAccountsCountryResponse>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get available metrics\&#39; definitions
     * Get the definitions for ads and organic metrics available across both synchronous and asynchronous report endpoints. The &#x60;display_name&#x60; attribute will match how the metric is named in our native tools like Ads Manager. See &lt;a href&#x3D;\&#39;/docs/api-features/analytics-overview/\&#39;&gt;Organic Analytics&lt;/a&gt; and &lt;a href&#x3D;\&#39;/docs/api-features/ads-reporting/\&#39;&gt;Ads Analytics&lt;/a&gt; for more information.
     * @param reportType Report type.
     
     */
    public deliveryMetricsGet(reportType?: 'SYNC' | 'ASYNC', observe?: 'body', headers?: Headers): Observable<DeliveryMetricsResponse>;
    public deliveryMetricsGet(reportType?: 'SYNC' | 'ASYNC', observe?: 'response', headers?: Headers): Observable<HttpResponse<DeliveryMetricsResponse>>;
    public deliveryMetricsGet(reportType?: 'SYNC' | 'ASYNC', observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (reportType !== undefined) {
            queryParameters.push('reportType='+encodeURIComponent(String(reportType)));
        }

        // authentication (pinterest_oauth2) required
        if (this.APIConfiguration.accessToken) {
            let accessToken = typeof this.APIConfiguration.accessToken === 'function'
                ? this.APIConfiguration.accessToken()
                : this.APIConfiguration.accessToken;
            headers['Authorization'] = 'Bearer ' + accessToken;
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<DeliveryMetricsResponse>> = this.httpClient.get(`${this.basePath}/resources/delivery_metrics?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <DeliveryMetricsResponse>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get interest details
     * &lt;p&gt;Get details of a specific interest given interest ID.&lt;/p&gt; &lt;p&gt;Click &lt;a href&#x3D;\&quot;https://docs.google.com/spreadsheets/d/1HxL-0Z3p2fgxis9YBP2HWC3tvPrs1hAuHDRtH-NJTIM/edit#gid&#x3D;118370875\&quot; target&#x3D;\&quot;_blank\&quot;&gt;here&lt;/a&gt; for a spreadsheet listing interests and their IDs.&lt;/p&gt;
     * @param interestId Unique identifier of an interest.
     
     */
    public interestTargetingOptionsGet(interestId: string, observe?: 'body', headers?: Headers): Observable<SingleInterestTargetingOptionResponse>;
    public interestTargetingOptionsGet(interestId: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<SingleInterestTargetingOptionResponse>>;
    public interestTargetingOptionsGet(interestId: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (interestId === null || interestId === undefined){
            throw new Error('Required parameter interestId was null or undefined when calling interestTargetingOptionsGet.');
        }

        // authentication (pinterest_oauth2) required
        if (this.APIConfiguration.accessToken) {
            let accessToken = typeof this.APIConfiguration.accessToken === 'function'
                ? this.APIConfiguration.accessToken()
                : this.APIConfiguration.accessToken;
            headers['Authorization'] = 'Bearer ' + accessToken;
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<SingleInterestTargetingOptionResponse>> = this.httpClient.get(`${this.basePath}/resources/targeting/interests/${encodeURIComponent(String(interestId))}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <SingleInterestTargetingOptionResponse>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get lead form questions
     * Get a list of all lead form question type names. Some questions might not be used.  &lt;strong&gt;This endpoint is currently in beta and not available to all apps. &lt;a href&#x3D;\&#39;/docs/getting-started/beta-and-advanced-access/\&#39;&gt;Learn more&lt;/a&gt;.&lt;/strong&gt;
     
     */
    public leadFormQuestionsGet(observe?: 'body', headers?: Headers): Observable<any>;
    public leadFormQuestionsGet(observe?: 'response', headers?: Headers): Observable<HttpResponse<any>>;
    public leadFormQuestionsGet(observe: any = 'body', headers: Headers = {}): Observable<any> {
        // authentication (pinterest_oauth2) required
        if (this.APIConfiguration.accessToken) {
            let accessToken = typeof this.APIConfiguration.accessToken === 'function'
                ? this.APIConfiguration.accessToken()
                : this.APIConfiguration.accessToken;
            headers['Authorization'] = 'Bearer ' + accessToken;
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<any>> = this.httpClient.get(`${this.basePath}/resources/lead_form_questions`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <any>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get metrics ready state
     * Learn whether conversion or non-conversion metrics are finalized and ready to query.
     * @param date Analytics reports request date (UTC). Format: YYYY-MM-DD
     
     */
    public metricsReadyStateGet(date: string, observe?: 'body', headers?: Headers): Observable<BookClosedResponse>;
    public metricsReadyStateGet(date: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<BookClosedResponse>>;
    public metricsReadyStateGet(date: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (date === null || date === undefined){
            throw new Error('Required parameter date was null or undefined when calling metricsReadyStateGet.');
        }

        let queryParameters: string[] = [];
        if (date !== undefined) {
            queryParameters.push('date='+encodeURIComponent(String(date)));
        }

        // authentication (pinterest_oauth2) required
        if (this.APIConfiguration.accessToken) {
            let accessToken = typeof this.APIConfiguration.accessToken === 'function'
                ? this.APIConfiguration.accessToken()
                : this.APIConfiguration.accessToken;
            headers['Authorization'] = 'Bearer ' + accessToken;
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<BookClosedResponse>> = this.httpClient.get(`${this.basePath}/resources/metrics_ready_state?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <BookClosedResponse>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get targeting options
     * &lt;p&gt;You can use targeting values in ads placement to define your intended audience. &lt;/p&gt; &lt;p&gt;Targeting metrics are organized around targeting specifications.&lt;/p&gt; &lt;p&gt;For more information on ads targeting, see &lt;a class&#x3D;\&quot;reference external\&quot; href&#x3D;\&quot;https://help.pinterest.com/en/business/article/audience-targeting\&quot; target&#x3D;\&quot;_blank\&quot;&gt;Audience targeting&lt;/a&gt;.&lt;/p&gt; &lt;p&gt;&lt;b&gt;Sample return:&lt;/b&gt;&lt;/p&gt; &lt;pre class&#x3D;\&quot;literal-block\&quot;&gt; [{&amp;quot;36313&amp;quot;: &amp;quot;Australia: Moreton Bay - North&amp;quot;, &amp;quot;124735&amp;quot;: &amp;quot;Canada: North Battleford&amp;quot;, &amp;quot;36109&amp;quot;: &amp;quot;Australia: Murray&amp;quot;, &amp;quot;36108&amp;quot;: &amp;quot;Australia: Mid North Coast&amp;quot;, &amp;quot;36101&amp;quot;: &amp;quot;Australia: Capital Region&amp;quot;, &amp;quot;811&amp;quot;: &amp;quot;U.S.: Reno&amp;quot;, &amp;quot;36103&amp;quot;: &amp;quot;Australia: Central West&amp;quot;, &amp;quot;36102&amp;quot;: &amp;quot;Australia: Central Coast&amp;quot;, &amp;quot;36105&amp;quot;: &amp;quot;Australia: Far West and Orana&amp;quot;, &amp;quot;36104&amp;quot;: &amp;quot;Australia: Coffs Harbour - Grafton&amp;quot;, &amp;quot;36107&amp;quot;: &amp;quot;Australia: Illawarra&amp;quot;, &amp;quot;36106&amp;quot;: &amp;quot;Australia: Hunter Valley Exc Newcastle&amp;quot;, &amp;quot;554017&amp;quot;: &amp;quot;New Zealand: Wanganui&amp;quot;, &amp;quot;554016&amp;quot;: &amp;quot;New Zealand: Marlborough&amp;quot;, &amp;quot;554015&amp;quot;: &amp;quot;New Zealand: Gisborne&amp;quot;, &amp;quot;554014&amp;quot;: &amp;quot;New Zealand: Tararua&amp;quot;, &amp;quot;554013&amp;quot;: &amp;quot;New Zealand: Invercargill&amp;quot;, &amp;quot;GR&amp;quot;: &amp;quot;Greece&amp;quot;, &amp;quot;554011&amp;quot;: &amp;quot;New Zealand: Whangarei&amp;quot;, &amp;quot;554010&amp;quot;: &amp;quot;New Zealand: Far North&amp;quot;, &amp;quot;717&amp;quot;: &amp;quot;U.S.: Quincy-Hannibal-Keokuk&amp;quot;, &amp;quot;716&amp;quot;: &amp;quot;U.S.: Baton Rouge&amp;quot;,...}] &lt;/pre&gt;
     * @param targetingType Public targeting type.
     * @param clientId Client ID.
     * @param oauthSignature Oauth signature
     * @param timestamp Timestamp
     * @param adAccountId Unique identifier of an ad account.
     
     */
    public targetingOptionsGet(targetingType: 'APPTYPE' | 'GENDER' | 'LOCALE' | 'AGE_BUCKET' | 'LOCATION' | 'GEO' | 'INTEREST' | 'KEYWORD' | 'AUDIENCE_INCLUDE' | 'AUDIENCE_EXCLUDE', clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, observe?: 'body', headers?: Headers): Observable<Array<object>>;
    public targetingOptionsGet(targetingType: 'APPTYPE' | 'GENDER' | 'LOCALE' | 'AGE_BUCKET' | 'LOCATION' | 'GEO' | 'INTEREST' | 'KEYWORD' | 'AUDIENCE_INCLUDE' | 'AUDIENCE_EXCLUDE', clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<Array<object>>>;
    public targetingOptionsGet(targetingType: 'APPTYPE' | 'GENDER' | 'LOCALE' | 'AGE_BUCKET' | 'LOCATION' | 'GEO' | 'INTEREST' | 'KEYWORD' | 'AUDIENCE_INCLUDE' | 'AUDIENCE_EXCLUDE', clientId?: string, oauthSignature?: string, timestamp?: string, adAccountId?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (targetingType === null || targetingType === undefined){
            throw new Error('Required parameter targetingType was null or undefined when calling targetingOptionsGet.');
        }

        let queryParameters: string[] = [];
        if (clientId !== undefined) {
            queryParameters.push('clientId='+encodeURIComponent(String(clientId)));
        }
        if (oauthSignature !== undefined) {
            queryParameters.push('oauthSignature='+encodeURIComponent(String(oauthSignature)));
        }
        if (timestamp !== undefined) {
            queryParameters.push('timestamp='+encodeURIComponent(String(timestamp)));
        }
        if (adAccountId !== undefined) {
            queryParameters.push('adAccountId='+encodeURIComponent(String(adAccountId)));
        }

        // authentication (pinterest_oauth2) required
        if (this.APIConfiguration.accessToken) {
            let accessToken = typeof this.APIConfiguration.accessToken === 'function'
                ? this.APIConfiguration.accessToken()
                : this.APIConfiguration.accessToken;
            headers['Authorization'] = 'Bearer ' + accessToken;
        }
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<Array<object>>> = this.httpClient.get(`${this.basePath}/resources/targeting/${encodeURIComponent(String(targetingType))}?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <Array<object>>(httpResponse.response))
               );
        }
        return response;
    }

}
