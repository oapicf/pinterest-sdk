// tslint:disable
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    KeywordUpdateBody,
    KeywordUpdateBodyFromJSON,
    KeywordUpdateBodyToJSON,
    KeywordsGet200Response,
    KeywordsGet200ResponseFromJSON,
    KeywordsGet200ResponseToJSON,
    KeywordsMetricsArrayResponse,
    KeywordsMetricsArrayResponseFromJSON,
    KeywordsMetricsArrayResponseToJSON,
    KeywordsRequest,
    KeywordsRequestFromJSON,
    KeywordsRequestToJSON,
    KeywordsResponse,
    KeywordsResponseFromJSON,
    KeywordsResponseToJSON,
    MatchType,
    MatchTypeFromJSON,
    MatchTypeToJSON,
    TrendType,
    TrendTypeFromJSON,
    TrendTypeToJSON,
    TrendingKeywordsResponse,
    TrendingKeywordsResponseFromJSON,
    TrendingKeywordsResponseToJSON,
    TrendsSupportedRegion,
    TrendsSupportedRegionFromJSON,
    TrendsSupportedRegionToJSON,
} from '../models';

export interface CountryKeywordsMetricsGetRequest {
    adAccountId: string;
    countryCode: string;
    keywords: Array<string>;
}

export interface KeywordsCreateRequest {
    adAccountId: string;
    keywordsRequest: KeywordsRequest;
}

export interface KeywordsGetRequest {
    adAccountId: string;
    campaignId?: string;
    adGroupId?: string;
    matchTypes?: Array<MatchType>;
    pageSize?: number;
    bookmark?: string;
}

export interface KeywordsUpdateRequest {
    adAccountId: string;
    keywordUpdateBody: KeywordUpdateBody;
}

export interface TrendingKeywordsListRequest {
    region: TrendsSupportedRegion;
    trendType: TrendType;
    interests?: Array<TrendingKeywordsListInterestsEnum>;
    genders?: Array<TrendingKeywordsListGendersEnum>;
    ages?: Array<TrendingKeywordsListAgesEnum>;
    includeKeywords?: Array<string>;
    normalizeAgainstGroup?: boolean;
    limit?: number;
}


/**
 * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
 * Get country\'s keyword metrics
 */
function countryKeywordsMetricsGetRaw<T>(requestParameters: CountryKeywordsMetricsGetRequest, requestConfig: runtime.TypedQueryConfig<T, KeywordsMetricsArrayResponse> = {}): QueryConfig<T> {
    if (requestParameters.adAccountId === null || requestParameters.adAccountId === undefined) {
        throw new runtime.RequiredError('adAccountId','Required parameter requestParameters.adAccountId was null or undefined when calling countryKeywordsMetricsGet.');
    }

    if (requestParameters.countryCode === null || requestParameters.countryCode === undefined) {
        throw new runtime.RequiredError('countryCode','Required parameter requestParameters.countryCode was null or undefined when calling countryKeywordsMetricsGet.');
    }

    if (requestParameters.keywords === null || requestParameters.keywords === undefined) {
        throw new runtime.RequiredError('keywords','Required parameter requestParameters.keywords was null or undefined when calling countryKeywordsMetricsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.countryCode !== undefined) {
        queryParameters['country_code'] = requestParameters.countryCode;
    }


    if (requestParameters.keywords) {
        queryParameters['keywords'] = requestParameters.keywords?.join(runtime.COLLECTION_FORMATS["csv"]);
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["ads:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/ad_accounts/{ad_account_id}/keywords/metrics`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters.adAccountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(KeywordsMetricsArrayResponseFromJSON(body), text);
    }

    return config;
}

/**
* See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
* Get country\'s keyword metrics
*/
export function countryKeywordsMetricsGet<T>(requestParameters: CountryKeywordsMetricsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, KeywordsMetricsArrayResponse>): QueryConfig<T> {
    return countryKeywordsMetricsGetRaw(requestParameters, requestConfig);
}

/**
 * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
 * Create keywords
 */
function keywordsCreateRaw<T>(requestParameters: KeywordsCreateRequest, requestConfig: runtime.TypedQueryConfig<T, KeywordsResponse> = {}): QueryConfig<T> {
    if (requestParameters.adAccountId === null || requestParameters.adAccountId === undefined) {
        throw new runtime.RequiredError('adAccountId','Required parameter requestParameters.adAccountId was null or undefined when calling keywordsCreate.');
    }

    if (requestParameters.keywordsRequest === null || requestParameters.keywordsRequest === undefined) {
        throw new runtime.RequiredError('keywordsRequest','Required parameter requestParameters.keywordsRequest was null or undefined when calling keywordsCreate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["ads:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/ad_accounts/{ad_account_id}/keywords`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters.adAccountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || KeywordsRequestToJSON(requestParameters.keywordsRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(KeywordsResponseFromJSON(body), text);
    }

    return config;
}

/**
* <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
* Create keywords
*/
export function keywordsCreate<T>(requestParameters: KeywordsCreateRequest, requestConfig?: runtime.TypedQueryConfig<T, KeywordsResponse>): QueryConfig<T> {
    return keywordsCreateRaw(requestParameters, requestConfig);
}

/**
 * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
 * Get keywords
 */
function keywordsGetRaw<T>(requestParameters: KeywordsGetRequest, requestConfig: runtime.TypedQueryConfig<T, KeywordsGet200Response> = {}): QueryConfig<T> {
    if (requestParameters.adAccountId === null || requestParameters.adAccountId === undefined) {
        throw new runtime.RequiredError('adAccountId','Required parameter requestParameters.adAccountId was null or undefined when calling keywordsGet.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.campaignId !== undefined) {
        queryParameters['campaign_id'] = requestParameters.campaignId;
    }


    if (requestParameters.adGroupId !== undefined) {
        queryParameters['ad_group_id'] = requestParameters.adGroupId;
    }


    if (requestParameters.matchTypes) {
        queryParameters['match_types'] = requestParameters.matchTypes;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["ads:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/ad_accounts/{ad_account_id}/keywords`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters.adAccountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(KeywordsGet200ResponseFromJSON(body), text);
    }

    return config;
}

/**
* <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
* Get keywords
*/
export function keywordsGet<T>(requestParameters: KeywordsGetRequest, requestConfig?: runtime.TypedQueryConfig<T, KeywordsGet200Response>): QueryConfig<T> {
    return keywordsGetRaw(requestParameters, requestConfig);
}

/**
 * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
 * Update keywords
 */
function keywordsUpdateRaw<T>(requestParameters: KeywordsUpdateRequest, requestConfig: runtime.TypedQueryConfig<T, KeywordsResponse> = {}): QueryConfig<T> {
    if (requestParameters.adAccountId === null || requestParameters.adAccountId === undefined) {
        throw new runtime.RequiredError('adAccountId','Required parameter requestParameters.adAccountId was null or undefined when calling keywordsUpdate.');
    }

    if (requestParameters.keywordUpdateBody === null || requestParameters.keywordUpdateBody === undefined) {
        throw new runtime.RequiredError('keywordUpdateBody','Required parameter requestParameters.keywordUpdateBody was null or undefined when calling keywordsUpdate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["ads:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/ad_accounts/{ad_account_id}/keywords`.replace(`{${"ad_account_id"}}`, encodeURIComponent(String(requestParameters.adAccountId))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'PATCH',
            headers: headerParameters,
        },
        body: queryParameters || KeywordUpdateBodyToJSON(requestParameters.keywordUpdateBody),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(KeywordsResponseFromJSON(body), text);
    }

    return config;
}

/**
* <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
* Update keywords
*/
export function keywordsUpdate<T>(requestParameters: KeywordsUpdateRequest, requestConfig?: runtime.TypedQueryConfig<T, KeywordsResponse>): QueryConfig<T> {
    return keywordsUpdateRaw(requestParameters, requestConfig);
}

/**
 * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
 * List trending keywords
 */
function trendingKeywordsListRaw<T>(requestParameters: TrendingKeywordsListRequest, requestConfig: runtime.TypedQueryConfig<T, TrendingKeywordsResponse> = {}): QueryConfig<T> {
    if (requestParameters.region === null || requestParameters.region === undefined) {
        throw new runtime.RequiredError('region','Required parameter requestParameters.region was null or undefined when calling trendingKeywordsList.');
    }

    if (requestParameters.trendType === null || requestParameters.trendType === undefined) {
        throw new runtime.RequiredError('trendType','Required parameter requestParameters.trendType was null or undefined when calling trendingKeywordsList.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.interests) {
        queryParameters['interests'] = requestParameters.interests;
    }


    if (requestParameters.genders) {
        queryParameters['genders'] = requestParameters.genders;
    }


    if (requestParameters.ages) {
        queryParameters['ages'] = requestParameters.ages;
    }


    if (requestParameters.includeKeywords) {
        queryParameters['include_keywords'] = requestParameters.includeKeywords;
    }


    if (requestParameters.normalizeAgainstGroup !== undefined) {
        queryParameters['normalize_against_group'] = requestParameters.normalizeAgainstGroup;
    }


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/trends/keywords/{region}/top/{trend_type}`.replace(`{${"region"}}`, encodeURIComponent(String(requestParameters.region))).replace(`{${"trend_type"}}`, encodeURIComponent(String(requestParameters.trendType))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(TrendingKeywordsResponseFromJSON(body), text);
    }

    return config;
}

/**
* <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
* List trending keywords
*/
export function trendingKeywordsList<T>(requestParameters: TrendingKeywordsListRequest, requestConfig?: runtime.TypedQueryConfig<T, TrendingKeywordsResponse>): QueryConfig<T> {
    return trendingKeywordsListRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum TrendingKeywordsListInterestsEnum {
    Animals = 'animals',
    Architecture = 'architecture',
    Art = 'art',
    Beauty = 'beauty',
    ChildrensFashion = 'childrens_fashion',
    Design = 'design',
    DiyAndCrafts = 'diy_and_crafts',
    Education = 'education',
    Electronics = 'electronics',
    Entertainment = 'entertainment',
    EventPlanning = 'event_planning',
    Finance = 'finance',
    FoodAndDrinks = 'food_and_drinks',
    Gardening = 'gardening',
    Health = 'health',
    HomeDecor = 'home_decor',
    MensFashion = 'mens_fashion',
    Parenting = 'parenting',
    Quotes = 'quotes',
    Sport = 'sport',
    Travel = 'travel',
    Vehicles = 'vehicles',
    Wedding = 'wedding',
    WomensFashion = 'womens_fashion'
}
/**
    * @export
    * @enum {string}
    */
export enum TrendingKeywordsListGendersEnum {
    Female = 'female',
    Male = 'male',
    Unknown = 'unknown'
}
/**
    * @export
    * @enum {string}
    */
export enum TrendingKeywordsListAgesEnum {
    _1824 = '18-24',
    _2534 = '25-34',
    _3544 = '35-44',
    _4549 = '45-49',
    _5054 = '50-54',
    _5564 = '55-64',
    _65 = '65+'
}
