// tslint:disable
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    Account,
    AccountFromJSON,
    AccountToJSON,
    AnalyticsMetricsResponse,
    AnalyticsMetricsResponseFromJSON,
    AnalyticsMetricsResponseToJSON,
    BoardsUserFollowsList200Response,
    BoardsUserFollowsList200ResponseFromJSON,
    BoardsUserFollowsList200ResponseToJSON,
    FollowUserRequest,
    FollowUserRequestFromJSON,
    FollowUserRequestToJSON,
    FollowersList200Response,
    FollowersList200ResponseFromJSON,
    FollowersList200ResponseToJSON,
    LinkedBusiness,
    LinkedBusinessFromJSON,
    LinkedBusinessToJSON,
    TopPinsAnalyticsResponse,
    TopPinsAnalyticsResponseFromJSON,
    TopPinsAnalyticsResponseToJSON,
    TopVideoPinsAnalyticsResponse,
    TopVideoPinsAnalyticsResponseFromJSON,
    TopVideoPinsAnalyticsResponseToJSON,
    UserAccountFollowedInterests200Response,
    UserAccountFollowedInterests200ResponseFromJSON,
    UserAccountFollowedInterests200ResponseToJSON,
    UserFollowingFeedType,
    UserFollowingFeedTypeFromJSON,
    UserFollowingFeedTypeToJSON,
    UserFollowingGet200Response,
    UserFollowingGet200ResponseFromJSON,
    UserFollowingGet200ResponseToJSON,
    UserSummary,
    UserSummaryFromJSON,
    UserSummaryToJSON,
    UserWebsiteSummary,
    UserWebsiteSummaryFromJSON,
    UserWebsiteSummaryToJSON,
    UserWebsiteVerificationCode,
    UserWebsiteVerificationCodeFromJSON,
    UserWebsiteVerificationCodeToJSON,
    UserWebsiteVerifyRequest,
    UserWebsiteVerifyRequestFromJSON,
    UserWebsiteVerifyRequestToJSON,
    UserWebsitesGet200Response,
    UserWebsitesGet200ResponseFromJSON,
    UserWebsitesGet200ResponseToJSON,
} from '../models';

export interface BoardsUserFollowsListRequest {
    bookmark?: string;
    pageSize?: number;
    explicitFollowing?: boolean;
    adAccountId?: string;
}

export interface FollowUserUpdateRequest {
    username: string;
    followUserRequest: FollowUserRequest;
}

export interface FollowersListRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface UnverifyWebsiteDeleteRequest {
    website: string;
}

export interface UserAccountAnalyticsRequest {
    startDate: Date;
    endDate: Date;
    fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsPinFormatEnum;
    appTypes?: UserAccountAnalyticsAppTypesEnum;
    contentType?: UserAccountAnalyticsContentTypeEnum;
    source?: UserAccountAnalyticsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>;
    splitField?: UserAccountAnalyticsSplitFieldEnum;
    adAccountId?: string;
}

export interface UserAccountAnalyticsTopPinsRequest {
    startDate: Date;
    endDate: Date;
    sortBy: UserAccountAnalyticsTopPinsSortByEnum;
    fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum;
    appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum;
    contentType?: UserAccountAnalyticsTopPinsContentTypeEnum;
    source?: UserAccountAnalyticsTopPinsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>;
    numOfPins?: number;
    createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum;
    adAccountId?: string;
}

export interface UserAccountAnalyticsTopVideoPinsRequest {
    startDate: Date;
    endDate: Date;
    sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum;
    fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum;
    appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum;
    contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum;
    source?: UserAccountAnalyticsTopVideoPinsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>;
    numOfPins?: number;
    createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum;
    adAccountId?: string;
}

export interface UserAccountFollowedInterestsRequest {
    username: string;
    bookmark?: string;
    pageSize?: number;
}

export interface UserAccountGetRequest {
    adAccountId?: string;
}

export interface UserFollowingGetRequest {
    bookmark?: string;
    pageSize?: number;
    feedType?: UserFollowingFeedType;
    explicitFollowing?: boolean;
    adAccountId?: string;
}

export interface UserWebsitesGetRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface VerifyWebsiteUpdateRequest {
    userWebsiteVerifyRequest: UserWebsiteVerifyRequest;
    adAccountId?: string;
}

export interface WebsiteVerificationGetRequest {
    adAccountId?: string;
}


/**
 * Get a list of the boards a user follows. The request returns a board summary object array.
 * List following boards
 */
function boardsUserFollowsListRaw<T>(requestParameters: BoardsUserFollowsListRequest, requestConfig: runtime.TypedQueryConfig<T, BoardsUserFollowsList200Response> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }


    if (requestParameters.explicitFollowing !== undefined) {
        queryParameters['explicit_following'] = requestParameters.explicitFollowing;
    }


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/following/boards`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(BoardsUserFollowsList200ResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get a list of the boards a user follows. The request returns a board summary object array.
* List following boards
*/
export function boardsUserFollowsList<T>(requestParameters: BoardsUserFollowsListRequest, requestConfig?: runtime.TypedQueryConfig<T, BoardsUserFollowsList200Response>): QueryConfig<T> {
    return boardsUserFollowsListRaw(requestParameters, requestConfig);
}

/**
 * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
 * Follow user
 */
function followUserUpdateRaw<T>(requestParameters: FollowUserUpdateRequest, requestConfig: runtime.TypedQueryConfig<T, UserSummary> = {}): QueryConfig<T> {
    if (requestParameters.username === null || requestParameters.username === undefined) {
        throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling followUserUpdate.');
    }

    if (requestParameters.followUserRequest === null || requestParameters.followUserRequest === undefined) {
        throw new runtime.RequiredError('followUserRequest','Required parameter requestParameters.followUserRequest was null or undefined when calling followUserUpdate.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/following/{username}`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || FollowUserRequestToJSON(requestParameters.followUserRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserSummaryFromJSON(body), text);
    }

    return config;
}

/**
* <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
* Follow user
*/
export function followUserUpdate<T>(requestParameters: FollowUserUpdateRequest, requestConfig?: runtime.TypedQueryConfig<T, UserSummary>): QueryConfig<T> {
    return followUserUpdateRaw(requestParameters, requestConfig);
}

/**
 * Get a list of your followers.
 * List followers
 */
function followersListRaw<T>(requestParameters: FollowersListRequest, requestConfig: runtime.TypedQueryConfig<T, FollowersList200Response> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/followers`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(FollowersList200ResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get a list of your followers.
* List followers
*/
export function followersList<T>(requestParameters: FollowersListRequest, requestConfig?: runtime.TypedQueryConfig<T, FollowersList200Response>): QueryConfig<T> {
    return followersListRaw(requestParameters, requestConfig);
}

/**
 * Get a list of your linked business accounts.
 * List linked businesses
 */
function linkedBusinessAccountsGetRaw<T>( requestConfig: runtime.TypedQueryConfig<T, Array<LinkedBusiness>> = {}): QueryConfig<T> {
    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/businesses`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(body.map(LinkedBusinessFromJSON), text);
    }

    return config;
}

/**
* Get a list of your linked business accounts.
* List linked businesses
*/
export function linkedBusinessAccountsGet<T>( requestConfig?: runtime.TypedQueryConfig<T, Array<LinkedBusiness>>): QueryConfig<T> {
    return linkedBusinessAccountsGetRaw( requestConfig);
}

/**
 * Unverifu a website verified by the signed-in user.
 * Unverify website
 */
function unverifyWebsiteDeleteRaw<T>(requestParameters: UnverifyWebsiteDeleteRequest, requestConfig: runtime.TypedQueryConfig<T, void> = {}): QueryConfig<T> {
    if (requestParameters.website === null || requestParameters.website === undefined) {
        throw new runtime.RequiredError('website','Required parameter requestParameters.website was null or undefined when calling unverifyWebsiteDelete.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.website !== undefined) {
        queryParameters['website'] = requestParameters.website;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/websites`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'DELETE',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
    }

    return config;
}

/**
* Unverifu a website verified by the signed-in user.
* Unverify website
*/
export function unverifyWebsiteDelete<T>(requestParameters: UnverifyWebsiteDeleteRequest, requestConfig?: runtime.TypedQueryConfig<T, void>): QueryConfig<T> {
    return unverifyWebsiteDeleteRaw(requestParameters, requestConfig);
}

/**
 * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
 * Get user account analytics
 */
function userAccountAnalyticsRaw<T>(requestParameters: UserAccountAnalyticsRequest, requestConfig: runtime.TypedQueryConfig<T, { [key: string]: AnalyticsMetricsResponse; }> = {}): QueryConfig<T> {
    if (requestParameters.startDate === null || requestParameters.startDate === undefined) {
        throw new runtime.RequiredError('startDate','Required parameter requestParameters.startDate was null or undefined when calling userAccountAnalytics.');
    }

    if (requestParameters.endDate === null || requestParameters.endDate === undefined) {
        throw new runtime.RequiredError('endDate','Required parameter requestParameters.endDate was null or undefined when calling userAccountAnalytics.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = (requestParameters.startDate as any).toISOString().substring(0,10);
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = (requestParameters.endDate as any).toISOString().substring(0,10);
    }


    if (requestParameters.fromClaimedContent !== undefined) {
        queryParameters['from_claimed_content'] = requestParameters.fromClaimedContent;
    }


    if (requestParameters.pinFormat !== undefined) {
        queryParameters['pin_format'] = requestParameters.pinFormat;
    }


    if (requestParameters.appTypes !== undefined) {
        queryParameters['app_types'] = requestParameters.appTypes;
    }


    if (requestParameters.contentType !== undefined) {
        queryParameters['content_type'] = requestParameters.contentType;
    }


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.metricTypes) {
        queryParameters['metric_types'] = requestParameters.metricTypes?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.splitField !== undefined) {
        queryParameters['split_field'] = requestParameters.splitField;
    }


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/analytics`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AnalyticsMetricsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
* Get user account analytics
*/
export function userAccountAnalytics<T>(requestParameters: UserAccountAnalyticsRequest, requestConfig?: runtime.TypedQueryConfig<T, { [key: string]: AnalyticsMetricsResponse; }>): QueryConfig<T> {
    return userAccountAnalyticsRaw(requestParameters, requestConfig);
}

/**
 * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
 * Get user account top pins analytics
 */
function userAccountAnalyticsTopPinsRaw<T>(requestParameters: UserAccountAnalyticsTopPinsRequest, requestConfig: runtime.TypedQueryConfig<T, TopPinsAnalyticsResponse> = {}): QueryConfig<T> {
    if (requestParameters.startDate === null || requestParameters.startDate === undefined) {
        throw new runtime.RequiredError('startDate','Required parameter requestParameters.startDate was null or undefined when calling userAccountAnalyticsTopPins.');
    }

    if (requestParameters.endDate === null || requestParameters.endDate === undefined) {
        throw new runtime.RequiredError('endDate','Required parameter requestParameters.endDate was null or undefined when calling userAccountAnalyticsTopPins.');
    }

    if (requestParameters.sortBy === null || requestParameters.sortBy === undefined) {
        throw new runtime.RequiredError('sortBy','Required parameter requestParameters.sortBy was null or undefined when calling userAccountAnalyticsTopPins.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = (requestParameters.startDate as any).toISOString().substring(0,10);
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = (requestParameters.endDate as any).toISOString().substring(0,10);
    }


    if (requestParameters.sortBy !== undefined) {
        queryParameters['sort_by'] = requestParameters.sortBy;
    }


    if (requestParameters.fromClaimedContent !== undefined) {
        queryParameters['from_claimed_content'] = requestParameters.fromClaimedContent;
    }


    if (requestParameters.pinFormat !== undefined) {
        queryParameters['pin_format'] = requestParameters.pinFormat;
    }


    if (requestParameters.appTypes !== undefined) {
        queryParameters['app_types'] = requestParameters.appTypes;
    }


    if (requestParameters.contentType !== undefined) {
        queryParameters['content_type'] = requestParameters.contentType;
    }


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.metricTypes) {
        queryParameters['metric_types'] = requestParameters.metricTypes?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.numOfPins !== undefined) {
        queryParameters['num_of_pins'] = requestParameters.numOfPins;
    }


    if (requestParameters.createdInLastNDays !== undefined) {
        queryParameters['created_in_last_n_days'] = requestParameters.createdInLastNDays;
    }


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["pins:read", "user_accounts:read"]];
    meta.authType = ['oauth', ["pins:read", "user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/analytics/top_pins`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(TopPinsAnalyticsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
* Get user account top pins analytics
*/
export function userAccountAnalyticsTopPins<T>(requestParameters: UserAccountAnalyticsTopPinsRequest, requestConfig?: runtime.TypedQueryConfig<T, TopPinsAnalyticsResponse>): QueryConfig<T> {
    return userAccountAnalyticsTopPinsRaw(requestParameters, requestConfig);
}

/**
 * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
 * Get user account top video pins analytics
 */
function userAccountAnalyticsTopVideoPinsRaw<T>(requestParameters: UserAccountAnalyticsTopVideoPinsRequest, requestConfig: runtime.TypedQueryConfig<T, TopVideoPinsAnalyticsResponse> = {}): QueryConfig<T> {
    if (requestParameters.startDate === null || requestParameters.startDate === undefined) {
        throw new runtime.RequiredError('startDate','Required parameter requestParameters.startDate was null or undefined when calling userAccountAnalyticsTopVideoPins.');
    }

    if (requestParameters.endDate === null || requestParameters.endDate === undefined) {
        throw new runtime.RequiredError('endDate','Required parameter requestParameters.endDate was null or undefined when calling userAccountAnalyticsTopVideoPins.');
    }

    if (requestParameters.sortBy === null || requestParameters.sortBy === undefined) {
        throw new runtime.RequiredError('sortBy','Required parameter requestParameters.sortBy was null or undefined when calling userAccountAnalyticsTopVideoPins.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.startDate !== undefined) {
        queryParameters['start_date'] = (requestParameters.startDate as any).toISOString().substring(0,10);
    }


    if (requestParameters.endDate !== undefined) {
        queryParameters['end_date'] = (requestParameters.endDate as any).toISOString().substring(0,10);
    }


    if (requestParameters.sortBy !== undefined) {
        queryParameters['sort_by'] = requestParameters.sortBy;
    }


    if (requestParameters.fromClaimedContent !== undefined) {
        queryParameters['from_claimed_content'] = requestParameters.fromClaimedContent;
    }


    if (requestParameters.pinFormat !== undefined) {
        queryParameters['pin_format'] = requestParameters.pinFormat;
    }


    if (requestParameters.appTypes !== undefined) {
        queryParameters['app_types'] = requestParameters.appTypes;
    }


    if (requestParameters.contentType !== undefined) {
        queryParameters['content_type'] = requestParameters.contentType;
    }


    if (requestParameters.source !== undefined) {
        queryParameters['source'] = requestParameters.source;
    }


    if (requestParameters.metricTypes) {
        queryParameters['metric_types'] = requestParameters.metricTypes?.join(runtime.COLLECTION_FORMATS["csv"]);
    }


    if (requestParameters.numOfPins !== undefined) {
        queryParameters['num_of_pins'] = requestParameters.numOfPins;
    }


    if (requestParameters.createdInLastNDays !== undefined) {
        queryParameters['created_in_last_n_days'] = requestParameters.createdInLastNDays;
    }


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["pins:read", "user_accounts:read"]];
    meta.authType = ['oauth', ["pins:read", "user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/analytics/top_video_pins`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(TopVideoPinsAnalyticsResponseFromJSON(body), text);
    }

    return config;
}

/**
* Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
* Get user account top video pins analytics
*/
export function userAccountAnalyticsTopVideoPins<T>(requestParameters: UserAccountAnalyticsTopVideoPinsRequest, requestConfig?: runtime.TypedQueryConfig<T, TopVideoPinsAnalyticsResponse>): QueryConfig<T> {
    return userAccountAnalyticsTopVideoPinsRaw(requestParameters, requestConfig);
}

/**
 * Get a list of a user\'s following interests in one place.
 * List following interests
 */
function userAccountFollowedInterestsRaw<T>(requestParameters: UserAccountFollowedInterestsRequest, requestConfig: runtime.TypedQueryConfig<T, UserAccountFollowedInterests200Response> = {}): QueryConfig<T> {
    if (requestParameters.username === null || requestParameters.username === undefined) {
        throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling userAccountFollowedInterests.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/users/{username}/interests/follow`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserAccountFollowedInterests200ResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get a list of a user\'s following interests in one place.
* List following interests
*/
export function userAccountFollowedInterests<T>(requestParameters: UserAccountFollowedInterestsRequest, requestConfig?: runtime.TypedQueryConfig<T, UserAccountFollowedInterests200Response>): QueryConfig<T> {
    return userAccountFollowedInterestsRaw(requestParameters, requestConfig);
}

/**
 * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
 * Get user account
 */
function userAccountGetRaw<T>(requestParameters: UserAccountGetRequest, requestConfig: runtime.TypedQueryConfig<T, Account> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AccountFromJSON(body), text);
    }

    return config;
}

/**
* Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
* Get user account
*/
export function userAccountGet<T>(requestParameters: UserAccountGetRequest, requestConfig?: runtime.TypedQueryConfig<T, Account>): QueryConfig<T> {
    return userAccountGetRaw(requestParameters, requestConfig);
}

/**
 * Get a list of who a certain user follows.
 * List following
 */
function userFollowingGetRaw<T>(requestParameters: UserFollowingGetRequest, requestConfig: runtime.TypedQueryConfig<T, UserFollowingGet200Response> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }


    if (requestParameters.feedType !== undefined) {
        queryParameters['feed_type'] = requestParameters.feedType;
    }


    if (requestParameters.explicitFollowing !== undefined) {
        queryParameters['explicit_following'] = requestParameters.explicitFollowing;
    }


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/following`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserFollowingGet200ResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get a list of who a certain user follows.
* List following
*/
export function userFollowingGet<T>(requestParameters: UserFollowingGetRequest, requestConfig?: runtime.TypedQueryConfig<T, UserFollowingGet200Response>): QueryConfig<T> {
    return userFollowingGetRaw(requestParameters, requestConfig);
}

/**
 * Get user websites, claimed or not
 * Get user websites
 */
function userWebsitesGetRaw<T>(requestParameters: UserWebsitesGetRequest, requestConfig: runtime.TypedQueryConfig<T, UserWebsitesGet200Response> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.bookmark !== undefined) {
        queryParameters['bookmark'] = requestParameters.bookmark;
    }


    if (requestParameters.pageSize !== undefined) {
        queryParameters['page_size'] = requestParameters.pageSize;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/websites`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserWebsitesGet200ResponseFromJSON(body), text);
    }

    return config;
}

/**
* Get user websites, claimed or not
* Get user websites
*/
export function userWebsitesGet<T>(requestParameters: UserWebsitesGetRequest, requestConfig?: runtime.TypedQueryConfig<T, UserWebsitesGet200Response>): QueryConfig<T> {
    return userWebsitesGetRaw(requestParameters, requestConfig);
}

/**
 * Verify a website as a signed-in user.
 * Verify website
 */
function verifyWebsiteUpdateRaw<T>(requestParameters: VerifyWebsiteUpdateRequest, requestConfig: runtime.TypedQueryConfig<T, UserWebsiteSummary> = {}): QueryConfig<T> {
    if (requestParameters.userWebsiteVerifyRequest === null || requestParameters.userWebsiteVerifyRequest === undefined) {
        throw new runtime.RequiredError('userWebsiteVerifyRequest','Required parameter requestParameters.userWebsiteVerifyRequest was null or undefined when calling verifyWebsiteUpdate.');
    }

    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};

    headerParameters['Content-Type'] = 'application/json';


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:write"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/websites`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'POST',
            headers: headerParameters,
        },
        body: queryParameters || UserWebsiteVerifyRequestToJSON(requestParameters.userWebsiteVerifyRequest),
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserWebsiteSummaryFromJSON(body), text);
    }

    return config;
}

/**
* Verify a website as a signed-in user.
* Verify website
*/
export function verifyWebsiteUpdate<T>(requestParameters: VerifyWebsiteUpdateRequest, requestConfig?: runtime.TypedQueryConfig<T, UserWebsiteSummary>): QueryConfig<T> {
    return verifyWebsiteUpdateRaw(requestParameters, requestConfig);
}

/**
 * Get verification code for user to install on the website to claim it.
 * Get user verification code for website claiming
 */
function websiteVerificationGetRaw<T>(requestParameters: WebsiteVerificationGetRequest, requestConfig: runtime.TypedQueryConfig<T, UserWebsiteVerificationCode> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.adAccountId !== undefined) {
        queryParameters['ad_account_id'] = requestParameters.adAccountId;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['oauth', ["user_accounts:read"]];
    meta.authType = ['oauth', ["user_accounts:read"]];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/user_account/websites/verification`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(UserWebsiteVerificationCodeFromJSON(body), text);
    }

    return config;
}

/**
* Get verification code for user to install on the website to claim it.
* Get user verification code for website claiming
*/
export function websiteVerificationGet<T>(requestParameters: WebsiteVerificationGetRequest, requestConfig?: runtime.TypedQueryConfig<T, UserWebsiteVerificationCode>): QueryConfig<T> {
    return websiteVerificationGetRaw(requestParameters, requestConfig);
}


/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsFromClaimedContentEnum {
    Other = 'OTHER',
    Claimed = 'CLAIMED',
    Both = 'BOTH'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsPinFormatEnum {
    All = 'ALL',
    OrganicImage = 'ORGANIC_IMAGE',
    OrganicProduct = 'ORGANIC_PRODUCT',
    OrganicVideo = 'ORGANIC_VIDEO',
    AdsStandard = 'ADS_STANDARD',
    AdsProduct = 'ADS_PRODUCT',
    AdsVideo = 'ADS_VIDEO',
    AdsIdea = 'ADS_IDEA'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsAppTypesEnum {
    All = 'ALL',
    Mobile = 'MOBILE',
    Tablet = 'TABLET',
    Web = 'WEB'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsContentTypeEnum {
    All = 'ALL',
    Paid = 'PAID',
    Organic = 'ORGANIC'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsSourceEnum {
    All = 'ALL',
    YourPins = 'YOUR_PINS',
    OtherPins = 'OTHER_PINS'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsMetricTypesEnum {
    Engagement = 'ENGAGEMENT',
    EngagementRate = 'ENGAGEMENT_RATE',
    Impression = 'IMPRESSION',
    OutboundClick = 'OUTBOUND_CLICK',
    OutboundClickRate = 'OUTBOUND_CLICK_RATE',
    PinClick = 'PIN_CLICK',
    PinClickRate = 'PIN_CLICK_RATE',
    Save = 'SAVE',
    SaveRate = 'SAVE_RATE'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsSplitFieldEnum {
    NoSplit = 'NO_SPLIT',
    AppType = 'APP_TYPE',
    OwnedContent = 'OWNED_CONTENT',
    Source = 'SOURCE',
    PinFormat = 'PIN_FORMAT'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsSortByEnum {
    Engagement = 'ENGAGEMENT',
    Impression = 'IMPRESSION',
    OutboundClick = 'OUTBOUND_CLICK',
    PinClick = 'PIN_CLICK',
    Save = 'SAVE'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsFromClaimedContentEnum {
    Other = 'OTHER',
    Claimed = 'CLAIMED',
    Both = 'BOTH'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsPinFormatEnum {
    All = 'ALL',
    OrganicImage = 'ORGANIC_IMAGE',
    OrganicProduct = 'ORGANIC_PRODUCT',
    OrganicVideo = 'ORGANIC_VIDEO',
    AdsStandard = 'ADS_STANDARD',
    AdsProduct = 'ADS_PRODUCT',
    AdsVideo = 'ADS_VIDEO',
    AdsIdea = 'ADS_IDEA'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsAppTypesEnum {
    All = 'ALL',
    Mobile = 'MOBILE',
    Tablet = 'TABLET',
    Web = 'WEB'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsContentTypeEnum {
    All = 'ALL',
    Paid = 'PAID',
    Organic = 'ORGANIC'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsSourceEnum {
    All = 'ALL',
    YourPins = 'YOUR_PINS',
    OtherPins = 'OTHER_PINS'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsMetricTypesEnum {
    Engagement = 'ENGAGEMENT',
    EngagementRate = 'ENGAGEMENT_RATE',
    Impression = 'IMPRESSION',
    OutboundClick = 'OUTBOUND_CLICK',
    OutboundClickRate = 'OUTBOUND_CLICK_RATE',
    PinClick = 'PIN_CLICK',
    PinClickRate = 'PIN_CLICK_RATE',
    Save = 'SAVE',
    SaveRate = 'SAVE_RATE'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum {
    NUMBER_30 = 30
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsSortByEnum {
    Impression = 'IMPRESSION',
    Save = 'SAVE',
    OutboundClick = 'OUTBOUND_CLICK',
    VideoMrcView = 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime = 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime = 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView = 'QUARTILE_95_PERCENT_VIEW',
    Video10SView = 'VIDEO_10S_VIEW',
    VideoStart = 'VIDEO_START'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum {
    Other = 'OTHER',
    Claimed = 'CLAIMED',
    Both = 'BOTH'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsPinFormatEnum {
    All = 'ALL',
    OrganicImage = 'ORGANIC_IMAGE',
    OrganicProduct = 'ORGANIC_PRODUCT',
    OrganicVideo = 'ORGANIC_VIDEO',
    AdsStandard = 'ADS_STANDARD',
    AdsProduct = 'ADS_PRODUCT',
    AdsVideo = 'ADS_VIDEO',
    AdsIdea = 'ADS_IDEA'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsAppTypesEnum {
    All = 'ALL',
    Mobile = 'MOBILE',
    Tablet = 'TABLET',
    Web = 'WEB'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsContentTypeEnum {
    All = 'ALL',
    Paid = 'PAID',
    Organic = 'ORGANIC'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsSourceEnum {
    All = 'ALL',
    YourPins = 'YOUR_PINS',
    OtherPins = 'OTHER_PINS'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsMetricTypesEnum {
    Impression = 'IMPRESSION',
    Save = 'SAVE',
    VideoMrcView = 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime = 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime = 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView = 'QUARTILE_95_PERCENT_VIEW',
    Video10SView = 'VIDEO_10S_VIEW',
    VideoStart = 'VIDEO_START',
    OutboundClick = 'OUTBOUND_CLICK'
}
/**
    * @export
    * @enum {string}
    */
export enum UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum {
    NUMBER_30 = 30
}
