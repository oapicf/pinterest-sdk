// tslint:disable
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI, COLLECTION_FORMATS } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    Account,
    AnalyticsMetricsResponse,
    BoardsUserFollowsList200Response,
    FollowUserRequest,
    FollowersList200Response,
    LinkedBusiness,
    TopPinsAnalyticsResponse,
    TopVideoPinsAnalyticsResponse,
    UserAccountFollowedInterests200Response,
    UserFollowingFeedType,
    UserFollowingGet200Response,
    UserSummary,
    UserWebsiteSummary,
    UserWebsiteVerificationCode,
    UserWebsiteVerifyRequest,
    UserWebsitesGet200Response,
} from '../models';

export interface BoardsUserFollowsListRequest {
    bookmark?: string;
    pageSize?: number;
    explicitFollowing?: boolean;
    adAccountId?: string;
}

export interface FollowUserUpdateRequest {
    username: string;
    followUserRequest: FollowUserRequest;
}

export interface FollowersListRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface UnverifyWebsiteDeleteRequest {
    website: string;
}

export interface UserAccountAnalyticsRequest {
    startDate: string;
    endDate: string;
    fromClaimedContent?: UserAccountAnalyticsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsPinFormatEnum;
    appTypes?: UserAccountAnalyticsAppTypesEnum;
    contentType?: UserAccountAnalyticsContentTypeEnum;
    source?: UserAccountAnalyticsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsMetricTypesEnum>;
    splitField?: UserAccountAnalyticsSplitFieldEnum;
    adAccountId?: string;
}

export interface UserAccountAnalyticsTopPinsRequest {
    startDate: string;
    endDate: string;
    sortBy: UserAccountAnalyticsTopPinsSortByEnum;
    fromClaimedContent?: UserAccountAnalyticsTopPinsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsTopPinsPinFormatEnum;
    appTypes?: UserAccountAnalyticsTopPinsAppTypesEnum;
    contentType?: UserAccountAnalyticsTopPinsContentTypeEnum;
    source?: UserAccountAnalyticsTopPinsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsTopPinsMetricTypesEnum>;
    numOfPins?: number;
    createdInLastNDays?: UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum;
    adAccountId?: string;
}

export interface UserAccountAnalyticsTopVideoPinsRequest {
    startDate: string;
    endDate: string;
    sortBy: UserAccountAnalyticsTopVideoPinsSortByEnum;
    fromClaimedContent?: UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum;
    pinFormat?: UserAccountAnalyticsTopVideoPinsPinFormatEnum;
    appTypes?: UserAccountAnalyticsTopVideoPinsAppTypesEnum;
    contentType?: UserAccountAnalyticsTopVideoPinsContentTypeEnum;
    source?: UserAccountAnalyticsTopVideoPinsSourceEnum;
    metricTypes?: Array<UserAccountAnalyticsTopVideoPinsMetricTypesEnum>;
    numOfPins?: number;
    createdInLastNDays?: UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum;
    adAccountId?: string;
}

export interface UserAccountFollowedInterestsRequest {
    username: string;
    bookmark?: string;
    pageSize?: number;
}

export interface UserAccountGetRequest {
    adAccountId?: string;
}

export interface UserFollowingGetRequest {
    bookmark?: string;
    pageSize?: number;
    feedType?: UserFollowingFeedType;
    explicitFollowing?: boolean;
    adAccountId?: string;
}

export interface UserWebsitesGetRequest {
    bookmark?: string;
    pageSize?: number;
}

export interface VerifyWebsiteUpdateRequest {
    userWebsiteVerifyRequest: UserWebsiteVerifyRequest;
    adAccountId?: string;
}

export interface WebsiteVerificationGetRequest {
    adAccountId?: string;
}

/**
 * no description
 */
export class UserAccountApi extends BaseAPI {

    /**
     * Get a list of the boards a user follows. The request returns a board summary object array.
     * List following boards
     */
    boardsUserFollowsList({ bookmark, pageSize, explicitFollowing, adAccountId }: BoardsUserFollowsListRequest): Observable<BoardsUserFollowsList200Response>
    boardsUserFollowsList({ bookmark, pageSize, explicitFollowing, adAccountId }: BoardsUserFollowsListRequest, opts?: OperationOpts): Observable<AjaxResponse<BoardsUserFollowsList200Response>>
    boardsUserFollowsList({ bookmark, pageSize, explicitFollowing, adAccountId }: BoardsUserFollowsListRequest, opts?: OperationOpts): Observable<BoardsUserFollowsList200Response | AjaxResponse<BoardsUserFollowsList200Response>> {

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (bookmark != null) { query['bookmark'] = bookmark; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (explicitFollowing != null) { query['explicit_following'] = explicitFollowing; }
        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<BoardsUserFollowsList200Response>({
            url: '/user_account/following/boards',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * <strong>This endpoint is currently in beta and not available to all apps. <a href=\'/docs/getting-started/beta-and-advanced-access/\'>Learn more</a>.</strong>  Use this request, as a signed-in user, to follow another user.
     * Follow user
     */
    followUserUpdate({ username, followUserRequest }: FollowUserUpdateRequest): Observable<UserSummary>
    followUserUpdate({ username, followUserRequest }: FollowUserUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserSummary>>
    followUserUpdate({ username, followUserRequest }: FollowUserUpdateRequest, opts?: OperationOpts): Observable<UserSummary | AjaxResponse<UserSummary>> {
        throwIfNullOrUndefined(username, 'username', 'followUserUpdate');
        throwIfNullOrUndefined(followUserRequest, 'followUserRequest', 'followUserUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:write'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        return this.request<UserSummary>({
            url: '/user_account/following/{username}'.replace('{username}', encodeURI(username)),
            method: 'POST',
            headers,
            body: followUserRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of your followers.
     * List followers
     */
    followersList({ bookmark, pageSize }: FollowersListRequest): Observable<FollowersList200Response>
    followersList({ bookmark, pageSize }: FollowersListRequest, opts?: OperationOpts): Observable<AjaxResponse<FollowersList200Response>>
    followersList({ bookmark, pageSize }: FollowersListRequest, opts?: OperationOpts): Observable<FollowersList200Response | AjaxResponse<FollowersList200Response>> {

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (bookmark != null) { query['bookmark'] = bookmark; }
        if (pageSize != null) { query['page_size'] = pageSize; }

        return this.request<FollowersList200Response>({
            url: '/user_account/followers',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of your linked business accounts.
     * List linked businesses
     */
    linkedBusinessAccountsGet(): Observable<Array<LinkedBusiness>>
    linkedBusinessAccountsGet(opts?: OperationOpts): Observable<AjaxResponse<Array<LinkedBusiness>>>
    linkedBusinessAccountsGet(opts?: OperationOpts): Observable<Array<LinkedBusiness> | AjaxResponse<Array<LinkedBusiness>>> {
        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        return this.request<Array<LinkedBusiness>>({
            url: '/user_account/businesses',
            method: 'GET',
            headers,
        }, opts?.responseOpts);
    };

    /**
     * Unverifu a website verified by the signed-in user.
     * Unverify website
     */
    unverifyWebsiteDelete({ website }: UnverifyWebsiteDeleteRequest): Observable<void>
    unverifyWebsiteDelete({ website }: UnverifyWebsiteDeleteRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>>
    unverifyWebsiteDelete({ website }: UnverifyWebsiteDeleteRequest, opts?: OperationOpts): Observable<void | AjaxResponse<void>> {
        throwIfNullOrUndefined(website, 'website', 'unverifyWebsiteDelete');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:write'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'website': website,
        };

        return this.request<void>({
            url: '/user_account/websites',
            method: 'DELETE',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get analytics for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account analytics
     */
    userAccountAnalytics({ startDate, endDate, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, splitField, adAccountId }: UserAccountAnalyticsRequest): Observable<{ [key: string]: AnalyticsMetricsResponse; }>
    userAccountAnalytics({ startDate, endDate, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, splitField, adAccountId }: UserAccountAnalyticsRequest, opts?: OperationOpts): Observable<AjaxResponse<{ [key: string]: AnalyticsMetricsResponse; }>>
    userAccountAnalytics({ startDate, endDate, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, splitField, adAccountId }: UserAccountAnalyticsRequest, opts?: OperationOpts): Observable<{ [key: string]: AnalyticsMetricsResponse; } | AjaxResponse<{ [key: string]: AnalyticsMetricsResponse; }>> {
        throwIfNullOrUndefined(startDate, 'startDate', 'userAccountAnalytics');
        throwIfNullOrUndefined(endDate, 'endDate', 'userAccountAnalytics');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_date': (startDate as any).toISOString().split('T')[0],
            'end_date': (endDate as any).toISOString().split('T')[0],
        };

        if (fromClaimedContent != null) { query['from_claimed_content'] = fromClaimedContent; }
        if (pinFormat != null) { query['pin_format'] = pinFormat; }
        if (appTypes != null) { query['app_types'] = appTypes; }
        if (contentType != null) { query['content_type'] = contentType; }
        if (source != null) { query['source'] = source; }
        if (metricTypes != null) { query['metric_types'] = metricTypes.join(COLLECTION_FORMATS['csv']); }
        if (splitField != null) { query['split_field'] = splitField; }
        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<{ [key: string]: AnalyticsMetricsResponse; }>({
            url: '/user_account/analytics',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Gets analytics data about a user\'s top pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account top pins analytics
     */
    userAccountAnalyticsTopPins({ startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId }: UserAccountAnalyticsTopPinsRequest): Observable<TopPinsAnalyticsResponse>
    userAccountAnalyticsTopPins({ startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId }: UserAccountAnalyticsTopPinsRequest, opts?: OperationOpts): Observable<AjaxResponse<TopPinsAnalyticsResponse>>
    userAccountAnalyticsTopPins({ startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId }: UserAccountAnalyticsTopPinsRequest, opts?: OperationOpts): Observable<TopPinsAnalyticsResponse | AjaxResponse<TopPinsAnalyticsResponse>> {
        throwIfNullOrUndefined(startDate, 'startDate', 'userAccountAnalyticsTopPins');
        throwIfNullOrUndefined(endDate, 'endDate', 'userAccountAnalyticsTopPins');
        throwIfNullOrUndefined(sortBy, 'sortBy', 'userAccountAnalyticsTopPins');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['pins:read', 'user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['pins:read', 'user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_date': (startDate as any).toISOString().split('T')[0],
            'end_date': (endDate as any).toISOString().split('T')[0],
            'sort_by': sortBy,
        };

        if (fromClaimedContent != null) { query['from_claimed_content'] = fromClaimedContent; }
        if (pinFormat != null) { query['pin_format'] = pinFormat; }
        if (appTypes != null) { query['app_types'] = appTypes; }
        if (contentType != null) { query['content_type'] = contentType; }
        if (source != null) { query['source'] = source; }
        if (metricTypes != null) { query['metric_types'] = metricTypes.join(COLLECTION_FORMATS['csv']); }
        if (numOfPins != null) { query['num_of_pins'] = numOfPins; }
        if (createdInLastNDays != null) { query['created_in_last_n_days'] = createdInLastNDays; }
        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<TopPinsAnalyticsResponse>({
            url: '/user_account/analytics/top_pins',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Gets analytics data about a user\'s top video pins (limited to the top 50). - By default, the \"operation user_account\" is the token user_account.  Optional: Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\".
     * Get user account top video pins analytics
     */
    userAccountAnalyticsTopVideoPins({ startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId }: UserAccountAnalyticsTopVideoPinsRequest): Observable<TopVideoPinsAnalyticsResponse>
    userAccountAnalyticsTopVideoPins({ startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId }: UserAccountAnalyticsTopVideoPinsRequest, opts?: OperationOpts): Observable<AjaxResponse<TopVideoPinsAnalyticsResponse>>
    userAccountAnalyticsTopVideoPins({ startDate, endDate, sortBy, fromClaimedContent, pinFormat, appTypes, contentType, source, metricTypes, numOfPins, createdInLastNDays, adAccountId }: UserAccountAnalyticsTopVideoPinsRequest, opts?: OperationOpts): Observable<TopVideoPinsAnalyticsResponse | AjaxResponse<TopVideoPinsAnalyticsResponse>> {
        throwIfNullOrUndefined(startDate, 'startDate', 'userAccountAnalyticsTopVideoPins');
        throwIfNullOrUndefined(endDate, 'endDate', 'userAccountAnalyticsTopVideoPins');
        throwIfNullOrUndefined(sortBy, 'sortBy', 'userAccountAnalyticsTopVideoPins');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['pins:read', 'user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['pins:read', 'user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'start_date': (startDate as any).toISOString().split('T')[0],
            'end_date': (endDate as any).toISOString().split('T')[0],
            'sort_by': sortBy,
        };

        if (fromClaimedContent != null) { query['from_claimed_content'] = fromClaimedContent; }
        if (pinFormat != null) { query['pin_format'] = pinFormat; }
        if (appTypes != null) { query['app_types'] = appTypes; }
        if (contentType != null) { query['content_type'] = contentType; }
        if (source != null) { query['source'] = source; }
        if (metricTypes != null) { query['metric_types'] = metricTypes.join(COLLECTION_FORMATS['csv']); }
        if (numOfPins != null) { query['num_of_pins'] = numOfPins; }
        if (createdInLastNDays != null) { query['created_in_last_n_days'] = createdInLastNDays; }
        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<TopVideoPinsAnalyticsResponse>({
            url: '/user_account/analytics/top_video_pins',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of a user\'s following interests in one place.
     * List following interests
     */
    userAccountFollowedInterests({ username, bookmark, pageSize }: UserAccountFollowedInterestsRequest): Observable<UserAccountFollowedInterests200Response>
    userAccountFollowedInterests({ username, bookmark, pageSize }: UserAccountFollowedInterestsRequest, opts?: OperationOpts): Observable<AjaxResponse<UserAccountFollowedInterests200Response>>
    userAccountFollowedInterests({ username, bookmark, pageSize }: UserAccountFollowedInterestsRequest, opts?: OperationOpts): Observable<UserAccountFollowedInterests200Response | AjaxResponse<UserAccountFollowedInterests200Response>> {
        throwIfNullOrUndefined(username, 'username', 'userAccountFollowedInterests');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (bookmark != null) { query['bookmark'] = bookmark; }
        if (pageSize != null) { query['page_size'] = pageSize; }

        return this.request<UserAccountFollowedInterests200Response>({
            url: '/users/{username}/interests/follow'.replace('{username}', encodeURI(username)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get account information for the \"operation user_account\" - By default, the \"operation user_account\" is the token user_account.  If using Business Access: Specify an ad_account_id to use the owner of that ad_account as the \"operation user_account\". See <a href=\'/docs/getting-started/using-business-access/\'>Understanding Business Access</a> for more information.
     * Get user account
     */
    userAccountGet({ adAccountId }: UserAccountGetRequest): Observable<Account>
    userAccountGet({ adAccountId }: UserAccountGetRequest, opts?: OperationOpts): Observable<AjaxResponse<Account>>
    userAccountGet({ adAccountId }: UserAccountGetRequest, opts?: OperationOpts): Observable<Account | AjaxResponse<Account>> {

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<Account>({
            url: '/user_account',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get a list of who a certain user follows.
     * List following
     */
    userFollowingGet({ bookmark, pageSize, feedType, explicitFollowing, adAccountId }: UserFollowingGetRequest): Observable<UserFollowingGet200Response>
    userFollowingGet({ bookmark, pageSize, feedType, explicitFollowing, adAccountId }: UserFollowingGetRequest, opts?: OperationOpts): Observable<AjaxResponse<UserFollowingGet200Response>>
    userFollowingGet({ bookmark, pageSize, feedType, explicitFollowing, adAccountId }: UserFollowingGetRequest, opts?: OperationOpts): Observable<UserFollowingGet200Response | AjaxResponse<UserFollowingGet200Response>> {

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (bookmark != null) { query['bookmark'] = bookmark; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (feedType != null) { query['feed_type'] = feedType; }
        if (explicitFollowing != null) { query['explicit_following'] = explicitFollowing; }
        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<UserFollowingGet200Response>({
            url: '/user_account/following',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Get user websites, claimed or not
     * Get user websites
     */
    userWebsitesGet({ bookmark, pageSize }: UserWebsitesGetRequest): Observable<UserWebsitesGet200Response>
    userWebsitesGet({ bookmark, pageSize }: UserWebsitesGetRequest, opts?: OperationOpts): Observable<AjaxResponse<UserWebsitesGet200Response>>
    userWebsitesGet({ bookmark, pageSize }: UserWebsitesGetRequest, opts?: OperationOpts): Observable<UserWebsitesGet200Response | AjaxResponse<UserWebsitesGet200Response>> {

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (bookmark != null) { query['bookmark'] = bookmark; }
        if (pageSize != null) { query['page_size'] = pageSize; }

        return this.request<UserWebsitesGet200Response>({
            url: '/user_account/websites',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * Verify a website as a signed-in user.
     * Verify website
     */
    verifyWebsiteUpdate({ userWebsiteVerifyRequest, adAccountId }: VerifyWebsiteUpdateRequest): Observable<UserWebsiteSummary>
    verifyWebsiteUpdate({ userWebsiteVerifyRequest, adAccountId }: VerifyWebsiteUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<UserWebsiteSummary>>
    verifyWebsiteUpdate({ userWebsiteVerifyRequest, adAccountId }: VerifyWebsiteUpdateRequest, opts?: OperationOpts): Observable<UserWebsiteSummary | AjaxResponse<UserWebsiteSummary>> {
        throwIfNullOrUndefined(userWebsiteVerifyRequest, 'userWebsiteVerifyRequest', 'verifyWebsiteUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:write'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<UserWebsiteSummary>({
            url: '/user_account/websites',
            method: 'POST',
            headers,
            query,
            body: userWebsiteVerifyRequest,
        }, opts?.responseOpts);
    };

    /**
     * Get verification code for user to install on the website to claim it.
     * Get user verification code for website claiming
     */
    websiteVerificationGet({ adAccountId }: WebsiteVerificationGetRequest): Observable<UserWebsiteVerificationCode>
    websiteVerificationGet({ adAccountId }: WebsiteVerificationGetRequest, opts?: OperationOpts): Observable<AjaxResponse<UserWebsiteVerificationCode>>
    websiteVerificationGet({ adAccountId }: WebsiteVerificationGetRequest, opts?: OperationOpts): Observable<UserWebsiteVerificationCode | AjaxResponse<UserWebsiteVerificationCode>> {

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('client_credentials', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (adAccountId != null) { query['ad_account_id'] = adAccountId; }

        return this.request<UserWebsiteVerificationCode>({
            url: '/user_account/websites/verification',
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsFromClaimedContentEnum {
    Other = 'OTHER',
    Claimed = 'CLAIMED',
    Both = 'BOTH'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsPinFormatEnum {
    All = 'ALL',
    OrganicImage = 'ORGANIC_IMAGE',
    OrganicProduct = 'ORGANIC_PRODUCT',
    OrganicVideo = 'ORGANIC_VIDEO',
    AdsStandard = 'ADS_STANDARD',
    AdsProduct = 'ADS_PRODUCT',
    AdsVideo = 'ADS_VIDEO',
    AdsIdea = 'ADS_IDEA'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsAppTypesEnum {
    All = 'ALL',
    Mobile = 'MOBILE',
    Tablet = 'TABLET',
    Web = 'WEB'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsContentTypeEnum {
    All = 'ALL',
    Paid = 'PAID',
    Organic = 'ORGANIC'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsSourceEnum {
    All = 'ALL',
    YourPins = 'YOUR_PINS',
    OtherPins = 'OTHER_PINS'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsMetricTypesEnum {
    Engagement = 'ENGAGEMENT',
    EngagementRate = 'ENGAGEMENT_RATE',
    Impression = 'IMPRESSION',
    OutboundClick = 'OUTBOUND_CLICK',
    OutboundClickRate = 'OUTBOUND_CLICK_RATE',
    PinClick = 'PIN_CLICK',
    PinClickRate = 'PIN_CLICK_RATE',
    Save = 'SAVE',
    SaveRate = 'SAVE_RATE'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsSplitFieldEnum {
    NoSplit = 'NO_SPLIT',
    AppType = 'APP_TYPE',
    OwnedContent = 'OWNED_CONTENT',
    Source = 'SOURCE',
    PinFormat = 'PIN_FORMAT'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsSortByEnum {
    Engagement = 'ENGAGEMENT',
    Impression = 'IMPRESSION',
    OutboundClick = 'OUTBOUND_CLICK',
    PinClick = 'PIN_CLICK',
    Save = 'SAVE'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsFromClaimedContentEnum {
    Other = 'OTHER',
    Claimed = 'CLAIMED',
    Both = 'BOTH'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsPinFormatEnum {
    All = 'ALL',
    OrganicImage = 'ORGANIC_IMAGE',
    OrganicProduct = 'ORGANIC_PRODUCT',
    OrganicVideo = 'ORGANIC_VIDEO',
    AdsStandard = 'ADS_STANDARD',
    AdsProduct = 'ADS_PRODUCT',
    AdsVideo = 'ADS_VIDEO',
    AdsIdea = 'ADS_IDEA'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsAppTypesEnum {
    All = 'ALL',
    Mobile = 'MOBILE',
    Tablet = 'TABLET',
    Web = 'WEB'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsContentTypeEnum {
    All = 'ALL',
    Paid = 'PAID',
    Organic = 'ORGANIC'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsSourceEnum {
    All = 'ALL',
    YourPins = 'YOUR_PINS',
    OtherPins = 'OTHER_PINS'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsMetricTypesEnum {
    Engagement = 'ENGAGEMENT',
    EngagementRate = 'ENGAGEMENT_RATE',
    Impression = 'IMPRESSION',
    OutboundClick = 'OUTBOUND_CLICK',
    OutboundClickRate = 'OUTBOUND_CLICK_RATE',
    PinClick = 'PIN_CLICK',
    PinClickRate = 'PIN_CLICK_RATE',
    Save = 'SAVE',
    SaveRate = 'SAVE_RATE'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopPinsCreatedInLastNDaysEnum {
    NUMBER_30 = 30
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsSortByEnum {
    Impression = 'IMPRESSION',
    Save = 'SAVE',
    OutboundClick = 'OUTBOUND_CLICK',
    VideoMrcView = 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime = 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime = 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView = 'QUARTILE_95_PERCENT_VIEW',
    Video10SView = 'VIDEO_10S_VIEW',
    VideoStart = 'VIDEO_START'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsFromClaimedContentEnum {
    Other = 'OTHER',
    Claimed = 'CLAIMED',
    Both = 'BOTH'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsPinFormatEnum {
    All = 'ALL',
    OrganicImage = 'ORGANIC_IMAGE',
    OrganicProduct = 'ORGANIC_PRODUCT',
    OrganicVideo = 'ORGANIC_VIDEO',
    AdsStandard = 'ADS_STANDARD',
    AdsProduct = 'ADS_PRODUCT',
    AdsVideo = 'ADS_VIDEO',
    AdsIdea = 'ADS_IDEA'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsAppTypesEnum {
    All = 'ALL',
    Mobile = 'MOBILE',
    Tablet = 'TABLET',
    Web = 'WEB'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsContentTypeEnum {
    All = 'ALL',
    Paid = 'PAID',
    Organic = 'ORGANIC'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsSourceEnum {
    All = 'ALL',
    YourPins = 'YOUR_PINS',
    OtherPins = 'OTHER_PINS'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsMetricTypesEnum {
    Impression = 'IMPRESSION',
    Save = 'SAVE',
    VideoMrcView = 'VIDEO_MRC_VIEW',
    VideoAvgWatchTime = 'VIDEO_AVG_WATCH_TIME',
    VideoV50WatchTime = 'VIDEO_V50_WATCH_TIME',
    Quartile95PercentView = 'QUARTILE_95_PERCENT_VIEW',
    Video10SView = 'VIDEO_10S_VIEW',
    VideoStart = 'VIDEO_START',
    OutboundClick = 'OUTBOUND_CLICK'
}
/**
 * @export
 * @enum {string}
 */
export enum UserAccountAnalyticsTopVideoPinsCreatedInLastNDaysEnum {
    NUMBER_30 = 30
}
