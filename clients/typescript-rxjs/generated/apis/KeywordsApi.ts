// tslint:disable
/**
 * Pinterest REST API
 * Pinterest\'s REST API
 *
 * The version of the OpenAPI document: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import type { Observable } from 'rxjs';
import type { AjaxResponse } from 'rxjs/ajax';
import { BaseAPI, throwIfNullOrUndefined, encodeURI, COLLECTION_FORMATS } from '../runtime';
import type { OperationOpts, HttpHeaders, HttpQuery } from '../runtime';
import type {
    KeywordUpdateBody,
    KeywordsGet200Response,
    KeywordsMetricsArrayResponse,
    KeywordsRequest,
    KeywordsResponse,
    MatchType,
    TrendType,
    TrendingKeywordsResponse,
    TrendsSupportedRegion,
} from '../models';

export interface CountryKeywordsMetricsGetRequest {
    adAccountId: string;
    countryCode: string;
    keywords: Array<string>;
}

export interface KeywordsCreateRequest {
    adAccountId: string;
    keywordsRequest: KeywordsRequest;
}

export interface KeywordsGetRequest {
    adAccountId: string;
    campaignId?: string;
    adGroupId?: string;
    matchTypes?: Array<MatchType>;
    pageSize?: number;
    bookmark?: string;
}

export interface KeywordsUpdateRequest {
    adAccountId: string;
    keywordUpdateBody: KeywordUpdateBody;
}

export interface TrendingKeywordsListRequest {
    region: TrendsSupportedRegion;
    trendType: TrendType;
    interests?: Array<TrendingKeywordsListInterestsEnum>;
    genders?: Array<TrendingKeywordsListGendersEnum>;
    ages?: Array<TrendingKeywordsListAgesEnum>;
    includeKeywords?: Array<string>;
    normalizeAgainstGroup?: boolean;
    limit?: number;
}

/**
 * no description
 */
export class KeywordsApi extends BaseAPI {

    /**
     * See keyword metrics for a specified country, aggregated across all of Pinterest. (Definitions are available from the \"Get delivery metrics definitions\" <a href=\"/docs/api/v5/#operation/delivery_metrics/get\">API endpoint</a>).
     * Get country\'s keyword metrics
     */
    countryKeywordsMetricsGet({ adAccountId, countryCode, keywords }: CountryKeywordsMetricsGetRequest): Observable<KeywordsMetricsArrayResponse>
    countryKeywordsMetricsGet({ adAccountId, countryCode, keywords }: CountryKeywordsMetricsGetRequest, opts?: OperationOpts): Observable<AjaxResponse<KeywordsMetricsArrayResponse>>
    countryKeywordsMetricsGet({ adAccountId, countryCode, keywords }: CountryKeywordsMetricsGetRequest, opts?: OperationOpts): Observable<KeywordsMetricsArrayResponse | AjaxResponse<KeywordsMetricsArrayResponse>> {
        throwIfNullOrUndefined(adAccountId, 'adAccountId', 'countryKeywordsMetricsGet');
        throwIfNullOrUndefined(countryCode, 'countryCode', 'countryKeywordsMetricsGet');
        throwIfNullOrUndefined(keywords, 'keywords', 'countryKeywordsMetricsGet');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['ads:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = { // required parameters are used directly since they are already checked by throwIfNullOrUndefined
            'country_code': countryCode,
            'keywords': keywords.join(COLLECTION_FORMATS['csv']),
        };

        return this.request<KeywordsMetricsArrayResponse>({
            url: '/ad_accounts/{ad_account_id}/keywords/metrics'.replace('{ad_account_id}', encodeURI(adAccountId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * <p>Create keywords for following entity types(advertiser, campaign, ad group or ad).</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a  target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul> <p><b>Rate limit</b>: <a href=\"/docs/reference/rate-limits/\">WRITE</a>.</p>
     * Create keywords
     */
    keywordsCreate({ adAccountId, keywordsRequest }: KeywordsCreateRequest): Observable<KeywordsResponse>
    keywordsCreate({ adAccountId, keywordsRequest }: KeywordsCreateRequest, opts?: OperationOpts): Observable<AjaxResponse<KeywordsResponse>>
    keywordsCreate({ adAccountId, keywordsRequest }: KeywordsCreateRequest, opts?: OperationOpts): Observable<KeywordsResponse | AjaxResponse<KeywordsResponse>> {
        throwIfNullOrUndefined(adAccountId, 'adAccountId', 'keywordsCreate');
        throwIfNullOrUndefined(keywordsRequest, 'keywordsRequest', 'keywordsCreate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['ads:write'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        return this.request<KeywordsResponse>({
            url: '/ad_accounts/{ad_account_id}/keywords'.replace('{ad_account_id}', encodeURI(adAccountId)),
            method: 'POST',
            headers,
            body: keywordsRequest,
        }, opts?.responseOpts);
    };

    /**
     * <p>Get a list of keywords based on the filters provided. If no filter is provided, it will default to the ad_account_id filter, which means it will only return keywords that specifically have parent_id set to the ad_account_id. Note: Keywords can have ad_account_ids, campaign_ids, and ad_group_ids set as their parent_ids. Keywords created through Ads Manager will have their parent_id set to an ad_group_id, not ad_account_id.</p> <p>For more information, see <a target=\"_blank\" href=\"https://help.pinterest.com/en/business/article/keyword-targeting\">Keyword targeting</a>.</p> <p><b>Notes:</b></p> <ul style=\"list-style-type: square;\"> <li>Advertisers and campaigns can only be assigned keywords with excluding (\'_NEGATIVE\').</li> <li>All keyword match types are available for ad groups.</li> </ul> <p>For more information on match types, see <a target=\"_blank\" href=\"/docs/api-features/targeting-overview/\">match type enums</a>.</p> <p><b>Returns:</b></p> <ul style=\"list-style-type: square;\"> <li><p>A successful call returns an object containing an array of new keyword objects and an empty &quot;errors&quot; object array.</p></li> <li><p>An unsuccessful call returns an empty keywords array, and, instead, inserts the entire object with nulled/negated properties into the &quot;errors&quot; object array:</p> <pre class=\"last literal-block\"> { \"keywords\": [], \"errors\": [ { \"data\": { \"archived\": null, \"match_type\": \"EXACT\", \"parent_type\": null, \"value\": \"foobar\", \"parent_id\": null, \"type\": \"keyword\", \"id\": null }, \"error_messages\": [ \"Advertisers and Campaigns only accept excluded targeting attributes.\" ] } } </pre></li> </ul>
     * Get keywords
     */
    keywordsGet({ adAccountId, campaignId, adGroupId, matchTypes, pageSize, bookmark }: KeywordsGetRequest): Observable<KeywordsGet200Response>
    keywordsGet({ adAccountId, campaignId, adGroupId, matchTypes, pageSize, bookmark }: KeywordsGetRequest, opts?: OperationOpts): Observable<AjaxResponse<KeywordsGet200Response>>
    keywordsGet({ adAccountId, campaignId, adGroupId, matchTypes, pageSize, bookmark }: KeywordsGetRequest, opts?: OperationOpts): Observable<KeywordsGet200Response | AjaxResponse<KeywordsGet200Response>> {
        throwIfNullOrUndefined(adAccountId, 'adAccountId', 'keywordsGet');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['ads:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (campaignId != null) { query['campaign_id'] = campaignId; }
        if (adGroupId != null) { query['ad_group_id'] = adGroupId; }
        if (matchTypes != null) { query['match_types'] = matchTypes; }
        if (pageSize != null) { query['page_size'] = pageSize; }
        if (bookmark != null) { query['bookmark'] = bookmark; }

        return this.request<KeywordsGet200Response>({
            url: '/ad_accounts/{ad_account_id}/keywords'.replace('{ad_account_id}', encodeURI(adAccountId)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

    /**
     * <p>Update one or more keywords\' bid and archived fields.</p> <p>Archiving a keyword effectively deletes it - keywords no longer receive metrics and no longer visible within the parent entity\'s keywords list.</p>
     * Update keywords
     */
    keywordsUpdate({ adAccountId, keywordUpdateBody }: KeywordsUpdateRequest): Observable<KeywordsResponse>
    keywordsUpdate({ adAccountId, keywordUpdateBody }: KeywordsUpdateRequest, opts?: OperationOpts): Observable<AjaxResponse<KeywordsResponse>>
    keywordsUpdate({ adAccountId, keywordUpdateBody }: KeywordsUpdateRequest, opts?: OperationOpts): Observable<KeywordsResponse | AjaxResponse<KeywordsResponse>> {
        throwIfNullOrUndefined(adAccountId, 'adAccountId', 'keywordsUpdate');
        throwIfNullOrUndefined(keywordUpdateBody, 'keywordUpdateBody', 'keywordsUpdate');

        const headers: HttpHeaders = {
            'Content-Type': 'application/json',
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['ads:write'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        return this.request<KeywordsResponse>({
            url: '/ad_accounts/{ad_account_id}/keywords'.replace('{ad_account_id}', encodeURI(adAccountId)),
            method: 'PATCH',
            headers,
            body: keywordUpdateBody,
        }, opts?.responseOpts);
    };

    /**
     * <p>Get the top trending search keywords among the Pinterest user audience.</p> <p>Trending keywords can be used to inform ad targeting, budget strategy, and creative decisions about which products and Pins will resonate with your audience.</p> <p>Geographic, demographic and interest-based filters are available to narrow down to the top trends among a specific audience. Multiple trend types are supported that can be used to identify newly-popular, evergreen or seasonal keywords.</p> <p>For an interactive way to explore this data, please visit <a href=\"https://trends.pinterest.com\">trends.pinterest.com</a>. 
     * List trending keywords
     */
    trendingKeywordsList({ region, trendType, interests, genders, ages, includeKeywords, normalizeAgainstGroup, limit }: TrendingKeywordsListRequest): Observable<TrendingKeywordsResponse>
    trendingKeywordsList({ region, trendType, interests, genders, ages, includeKeywords, normalizeAgainstGroup, limit }: TrendingKeywordsListRequest, opts?: OperationOpts): Observable<AjaxResponse<TrendingKeywordsResponse>>
    trendingKeywordsList({ region, trendType, interests, genders, ages, includeKeywords, normalizeAgainstGroup, limit }: TrendingKeywordsListRequest, opts?: OperationOpts): Observable<TrendingKeywordsResponse | AjaxResponse<TrendingKeywordsResponse>> {
        throwIfNullOrUndefined(region, 'region', 'trendingKeywordsList');
        throwIfNullOrUndefined(trendType, 'trendType', 'trendingKeywordsList');

        const headers: HttpHeaders = {
            // oauth required
            ...(this.configuration.accessToken != null
                ? { Authorization: typeof this.configuration.accessToken === 'function'
                    ? this.configuration.accessToken('pinterest_oauth2', ['user_accounts:read'])
                    : this.configuration.accessToken }
                : undefined
            ),
        };

        const query: HttpQuery = {};

        if (interests != null) { query['interests'] = interests; }
        if (genders != null) { query['genders'] = genders; }
        if (ages != null) { query['ages'] = ages; }
        if (includeKeywords != null) { query['include_keywords'] = includeKeywords; }
        if (normalizeAgainstGroup != null) { query['normalize_against_group'] = normalizeAgainstGroup; }
        if (limit != null) { query['limit'] = limit; }

        return this.request<TrendingKeywordsResponse>({
            url: '/trends/keywords/{region}/top/{trend_type}'.replace('{region}', encodeURI(region)).replace('{trend_type}', encodeURI(trendType)),
            method: 'GET',
            headers,
            query,
        }, opts?.responseOpts);
    };

}

/**
 * @export
 * @enum {string}
 */
export enum TrendingKeywordsListInterestsEnum {
    Animals = 'animals',
    Architecture = 'architecture',
    Art = 'art',
    Beauty = 'beauty',
    ChildrensFashion = 'childrens_fashion',
    Design = 'design',
    DiyAndCrafts = 'diy_and_crafts',
    Education = 'education',
    Electronics = 'electronics',
    Entertainment = 'entertainment',
    EventPlanning = 'event_planning',
    Finance = 'finance',
    FoodAndDrinks = 'food_and_drinks',
    Gardening = 'gardening',
    Health = 'health',
    HomeDecor = 'home_decor',
    MensFashion = 'mens_fashion',
    Parenting = 'parenting',
    Quotes = 'quotes',
    Sport = 'sport',
    Travel = 'travel',
    Vehicles = 'vehicles',
    Wedding = 'wedding',
    WomensFashion = 'womens_fashion'
}
/**
 * @export
 * @enum {string}
 */
export enum TrendingKeywordsListGendersEnum {
    Female = 'female',
    Male = 'male',
    Unknown = 'unknown'
}
/**
 * @export
 * @enum {string}
 */
export enum TrendingKeywordsListAgesEnum {
    _1824 = '18-24',
    _2534 = '25-34',
    _3544 = '35-44',
    _4549 = '45-49',
    _5054 = '50-54',
    _5564 = '55-64',
    _65 = '65+'
}
