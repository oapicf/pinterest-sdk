/**
 * Pinterest REST API
 * Pinterest's REST API
 *
 * OpenAPI spec version: 5.14.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * https://github.com/OpenAPITools/openapi-generator
 * Do not edit the class manually.
 */

#include "OpenAPICatalogsApiOperations.h"

#include "OpenAPIModule.h"
#include "OpenAPIHelpers.h"

#include "Dom/JsonObject.h"
#include "Templates/SharedPointer.h"
#include "HttpModule.h"
#include "PlatformHttp.h"

namespace OpenAPI
{

FString OpenAPICatalogsApi::CatalogsProductGroupPinsListRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("product_group_id"), FStringFormatArg(ToUrlString(ProductGroupId)) } };

	FString Path = FString::Format(TEXT("/catalogs/product_groups/{product_group_id}/products"), PathParams);

	TArray<FString> QueryParams;
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	if(PinMetrics.IsSet())
	{
		QueryParams.Add(FString(TEXT("pin_metrics=")) + ToUrlString(PinMetrics.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupPinsListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::CatalogsProductGroupPinsListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 404:
		SetResponseString(TEXT("Catalogs product group not found."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupPinsListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsProductGroupsCreateRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/product_groups"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsCreateRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIMultipleProductGroupsInner);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIMultipleProductGroupsInner) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIMultipleProductGroupsInner) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::CatalogsProductGroupsCreateResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 201:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid body."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t create this catalogs product group with this value."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsCreateResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsProductGroupsCreateManyRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/product_groups/multiple"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsCreateManyRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIMultipleProductGroupsInner);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIMultipleProductGroupsInner) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIMultipleProductGroupsInner) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::CatalogsProductGroupsCreateManyResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 201:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid body."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t create this catalogs product group with this value."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsCreateManyResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsProductGroupsDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("product_group_id"), FStringFormatArg(ToUrlString(ProductGroupId)) } };

	FString Path = FString::Format(TEXT("/catalogs/product_groups/{product_group_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPICatalogsApi::CatalogsProductGroupsDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Catalogs Product Group deleted successfully."));
		break;
	case 400:
		SetResponseString(TEXT("Invalid catalogs product group id parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Catalogs product group not found."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t delete this catalogs product group."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPICatalogsApi::CatalogsProductGroupsDeleteManyRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/product_groups/multiple"));
	TArray<FString> QueryParams;
	QueryParams.Add(FString(TEXT("id=")) + CollectionToUrlString_csv(Id, TEXT("id")));
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsDeleteManyRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPICatalogsApi::CatalogsProductGroupsDeleteManyResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Catalogs Product Groups deleted successfully."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Catalogs product group not found."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t delete this catalogs product group."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsDeleteManyResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPICatalogsApi::CatalogsProductGroupsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("product_group_id"), FStringFormatArg(ToUrlString(ProductGroupId)) } };

	FString Path = FString::Format(TEXT("/catalogs/product_groups/{product_group_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::CatalogsProductGroupsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid catalogs product group id parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Catalogs product group not found."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t get a catalogs product group without an existing catalog."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsProductGroupsListRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/product_groups"));
	TArray<FString> QueryParams;
	if(Id.IsSet())
	{
		QueryParams.Add(FString(TEXT("id=")) + CollectionToUrlString_csv(Id.GetValue(), TEXT("id")));
	}
	if(FeedId.IsSet())
	{
		QueryParams.Add(FString(TEXT("feed_id=")) + ToUrlString(FeedId.GetValue()));
	}
	if(CatalogId.IsSet())
	{
		QueryParams.Add(FString(TEXT("catalog_id=")) + ToUrlString(CatalogId.GetValue()));
	}
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::CatalogsProductGroupsListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid feed parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Data feed not found."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t create this catalogs product group with this value."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsProductGroupsProductCountsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("product_group_id"), FStringFormatArg(ToUrlString(ProductGroupId)) } };

	FString Path = FString::Format(TEXT("/catalogs/product_groups/{product_group_id}/product_counts"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsProductCountsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::CatalogsProductGroupsProductCountsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 404:
		SetResponseString(TEXT("Product Group Not Found."));
		break;
	case 409:
		SetResponseString(TEXT("Can&#39;t access this feature without an existing catalog."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsProductCountsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsProductGroupsUpdateRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("product_group_id"), FStringFormatArg(ToUrlString(ProductGroupId)) } };

	FString Path = FString::Format(TEXT("/catalogs/product_groups/{product_group_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsProductGroupsUpdateRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICatalogsProductGroupsUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsProductGroupsUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsProductGroupsUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::CatalogsProductGroupsUpdateResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for catalog product group mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Catalogs product group not found."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t update this catalogs product group to this value."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsProductGroupsUpdateResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsCreateRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsCreateRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICatalogsCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::CatalogsCreateResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsCreateResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::CatalogsListRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs"));
	TArray<FString> QueryParams;
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::CatalogsListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::CatalogsListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::CatalogsListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::FeedProcessingResultsListRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("feed_id"), FStringFormatArg(ToUrlString(FeedId)) } };

	FString Path = FString::Format(TEXT("/catalogs/feeds/{feed_id}/processing_results"), PathParams);

	TArray<FString> QueryParams;
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedProcessingResultsListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::FeedProcessingResultsListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 404:
		SetResponseString(TEXT("Feed not found."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::FeedProcessingResultsListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::FeedsCreateRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/feeds"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedsCreateRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIFeedsCreateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIFeedsCreateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIFeedsCreateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::FeedsCreateResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 201:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid feed parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 403:
		SetResponseString(TEXT("Business account required."));
		break;
	case 409:
		SetResponseString(TEXT("User website required."));
		break;
	case 422:
		SetResponseString(TEXT("Unique feed name is required."));
		break;
	case 501:
		SetResponseString(TEXT("Not implemented (absent \&quot;default_country\&quot; or \&quot;default_locale\&quot;)."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::FeedsCreateResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::FeedsDeleteRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("feed_id"), FStringFormatArg(ToUrlString(FeedId)) } };

	FString Path = FString::Format(TEXT("/catalogs/feeds/{feed_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedsDeleteRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("DELETE"));

}

void OpenAPICatalogsApi::FeedsDeleteResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 204:
		SetResponseString(TEXT("Feed deleted successfully."));
		break;
	case 400:
		SetResponseString(TEXT("Invalid feed parameters."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for feed mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Data feed not found."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t delete a feed with active promotions."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::FeedsDeleteResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return true;
}

FString OpenAPICatalogsApi::FeedsGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("feed_id"), FStringFormatArg(ToUrlString(FeedId)) } };

	FString Path = FString::Format(TEXT("/catalogs/feeds/{feed_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::FeedsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid feed parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 404:
		SetResponseString(TEXT("Data feed not found."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::FeedsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::FeedsIngestRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("feed_id"), FStringFormatArg(ToUrlString(FeedId)) } };

	FString Path = FString::Format(TEXT("/catalogs/feeds/{feed_id}/ingest"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedsIngestRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::FeedsIngestResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("The ingestion process was successfully started."));
		break;
	case 400:
		SetResponseString(TEXT("Invalid feed parameters."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for feed mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Data feed not found."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::FeedsIngestResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::FeedsListRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/feeds"));
	TArray<FString> QueryParams;
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(CatalogId.IsSet())
	{
		QueryParams.Add(FString(TEXT("catalog_id=")) + ToUrlString(CatalogId.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedsListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::FeedsListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::FeedsListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::FeedsUpdateRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("feed_id"), FStringFormatArg(ToUrlString(FeedId)) } };

	FString Path = FString::Format(TEXT("/catalogs/feeds/{feed_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::FeedsUpdateRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("PATCH"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIFeedsUpdateRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIFeedsUpdateRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIFeedsUpdateRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::FeedsUpdateResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid feed parameters."));
		break;
	case 403:
		SetResponseString(TEXT("Forbidden. Account not approved for feed mutations yet."));
		break;
	case 404:
		SetResponseString(TEXT("Data feed not found."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::FeedsUpdateResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ItemsBatchGetRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("batch_id"), FStringFormatArg(ToUrlString(BatchId)) } };

	FString Path = FString::Format(TEXT("/catalogs/items/batch/{batch_id}"), PathParams);

	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ItemsBatchGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::ItemsBatchGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response containing the requested catalogs items batch"));
		break;
	case 401:
		SetResponseString(TEXT("Not authenticated to access catalogs items batch"));
		break;
	case 403:
		SetResponseString(TEXT("Not authorized to access catalogs items batch"));
		break;
	case 404:
		SetResponseString(TEXT("Catalogs items batch not found"));
		break;
	case 405:
		SetResponseString(TEXT("Method Not Allowed."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ItemsBatchGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ItemsBatchPostRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/items/batch"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ItemsBatchPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPIItemsBatchPostRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIItemsBatchPostRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPIItemsBatchPostRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::ItemsBatchPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response containing the requested catalogs items batch"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid request parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Not authenticated to post catalogs items"));
		break;
	case 403:
		SetResponseString(TEXT("Not authorized to post catalogs items"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ItemsBatchPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ItemsIssuesListRequest::ComputePath() const
{
	TMap<FString, FStringFormatArg> PathParams = { 
	{ TEXT("processing_result_id"), FStringFormatArg(ToUrlString(ProcessingResultId)) } };

	FString Path = FString::Format(TEXT("/catalogs/processing_results/{processing_result_id}/item_issues"), PathParams);

	TArray<FString> QueryParams;
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(ItemNumbers.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ItemNumbers.GetValue(), TEXT("item_numbers")));
	}
	if(ItemValidationIssue.IsSet())
	{
		QueryParams.Add(FString(TEXT("item_validation_issue=")) + ToUrlString(ItemValidationIssue.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ItemsIssuesListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::ItemsIssuesListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 404:
		SetResponseString(TEXT("Processing Result not found."));
		break;
	case 501:
		SetResponseString(TEXT("Not implemented."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::ItemsIssuesListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ItemsGetRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/items"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	QueryParams.Add(FString(TEXT("country=")) + ToUrlString(Country));
	QueryParams.Add(FString(TEXT("language=")) + ToUrlString(Language));
	if(ItemIds.IsSet())
	{
		QueryParams.Add(CollectionToUrlString_multi(ItemIds.GetValue(), TEXT("item_ids")));
	}
	if(Filters.IsSet())
	{
		QueryParams.Add(FString(TEXT("filters=")) + ToUrlString(Filters.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ItemsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::ItemsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response containing the requested catalogs items"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid request parameters."));
		break;
	case 401:
		SetResponseString(TEXT("Not authorized to access catalogs items"));
		break;
	case 403:
		SetResponseString(TEXT("Not authorized to access catalogs items"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ItemsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ItemsPostRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/items"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ItemsPostRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICatalogsItemsRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsItemsRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsItemsRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::ItemsPostResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response containing the requested catalogs items"));
		break;
	case 400:
		SetResponseString(TEXT("Invalid request"));
		break;
	case 401:
		SetResponseString(TEXT("Not authorized to access catalogs items"));
		break;
	case 403:
		SetResponseString(TEXT("Not authorized to access catalogs items"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ItemsPostResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ProductsByProductGroupFilterListRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/products/get_by_product_group_filters"));
	TArray<FString> QueryParams;
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	if(PinMetrics.IsSet())
	{
		QueryParams.Add(FString(TEXT("pin_metrics=")) + ToUrlString(PinMetrics.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ProductsByProductGroupFilterListRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICatalogsListProductsByFilterRequest);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsListProductsByFilterRequest) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsListProductsByFilterRequest) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::ProductsByProductGroupFilterListResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Success"));
		break;
	case 401:
		SetResponseString(TEXT("Unauthorized access."));
		break;
	case 409:
		SetResponseString(TEXT("Conflict. Can&#39;t get products."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error."));
		break;
	}
}

bool OpenAPICatalogsApi::ProductsByProductGroupFilterListResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ReportsCreateRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/reports"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ReportsCreateRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = { TEXT("application/json") };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("POST"));

	// Default to Json Body request
	if (Consumes.Num() == 0 || Consumes.Contains(TEXT("application/json")))
	{
		// Body parameters
		FString JsonBody;
		JsonWriter Writer = TJsonWriterFactory<>::Create(&JsonBody);

		WriteJsonValue(Writer, OpenAPICatalogsReportParameters);
		Writer->Close();

		HttpRequest->SetHeader(TEXT("Content-Type"), TEXT("application/json; charset=utf-8"));
		HttpRequest->SetContentAsString(JsonBody);
	}
	else if (Consumes.Contains(TEXT("multipart/form-data")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsReportParameters) was ignored, not supported in multipart form"));
	}
	else if (Consumes.Contains(TEXT("application/x-www-form-urlencoded")))
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Body parameter (OpenAPICatalogsReportParameters) was ignored, not supported in urlencoded requests"));
	}
	else
	{
		UE_LOG(LogOpenAPI, Error, TEXT("Request ContentType not supported (%s)"), *FString::Join(Consumes, TEXT(",")));
	}
}

void OpenAPICatalogsApi::ReportsCreateResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response containing the report token"));
		break;
	case 404:
		SetResponseString(TEXT("Entity (e.g., catalog, feed or processing_result) not found"));
		break;
	case 409:
		SetResponseString(TEXT("Can&#39;t access this feature without an existing catalog."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ReportsCreateResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ReportsGetRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/reports"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	QueryParams.Add(FString(TEXT("token=")) + ToUrlString(Token));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ReportsGetRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::ReportsGetResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response that contains a link to download the report"));
		break;
	case 400:
		SetResponseString(TEXT("The token you provided is not valid or has expired."));
		break;
	case 409:
		SetResponseString(TEXT("Can&#39;t access this feature without an existing catalog."));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ReportsGetResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

FString OpenAPICatalogsApi::ReportsStatsRequest::ComputePath() const
{
	FString Path(TEXT("/catalogs/reports/stats"));
	TArray<FString> QueryParams;
	if(AdAccountId.IsSet())
	{
		QueryParams.Add(FString(TEXT("ad_account_id=")) + ToUrlString(AdAccountId.GetValue()));
	}
	if(PageSize.IsSet())
	{
		QueryParams.Add(FString(TEXT("page_size=")) + ToUrlString(PageSize.GetValue()));
	}
	if(Bookmark.IsSet())
	{
		QueryParams.Add(FString(TEXT("bookmark=")) + ToUrlString(Bookmark.GetValue()));
	}
	QueryParams.Add(FString(TEXT("parameters=")) + ToUrlString(Parameters));
	Path += TCHAR('?');
	Path += FString::Join(QueryParams, TEXT("&"));

	return Path;
}

void OpenAPICatalogsApi::ReportsStatsRequest::SetupHttpRequest(const FHttpRequestRef& HttpRequest) const
{
	static const TArray<FString> Consumes = {  };
	//static const TArray<FString> Produces = { TEXT("application/json") };

	HttpRequest->SetVerb(TEXT("GET"));

}

void OpenAPICatalogsApi::ReportsStatsResponse::SetHttpResponseCode(EHttpResponseCodes::Type InHttpResponseCode)
{
	Response::SetHttpResponseCode(InHttpResponseCode);
	switch ((int)InHttpResponseCode)
	{
	case 200:
		SetResponseString(TEXT("Response containing the diagnostics aggregated counters"));
		break;
	case 401:
		SetResponseString(TEXT("Not authorized to access catalogs"));
		break;
	case 0:
	default:
		SetResponseString(TEXT("Unexpected error"));
		break;
	}
}

bool OpenAPICatalogsApi::ReportsStatsResponse::FromJson(const TSharedPtr<FJsonValue>& JsonValue)
{
	return TryGetJsonValue(JsonValue, Content);
}

}
